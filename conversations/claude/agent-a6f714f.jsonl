{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":"探索这个项目中参考图是否会被多个记录共享，以及删除逻辑：\n\n1. 参考图的 ID 生成逻辑是什么？同一张图片多次使用会创建独立副本还是共享同一个文件？\n2. `delete_record_with_files` 方法的完整实现是什么？\n3. 删除记录时如何处理参考图？是否会检查参考图是否被其他记录引用？\n4. 数据库中 `reference_assets` 表的 `generation_id` 外键是如何工作的？\n\n关键文件：\n- modules/repository/manager.py (delete_record_with_files)\n- modules/seedream/manager.py (_generate_reference_asset_id)\n- modules/repository/sqlite_handler.py\n\n请详细分析参考图是否存在共享风险。"},"uuid":"9ac1482b-6c01-4961-a4fa-8f35cab6d124","timestamp":"2025-12-13T13:22:02.190Z"}
{"parentUuid":"9ac1482b-6c01-4961-a4fa-8f35cab6d124","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FDsWhCEdEwdXcXJrm4713w","type":"message","role":"assistant","content":[{"type":"text","text":"我来帮你深入探索参考图的共享机制和删除逻辑。让我先找到关键文件并分析它们。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1991,"cache_read_input_tokens":17395,"cache_creation":{"ephemeral_5m_input_tokens":1991,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"3723fe6f-d79c-4935-bc71-45e6f1f0bcb3","timestamp":"2025-12-13T13:22:05.720Z"}
{"parentUuid":"3723fe6f-d79c-4935-bc71-45e6f1f0bcb3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FDsWhCEdEwdXcXJrm4713w","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VXs6rg5i3CLxNt7sfwViJZ","name":"Bash","input":{"command":"find /Users/yunchang/Documents/GitHub/gemeng2 -type f -name \"*.py\" | grep -E \"(manager|handler)\" | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1991,"cache_read_input_tokens":17395,"cache_creation":{"ephemeral_5m_input_tokens":1991,"ephemeral_1h_input_tokens":0},"output_tokens":131,"service_tier":"standard"}},"type":"assistant","uuid":"dc3d1da2-4bb1-4698-9ffa-f5f39336d23c","timestamp":"2025-12-13T13:22:06.091Z"}
{"parentUuid":"dc3d1da2-4bb1-4698-9ffa-f5f39336d23c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VXs6rg5i3CLxNt7sfwViJZ","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedance/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/glm/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedance/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/glm/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/project_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/edition/trial_license_manager.py","is_error":false}]},"uuid":"a3a7eb16-09a4-4d9e-8739-bd1e418700b5","timestamp":"2025-12-13T13:22:06.201Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedance/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/glm/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/utils/error_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedance/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/glm/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/project_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/edition/trial_license_manager.py","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"a3a7eb16-09a4-4d9e-8739-bd1e418700b5","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019DsDomJ7Y7f3fe5hA86utK","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查找项目的主要源码目录："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1098,"cache_read_input_tokens":19386,"cache_creation":{"ephemeral_5m_input_tokens":1098,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"ee6c9811-494a-4a4e-9037-35f0f108d24e","timestamp":"2025-12-13T13:22:09.889Z"}
{"parentUuid":"ee6c9811-494a-4a4e-9037-35f0f108d24e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019DsDomJ7Y7f3fe5hA86utK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011eMhobn7NVegymgUjo7zcX","name":"Bash","input":{"command":"ls -la /Users/yunchang/Documents/GitHub/gemeng2/modules 2>/dev/null | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1098,"cache_read_input_tokens":19386,"cache_creation":{"ephemeral_5m_input_tokens":1098,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5e1f98ff-5b50-4845-b010-d72a257fe22a","timestamp":"2025-12-13T13:22:10.109Z"}
{"parentUuid":"5e1f98ff-5b50-4845-b010-d72a257fe22a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011eMhobn7NVegymgUjo7zcX","type":"tool_result","content":"total 8\ndrwxr-xr-x@ 11 yunchang  staff   352 Dec 13 20:58 .\ndrwxr-xr-x@ 87 yunchang  staff  2784 Dec 13 21:03 ..\n-rw-r--r--@  1 yunchang  staff  1579 Nov 26 00:31 __init__.py\ndrwxr-xr-x@  3 yunchang  staff    96 Nov 27 09:13 __pycache__\ndrwxr-xr-x@  3 yunchang  staff    96 Nov 26 00:32 config\ndrwxr-xr-x@ 10 yunchang  staff   320 Dec 13 19:15 provider\ndrwxr-xr-x@  7 yunchang  staff   224 Dec 13 20:58 repository\ndrwxr-xr-x@  7 yunchang  staff   224 Dec 12 10:55 seedance\ndrwxr-xr-x@  6 yunchang  staff   192 Dec 11 14:56 seedream\ndrwxr-xr-x@  6 yunchang  staff   192 Dec  1 13:48 storage\ndrwxr-xr-x@  6 yunchang  staff   192 Nov 27 23:54 utils","is_error":false}]},"uuid":"d466b6ae-6218-44ae-b19e-5e56d6407859","timestamp":"2025-12-13T13:22:10.196Z","toolUseResult":{"stdout":"total 8\ndrwxr-xr-x@ 11 yunchang  staff   352 Dec 13 20:58 .\ndrwxr-xr-x@ 87 yunchang  staff  2784 Dec 13 21:03 ..\n-rw-r--r--@  1 yunchang  staff  1579 Nov 26 00:31 __init__.py\ndrwxr-xr-x@  3 yunchang  staff    96 Nov 27 09:13 __pycache__\ndrwxr-xr-x@  3 yunchang  staff    96 Nov 26 00:32 config\ndrwxr-xr-x@ 10 yunchang  staff   320 Dec 13 19:15 provider\ndrwxr-xr-x@  7 yunchang  staff   224 Dec 13 20:58 repository\ndrwxr-xr-x@  7 yunchang  staff   224 Dec 12 10:55 seedance\ndrwxr-xr-x@  6 yunchang  staff   192 Dec 11 14:56 seedream\ndrwxr-xr-x@  6 yunchang  staff   192 Dec  1 13:48 storage\ndrwxr-xr-x@  6 yunchang  staff   192 Nov 27 23:54 utils","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"d466b6ae-6218-44ae-b19e-5e56d6407859","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A3nbnY8UEXyUiZnqSSTvHr","type":"message","role":"assistant","content":[{"type":"text","text":"很好，现在让我获取关键文件的内容。我会并行读取多个文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":499,"cache_read_input_tokens":20484,"cache_creation":{"ephemeral_5m_input_tokens":499,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"cc14e77a-47b6-4289-bc83-9921e45a0443","timestamp":"2025-12-13T13:22:13.194Z"}
{"parentUuid":"cc14e77a-47b6-4289-bc83-9921e45a0443","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A3nbnY8UEXyUiZnqSSTvHr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0186mrPz1hs3HNLnsNJvfY7S","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":499,"cache_read_input_tokens":20484,"cache_creation":{"ephemeral_5m_input_tokens":499,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"437a2b93-c245-49d9-b0bb-bc40533e2f62","timestamp":"2025-12-13T13:22:13.465Z"}
{"parentUuid":"437a2b93-c245-49d9-b0bb-bc40533e2f62","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A3nbnY8UEXyUiZnqSSTvHr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015v2JChQk9ns3RkhFfyPgFT","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":499,"cache_read_input_tokens":20484,"cache_creation":{"ephemeral_5m_input_tokens":499,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"530979fc-ee73-4338-a3cc-4015ffd76595","timestamp":"2025-12-13T13:22:13.749Z"}
{"parentUuid":"530979fc-ee73-4338-a3cc-4015ffd76595","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A3nbnY8UEXyUiZnqSSTvHr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011oQs2XaPq97QaFgMVSpiHQ","name":"Glob","input":{"pattern":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":499,"cache_read_input_tokens":20484,"cache_creation":{"ephemeral_5m_input_tokens":499,"ephemeral_1h_input_tokens":0},"output_tokens":215,"service_tier":"standard"}},"type":"assistant","uuid":"ad8fcf39-161a-4a85-a85b-12690215e502","timestamp":"2025-12-13T13:22:13.974Z"}
{"parentUuid":"ad8fcf39-161a-4a85-a85b-12690215e502","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011oQs2XaPq97QaFgMVSpiHQ","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py"}]},"uuid":"03d21875-f186-479e-97a1-a3c38cae4a64","timestamp":"2025-12-13T13:22:14.020Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py"],"durationMs":13,"numFiles":4,"truncated":false}}
{"parentUuid":"03d21875-f186-479e-97a1-a3c38cae4a64","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0186mrPz1hs3HNLnsNJvfY7S","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→仓库管理器 - 统一管理所有内容仓库功能\n     5→\n     6→主要功能：\n     7→- 协调各个子模块的工作\n     8→- 提供统一的API接口\n     9→- 管理仓库配置和状态\n    10→- 处理跨模块的数据交互\n    11→\"\"\"\n    12→\n    13→import os\n    14→import json\n    15→import shutil\n    16→from pathlib import Path\n    17→from typing import Dict, List, Optional, Any\n    18→from datetime import datetime\n    19→from typing import Tuple\n    20→\n    21→from .sqlite_handler import SQLiteHandler\n    22→from tools import export_records\n    23→from loguru import logger\n    24→try:\n    25→    from utils.error_handler import global_error_handler as _global_error_handler\n    26→except Exception:\n    27→    _global_error_handler = None\n    28→\n    29→\n    30→class _RepoErrorHandler:\n    31→    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    32→    def log_error(self, message: str):\n    33→        try:\n    34→            if _global_error_handler:\n    35→                logger.error(message)\n    36→            else:\n    37→                print(f\"[RepositoryManager][ERROR] {message}\")\n    38→        except Exception:\n    39→            print(f\"[RepositoryManager][ERROR] {message}\")\n    40→\n    41→\n    42→class _NullTagManager:\n    43→    def get_content_tags(self, content_id: str):\n    44→        return []\n    45→    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n    46→        return False\n    47→    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n    48→        return False\n    49→    def get_all_tags(self, category: str = None):\n    50→        return []\n    51→    def get_statistics(self):\n    52→        return {}\n    53→    def export_data(self):\n    54→        return {}\n    55→\n    56→\n    57→class _NullSearchEngine:\n    58→    def get_total_count(self) -> int:\n    59→        return 0\n    60→    def export_data(self):\n    61→        return {}\n    62→\n    63→\n    64→class RepositoryManager:\n    65→    \"\"\"\n    66→    仓库管理器 - 内容仓库的核心控制器\n    67→    \n    68→    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    69→    为上层应用提供统一的仓库管理接口。\n    70→    \"\"\"\n    71→    \n    72→    def __init__(self, storage_root: str):\n    73→        \"\"\"\n    74→        初始化仓库管理器\n    75→        \n    76→        Args:\n    77→            storage_root: 用户指定的存储根目录\n    78→        \"\"\"\n    79→        self.storage_root = Path(storage_root)\n    80→        self.repository_root = self.storage_root / \"repository\"\n    81→        self.config_file = self.repository_root / \"config.json\"\n    82→        \n    83→        # 确保仓库目录存在\n    84→        self.repository_root.mkdir(parents=True, exist_ok=True)\n    85→        \n    86→        # 初始化子模块\n    87→        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n    88→        # 提供占位依赖，避免未实现接口导致崩溃\n    89→        self.error_handler = _RepoErrorHandler()\n    90→        self.tag_manager = _NullTagManager()\n    91→        self.search_engine = _NullSearchEngine()\n    92→        \n    93→        # 加载配置\n    94→        self.config = self._load_config()\n    95→        \n    96→        # 初始化仓库\n    97→        self._initialize_repository()\n    98→    \n    99→    def _load_config(self) -> Dict[str, Any]:\n   100→        \"\"\"\n   101→        加载仓库配置\n   102→        \n   103→        Returns:\n   104→            配置字典\n   105→        \"\"\"\n   106→        default_config = {\n   107→            \"version\": \"0.1.5\",\n   108→            \"created_at\": datetime.now().isoformat(),\n   109→            \"last_updated\": datetime.now().isoformat(),\n   110→            \"auto_tag_enabled\": True,\n   111→            \"search_index_enabled\": True,\n   112→            \"tag_categories\": [\n   113→                \"内容类型\",\n   114→                \"创建时间\", \n   115→                \"质量评级\",\n   116→                \"使用场景\",\n   117→                \"风格特征\",\n   118→                \"自定义标签\"\n   119→            ],\n   120→            \"supported_file_types\": [\"image\", \"video\", \"audio\", \"chat\"],\n   121→            \"max_tags_per_item\": 20,\n   122→            \"search_result_limit\": 100\n   123→        }\n   124→        \n   125→        if self.config_file.exists():\n   126→            try:\n   127→                with open(self.config_file, 'r', encoding='utf-8') as f:\n   128→                    config = json.load(f)\n   129→                # 合并默认配置，确保新字段存在\n   130→                for key, value in default_config.items():\n   131→                    if key not in config:\n   132→                        config[key] = value\n   133→                return config\n   134→            except Exception as e:\n   135→                self.error_handler.log_error(f\"加载仓库配置失败: {e}\")\n   136→                return default_config\n   137→        else:\n   138→            # 创建默认配置文件\n   139→            self._save_config(default_config)\n   140→            return default_config\n   141→    \n   142→    def _save_config(self, config: Dict[str, Any]) -> None:\n   143→        \"\"\"\n   144→        保存仓库配置\n   145→        \n   146→        Args:\n   147→            config: 配置字典\n   148→        \"\"\"\n   149→        try:\n   150→            config[\"last_updated\"] = datetime.now().isoformat()\n   151→            with open(self.config_file, 'w', encoding='utf-8') as f:\n   152→                json.dump(config, f, ensure_ascii=False, indent=2)\n   153→        except Exception as e:\n   154→            self.error_handler.log_error(f\"保存仓库配置失败: {e}\")\n   155→    \n   156→    def _initialize_repository(self) -> None:\n   157→        \"\"\"\n   158→        初始化仓库结构\n   159→        \"\"\"\n   160→        try:\n   161→            # 创建必要的子目录\n   162→            subdirs = [\"tags\", \"index\", \"cache\", \"exports\"]\n   163→            for subdir in subdirs:\n   164→                (self.repository_root / subdir).mkdir(exist_ok=True)\n   165→            \n   166→            print(f\"仓库初始化完成: {self.repository_root}\")\n   167→            \n   168→        except Exception as e:\n   169→            self.error_handler.log_error(f\"仓库初始化失败: {e}\")\n   170→            raise\n   171→\n   172→    def _ensure_dict(self, value: Any) -> Dict[str, Any]:\n   173→        if isinstance(value, dict):\n   174→            return value\n   175→        if isinstance(value, str) and value:\n   176→            try:\n   177→                loaded = json.loads(value)\n   178→                return loaded if isinstance(loaded, dict) else {}\n   179→            except Exception:\n   180→                return {}\n   181→        return {}\n   182→\n   183→    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n   184→        normalized: List[Dict[str, Any]] = []\n   185→        if not records:\n   186→            return normalized\n   187→        seen_keys: set[str] = set()\n   188→        for record in records:\n   189→            normalized_record = self._normalize_record(record, content_type)\n   190→            if not normalized_record:\n   191→                continue\n   192→            gen_key = normalized_record.get('generation_id') or normalized_record.get('task_id') or normalized_record.get('file_id')\n   193→            key = str(gen_key) if gen_key else None\n   194→            if key and key in seen_keys:\n   195→                continue\n   196→            if key:\n   197→                seen_keys.add(key)\n   198→            normalized.append(normalized_record)\n   199→        return normalized\n   200→\n   201→    \n   202→    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n   203→        if not isinstance(record, dict):\n   204→            return {}\n   205→\n   206→        item = dict(record)\n   207→        metadata_raw = item.get('metadata') or {}\n   208→        if isinstance(metadata_raw, str):\n   209→            try:\n   210→                metadata_raw = json.loads(metadata_raw) or {}\n   211→            except Exception:\n   212→                metadata_raw = {}\n   213→        item['metadata'] = metadata_raw\n   214→\n   215→        # 统一内容类型\n   216→        ctype = item.get('content_type') or content_type or ''\n   217→        if ctype == 'image':\n   218→            ctype = 'images'\n   219→        elif ctype == 'video':\n   220→            ctype = 'videos'\n   221→        item['content_type'] = ctype\n   222→\n   223→        # 解析JSON字段\n   224→        item['parameters'] = self._ensure_dict(item.get('parameters'))\n   225→        item['metadata'] = self._ensure_dict(item.get('metadata'))\n   226→        item['batch_info'] = self._ensure_dict(item.get('batch_info'))\n   227→\n   228→        metadata = item['metadata']\n   229→\n   230→        # 同步核心字段\n   231→        created_at = item.get('created_at')\n   232→        if not created_at:\n   233→            created_at = metadata.get('created_at') or metadata.get('completed_at')\n   234→        if not created_at:\n   235→            created_at = datetime.now().isoformat()\n   236→        if isinstance(created_at, datetime):\n   237→            item['created_at'] = created_at.isoformat()\n   238→        else:\n   239→            item['created_at'] = created_at\n   240→\n   241→        file_id = item.get('file_id') or item.get('generation_id') or metadata.get('task_id')\n   242→        if file_id:\n   243→            item['file_id'] = str(file_id)\n   244→\n   245→        generation_id = item.get('generation_id') or metadata.get('generation_id') or metadata.get('task_id')\n   246→        if generation_id:\n   247→            item['generation_id'] = str(generation_id)\n   248→\n   249→        resolved_path = item.get('resolved_path')\n   250→        candidate_paths = [\n   251→            resolved_path,\n   252→            item.get('absolute_path'),\n   253→            metadata.get('local_path'),\n   254→            item.get('file_path'),\n   255→        ]\n   256→        abs_path = next((p for p in candidate_paths if p), None)\n   257→        \n   258→        # 验证绝对路径是否真实存在（修复旧记录路径失效问题）\n   259→        if abs_path and not Path(abs_path).exists():\n   260→            logger.warning(f\"绝对路径无效，将尝试从relative_path重新构造: {abs_path}\")\n   261→            abs_path = None  # 重置，触发下面的重新构造逻辑\n   262→        \n   263→        if not abs_path and (item.get('relative_path') or metadata.get('relative_path')):\n   264→            rel = item.get('relative_path') or metadata.get('relative_path')\n   265→            try:\n   266→                root = self.storage_root\n   267→                original_path = Path(root) / rel\n   268→                if original_path.exists():\n   269→                    abs_path = str(original_path)\n   270→                    logger.debug(f\"使用路径: {abs_path}\")\n   271→                else:\n   272→                    abs_path = str(original_path)\n   273→                    logger.warning(f\"文件不存在: {original_path}\")\n   274→            except Exception as e:\n   275→                logger.error(f\"路径解析失败: {rel}, 错误: {e}\")\n   276→                abs_path = None\n   277→\n   278→        if abs_path:\n   279→            abs_path = str(abs_path)\n   280→            item['absolute_path'] = abs_path\n   281→            item['local_path'] = abs_path\n   282→            item['file_path'] = abs_path\n   283→\n   284→        # 记录相对路径\n   285→        rel_value = item.get('relative_path') or metadata.get('relative_path')\n   286→        if rel_value:\n   287→            item['relative_path'] = str(rel_value)\n   288→\n   289→        # 若缺少真实路径且状态已完成，则忽略该记录\n   290→        if not (item.get('file_path') or item.get('absolute_path') or item.get('relative_path')):\n   291→            status = str(item.get('status') or '').lower()\n   292→            # pending 状态的记录应该保留（即使缺路径，用于占位卡片显示）\n   293→            if status == 'pending':\n   294→                pass  # 不过滤，继续处理\n   295→            elif not status or status in {'completed', 'success'}:\n   296→                return {}\n   297→\n   298→       # 缩略图字段\n   299→        thumb_local = item.get('thumbnail_local_path') or metadata.get('thumbnail_local_path') or metadata.get('api_thumbnail_local_path')\n   300→        if thumb_local:\n   301→            item['thumbnail_local_path'] = str(thumb_local)\n   302→\n   303→        thumb_rel = item.get('thumbnail_path') or metadata.get('thumbnail_path') or item.get('thumbnail_local_path')\n   304→        if thumb_rel:\n   305→            item['thumbnail_path'] = str(thumb_rel)\n   306→            # 如果没有 thumbnail_local_path，则从相对路径生成绝对路径\n   307→            if not thumb_local:\n   308→                try:\n   309→                    thumb_abs = Path(self.storage_root) / thumb_rel\n   310→                    if thumb_abs.exists():\n   311→                        item['thumbnail_local_path'] = str(thumb_abs)\n   312→                        logger.debug(f\"生成缩略图绝对路径: {thumb_abs}\")\n   313→                    else:\n   314→                        logger.debug(f\"缩略图文件不存在: {thumb_abs}\")\n   315→                except Exception as e:\n   316→                    logger.debug(f\"缩略图路径解析失败: {thumb_rel}, 错误: {e}\")\n   317→\n   318→        # 补充尺寸信息，便于前端按比例渲染\n   319→        width = item.get('width') or metadata.get('width')\n   320→        height = item.get('height') or metadata.get('height')\n   321→        if width:\n   322→            try:\n   323→                item['width'] = int(float(width))\n   324→            except Exception:\n   325→                pass\n   326→        if height:\n   327→            try:\n   328→                item['height'] = int(float(height))\n   329→            except Exception:\n   330→                pass\n   331→        # 尝试从参数 size 提取比例（如果未提供 width/height）\n   332→        if (not item.get('width') or not item.get('height')):\n   333→            size_txt = item['parameters'].get('size') if isinstance(item['parameters'], dict) else None\n   334→            if isinstance(size_txt, str) and 'x' in size_txt:\n   335→                try:\n   336→                    sw, sh = size_txt.split('x')\n   337→                    item['width'] = item.get('width') or int(float(sw))\n   338→                    item['height'] = item.get('height') or int(float(sh))\n   339→                except Exception:\n   340→                    pass\n   341→        # 兜底：若本地文件存在且仍缺尺寸，尝试读取一次\n   342→        if (not item.get('width') or not item.get('height')):\n   343→            try:\n   344→                abs_path_probe = item.get('absolute_path') or item.get('file_path')\n   345→                if abs_path_probe and Path(abs_path_probe).exists():\n   346→                    from PIL import Image\n   347→                    with Image.open(abs_path_probe) as img:\n   348→                        item['width'] = item.get('width') or int(img.width)\n   349→                        item['height'] = item.get('height') or int(img.height)\n   350→            except Exception as exc:\n   351→                logger.debug(f\"尺寸读取失败: {exc}\")\n   352→\n   353→        # 提升 prompt 等常用字段\n   354→        if not item.get('prompt') and item['parameters'].get('prompt'):\n   355→            item['prompt'] = item['parameters']['prompt']\n   356→\n   357→        return item\n   358→\n   359→    def _parse_created_at(self, value: Any) -> datetime:\n   360→        if isinstance(value, datetime):\n   361→            return value\n   362→        if not value:\n   363→            return datetime.min\n   364→        text = str(value)\n   365→        try:\n   366→            if text.endswith('Z'):\n   367→                text = text[:-1] + '+00:00'\n   368→            return datetime.fromisoformat(text)\n   369→        except Exception:\n   370→            try:\n   371→                return datetime.strptime(text, '%Y-%m-%d %H:%M:%S')\n   372→            except Exception:\n   373→                return datetime.min\n   374→\n   375→    def _record_sort_key(self, record: Dict[str, Any]) -> Tuple[datetime, str]:\n   376→        created_dt = self._parse_created_at(record.get('created_at'))\n   377→        # fallback: 如果 created_at 无效，尝试使用 updated_at\n   378→        if created_dt == datetime.min:\n   379→            created_dt = self._parse_created_at(record.get('updated_at'))\n   380→        file_id = str(record.get('file_id', ''))\n   381→        return (created_dt, file_id)\n   382→\n   383→    def add_content(self, content_id: str, content_type: str, \n   384→                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n   385→        \"\"\"\n   386→        添加内容到仓库\n   387→        \n   388→        Args:\n   389→            content_id: 内容唯一标识\n   390→            content_type: 内容类型 (image/video/audio/chat)\n   391→            metadata: 内容元数据\n   392→            auto_tag: 是否自动生成标签\n   393→        \n   394→        Returns:\n   395→            是否添加成功\n   396→        \"\"\"\n   397→        try:\n   398→            normalized_type = (content_type or '').lower()\n   399→            if normalized_type in {'image', 'images'}:\n   400→                storage_type = 'images'\n   401→            elif normalized_type in {'video', 'videos'}:\n   402→                storage_type = 'videos'\n   403→            else:\n   404→                storage_type = normalized_type or 'unknown'\n   405→            status = metadata.get('status', 'unknown')\n   406→            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n   407→            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n   408→            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n   409→            return result\n   410→        except Exception as e:\n   411→            logger.error(f\"添加内容失败: {e}\")\n   412→            return False\n   413→    \n   414→    def update_record(self, record_id: str, data: Dict[str, Any]) -> bool:\n   415→        \"\"\"更新记录\"\"\"\n   416→        try:\n   417→            return self.sqlite_handler.update_record(record_id, data)\n   418→        except Exception as e:\n   419→            logger.error(f\"更新记录失败: {e}\")\n   420→            return False\n   421→\n   422→    def delete_record(self, record_id: str) -> bool:\n   423→        \"\"\"删除记录\"\"\"\n   424→        try:\n   425→            return self.sqlite_handler.delete_record(record_id)\n   426→        except Exception as e:\n   427→            logger.error(f\"删除记录失败: {e}\")\n   428→            return False\n   429→\n   430→    def delete_record_with_files(self, record_id: str) -> bool:\n   431→        \"\"\"删除记录及其所有关联文件\n   432→        \n   433→        Args:\n   434→            record_id: 记录ID\n   435→            \n   436→        Returns:\n   437→            bool: 是否删除成功\n   438→        \"\"\"\n   439→        if not record_id:\n   440→            return False\n   441→            \n   442→        try:\n   443→            # 1. 获取记录详情\n   444→            record = self.get_record_by_id(record_id)\n   445→            if not record:\n   446→                logger.warning(f\"删除记录: 未找到记录 {record_id}\")\n   447→                return False\n   448→            \n   449→            # 2. 收集需要删除的文件路径\n   450→            files_to_delete = []\n   451→            \n   452→            # 主文件（图片/视频）\n   453→            file_path = record.get('absolute_path') or record.get('file_path')\n   454→            if file_path:\n   455→                files_to_delete.append(file_path)\n   456→            \n   457→            # 缩略图\n   458→            thumb_path = record.get('thumbnail_local_path')\n   459→            if thumb_path:\n   460→                files_to_delete.append(thumb_path)\n   461→            \n   462→            # 参考图资产\n   463→            ref_info = record.get('_reference_info') or {}\n   464→            ref_assets = ref_info.get('assets', [])\n   465→            if not ref_assets:\n   466→                # 尝试从 parameters 中获取\n   467→                params = record.get('parameters') or {}\n   468→                ref_assets = params.get('reference_assets', [])\n   469→            \n   470→            for ref in ref_assets:\n   471→                if isinstance(ref, dict):\n   472→                    ref_path = ref.get('absolute_path') or ref.get('path')\n   473→                    if ref_path and str(ref_path) not in [str(f) for f in files_to_delete]:\n   474→                        # 转换相对路径为绝对路径\n   475→                        if not Path(ref_path).is_absolute():\n   476→                            ref_path = str(self.storage_root / ref_path)\n   477→                        files_to_delete.append(ref_path)\n   478→            \n   479→            # 3. 删除数据库记录\n   480→            if not self.delete_record(record_id):\n   481→                logger.error(f\"删除记录失败: 数据库删除失败 {record_id}\")\n   482→                return False\n   483→            \n   484→            # 4. 删除文件（忽略不存在的文件）\n   485→            deleted_files = []\n   486→            for path in files_to_delete:\n   487→                try:\n   488→                    if path and Path(path).exists():\n   489→                        Path(path).unlink()\n   490→                        deleted_files.append(path)\n   491→                        logger.debug(f\"已删除文件: {path}\")\n   492→                except Exception as e:\n   493→                    logger.warning(f\"删除文件失败: {path}, {e}\")\n   494→            \n   495→            logger.info(f\"删除记录完成: {record_id}, 删除了 {len(deleted_files)} 个文件\")\n   496→            return True\n   497→            \n   498→        except Exception as e:\n   499→            logger.error(f\"删除记录及文件失败: {record_id}, {e}\")\n   500→            return False\n   501→\n   502→    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n   503→        \"\"\"清理超时的 pending 记录\n   504→\n   505→        Args:\n   506→            timeout_hours: 超时时间（小时），默认 1 小时\n   507→\n   508→        Returns:\n   509→            清理的记录数量\n   510→        \"\"\"\n   511→        try:\n   512→            return self.sqlite_handler.cleanup_stale_pending_records(timeout_hours)\n   513→        except Exception as e:\n   514→            logger.error(f\"清理过期 pending 记录失败: {e}\")\n   515→            return 0\n   516→\n   517→    def get_record_by_id(self, record_id: str) -> Optional[Dict[str, Any]]:\n   518→        \"\"\"根据 ID 获取单条记录。\"\"\"\n   519→        if not record_id:\n   520→            return None\n   521→        try:\n   522→            raw = self.sqlite_handler.get_record_by_id(record_id)\n   523→            if not raw:\n   524→                return None\n   525→            content_type = raw.get('content_type') or 'image'\n   526→            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n   527→            normalized = self._normalize_record(raw, normalized_type)\n   528→            if not normalized:\n   529→                return None\n   530→            self._attach_reference_assets([normalized], absolute=True)\n   531→            return normalized\n   532→        except Exception as e:\n   533→            logger.error(f\"获取记录失败: {e}\")\n   534→            return None\n   535→    \n   536→    def get_records_batch(self, start_index=0, batch_size=40, record_type='all'):\n   537→        \"\"\"\n   538→        批量获取记录，支持分页查询\n   539→        \n   540→        Args:\n   541→            start_index: 起始索引\n   542→            batch_size: 批量大小\n   543→            record_type: 记录类型 ('image', 'video', 'all')\n   544→        \n   545→        Returns:\n   546→            List[Dict]: 记录列表\n   547→        \"\"\"\n   548→        try:\n   549→            normalized_type = (record_type or 'all').lower()\n   550→            if normalized_type == 'images':\n   551→                normalized_type = 'image'\n   552→            elif normalized_type == 'videos':\n   553→                normalized_type = 'video'\n   554→\n   555→            if normalized_type == 'all':\n   556→                fetch_limit = max(batch_size, start_index + batch_size)\n   557→                images = self.sqlite_handler.get_records('images', fetch_limit, 0) or []\n   558→                videos = self.sqlite_handler.get_records('videos', fetch_limit, 0) or []\n   559→                combined = images + videos\n   560→                combined.sort(key=self._record_sort_key, reverse=True)\n   561→                end_index = start_index + batch_size\n   562→                result = combined[start_index:end_index]\n   563→            else:\n   564→                content_type = 'images' if normalized_type == 'image' else 'videos'\n   565→                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n   566→                result.sort(key=self._record_sort_key, reverse=True)\n   567→\n   568→            normalized = self._normalize_records(result, normalized_type)\n   569→            self._attach_reference_assets(normalized, absolute=True)\n   570→            return normalized\n   571→        except Exception as e:\n   572→            self.error_handler.log_error(f\"批量获取记录失败: {e}\")\n   573→            return []\n   574→\n   575→    def get_records_batch_reverse(self, limit=80, offset=0, record_type='all'):\n   576→        \"\"\"\n   577→        倒序分页查询记录 - 瀑布流1000条方案专用\n   578→        \n   579→        优化特性：\n   580→        - 从最新记录开始的高效倒序查询\n   581→        - 支持80+30增量加载模式\n   582→        - 针对1000条数据优化的性能\n   583→        - 减少内存占用和查询时间\n   584→        \n   585→        Args:\n   586→            limit: 查询数量限制 (默认80，增量30)\n   587→            offset: 偏移量 (从最新记录开始计算)\n   588→            record_type: 记录类型 ('image', 'video', 'all')\n   589→        \n   590→        Returns:\n   591→            List[Dict]: 按时间倒序排列的记录列表\n   592→        \"\"\"\n   593→        try:\n   594→            normalized_type = (record_type or 'all').lower()\n   595→            if normalized_type == 'images':\n   596→                normalized_type = 'image'\n   597→            elif normalized_type == 'videos':\n   598→                normalized_type = 'video'\n   599→\n   600→            max_single_query = min(limit + 50, 200)\n   601→\n   602→            if normalized_type == 'all':\n   603→                images = self.sqlite_handler.get_records('images', max_single_query, 0) or []\n   604→                videos = self.sqlite_handler.get_records('videos', max_single_query, 0) or []\n   605→                combined = images + videos\n   606→                combined.sort(key=self._record_sort_key, reverse=True)\n   607→                start_idx = offset\n   608→                end_idx = offset + limit\n   609→                result = combined[start_idx:end_idx]\n   610→            else:\n   611→                content_type = 'images' if normalized_type == 'image' else 'videos'\n   612→                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n   613→                result.sort(key=self._record_sort_key, reverse=True)\n   614→\n   615→            normalized = self._normalize_records(result, normalized_type)\n   616→            self._attach_reference_assets(normalized, absolute=True)\n   617→\n   618→            return normalized\n   619→\n   620→        except Exception as e:\n   621→            self.error_handler.log_error(f\"倒序分页查询失败: {e}\")\n   622→            return []\n   623→\n   624→    def get_records_count_optimized(self, record_type='all'):\n   625→        \"\"\"\n   626→        优化的记录计数方法 - 瀑布流1000条方案专用\n   627→        \n   628→        提供快速的记录计数，支持1000条限制逻辑\n   629→        \n   630→        Args:\n   631→            record_type: 记录类型 ('image', 'video', 'all')\n   632→        \n   633→        Returns:\n   634→            Dict: {'total': int, 'capped_at_1000': bool}\n   635→        \"\"\"\n   636→        try:\n   637→            normalized_type = (record_type or 'all').lower()\n   638→            if normalized_type == 'image':\n   639→                total = self.sqlite_handler.get_total_count('images')\n   640→            elif normalized_type == 'video':\n   641→                total = self.sqlite_handler.get_total_count('videos')\n   642→            else:\n   643→                total = (\n   644→                    self.sqlite_handler.get_total_count('images') +\n   645→                    self.sqlite_handler.get_total_count('videos')\n   646→                )\n   647→\n   648→            # 1000条限制逻辑\n   649→            capped_at_1000 = total > 1000\n   650→            effective_total = min(total, 1000)\n   651→            \n   652→            return {\n   653→                'total': effective_total,\n   654→                'actual_total': total,\n   655→                'capped_at_1000': capped_at_1000\n   656→            }\n   657→            \n   658→        except Exception as e:\n   659→            self.error_handler.log_error(f\"优化记录计数失败: {e}\")\n   660→            return {'total': 0, 'actual_total': 0, 'capped_at_1000': False}\n   661→\n   662→    # =========================\n   663→    # 游标分页协议（初版实现）\n   664→    # 接口：get_records(page_size, cursor, record_type) -> { items, next_cursor }\n   665→    # 说明：当前实现基于现有CSV读取能力合并排序后切片，后续可在存储层优化为限窗/游标扫描。\n   666→    # =========================\n   667→    def get_records(self, page_size: int = 40, cursor: Optional[str] = None, record_type: str = 'all') -> Dict[str, Any]:\n   668→        \"\"\"\n   669→        游标分页获取记录\n   670→\n   671→        Args:\n   672→            page_size: 每页大小\n   673→            cursor: 上一页游标（格式：\"<created_at>|<file_id>|<type>\"），None表示第一页\n   674→            record_type: 'image' | 'video' | 'all'\n   675→\n   676→        Returns:\n   677→            dict: { items: List[Dict], next_cursor: Optional[str] }\n   678→        \"\"\"\n   679→        try:\n   680→            # 解析游标\n   681→            cursor_tuple: Optional[Tuple[str, str, str]] = None\n   682→            if cursor:\n   683→                try:\n   684→                    parts = cursor.split('|')\n   685→                    if len(parts) >= 3:\n   686→                        cursor_tuple = (parts[0], parts[1], parts[2])  # created_at, file_id, type\n   687→                except Exception:\n   688→                    cursor_tuple = None\n   689→\n   690→            # 拉取候选数据（按需窗口，尽量少取）\n   691→            fetch_limit = max(page_size * 3, 60)\n   692→\n   693→            def _load(ct: str) -> List[Dict[str, Any]]:\n   694→                return self._normalize_records(\n   695→                    self.sqlite_handler.get_records(ct, fetch_limit, 0) or [],\n   696→                    ct\n   697→                )\n   698→\n   699→            if record_type == 'image':\n   700→                records = _load('images')\n   701→            elif record_type == 'video':\n   702→                records = _load('videos')\n   703→            else:\n   704→                records = _load('images') + _load('videos')\n   705→\n   706→            # 排序：created_at DESC, file_id DESC\n   707→            records.sort(key=self._record_sort_key, reverse=True)\n   708→\n   709→            # 光标过滤：跳过光标及其之前的元素（保持稳定倒序）\n   710→            filtered: List[Dict[str, Any]] = []\n   711→            if cursor_tuple:\n   712→                cur_created, cur_id, cur_type = cursor_tuple\n   713→                passed = False\n   714→                for rec in records:\n   715→                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n   716→                    rec_key = (rec.get('created_at', '1970-01-01T00:00:00'), rec.get('file_id', ''), rec_type)\n   717→                    # 记录严格小于游标（因为倒序），才加入\n   718→                    if passed:\n   719→                        filtered.append(rec)\n   720→                    else:\n   721→                        if (rec_key[0] < cur_created) or (rec_key[0] == cur_created and rec_key[1] < cur_id) or (rec_key[0] == cur_created and rec_key[1] == cur_id and rec_key[2] < cur_type):\n   722→                            passed = True\n   723→                            filtered.append(rec)\n   724→                candidates = filtered\n   725→            else:\n   726→                candidates = records\n   727→\n   728→            # 取一页\n   729→            page_items = candidates[:page_size]\n   730→            self._attach_reference_assets(page_items, absolute=True)\n   731→\n   732→            # 生成 next_cursor\n   733→            if page_items:\n   734→                last = page_items[-1]\n   735→                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n   736→                next_cursor = f\"{last.get('created_at','')}|{last.get('file_id','')}|{last_type}\"\n   737→            else:\n   738→                next_cursor = None\n   739→\n   740→            return {\n   741→                'items': page_items,\n   742→                'next_cursor': next_cursor\n   743→            }\n   744→\n   745→        except Exception as e:\n   746→            self.error_handler.log_error(f\"游标分页获取记录失败: {e}\")\n   747→            return {\n   748→                'items': [],\n   749→                'next_cursor': None\n   750→            }\n   751→\n   752→    def get_total_count(self, record_type='all'):\n   753→        \"\"\"\n   754→        获取总记录数\n   755→        \n   756→        Args:\n   757→            record_type: 记录类型 ('image', 'video', 'all')\n   758→            \n   759→        Returns:\n   760→            int: 总记录数\n   761→        \"\"\"\n   762→        try:\n   763→            normalized_type = (record_type or 'all').lower()\n   764→            if normalized_type == 'image':\n   765→                return self.sqlite_handler.get_total_count('images')\n   766→            if normalized_type == 'video':\n   767→                return self.sqlite_handler.get_total_count('videos')\n   768→\n   769→            return (\n   770→                self.sqlite_handler.get_total_count('images') +\n   771→                self.sqlite_handler.get_total_count('videos')\n   772→            )\n   773→        except Exception as e:\n   774→            self.error_handler.log_error(f\"获取记录总数失败: {e}\")\n   775→            return 0\n   776→\n   777→    def _resolve_reference_assets(self, record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n   778→        if not isinstance(record, dict):\n   779→            return []\n   780→\n   781→        params_raw = record.get('parameters')\n   782→        params_dict: Dict[str, Any] = {}\n   783→        if isinstance(params_raw, dict):\n   784→            params_dict = params_raw\n   785→        elif isinstance(params_raw, str):\n   786→            try:\n   787→                params_dict = json.loads(params_raw) or {}\n   788→            except Exception:\n   789→                params_dict = {}\n   790→\n   791→        assets = []\n   792→        if isinstance(params_dict, dict):\n   793→            assets = params_dict.get('reference_assets') or []\n   794→        if not assets:\n   795→            fallback = record.get('reference_assets')\n   796→            assets = fallback if isinstance(fallback, list) else []\n   797→        if not assets:\n   798→            return []\n   799→\n   800→        resolved: List[Dict[str, Any]] = []\n   801→        for item in assets:\n   802→            if not isinstance(item, dict):\n   803→                continue\n   804→            rec = dict(item)\n   805→            rel_path = rec.get('relative_path') or rec.get('asset_path')\n   806→            if rel_path and absolute:\n   807→                abs_path = Path(self.storage_root) / rel_path\n   808→                rec['absolute_path'] = str(abs_path)\n   809→                rec['asset_path'] = str(abs_path)\n   810→            resolved.append(rec)\n   811→        return resolved\n   812→\n   813→    \n   814→    def _resolve_video_reference_assets(self, record: Dict[str, Any]) -> List[Dict[str, Any]]:\n   815→        \"\"\"\n   816→        解析视频记录中的参考图资产\n   817→        \n   818→        从parameters.first_frame和image_path提取参考图信息\n   819→        \"\"\"\n   820→        if not isinstance(record, dict):\n   821→            return []\n   822→            \n   823→        params = record.get('parameters', {})\n   824→        if isinstance(params, str):\n   825→            try:\n   826→                params = json.loads(params)\n   827→            except:\n   828→                params = {}\n   829→\n   830→        # 收集参考图路径\n   831→        ref_paths = []\n   832→\n   833→        storage_root = self.storage_root\n   834→\n   835→        def _resolve_path(path_str: Optional[str]) -> Optional[Path]:\n   836→            if not path_str:\n   837→                return None\n   838→            candidate = Path(path_str).expanduser()\n   839→            if candidate.is_absolute():\n   840→                return candidate if candidate.exists() else None\n   841→            combined = storage_root / path_str.lstrip('/\\\\')\n   842→            return combined if combined.exists() else None\n   843→\n   844→        # 从first_frame提取\n   845→        first_frame = params.get('first_frame')\n   846→        resolved_first = _resolve_path(first_frame) if isinstance(first_frame, str) else None\n   847→        if resolved_first:\n   848→            ref_paths.append(('first_frame', str(resolved_first)))\n   849→\n   850→        # 从last_frame提取（首尾帧模式）\n   851→        last_frame = params.get('last_frame')\n   852→        resolved_last = _resolve_path(last_frame) if isinstance(last_frame, str) else None\n   853→        if resolved_last:\n   854→            ref_paths.append(('last_frame', str(resolved_last)))\n   855→\n   856→        # 从image_path提取\n   857→        image_path = params.get('image_path')\n   858→        resolved_image = _resolve_path(image_path) if isinstance(image_path, str) else None\n   859→        if resolved_image and all(str(resolved_image) != existing_path for _, existing_path in ref_paths):\n   860→            ref_paths.append(('image', str(resolved_image)))\n   861→\n   862→        # 构建参考图资产信息\n   863→        resolved_assets = []\n   864→        for i, (kind, path) in enumerate(ref_paths):\n   865→            try:\n   866→                file_path = Path(path)\n   867→                if file_path.exists():\n   868→                    stat = file_path.stat()\n   869→                    try:\n   870→                        rel = file_path.resolve().relative_to(storage_root)\n   871→                        rel_str = str(rel).replace('\\\\', '/')\n   872→                    except ValueError:\n   873→                        rel_str = str(file_path)\n   874→                    asset = {\n   875→                        'id': f'ref_video_{record.get(\"generation_id\", \"unknown\")}_{i}',\n   876→                        'path': rel_str,\n   877→                        'relative_path': rel_str,\n   878→                        'absolute_path': str(file_path.resolve()),\n   879→                        'type': 'image',\n   880→                        'kind': kind or 'image',\n   881→                        'source': file_path.name,\n   882→                        'order': i,\n   883→                        'size': stat.st_size,\n   884→                        'exists': True,\n   885→                        'created_at': record.get('created_at', datetime.now().isoformat())\n   886→                    }\n   887→\n   888→                    # 尝试获取图片尺寸\n   889→                    try:\n   890→                        from PIL import Image\n   891→                        with Image.open(path) as img:\n   892→                            asset['width'] = img.width\n   893→                            asset['height'] = img.height\n   894→                    except:\n   895→                        asset['width'] = None\n   896→                        asset['height'] = None\n   897→                        \n   898→                    resolved_assets.append(asset)\n   899→            except Exception as e:\n   900→                print(f\"  ⚠️ 解析参考图失败: {path} - {e}\")\n   901→                \n   902→        return resolved_assets\n   903→\n   904→    def _attach_reference_assets(self, records: List[Dict[str, Any]], *, absolute: bool = False) -> None:\n   905→        if not records:\n   906→            return\n   907→        for record in records:\n   908→            try:\n   909→                # 先尝试原有的解析逻辑\n   910→                resolved = self._resolve_reference_assets(record, absolute=absolute)\n   911→                \n   912→                # 如果原有逻辑没有找到参考图，尝试视频参考图解析\n   913→                if not resolved and record.get('content_type') == 'videos':\n   914→                    video_refs = self._resolve_video_reference_assets(record)\n   915→                    if video_refs:\n   916→                        resolved = video_refs\n   917→                        # 更新_reference_info\n   918→                        record['_reference_info'] = {\n   919→                            'count': len(video_refs),\n   920→                            'summary': f'{len(video_refs)}个参考图',\n   921→                            'labels': ['参考图'],\n   922→                            'assets': video_refs\n   923→                        }\n   924→                \n   925→                if absolute:\n   926→                    record['_resolved_reference_assets_abs'] = resolved\n   927→                record['_resolved_reference_assets'] = resolved\n   928→                \n   929→                # 确保_reference_info存在\n   930→                if '_reference_info' not in record:\n   931→                    record['_reference_info'] = {\n   932→                        'count': len(resolved),\n   933→                        'summary': f'{len(resolved)}个参考图' if resolved else '',\n   934→                        'labels': ['参考图'] if resolved else [],\n   935→                        'assets': resolved\n   936→                    }\n   937→                    \n   938→            except Exception as exc:\n   939→                logger.debug(f\"attach_reference_assets failed: {exc}\")\n   940→\n   941→    def search_content(self, query: str, content_type: Optional[str] = None,\n   942→                      tags: Optional[List[str]] = None, \n   943→                      limit: int = None) -> List[Dict[str, Any]]:\n   944→        \"\"\"\n   945→        搜索仓库内容\n   946→        \n   947→        Args:\n   948→            query: 搜索关键词\n   949→            content_type: 内容类型过滤\n   950→            tags: 标签过滤\n   951→            limit: 结果数量限制\n   952→        \n   953→        Returns:\n   954→            搜索结果列表\n   955→        \"\"\"\n   956→        try:\n   957→            if limit is None or limit <= 0:\n   958→                limit = self.config.get(\"search_result_limit\", 100)\n   959→\n   960→            keyword = (query or \"\").strip()\n   961→            if not keyword:\n   962→                return []\n   963→\n   964→            normalized_type = 'all'\n   965→            sqlite_type: Optional[str] = None\n   966→            if content_type:\n   967→                ct = content_type.lower()\n   968→                if ct in {'image', 'images'}:\n   969→                    sqlite_type = 'images'\n   970→                    normalized_type = 'image'\n   971→                elif ct in {'video', 'videos'}:\n   972→                    sqlite_type = 'videos'\n   973→                    normalized_type = 'video'\n   974→\n   975→            results = self.sqlite_handler.search_records(keyword, sqlite_type, limit) or []\n   976→            normalized = self._normalize_records(results, normalized_type)\n   977→            self._attach_reference_assets(normalized, absolute=True)\n   978→            return normalized\n   979→        except Exception as e:\n   980→            logger.error(f\"搜索内容失败: {e}\")\n   981→            return []\n   982→    \n   983→    def get_content_tags(self, content_id: str) -> List[str]:\n   984→        \"\"\"\n   985→        获取内容的所有标签\n   986→        \n   987→        Args:\n   988→            content_id: 内容ID\n   989→        \n   990→        Returns:\n   991→            标签列表\n   992→        \"\"\"\n   993→        return self.tag_manager.get_content_tags(content_id)\n   994→    \n   995→    def add_tag_to_content(self, content_id: str, tag: str, \n   996→                          category: str = \"自定义标签\") -> bool:\n   997→        \"\"\"\n   998→        为内容添加标签\n   999→        \n  1000→        Args:\n  1001→            content_id: 内容ID\n  1002→            tag: 标签名称\n  1003→            category: 标签分类\n  1004→        \n  1005→        Returns:\n  1006→            是否添加成功\n  1007→        \"\"\"\n  1008→        return self.tag_manager.add_tag_to_content(content_id, tag, category)\n  1009→    \n  1010→    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n  1011→        \"\"\"\n  1012→        从内容中移除标签\n  1013→        \n  1014→        Args:\n  1015→            content_id: 内容ID\n  1016→            tag: 标签名称\n  1017→        \n  1018→        Returns:\n  1019→            是否移除成功\n  1020→        \"\"\"\n  1021→        return self.tag_manager.remove_tag_from_content(content_id, tag)\n  1022→    \n  1023→    def get_all_tags(self, category: Optional[str] = None) -> List[str]:\n  1024→        \"\"\"\n  1025→        获取所有标签\n  1026→        \n  1027→        Args:\n  1028→            category: 标签分类过滤\n  1029→        \n  1030→        Returns:\n  1031→            标签列表\n  1032→        \"\"\"\n  1033→        return self.tag_manager.get_all_tags(category)\n  1034→    \n  1035→    def get_tag_statistics(self) -> Dict[str, Any]:\n  1036→        \"\"\"\n  1037→        获取标签统计信息\n  1038→        \n  1039→        Returns:\n  1040→            统计信息字典\n  1041→        \"\"\"\n  1042→        return self.tag_manager.get_statistics()\n  1043→    \n  1044→    def export_repository_data(self, export_format: str = \"json\") -> str:\n  1045→        \"\"\"\n  1046→        导出仓库数据\n  1047→\n  1048→        Args:\n  1049→            export_format: 导出格式 (json/csv/xlsx)\n  1050→\n  1051→        Returns:\n  1052→            导出文件路径\n  1053→        \"\"\"\n  1054→        try:\n  1055→            export_dir = self.repository_root / \"exports\"\n  1056→            export_dir.mkdir(exist_ok=True)\n  1057→            \n  1058→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n  1059→            filename = f\"repository_export_{timestamp}.{export_format}\"\n  1060→            export_path = export_dir / filename\n  1061→            \n  1062→            # 收集所有数据\n  1063→            storage_stats = {\n  1064→                \"images\": self.sqlite_handler.get_total_count('images'),\n  1065→                \"videos\": self.sqlite_handler.get_total_count('videos')\n  1066→            }\n  1067→            data = {\n  1068→                \"config\": self.config,\n  1069→                \"tags\": self.tag_manager.export_data(),\n  1070→                \"search_index\": self.search_engine.export_data(),\n  1071→                \"storage_stats\": storage_stats,\n  1072→                \"export_time\": datetime.now().isoformat()\n  1073→            }\n  1074→            \n  1075→            if export_format == \"json\":\n  1076→                with open(export_path, 'w', encoding='utf-8') as f:\n  1077→                    json.dump(data, f, ensure_ascii=False, indent=2)\n  1078→            \n  1079→            return str(export_path)\n  1080→            \n  1081→        except Exception as e:\n  1082→            self.error_handler.log_error(f\"导出仓库数据失败: {e}\")\n  1083→            return \"\"\n  1084→\n  1085→    def export_generation_bundle(\n  1086→        self,\n  1087→        file_ids: List[str],\n  1088→        record_type: str = \"image\",\n  1089→        *,\n  1090→        destination_dir: Optional[str] = None,\n  1091→    ) -> Dict[str, Any]:\n  1092→        \"\"\"导出指定文件ID的生成记录及参考图。\"\"\"\n  1093→        def _mask(value: Any) -> str:\n  1094→            if value in (None, \"\"):\n  1095→                return \"-\"\n  1096→            text = str(value)\n  1097→            return f\"{text[:6]}***\"\n  1098→\n  1099→        record_type = (record_type or \"\").lower()\n  1100→        if record_type not in {\"image\", \"video\"}:\n  1101→            raise ValueError(f\"不支持的记录类型: {record_type}\")\n  1102→\n  1103→        exports_dir = Path(self.storage_root) / \"exports\"\n  1104→        exports_dir.mkdir(parents=True, exist_ok=True)\n  1105→        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n  1106→        output_base = exports_dir / f\"{record_type}_bundle_{timestamp}\"\n  1107→\n  1108→        normalized_ids = [str(fid) for fid in file_ids if fid]\n  1109→        export_result = export_records(record_type, normalized_ids, output_base)\n  1110→        if not export_result:\n  1111→            masked_ids = \",\".join(_mask(fid) for fid in normalized_ids) or \"-\"\n  1112→            logger.warning(\n  1113→                \"摘要|operation=export_bundle status=failed record_type={rtype} record_ids={ids} reason={reason}\",\n  1114→                rtype=record_type,\n  1115→                ids=masked_ids,\n  1116→                reason=\"no_result\",\n  1117→            )\n  1118→            raise RuntimeError(\"导出参考图失败\")\n  1119→\n  1120→        zip_path = Path(export_result[\"zip_path\"])\n  1121→        manifest_json = Path(export_result[\"manifest_json\"])\n  1122→        manifest_csv = Path(export_result[\"manifest_csv\"])\n  1123→\n  1124→        destination_zip = None\n  1125→        destination_manifest_json = None\n  1126→        destination_manifest_csv = None\n  1127→\n  1128→        if destination_dir:\n  1129→            dest_dir_path = Path(destination_dir).expanduser()\n  1130→            dest_dir_path.mkdir(parents=True, exist_ok=True)\n  1131→            try:\n  1132→                destination_zip = dest_dir_path / zip_path.name\n  1133→                shutil.copy2(zip_path, destination_zip)\n  1134→                destination_manifest_json = dest_dir_path / manifest_json.name\n  1135→                shutil.copy2(manifest_json, destination_manifest_json)\n  1136→                destination_manifest_csv = dest_dir_path / manifest_csv.name\n  1137→                shutil.copy2(manifest_csv, destination_manifest_csv)\n  1138→            except PermissionError as exc:\n  1139→                logger.warning(\n  1140→                    \"摘要|operation=export_bundle status=failed reason=permission_denied record_type={rtype} dest={dest}\",\n  1141→                    rtype=record_type,\n  1142→                    dest=dest_dir_path.name,\n  1143→                )\n  1144→                raise PermissionError(\"导出目录无写入权限\") from exc\n  1145→\n  1146→        reference_ids = export_result.get(\"reference_ids\", [])\n  1147→        masked_refs = \",\".join(_mask(rid) for rid in reference_ids if rid) or \"-\"\n  1148→        status = export_result.get(\"status\", \"success\") or \"success\"\n  1149→        missing_records = export_result.get(\"missing_records\", []) or []\n  1150→        missing_main_files = export_result.get(\"missing_main_files\", []) or []\n  1151→        missing_references = export_result.get(\"missing_references\", []) or []\n  1152→        dest_hint_path = destination_zip.parent if destination_zip else zip_path.parent\n  1153→        try:\n  1154→            dest_hint_text = Path(dest_hint_path).name or Path(dest_hint_path).parent.name\n  1155→        except Exception:\n  1156→            dest_hint_text = \"-\"\n  1157→        logger.info(\n  1158→            \"摘要|operation=export_bundle status={status} record_type={rtype} record_ids={ids} ref_count={ref_count} ref_ids={refs} missing_records={miss_rec} missing_files={miss_files} missing_refs={miss_refs} dest={dest}\",\n  1159→            status=status,\n  1160→            rtype=record_type,\n  1161→            ids=\",\".join(_mask(fid) for fid in normalized_ids) or \"-\",\n  1162→            ref_count=export_result.get(\"reference_count\", 0),\n  1163→            refs=masked_refs,\n  1164→            miss_rec=len(missing_records),\n  1165→            miss_files=len(missing_main_files),\n  1166→            miss_refs=len(missing_references),\n  1167→            dest=dest_hint_text or \"-\",\n  1168→        )\n  1169→\n  1170→        return {\n  1171→            \"zip_path\": str(zip_path),\n  1172→            \"manifest_json\": str(manifest_json),\n  1173→            \"manifest_csv\": str(manifest_csv),\n  1174→            \"destination_zip\": str(destination_zip) if destination_zip else None,\n  1175→            \"destination_manifest_json\": str(destination_manifest_json) if destination_manifest_json else None,\n  1176→            \"destination_manifest_csv\": str(destination_manifest_csv) if destination_manifest_csv else None,\n  1177→            \"status\": status,\n  1178→            \"reference_count\": export_result.get(\"reference_count\", 0),\n  1179→            \"reference_ids\": reference_ids,\n  1180→            \"missing_records\": missing_records,\n  1181→            \"missing_main_files\": missing_main_files,\n  1182→            \"missing_references\": missing_references,\n  1183→            \"records\": export_result.get(\"records\", []),\n  1184→            \"exported_record_ids\": export_result.get(\"exported_record_ids\", normalized_ids),\n  1185→        }\n  1186→    \n  1187→    def get_repository_status(self) -> Dict[str, Any]:\n  1188→        \"\"\"\n  1189→        获取仓库状态信息\n  1190→        \n  1191→        Returns:\n  1192→            状态信息字典\n  1193→        \"\"\"\n  1194→        try:\n  1195→            return {\n  1196→                \"version\": self.config.get(\"version\", \"0.1.5\"),\n  1197→                \"storage_root\": str(self.storage_root),\n  1198→                \"repository_root\": str(self.repository_root),\n  1199→                \"total_content_count\": self.get_total_count('all'),\n  1200→                \"total_tags_count\": len(self.tag_manager.get_all_tags()),\n  1201→                \"tag_categories\": self.config.get(\"tag_categories\", []),\n  1202→                \"last_updated\": self.config.get(\"last_updated\"),\n  1203→                \"auto_tag_enabled\": self.config.get(\"auto_tag_enabled\", True),\n  1204→                \"search_index_enabled\": self.config.get(\"search_index_enabled\", True)\n  1205→            }\n  1206→        except Exception as e:\n  1207→            self.error_handler.log_error(f\"获取仓库状态失败: {e}\")\n  1208→            return {}\n  1209→    \n  1210→    def update_config(self, new_config: Dict[str, Any]) -> bool:\n  1211→        \"\"\"\n  1212→        更新仓库配置\n  1213→        \n  1214→        Args:\n  1215→            new_config: 新配置字典\n  1216→        \n  1217→        Returns:\n  1218→            是否更新成功\n  1219→        \"\"\"\n  1220→        try:\n  1221→            self.config.update(new_config)\n  1222→            self._save_config(self.config)\n  1223→            return True\n  1224→        except Exception as e:\n  1225→            self.error_handler.log_error(f\"更新仓库配置失败: {e}\")\n  1226→            return False\n  1227→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"274c3080-eb93-4904-af5c-6fb139e03dea","timestamp":"2025-12-13T13:22:15.308Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n仓库管理器 - 统一管理所有内容仓库功能\n\n主要功能：\n- 协调各个子模块的工作\n- 提供统一的API接口\n- 管理仓库配置和状态\n- 处理跨模块的数据交互\n\"\"\"\n\nimport os\nimport json\nimport shutil\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nfrom typing import Tuple\n\nfrom .sqlite_handler import SQLiteHandler\nfrom tools import export_records\nfrom loguru import logger\ntry:\n    from utils.error_handler import global_error_handler as _global_error_handler\nexcept Exception:\n    _global_error_handler = None\n\n\nclass _RepoErrorHandler:\n    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    def log_error(self, message: str):\n        try:\n            if _global_error_handler:\n                logger.error(message)\n            else:\n                print(f\"[RepositoryManager][ERROR] {message}\")\n        except Exception:\n            print(f\"[RepositoryManager][ERROR] {message}\")\n\n\nclass _NullTagManager:\n    def get_content_tags(self, content_id: str):\n        return []\n    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n        return False\n    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n        return False\n    def get_all_tags(self, category: str = None):\n        return []\n    def get_statistics(self):\n        return {}\n    def export_data(self):\n        return {}\n\n\nclass _NullSearchEngine:\n    def get_total_count(self) -> int:\n        return 0\n    def export_data(self):\n        return {}\n\n\nclass RepositoryManager:\n    \"\"\"\n    仓库管理器 - 内容仓库的核心控制器\n    \n    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    为上层应用提供统一的仓库管理接口。\n    \"\"\"\n    \n    def __init__(self, storage_root: str):\n        \"\"\"\n        初始化仓库管理器\n        \n        Args:\n            storage_root: 用户指定的存储根目录\n        \"\"\"\n        self.storage_root = Path(storage_root)\n        self.repository_root = self.storage_root / \"repository\"\n        self.config_file = self.repository_root / \"config.json\"\n        \n        # 确保仓库目录存在\n        self.repository_root.mkdir(parents=True, exist_ok=True)\n        \n        # 初始化子模块\n        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n        # 提供占位依赖，避免未实现接口导致崩溃\n        self.error_handler = _RepoErrorHandler()\n        self.tag_manager = _NullTagManager()\n        self.search_engine = _NullSearchEngine()\n        \n        # 加载配置\n        self.config = self._load_config()\n        \n        # 初始化仓库\n        self._initialize_repository()\n    \n    def _load_config(self) -> Dict[str, Any]:\n        \"\"\"\n        加载仓库配置\n        \n        Returns:\n            配置字典\n        \"\"\"\n        default_config = {\n            \"version\": \"0.1.5\",\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"auto_tag_enabled\": True,\n            \"search_index_enabled\": True,\n            \"tag_categories\": [\n                \"内容类型\",\n                \"创建时间\", \n                \"质量评级\",\n                \"使用场景\",\n                \"风格特征\",\n                \"自定义标签\"\n            ],\n            \"supported_file_types\": [\"image\", \"video\", \"audio\", \"chat\"],\n            \"max_tags_per_item\": 20,\n            \"search_result_limit\": 100\n        }\n        \n        if self.config_file.exists():\n            try:\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    config = json.load(f)\n                # 合并默认配置，确保新字段存在\n                for key, value in default_config.items():\n                    if key not in config:\n                        config[key] = value\n                return config\n            except Exception as e:\n                self.error_handler.log_error(f\"加载仓库配置失败: {e}\")\n                return default_config\n        else:\n            # 创建默认配置文件\n            self._save_config(default_config)\n            return default_config\n    \n    def _save_config(self, config: Dict[str, Any]) -> None:\n        \"\"\"\n        保存仓库配置\n        \n        Args:\n            config: 配置字典\n        \"\"\"\n        try:\n            config[\"last_updated\"] = datetime.now().isoformat()\n            with open(self.config_file, 'w', encoding='utf-8') as f:\n                json.dump(config, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            self.error_handler.log_error(f\"保存仓库配置失败: {e}\")\n    \n    def _initialize_repository(self) -> None:\n        \"\"\"\n        初始化仓库结构\n        \"\"\"\n        try:\n            # 创建必要的子目录\n            subdirs = [\"tags\", \"index\", \"cache\", \"exports\"]\n            for subdir in subdirs:\n                (self.repository_root / subdir).mkdir(exist_ok=True)\n            \n            print(f\"仓库初始化完成: {self.repository_root}\")\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"仓库初始化失败: {e}\")\n            raise\n\n    def _ensure_dict(self, value: Any) -> Dict[str, Any]:\n        if isinstance(value, dict):\n            return value\n        if isinstance(value, str) and value:\n            try:\n                loaded = json.loads(value)\n                return loaded if isinstance(loaded, dict) else {}\n            except Exception:\n                return {}\n        return {}\n\n    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n        normalized: List[Dict[str, Any]] = []\n        if not records:\n            return normalized\n        seen_keys: set[str] = set()\n        for record in records:\n            normalized_record = self._normalize_record(record, content_type)\n            if not normalized_record:\n                continue\n            gen_key = normalized_record.get('generation_id') or normalized_record.get('task_id') or normalized_record.get('file_id')\n            key = str(gen_key) if gen_key else None\n            if key and key in seen_keys:\n                continue\n            if key:\n                seen_keys.add(key)\n            normalized.append(normalized_record)\n        return normalized\n\n    \n    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n        if not isinstance(record, dict):\n            return {}\n\n        item = dict(record)\n        metadata_raw = item.get('metadata') or {}\n        if isinstance(metadata_raw, str):\n            try:\n                metadata_raw = json.loads(metadata_raw) or {}\n            except Exception:\n                metadata_raw = {}\n        item['metadata'] = metadata_raw\n\n        # 统一内容类型\n        ctype = item.get('content_type') or content_type or ''\n        if ctype == 'image':\n            ctype = 'images'\n        elif ctype == 'video':\n            ctype = 'videos'\n        item['content_type'] = ctype\n\n        # 解析JSON字段\n        item['parameters'] = self._ensure_dict(item.get('parameters'))\n        item['metadata'] = self._ensure_dict(item.get('metadata'))\n        item['batch_info'] = self._ensure_dict(item.get('batch_info'))\n\n        metadata = item['metadata']\n\n        # 同步核心字段\n        created_at = item.get('created_at')\n        if not created_at:\n            created_at = metadata.get('created_at') or metadata.get('completed_at')\n        if not created_at:\n            created_at = datetime.now().isoformat()\n        if isinstance(created_at, datetime):\n            item['created_at'] = created_at.isoformat()\n        else:\n            item['created_at'] = created_at\n\n        file_id = item.get('file_id') or item.get('generation_id') or metadata.get('task_id')\n        if file_id:\n            item['file_id'] = str(file_id)\n\n        generation_id = item.get('generation_id') or metadata.get('generation_id') or metadata.get('task_id')\n        if generation_id:\n            item['generation_id'] = str(generation_id)\n\n        resolved_path = item.get('resolved_path')\n        candidate_paths = [\n            resolved_path,\n            item.get('absolute_path'),\n            metadata.get('local_path'),\n            item.get('file_path'),\n        ]\n        abs_path = next((p for p in candidate_paths if p), None)\n        \n        # 验证绝对路径是否真实存在（修复旧记录路径失效问题）\n        if abs_path and not Path(abs_path).exists():\n            logger.warning(f\"绝对路径无效，将尝试从relative_path重新构造: {abs_path}\")\n            abs_path = None  # 重置，触发下面的重新构造逻辑\n        \n        if not abs_path and (item.get('relative_path') or metadata.get('relative_path')):\n            rel = item.get('relative_path') or metadata.get('relative_path')\n            try:\n                root = self.storage_root\n                original_path = Path(root) / rel\n                if original_path.exists():\n                    abs_path = str(original_path)\n                    logger.debug(f\"使用路径: {abs_path}\")\n                else:\n                    abs_path = str(original_path)\n                    logger.warning(f\"文件不存在: {original_path}\")\n            except Exception as e:\n                logger.error(f\"路径解析失败: {rel}, 错误: {e}\")\n                abs_path = None\n\n        if abs_path:\n            abs_path = str(abs_path)\n            item['absolute_path'] = abs_path\n            item['local_path'] = abs_path\n            item['file_path'] = abs_path\n\n        # 记录相对路径\n        rel_value = item.get('relative_path') or metadata.get('relative_path')\n        if rel_value:\n            item['relative_path'] = str(rel_value)\n\n        # 若缺少真实路径且状态已完成，则忽略该记录\n        if not (item.get('file_path') or item.get('absolute_path') or item.get('relative_path')):\n            status = str(item.get('status') or '').lower()\n            # pending 状态的记录应该保留（即使缺路径，用于占位卡片显示）\n            if status == 'pending':\n                pass  # 不过滤，继续处理\n            elif not status or status in {'completed', 'success'}:\n                return {}\n\n       # 缩略图字段\n        thumb_local = item.get('thumbnail_local_path') or metadata.get('thumbnail_local_path') or metadata.get('api_thumbnail_local_path')\n        if thumb_local:\n            item['thumbnail_local_path'] = str(thumb_local)\n\n        thumb_rel = item.get('thumbnail_path') or metadata.get('thumbnail_path') or item.get('thumbnail_local_path')\n        if thumb_rel:\n            item['thumbnail_path'] = str(thumb_rel)\n            # 如果没有 thumbnail_local_path，则从相对路径生成绝对路径\n            if not thumb_local:\n                try:\n                    thumb_abs = Path(self.storage_root) / thumb_rel\n                    if thumb_abs.exists():\n                        item['thumbnail_local_path'] = str(thumb_abs)\n                        logger.debug(f\"生成缩略图绝对路径: {thumb_abs}\")\n                    else:\n                        logger.debug(f\"缩略图文件不存在: {thumb_abs}\")\n                except Exception as e:\n                    logger.debug(f\"缩略图路径解析失败: {thumb_rel}, 错误: {e}\")\n\n        # 补充尺寸信息，便于前端按比例渲染\n        width = item.get('width') or metadata.get('width')\n        height = item.get('height') or metadata.get('height')\n        if width:\n            try:\n                item['width'] = int(float(width))\n            except Exception:\n                pass\n        if height:\n            try:\n                item['height'] = int(float(height))\n            except Exception:\n                pass\n        # 尝试从参数 size 提取比例（如果未提供 width/height）\n        if (not item.get('width') or not item.get('height')):\n            size_txt = item['parameters'].get('size') if isinstance(item['parameters'], dict) else None\n            if isinstance(size_txt, str) and 'x' in size_txt:\n                try:\n                    sw, sh = size_txt.split('x')\n                    item['width'] = item.get('width') or int(float(sw))\n                    item['height'] = item.get('height') or int(float(sh))\n                except Exception:\n                    pass\n        # 兜底：若本地文件存在且仍缺尺寸，尝试读取一次\n        if (not item.get('width') or not item.get('height')):\n            try:\n                abs_path_probe = item.get('absolute_path') or item.get('file_path')\n                if abs_path_probe and Path(abs_path_probe).exists():\n                    from PIL import Image\n                    with Image.open(abs_path_probe) as img:\n                        item['width'] = item.get('width') or int(img.width)\n                        item['height'] = item.get('height') or int(img.height)\n            except Exception as exc:\n                logger.debug(f\"尺寸读取失败: {exc}\")\n\n        # 提升 prompt 等常用字段\n        if not item.get('prompt') and item['parameters'].get('prompt'):\n            item['prompt'] = item['parameters']['prompt']\n\n        return item\n\n    def _parse_created_at(self, value: Any) -> datetime:\n        if isinstance(value, datetime):\n            return value\n        if not value:\n            return datetime.min\n        text = str(value)\n        try:\n            if text.endswith('Z'):\n                text = text[:-1] + '+00:00'\n            return datetime.fromisoformat(text)\n        except Exception:\n            try:\n                return datetime.strptime(text, '%Y-%m-%d %H:%M:%S')\n            except Exception:\n                return datetime.min\n\n    def _record_sort_key(self, record: Dict[str, Any]) -> Tuple[datetime, str]:\n        created_dt = self._parse_created_at(record.get('created_at'))\n        # fallback: 如果 created_at 无效，尝试使用 updated_at\n        if created_dt == datetime.min:\n            created_dt = self._parse_created_at(record.get('updated_at'))\n        file_id = str(record.get('file_id', ''))\n        return (created_dt, file_id)\n\n    def add_content(self, content_id: str, content_type: str, \n                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n        \"\"\"\n        添加内容到仓库\n        \n        Args:\n            content_id: 内容唯一标识\n            content_type: 内容类型 (image/video/audio/chat)\n            metadata: 内容元数据\n            auto_tag: 是否自动生成标签\n        \n        Returns:\n            是否添加成功\n        \"\"\"\n        try:\n            normalized_type = (content_type or '').lower()\n            if normalized_type in {'image', 'images'}:\n                storage_type = 'images'\n            elif normalized_type in {'video', 'videos'}:\n                storage_type = 'videos'\n            else:\n                storage_type = normalized_type or 'unknown'\n            status = metadata.get('status', 'unknown')\n            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n            return result\n        except Exception as e:\n            logger.error(f\"添加内容失败: {e}\")\n            return False\n    \n    def update_record(self, record_id: str, data: Dict[str, Any]) -> bool:\n        \"\"\"更新记录\"\"\"\n        try:\n            return self.sqlite_handler.update_record(record_id, data)\n        except Exception as e:\n            logger.error(f\"更新记录失败: {e}\")\n            return False\n\n    def delete_record(self, record_id: str) -> bool:\n        \"\"\"删除记录\"\"\"\n        try:\n            return self.sqlite_handler.delete_record(record_id)\n        except Exception as e:\n            logger.error(f\"删除记录失败: {e}\")\n            return False\n\n    def delete_record_with_files(self, record_id: str) -> bool:\n        \"\"\"删除记录及其所有关联文件\n        \n        Args:\n            record_id: 记录ID\n            \n        Returns:\n            bool: 是否删除成功\n        \"\"\"\n        if not record_id:\n            return False\n            \n        try:\n            # 1. 获取记录详情\n            record = self.get_record_by_id(record_id)\n            if not record:\n                logger.warning(f\"删除记录: 未找到记录 {record_id}\")\n                return False\n            \n            # 2. 收集需要删除的文件路径\n            files_to_delete = []\n            \n            # 主文件（图片/视频）\n            file_path = record.get('absolute_path') or record.get('file_path')\n            if file_path:\n                files_to_delete.append(file_path)\n            \n            # 缩略图\n            thumb_path = record.get('thumbnail_local_path')\n            if thumb_path:\n                files_to_delete.append(thumb_path)\n            \n            # 参考图资产\n            ref_info = record.get('_reference_info') or {}\n            ref_assets = ref_info.get('assets', [])\n            if not ref_assets:\n                # 尝试从 parameters 中获取\n                params = record.get('parameters') or {}\n                ref_assets = params.get('reference_assets', [])\n            \n            for ref in ref_assets:\n                if isinstance(ref, dict):\n                    ref_path = ref.get('absolute_path') or ref.get('path')\n                    if ref_path and str(ref_path) not in [str(f) for f in files_to_delete]:\n                        # 转换相对路径为绝对路径\n                        if not Path(ref_path).is_absolute():\n                            ref_path = str(self.storage_root / ref_path)\n                        files_to_delete.append(ref_path)\n            \n            # 3. 删除数据库记录\n            if not self.delete_record(record_id):\n                logger.error(f\"删除记录失败: 数据库删除失败 {record_id}\")\n                return False\n            \n            # 4. 删除文件（忽略不存在的文件）\n            deleted_files = []\n            for path in files_to_delete:\n                try:\n                    if path and Path(path).exists():\n                        Path(path).unlink()\n                        deleted_files.append(path)\n                        logger.debug(f\"已删除文件: {path}\")\n                except Exception as e:\n                    logger.warning(f\"删除文件失败: {path}, {e}\")\n            \n            logger.info(f\"删除记录完成: {record_id}, 删除了 {len(deleted_files)} 个文件\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"删除记录及文件失败: {record_id}, {e}\")\n            return False\n\n    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n        \"\"\"清理超时的 pending 记录\n\n        Args:\n            timeout_hours: 超时时间（小时），默认 1 小时\n\n        Returns:\n            清理的记录数量\n        \"\"\"\n        try:\n            return self.sqlite_handler.cleanup_stale_pending_records(timeout_hours)\n        except Exception as e:\n            logger.error(f\"清理过期 pending 记录失败: {e}\")\n            return 0\n\n    def get_record_by_id(self, record_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"根据 ID 获取单条记录。\"\"\"\n        if not record_id:\n            return None\n        try:\n            raw = self.sqlite_handler.get_record_by_id(record_id)\n            if not raw:\n                return None\n            content_type = raw.get('content_type') or 'image'\n            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n            normalized = self._normalize_record(raw, normalized_type)\n            if not normalized:\n                return None\n            self._attach_reference_assets([normalized], absolute=True)\n            return normalized\n        except Exception as e:\n            logger.error(f\"获取记录失败: {e}\")\n            return None\n    \n    def get_records_batch(self, start_index=0, batch_size=40, record_type='all'):\n        \"\"\"\n        批量获取记录，支持分页查询\n        \n        Args:\n            start_index: 起始索引\n            batch_size: 批量大小\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            List[Dict]: 记录列表\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'images':\n                normalized_type = 'image'\n            elif normalized_type == 'videos':\n                normalized_type = 'video'\n\n            if normalized_type == 'all':\n                fetch_limit = max(batch_size, start_index + batch_size)\n                images = self.sqlite_handler.get_records('images', fetch_limit, 0) or []\n                videos = self.sqlite_handler.get_records('videos', fetch_limit, 0) or []\n                combined = images + videos\n                combined.sort(key=self._record_sort_key, reverse=True)\n                end_index = start_index + batch_size\n                result = combined[start_index:end_index]\n            else:\n                content_type = 'images' if normalized_type == 'image' else 'videos'\n                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n                result.sort(key=self._record_sort_key, reverse=True)\n\n            normalized = self._normalize_records(result, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n            return normalized\n        except Exception as e:\n            self.error_handler.log_error(f\"批量获取记录失败: {e}\")\n            return []\n\n    def get_records_batch_reverse(self, limit=80, offset=0, record_type='all'):\n        \"\"\"\n        倒序分页查询记录 - 瀑布流1000条方案专用\n        \n        优化特性：\n        - 从最新记录开始的高效倒序查询\n        - 支持80+30增量加载模式\n        - 针对1000条数据优化的性能\n        - 减少内存占用和查询时间\n        \n        Args:\n            limit: 查询数量限制 (默认80，增量30)\n            offset: 偏移量 (从最新记录开始计算)\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            List[Dict]: 按时间倒序排列的记录列表\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'images':\n                normalized_type = 'image'\n            elif normalized_type == 'videos':\n                normalized_type = 'video'\n\n            max_single_query = min(limit + 50, 200)\n\n            if normalized_type == 'all':\n                images = self.sqlite_handler.get_records('images', max_single_query, 0) or []\n                videos = self.sqlite_handler.get_records('videos', max_single_query, 0) or []\n                combined = images + videos\n                combined.sort(key=self._record_sort_key, reverse=True)\n                start_idx = offset\n                end_idx = offset + limit\n                result = combined[start_idx:end_idx]\n            else:\n                content_type = 'images' if normalized_type == 'image' else 'videos'\n                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n                result.sort(key=self._record_sort_key, reverse=True)\n\n            normalized = self._normalize_records(result, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n\n            return normalized\n\n        except Exception as e:\n            self.error_handler.log_error(f\"倒序分页查询失败: {e}\")\n            return []\n\n    def get_records_count_optimized(self, record_type='all'):\n        \"\"\"\n        优化的记录计数方法 - 瀑布流1000条方案专用\n        \n        提供快速的记录计数，支持1000条限制逻辑\n        \n        Args:\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            Dict: {'total': int, 'capped_at_1000': bool}\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'image':\n                total = self.sqlite_handler.get_total_count('images')\n            elif normalized_type == 'video':\n                total = self.sqlite_handler.get_total_count('videos')\n            else:\n                total = (\n                    self.sqlite_handler.get_total_count('images') +\n                    self.sqlite_handler.get_total_count('videos')\n                )\n\n            # 1000条限制逻辑\n            capped_at_1000 = total > 1000\n            effective_total = min(total, 1000)\n            \n            return {\n                'total': effective_total,\n                'actual_total': total,\n                'capped_at_1000': capped_at_1000\n            }\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"优化记录计数失败: {e}\")\n            return {'total': 0, 'actual_total': 0, 'capped_at_1000': False}\n\n    # =========================\n    # 游标分页协议（初版实现）\n    # 接口：get_records(page_size, cursor, record_type) -> { items, next_cursor }\n    # 说明：当前实现基于现有CSV读取能力合并排序后切片，后续可在存储层优化为限窗/游标扫描。\n    # =========================\n    def get_records(self, page_size: int = 40, cursor: Optional[str] = None, record_type: str = 'all') -> Dict[str, Any]:\n        \"\"\"\n        游标分页获取记录\n\n        Args:\n            page_size: 每页大小\n            cursor: 上一页游标（格式：\"<created_at>|<file_id>|<type>\"），None表示第一页\n            record_type: 'image' | 'video' | 'all'\n\n        Returns:\n            dict: { items: List[Dict], next_cursor: Optional[str] }\n        \"\"\"\n        try:\n            # 解析游标\n            cursor_tuple: Optional[Tuple[str, str, str]] = None\n            if cursor:\n                try:\n                    parts = cursor.split('|')\n                    if len(parts) >= 3:\n                        cursor_tuple = (parts[0], parts[1], parts[2])  # created_at, file_id, type\n                except Exception:\n                    cursor_tuple = None\n\n            # 拉取候选数据（按需窗口，尽量少取）\n            fetch_limit = max(page_size * 3, 60)\n\n            def _load(ct: str) -> List[Dict[str, Any]]:\n                return self._normalize_records(\n                    self.sqlite_handler.get_records(ct, fetch_limit, 0) or [],\n                    ct\n                )\n\n            if record_type == 'image':\n                records = _load('images')\n            elif record_type == 'video':\n                records = _load('videos')\n            else:\n                records = _load('images') + _load('videos')\n\n            # 排序：created_at DESC, file_id DESC\n            records.sort(key=self._record_sort_key, reverse=True)\n\n            # 光标过滤：跳过光标及其之前的元素（保持稳定倒序）\n            filtered: List[Dict[str, Any]] = []\n            if cursor_tuple:\n                cur_created, cur_id, cur_type = cursor_tuple\n                passed = False\n                for rec in records:\n                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n                    rec_key = (rec.get('created_at', '1970-01-01T00:00:00'), rec.get('file_id', ''), rec_type)\n                    # 记录严格小于游标（因为倒序），才加入\n                    if passed:\n                        filtered.append(rec)\n                    else:\n                        if (rec_key[0] < cur_created) or (rec_key[0] == cur_created and rec_key[1] < cur_id) or (rec_key[0] == cur_created and rec_key[1] == cur_id and rec_key[2] < cur_type):\n                            passed = True\n                            filtered.append(rec)\n                candidates = filtered\n            else:\n                candidates = records\n\n            # 取一页\n            page_items = candidates[:page_size]\n            self._attach_reference_assets(page_items, absolute=True)\n\n            # 生成 next_cursor\n            if page_items:\n                last = page_items[-1]\n                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n                next_cursor = f\"{last.get('created_at','')}|{last.get('file_id','')}|{last_type}\"\n            else:\n                next_cursor = None\n\n            return {\n                'items': page_items,\n                'next_cursor': next_cursor\n            }\n\n        except Exception as e:\n            self.error_handler.log_error(f\"游标分页获取记录失败: {e}\")\n            return {\n                'items': [],\n                'next_cursor': None\n            }\n\n    def get_total_count(self, record_type='all'):\n        \"\"\"\n        获取总记录数\n        \n        Args:\n            record_type: 记录类型 ('image', 'video', 'all')\n            \n        Returns:\n            int: 总记录数\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'image':\n                return self.sqlite_handler.get_total_count('images')\n            if normalized_type == 'video':\n                return self.sqlite_handler.get_total_count('videos')\n\n            return (\n                self.sqlite_handler.get_total_count('images') +\n                self.sqlite_handler.get_total_count('videos')\n            )\n        except Exception as e:\n            self.error_handler.log_error(f\"获取记录总数失败: {e}\")\n            return 0\n\n    def _resolve_reference_assets(self, record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n        if not isinstance(record, dict):\n            return []\n\n        params_raw = record.get('parameters')\n        params_dict: Dict[str, Any] = {}\n        if isinstance(params_raw, dict):\n            params_dict = params_raw\n        elif isinstance(params_raw, str):\n            try:\n                params_dict = json.loads(params_raw) or {}\n            except Exception:\n                params_dict = {}\n\n        assets = []\n        if isinstance(params_dict, dict):\n            assets = params_dict.get('reference_assets') or []\n        if not assets:\n            fallback = record.get('reference_assets')\n            assets = fallback if isinstance(fallback, list) else []\n        if not assets:\n            return []\n\n        resolved: List[Dict[str, Any]] = []\n        for item in assets:\n            if not isinstance(item, dict):\n                continue\n            rec = dict(item)\n            rel_path = rec.get('relative_path') or rec.get('asset_path')\n            if rel_path and absolute:\n                abs_path = Path(self.storage_root) / rel_path\n                rec['absolute_path'] = str(abs_path)\n                rec['asset_path'] = str(abs_path)\n            resolved.append(rec)\n        return resolved\n\n    \n    def _resolve_video_reference_assets(self, record: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"\n        解析视频记录中的参考图资产\n        \n        从parameters.first_frame和image_path提取参考图信息\n        \"\"\"\n        if not isinstance(record, dict):\n            return []\n            \n        params = record.get('parameters', {})\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n\n        # 收集参考图路径\n        ref_paths = []\n\n        storage_root = self.storage_root\n\n        def _resolve_path(path_str: Optional[str]) -> Optional[Path]:\n            if not path_str:\n                return None\n            candidate = Path(path_str).expanduser()\n            if candidate.is_absolute():\n                return candidate if candidate.exists() else None\n            combined = storage_root / path_str.lstrip('/\\\\')\n            return combined if combined.exists() else None\n\n        # 从first_frame提取\n        first_frame = params.get('first_frame')\n        resolved_first = _resolve_path(first_frame) if isinstance(first_frame, str) else None\n        if resolved_first:\n            ref_paths.append(('first_frame', str(resolved_first)))\n\n        # 从last_frame提取（首尾帧模式）\n        last_frame = params.get('last_frame')\n        resolved_last = _resolve_path(last_frame) if isinstance(last_frame, str) else None\n        if resolved_last:\n            ref_paths.append(('last_frame', str(resolved_last)))\n\n        # 从image_path提取\n        image_path = params.get('image_path')\n        resolved_image = _resolve_path(image_path) if isinstance(image_path, str) else None\n        if resolved_image and all(str(resolved_image) != existing_path for _, existing_path in ref_paths):\n            ref_paths.append(('image', str(resolved_image)))\n\n        # 构建参考图资产信息\n        resolved_assets = []\n        for i, (kind, path) in enumerate(ref_paths):\n            try:\n                file_path = Path(path)\n                if file_path.exists():\n                    stat = file_path.stat()\n                    try:\n                        rel = file_path.resolve().relative_to(storage_root)\n                        rel_str = str(rel).replace('\\\\', '/')\n                    except ValueError:\n                        rel_str = str(file_path)\n                    asset = {\n                        'id': f'ref_video_{record.get(\"generation_id\", \"unknown\")}_{i}',\n                        'path': rel_str,\n                        'relative_path': rel_str,\n                        'absolute_path': str(file_path.resolve()),\n                        'type': 'image',\n                        'kind': kind or 'image',\n                        'source': file_path.name,\n                        'order': i,\n                        'size': stat.st_size,\n                        'exists': True,\n                        'created_at': record.get('created_at', datetime.now().isoformat())\n                    }\n\n                    # 尝试获取图片尺寸\n                    try:\n                        from PIL import Image\n                        with Image.open(path) as img:\n                            asset['width'] = img.width\n                            asset['height'] = img.height\n                    except:\n                        asset['width'] = None\n                        asset['height'] = None\n                        \n                    resolved_assets.append(asset)\n            except Exception as e:\n                print(f\"  ⚠️ 解析参考图失败: {path} - {e}\")\n                \n        return resolved_assets\n\n    def _attach_reference_assets(self, records: List[Dict[str, Any]], *, absolute: bool = False) -> None:\n        if not records:\n            return\n        for record in records:\n            try:\n                # 先尝试原有的解析逻辑\n                resolved = self._resolve_reference_assets(record, absolute=absolute)\n                \n                # 如果原有逻辑没有找到参考图，尝试视频参考图解析\n                if not resolved and record.get('content_type') == 'videos':\n                    video_refs = self._resolve_video_reference_assets(record)\n                    if video_refs:\n                        resolved = video_refs\n                        # 更新_reference_info\n                        record['_reference_info'] = {\n                            'count': len(video_refs),\n                            'summary': f'{len(video_refs)}个参考图',\n                            'labels': ['参考图'],\n                            'assets': video_refs\n                        }\n                \n                if absolute:\n                    record['_resolved_reference_assets_abs'] = resolved\n                record['_resolved_reference_assets'] = resolved\n                \n                # 确保_reference_info存在\n                if '_reference_info' not in record:\n                    record['_reference_info'] = {\n                        'count': len(resolved),\n                        'summary': f'{len(resolved)}个参考图' if resolved else '',\n                        'labels': ['参考图'] if resolved else [],\n                        'assets': resolved\n                    }\n                    \n            except Exception as exc:\n                logger.debug(f\"attach_reference_assets failed: {exc}\")\n\n    def search_content(self, query: str, content_type: Optional[str] = None,\n                      tags: Optional[List[str]] = None, \n                      limit: int = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        搜索仓库内容\n        \n        Args:\n            query: 搜索关键词\n            content_type: 内容类型过滤\n            tags: 标签过滤\n            limit: 结果数量限制\n        \n        Returns:\n            搜索结果列表\n        \"\"\"\n        try:\n            if limit is None or limit <= 0:\n                limit = self.config.get(\"search_result_limit\", 100)\n\n            keyword = (query or \"\").strip()\n            if not keyword:\n                return []\n\n            normalized_type = 'all'\n            sqlite_type: Optional[str] = None\n            if content_type:\n                ct = content_type.lower()\n                if ct in {'image', 'images'}:\n                    sqlite_type = 'images'\n                    normalized_type = 'image'\n                elif ct in {'video', 'videos'}:\n                    sqlite_type = 'videos'\n                    normalized_type = 'video'\n\n            results = self.sqlite_handler.search_records(keyword, sqlite_type, limit) or []\n            normalized = self._normalize_records(results, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n            return normalized\n        except Exception as e:\n            logger.error(f\"搜索内容失败: {e}\")\n            return []\n    \n    def get_content_tags(self, content_id: str) -> List[str]:\n        \"\"\"\n        获取内容的所有标签\n        \n        Args:\n            content_id: 内容ID\n        \n        Returns:\n            标签列表\n        \"\"\"\n        return self.tag_manager.get_content_tags(content_id)\n    \n    def add_tag_to_content(self, content_id: str, tag: str, \n                          category: str = \"自定义标签\") -> bool:\n        \"\"\"\n        为内容添加标签\n        \n        Args:\n            content_id: 内容ID\n            tag: 标签名称\n            category: 标签分类\n        \n        Returns:\n            是否添加成功\n        \"\"\"\n        return self.tag_manager.add_tag_to_content(content_id, tag, category)\n    \n    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n        \"\"\"\n        从内容中移除标签\n        \n        Args:\n            content_id: 内容ID\n            tag: 标签名称\n        \n        Returns:\n            是否移除成功\n        \"\"\"\n        return self.tag_manager.remove_tag_from_content(content_id, tag)\n    \n    def get_all_tags(self, category: Optional[str] = None) -> List[str]:\n        \"\"\"\n        获取所有标签\n        \n        Args:\n            category: 标签分类过滤\n        \n        Returns:\n            标签列表\n        \"\"\"\n        return self.tag_manager.get_all_tags(category)\n    \n    def get_tag_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取标签统计信息\n        \n        Returns:\n            统计信息字典\n        \"\"\"\n        return self.tag_manager.get_statistics()\n    \n    def export_repository_data(self, export_format: str = \"json\") -> str:\n        \"\"\"\n        导出仓库数据\n\n        Args:\n            export_format: 导出格式 (json/csv/xlsx)\n\n        Returns:\n            导出文件路径\n        \"\"\"\n        try:\n            export_dir = self.repository_root / \"exports\"\n            export_dir.mkdir(exist_ok=True)\n            \n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"repository_export_{timestamp}.{export_format}\"\n            export_path = export_dir / filename\n            \n            # 收集所有数据\n            storage_stats = {\n                \"images\": self.sqlite_handler.get_total_count('images'),\n                \"videos\": self.sqlite_handler.get_total_count('videos')\n            }\n            data = {\n                \"config\": self.config,\n                \"tags\": self.tag_manager.export_data(),\n                \"search_index\": self.search_engine.export_data(),\n                \"storage_stats\": storage_stats,\n                \"export_time\": datetime.now().isoformat()\n            }\n            \n            if export_format == \"json\":\n                with open(export_path, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, ensure_ascii=False, indent=2)\n            \n            return str(export_path)\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"导出仓库数据失败: {e}\")\n            return \"\"\n\n    def export_generation_bundle(\n        self,\n        file_ids: List[str],\n        record_type: str = \"image\",\n        *,\n        destination_dir: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"导出指定文件ID的生成记录及参考图。\"\"\"\n        def _mask(value: Any) -> str:\n            if value in (None, \"\"):\n                return \"-\"\n            text = str(value)\n            return f\"{text[:6]}***\"\n\n        record_type = (record_type or \"\").lower()\n        if record_type not in {\"image\", \"video\"}:\n            raise ValueError(f\"不支持的记录类型: {record_type}\")\n\n        exports_dir = Path(self.storage_root) / \"exports\"\n        exports_dir.mkdir(parents=True, exist_ok=True)\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        output_base = exports_dir / f\"{record_type}_bundle_{timestamp}\"\n\n        normalized_ids = [str(fid) for fid in file_ids if fid]\n        export_result = export_records(record_type, normalized_ids, output_base)\n        if not export_result:\n            masked_ids = \",\".join(_mask(fid) for fid in normalized_ids) or \"-\"\n            logger.warning(\n                \"摘要|operation=export_bundle status=failed record_type={rtype} record_ids={ids} reason={reason}\",\n                rtype=record_type,\n                ids=masked_ids,\n                reason=\"no_result\",\n            )\n            raise RuntimeError(\"导出参考图失败\")\n\n        zip_path = Path(export_result[\"zip_path\"])\n        manifest_json = Path(export_result[\"manifest_json\"])\n        manifest_csv = Path(export_result[\"manifest_csv\"])\n\n        destination_zip = None\n        destination_manifest_json = None\n        destination_manifest_csv = None\n\n        if destination_dir:\n            dest_dir_path = Path(destination_dir).expanduser()\n            dest_dir_path.mkdir(parents=True, exist_ok=True)\n            try:\n                destination_zip = dest_dir_path / zip_path.name\n                shutil.copy2(zip_path, destination_zip)\n                destination_manifest_json = dest_dir_path / manifest_json.name\n                shutil.copy2(manifest_json, destination_manifest_json)\n                destination_manifest_csv = dest_dir_path / manifest_csv.name\n                shutil.copy2(manifest_csv, destination_manifest_csv)\n            except PermissionError as exc:\n                logger.warning(\n                    \"摘要|operation=export_bundle status=failed reason=permission_denied record_type={rtype} dest={dest}\",\n                    rtype=record_type,\n                    dest=dest_dir_path.name,\n                )\n                raise PermissionError(\"导出目录无写入权限\") from exc\n\n        reference_ids = export_result.get(\"reference_ids\", [])\n        masked_refs = \",\".join(_mask(rid) for rid in reference_ids if rid) or \"-\"\n        status = export_result.get(\"status\", \"success\") or \"success\"\n        missing_records = export_result.get(\"missing_records\", []) or []\n        missing_main_files = export_result.get(\"missing_main_files\", []) or []\n        missing_references = export_result.get(\"missing_references\", []) or []\n        dest_hint_path = destination_zip.parent if destination_zip else zip_path.parent\n        try:\n            dest_hint_text = Path(dest_hint_path).name or Path(dest_hint_path).parent.name\n        except Exception:\n            dest_hint_text = \"-\"\n        logger.info(\n            \"摘要|operation=export_bundle status={status} record_type={rtype} record_ids={ids} ref_count={ref_count} ref_ids={refs} missing_records={miss_rec} missing_files={miss_files} missing_refs={miss_refs} dest={dest}\",\n            status=status,\n            rtype=record_type,\n            ids=\",\".join(_mask(fid) for fid in normalized_ids) or \"-\",\n            ref_count=export_result.get(\"reference_count\", 0),\n            refs=masked_refs,\n            miss_rec=len(missing_records),\n            miss_files=len(missing_main_files),\n            miss_refs=len(missing_references),\n            dest=dest_hint_text or \"-\",\n        )\n\n        return {\n            \"zip_path\": str(zip_path),\n            \"manifest_json\": str(manifest_json),\n            \"manifest_csv\": str(manifest_csv),\n            \"destination_zip\": str(destination_zip) if destination_zip else None,\n            \"destination_manifest_json\": str(destination_manifest_json) if destination_manifest_json else None,\n            \"destination_manifest_csv\": str(destination_manifest_csv) if destination_manifest_csv else None,\n            \"status\": status,\n            \"reference_count\": export_result.get(\"reference_count\", 0),\n            \"reference_ids\": reference_ids,\n            \"missing_records\": missing_records,\n            \"missing_main_files\": missing_main_files,\n            \"missing_references\": missing_references,\n            \"records\": export_result.get(\"records\", []),\n            \"exported_record_ids\": export_result.get(\"exported_record_ids\", normalized_ids),\n        }\n    \n    def get_repository_status(self) -> Dict[str, Any]:\n        \"\"\"\n        获取仓库状态信息\n        \n        Returns:\n            状态信息字典\n        \"\"\"\n        try:\n            return {\n                \"version\": self.config.get(\"version\", \"0.1.5\"),\n                \"storage_root\": str(self.storage_root),\n                \"repository_root\": str(self.repository_root),\n                \"total_content_count\": self.get_total_count('all'),\n                \"total_tags_count\": len(self.tag_manager.get_all_tags()),\n                \"tag_categories\": self.config.get(\"tag_categories\", []),\n                \"last_updated\": self.config.get(\"last_updated\"),\n                \"auto_tag_enabled\": self.config.get(\"auto_tag_enabled\", True),\n                \"search_index_enabled\": self.config.get(\"search_index_enabled\", True)\n            }\n        except Exception as e:\n            self.error_handler.log_error(f\"获取仓库状态失败: {e}\")\n            return {}\n    \n    def update_config(self, new_config: Dict[str, Any]) -> bool:\n        \"\"\"\n        更新仓库配置\n        \n        Args:\n            new_config: 新配置字典\n        \n        Returns:\n            是否更新成功\n        \"\"\"\n        try:\n            self.config.update(new_config)\n            self._save_config(self.config)\n            return True\n        except Exception as e:\n            self.error_handler.log_error(f\"更新仓库配置失败: {e}\")\n            return False\n","numLines":1227,"startLine":1,"totalLines":1227}}}
{"parentUuid":"274c3080-eb93-4904-af5c-6fb139e03dea","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015v2JChQk9ns3RkhFfyPgFT","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config_api import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n    59→        \n    60→        # 保持兼容性别名\n    61→        self.file_manager = self.storage_manager\n    62→        self.metadata_manager = self.storage_manager\n    63→        self.image_storage_manager = self.storage_manager\n    64→        \n    65→        # 保留原有的目录属性以保持兼容性\n    66→        self.data_dir = Path(self.storage_manager.root_path)\n    67→        self.images_dir = self.data_dir / \"images\"\n    68→        self.metadata_dir = self.data_dir / \"metadata\"\n    69→\n    70→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    71→\n    72→    def generate_text_to_image(\n    73→        self,\n    74→        prompt: str,\n    75→        size: str = \"1024x1024\",\n    76→        guidance_scale: float = 2.5,\n    77→        seed: int = -1,\n    78→        save_local: bool = True,\n    79→        reference_images: Optional[List[Any]] = None,\n    80→        model_variant: Optional[str] = None,\n    81→        generation_id: Optional[str] = None,\n    82→        count: int = 1,\n    83→        sequential_mode: bool = False,\n    84→        derived_ids: Optional[List[str]] = None,\n    85→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    86→    ) -> Dict[str, Any]:\n    87→        \"\"\"\n    88→        生成文生图并保存到本地\n    89→\n    90→        Args:\n    91→            prompt: 图像生成提示词\n    92→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    93→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    94→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    95→            response_format: 返回格式，\"url\"或\"b64_json\"\n    96→            save_local: 是否保存到本地\n    97→            reference_images: 参考图列表\n    98→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n    99→            count: 生成图片数量（组图模式下生效）\n   100→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   101→            derived_ids: 组图生成的ID列表（用于关联）\n   102→\n   103→        Returns:\n   104→            Dict: 生成结果，包含本地文件路径\n   105→\n   106→        Note:\n   107→            model和watermark参数已固定，不再需要前端控制\n   108→        \"\"\"\n   109→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   110→        \n   111→        # 根据 model_variant 设置环境变量\n   112→        if model_variant == 'seedream_v4':\n   113→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4\"\n   114→        elif model_variant == 'seedream_v4_5':\n   115→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4_5\"\n   116→        else:\n   117→            # 默认使用 volc_v3\n   118→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v3\"\n   119→\n   120→        # 生成唯一ID，优先使用外部传入的generation_id\n   121→        task_id = generation_id or str(uuid.uuid4())\n   122→\n   123→        ref_assets: List[Dict[str, Any]] = []\n   124→        ref_paths: List[str] = []\n   125→        ref_summary: Dict[str, Any] = {}\n   126→        ref_payloads: List[str] = []\n   127→\n   128→        try:\n   129→            if reference_images:\n   130→                ref_summary = self._process_reference_assets(\n   131→                    reference_images,\n   132→                    max_refs=MAX_REFERENCE_IMAGES,\n   133→                    expected_outputs=1,\n   134→                )\n   135→                ref_assets = list(ref_summary.get('assets', []))\n   136→                ref_paths = list(ref_summary.get('paths', []))\n   137→                ref_payloads = self._build_reference_payloads(ref_assets)\n   138→\n   139→                if ref_summary.get('errors'):\n   140→                    logger.warning(\n   141→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   142→                    )\n   143→                if ref_summary.get('warnings'):\n   144→                    for warn in ref_summary['warnings']:\n   145→                        logger.warning(f\"参考图提示: {warn}\")\n   146→\n   147→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   148→            try:\n   149→                norm, fb, reason = validate_and_normalize_t2i(\n   150→                    TextToImageParams(\n   151→                        prompt=prompt,\n   152→                        size=size,\n   153→                        guidance_scale=guidance_scale,\n   154→                        seed=(None if seed == -1 else seed),\n   155→                    )\n   156→                )\n   157→                logger.info(\n   158→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   159→                )\n   160→                if fb:\n   161→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   162→            except Exception as _e:\n   163→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   164→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   165→            actual_count = max(1, count)\n   166→            use_group_mode = bool(sequential_mode and actual_count > 1)\n   167→\n   168→            api_result = self.client.text_to_image(\n   169→                prompt=prompt,\n   170→                size=size,\n   171→                guidance_scale=guidance_scale,\n   172→                seed=seed,\n   173→                reference_images=ref_payloads or None,\n   174→                n=actual_count if use_group_mode else 1,\n   175→                sequential_mode=sequential_mode,\n   176→            )\n   177→\n   178→            # 组图模式：API 返回多张图，需要逐一保存\n   179→            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n   180→            images_count = len(images_list)\n   181→            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n   182→\n   183→            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n   184→            if use_group_mode and images_count < actual_count:\n   185→                logger.warning(\n   186→                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n   187→                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n   188→                )\n   189→\n   190→            if use_group_mode and images_count > 1:\n   191→                results_batch = []\n   192→                success_count = 0\n   193→                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n   194→                total_images = len(images_list)\n   195→\n   196→                for idx, img_data in enumerate(images_list):\n   197→                    # 发送下载进度（每张图开始下载时）\n   198→                    if progress_callback:\n   199→                        try:\n   200→                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n   201→                        except Exception:\n   202→                            pass\n   203→\n   204→                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n   205→                    per_result = {\n   206→                        \"task_id\": per_id,\n   207→                        \"success\": True,\n   208→                        \"type\": \"text_to_image\",\n   209→                        \"prompt\": prompt,\n   210→                        \"image_url\": img_data[\"url\"],\n   211→                        \"parameters\": {\n   212→                            \"size\": size,\n   213→                            \"guidance_scale\": guidance_scale,\n   214→                            \"seed\": seed,\n   215→                            \"response_format\": \"url\",\n   216→                            \"watermark\": False,\n   217→                            \"model\": self._resolve_model_id(\n   218→                                \"doubao-seedream-3-0-t2i-250415\",\n   219→                                \"doubao-seedream-4-0-250828\",\n   220→                                \"doubao-seedream-4-5-251128\",\n   221→                            ),\n   222→                            \"sequential_mode\": True,\n   223→                            \"group_index\": idx + 1,\n   224→                            \"group_total\": total_images,\n   225→                        },\n   226→                        \"created_at\": datetime.now().isoformat(),\n   227→                        \"usage\": api_result.get(\"usage\", {}),\n   228→                    }\n   229→\n   230→                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   231→                    if sanitized_refs:\n   232→                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   233→                        per_result[\"reference_assets\"] = sanitized_refs\n   234→\n   235→                    if save_local and per_result.get(\"image_url\"):\n   236→                        local_result = self._save_image_locally(per_result)\n   237→                        per_result.update(local_result)\n   238→                        if not local_result.get('local_save_error'):\n   239→                            success_count += 1\n   240→\n   241→                    results_batch.append(per_result)\n   242→\n   243→                    # 发送下载完成进度\n   244→                    if progress_callback:\n   245→                        try:\n   246→                            progress_callback(idx + 1, total_images, per_result)\n   247→                        except Exception:\n   248→                            pass\n   249→\n   250→                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n   251→                return {\n   252→                    \"batch\": True,\n   253→                    \"results\": results_batch,\n   254→                    \"success_count\": success_count,\n   255→                    \"total_count\": len(results_batch),\n   256→                    \"derived_ids\": group_ids,\n   257→                }\n   258→\n   259→            # 单图模式（默认）\n   260→            result = {\n   261→                \"task_id\": task_id,\n   262→                \"success\": True,\n   263→                \"type\": \"text_to_image\",\n   264→                \"prompt\": prompt,\n   265→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   266→                \"parameters\": {\n   267→                    \"size\": size,\n   268→                    \"guidance_scale\": guidance_scale,\n   269→                    \"seed\": seed,\n   270→                    \"response_format\": \"url\",  # 固定值\n   271→                    \"watermark\": False,  # 固定值\n   272→                    \"model\": self._resolve_model_id(\n   273→                        \"doubao-seedream-3-0-t2i-250415\",\n   274→                        \"doubao-seedream-4-0-250828\",\n   275→                        \"doubao-seedream-4-5-251128\",\n   276→                    )\n   277→                },\n   278→                \"created_at\": datetime.now().isoformat(),\n   279→                \"usage\": api_result.get(\"usage\", {}),\n   280→            }\n   281→\n   282→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   283→            if sanitized_refs:\n   284→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   285→                result[\"reference_assets\"] = sanitized_refs\n   286→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   287→                logger.info(\n   288→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   289→                    len(sanitized_refs),\n   290→                    masked_ids or \"-\",\n   291→                    self._provider_used(),\n   292→                )\n   293→            else:\n   294→                result[\"parameters\"][\"reference_assets\"] = []\n   295→                result[\"reference_assets\"] = []\n   296→\n   297→            # 保存到本地\n   298→            if save_local and result.get(\"image_url\"):\n   299→                local_result = self._save_image_locally(result)\n   300→                result.update(local_result)\n   301→                if local_result.get('local_save_error') and sanitized_refs:\n   302→                    self._cleanup_reference_paths(ref_paths)\n   303→                    result[\"parameters\"][\"reference_assets\"] = []\n   304→                    result[\"reference_assets\"] = []\n   305→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   306→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   307→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   308→\n   309→            logger.success(f\"文生图任务完成: {task_id}\")\n   310→            return result\n   311→\n   312→        except Exception as e:\n   313→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   314→            self._cleanup_reference_paths(ref_paths)\n   315→            return {\n   316→                \"task_id\": task_id,\n   317→                \"success\": False,\n   318→                \"error\": str(e),\n   319→                \"type\": \"text_to_image\"\n   320→            }\n   321→\n   322→    def generate_image_to_image(\n   323→        self,\n   324→        prompt: str,\n   325→        image: str,\n   326→        guidance_scale: float = 5.5,\n   327→        seed: int = -1,\n   328→        save_local: bool = True,\n   329→        reference_images: Optional[List[Any]] = None,\n   330→        generation_id: Optional[str] = None,\n   331→    ) -> Dict[str, Any]:\n   332→        \"\"\"\n   333→        生成图生图并保存到本地\n   334→\n   335→        Args:\n   336→            prompt: 编辑提示词\n   337→            image_path: 原始图像路径（本地路径或URL）\n   338→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   339→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   340→            response_format: 返回格式，\"url\"或\"b64_json\"\n   341→            save_local: 是否保存到本地\n   342→\n   343→        Returns:\n   344→            Dict: 生成结果\n   345→        \n   346→        Note:\n   347→            model、size、watermark参数已固定，不再需要前端控制\n   348→        \"\"\"\n   349→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   350→\n   351→        # 生成唯一ID，优先使用外部传入的generation_id\n   352→        task_id = generation_id or str(uuid.uuid4())\n   353→\n   354→        ref_paths: List[str] = []\n   355→\n   356→        try:\n   357→            # 处理输入图像\n   358→            image_data = self._prepare_input_image(image)\n   359→            if not image_data:\n   360→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   361→\n   362→            # 处理参考图（复制到 references 并准备 API 载荷）\n   363→            ref_summary = self._process_reference_assets(\n   364→                reference_images,\n   365→                max_refs=MAX_REFERENCE_IMAGES,\n   366→                expected_outputs=1,\n   367→            )\n   368→            ref_assets = ref_summary.get('assets', [])\n   369→            ref_paths = list(ref_summary.get('paths', []))\n   370→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   371→            if ref_summary.get('errors'):\n   372→                logger.warning(\n   373→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   374→                )\n   375→            if ref_summary.get('warnings'):\n   376→                for warn in ref_summary['warnings']:\n   377→                    logger.warning(f\"参考图提示: {warn}\")\n   378→\n   379→            # 前置参数校验（不改变流程，仅记录摘要）\n   380→            fb = False\n   381→            reason = \"\"\n   382→            try:\n   383→                norm, fb, reason = validate_and_normalize_i2i(\n   384→                    ImageToImageParams(\n   385→                        prompt=prompt,\n   386→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   387→                        guidance_scale=guidance_scale,\n   388→                        seed=(None if seed == -1 else seed),\n   389→                        reference_images=ref_payloads,\n   390→                    )\n   391→                )\n   392→                logger.info(\n   393→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   394→                )\n   395→                if fb:\n   396→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   397→            except Exception as _e:\n   398→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   399→\n   400→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   401→            api_result = self.client.image_to_image(\n   402→                prompt=prompt,\n   403→                image=image_data,\n   404→                guidance_scale=guidance_scale,\n   405→                seed=seed,\n   406→                reference_images=(ref_payloads or None),\n   407→            )\n   408→\n   409→            # 处理input_image字段，避免在日志中输出大量base64数据\n   410→            input_image_info = \"[图像数据]\"\n   411→            if image:\n   412→                if image.startswith(\"data:image/\"):\n   413→                    # 如果是base64数据，只保留格式信息\n   414→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   415→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   416→                elif image.startswith((\"http://\", \"https://\")):\n   417→                    # 如果是URL，保留URL\n   418→                    input_image_info = image\n   419→                else:\n   420→                    # 如果是文件路径，只保留文件名\n   421→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   422→            \n   423→            result = {\n   424→                \"task_id\": task_id,\n   425→                \"success\": True,\n   426→                \"type\": \"image_to_image\",\n   427→                \"prompt\": prompt,\n   428→                \"input_image\": input_image_info,\n   429→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   430→                \"parameters\": {\n   431→                    \"guidance_scale\": guidance_scale, \n   432→                    \"seed\": seed, \n   433→                    \"response_format\": \"url\",  # 固定值\n   434→                    \"watermark\": False,  # 固定值\n   435→                    \"size\": \"adaptive\",  # 固定值\n   436→                    \"model\": self._resolve_model_id(\n   437→                        \"doubao-seededit-3-0-i2i-250628\",\n   438→                        \"doubao-seedream-4-0-250828\",\n   439→                        \"doubao-seedream-4-5-251128\",\n   440→                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n   441→                },\n   442→                \"created_at\": datetime.now().isoformat(),\n   443→                \"usage\": api_result.get(\"usage\", {}),\n   444→            }\n   445→\n   446→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   447→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   448→            result[\"reference_assets\"] = sanitized_refs\n   449→            if ref_summary.get('errors'):\n   450→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   451→            if ref_summary.get('warnings'):\n   452→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   453→            if fb and reason:\n   454→                result[\"fallback_applied\"] = True\n   455→                result[\"fallback_reason\"] = reason\n   456→\n   457→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   458→            logger.info(\n   459→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   460→                len(sanitized_refs),\n   461→                masked_ids or \"-\",\n   462→                self._provider_used(),\n   463→            )\n   464→\n   465→            # 保存到本地\n   466→            if save_local and result.get(\"image_url\"):\n   467→                local_result = self._save_image_locally(result)\n   468→                result.update(local_result)\n   469→                if local_result.get('local_save_error'):\n   470→                    self._cleanup_reference_paths(ref_paths)\n   471→                    result[\"parameters\"][\"reference_assets\"] = []\n   472→                    result[\"reference_assets\"] = []\n   473→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   474→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   475→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   476→\n   477→            logger.success(f\"图生图任务完成: {task_id}\")\n   478→            return result\n   479→\n   480→        except Exception as e:\n   481→            # 避免在日志中显示可能包含base64数据的异常信息\n   482→            error_msg = str(e)\n   483→            if len(error_msg) > 200:\n   484→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   485→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   486→            self._cleanup_reference_paths(ref_paths)\n   487→            return {\n   488→                \"task_id\": task_id,\n   489→                \"success\": False,\n   490→                \"error\": error_msg,\n   491→                \"type\": \"image_to_image\"\n   492→            }\n   493→\n   494→    def batch_generate_text_to_image(\n   495→        self,\n   496→        prompts: List[str],\n   497→        size: str = \"1024x1024\",\n   498→        guidance_scale: float = 2.5,\n   499→        save_local: bool = True,\n   500→    ) -> List[Dict[str, Any]]:\n   501→        \"\"\"\n   502→        批量生成文生图（顺序执行，保持向后兼容）\n   503→\n   504→        Args:\n   505→            prompts: 提示词列表\n   506→            size: 图像尺寸\n   507→            guidance_scale: 提示词一致性\n   508→            save_local: 是否保存到本地\n   509→\n   510→        Returns:\n   511→            List[Dict]: 生成结果列表\n   512→        \n   513→        Note:\n   514→            水印参数已固定为False，不再需要前端控制\n   515→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   516→        \"\"\"\n   517→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   518→\n   519→        results = []\n   520→        for i, prompt in enumerate(prompts, 1):\n   521→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   522→\n   523→            result = self.generate_text_to_image(\n   524→                prompt=prompt,\n   525→                size=size,\n   526→                guidance_scale=guidance_scale,\n   527→                save_local=save_local,\n   528→                generation_id=None,\n   529→            )\n   530→\n   531→            results.append(result)\n   532→\n   533→        success_count = sum(1 for r in results if r[\"success\"])\n   534→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   535→\n   536→        return results\n   537→\n   538→    def concurrent_generate_text_to_image(\n   539→        self,\n   540→        prompt: str,\n   541→        count: int = 4,\n   542→        size: str = \"1024x1024\",\n   543→        guidance_scale: float = 2.5,\n   544→        seed: int = -1,\n   545→        save_local: bool = True,\n   546→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   547→        max_workers: int = 5,\n   548→        derived_ids: Optional[List[str]] = None,\n   549→        generation_id: Optional[str] = None,\n   550→        model_variant: Optional[str] = None,\n   551→        sequential_mode: bool = False,\n   552→    ) -> Dict[str, Any]:\n   553→        \"\"\"\n   554→        并发生成多张文生图\n   555→\n   556→        Args:\n   557→            prompt: 图像生成提示词\n   558→            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n   559→            size: 图像尺寸\n   560→            guidance_scale: 引导强度\n   561→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   562→            save_local: 是否保存到本地\n   563→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   564→            max_workers: 最大并发数\n   565→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   566→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   567→\n   568→        Returns:\n   569→            Dict: 包含所有任务结果的字典\n   570→        \"\"\"\n   571→        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n   572→        max_allowed = 15 if sequential_mode else 10\n   573→        if count < 1 or count > max_allowed:\n   574→            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n   575→\n   576→        # 组图模式：单次 API 调用返回多张图\n   577→        if sequential_mode:\n   578→            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n   579→            return self.generate_text_to_image(\n   580→                prompt=prompt,\n   581→                size=size,\n   582→                guidance_scale=guidance_scale,\n   583→                seed=seed,\n   584→                save_local=save_local,\n   585→                model_variant=model_variant,\n   586→                generation_id=generation_id,\n   587→                count=count,\n   588→                sequential_mode=True,\n   589→                derived_ids=derived_ids,\n   590→                progress_callback=progress_callback,\n   591→            )\n   592→        \n   593→        if max_workers > count:\n   594→            max_workers = count\n   595→        \n   596→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   597→        \n   598→        # 生成批次ID\n   599→        batch_id = str(uuid.uuid4())\n   600→        start_time = time.time()\n   601→\n   602→        slots = max(1, count)\n   603→        per_ids: List[str] = list(derived_ids or [])\n   604→        if len(per_ids) < slots:\n   605→            base = generation_id or batch_id\n   606→            for idx in range(len(per_ids), slots):\n   607→                per_ids.append(f\"{base}_{idx + 1}\")\n   608→        \n   609→        # 准备任务参数\n   610→        tasks = []\n   611→        for i in range(count):\n   612→            # 为每个任务生成不同的种子（如果seed为-1）\n   613→            task_seed = seed if seed != -1 else None\n   614→            gen_id = per_ids[i] if i < len(per_ids) else None\n   615→            tasks.append({\n   616→                'prompt': prompt,\n   617→                'size': size,\n   618→                'guidance_scale': guidance_scale,\n   619→                'seed': task_seed,\n   620→                'save_local': save_local,\n   621→                'task_index': i + 1,\n   622→                'generation_id': gen_id,\n   623→                'model_variant': model_variant,\n   624→            })\n   625→        \n   626→        # 使用线程池并发执行\n   627→        results = []\n   628→        completed_count = 0\n   629→        \n   630→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   631→            # 提交所有任务\n   632→            future_to_task = {\n   633→                executor.submit(self._execute_single_text_to_image_task, task): task \n   634→                for task in tasks\n   635→            }\n   636→            \n   637→            # 收集结果\n   638→            for future in as_completed(future_to_task):\n   639→                task = future_to_task[future]\n   640→                try:\n   641→                    result = future.result()\n   642→                    result['task_index'] = task['task_index']\n   643→                    result['batch_id'] = batch_id\n   644→                    results.append(result)\n   645→                    \n   646→                    completed_count += 1\n   647→                    \n   648→                    # 调用进度回调\n   649→                    if progress_callback:\n   650→                        try:\n   651→                            progress_callback(completed_count, count, result)\n   652→                        except Exception as e:\n   653→                            logger.warning(f\"进度回调执行失败: {e}\")\n   654→                    \n   655→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   656→                    \n   657→                except Exception as e:\n   658→                    error_result = {\n   659→                        'task_index': task['task_index'],\n   660→                        'batch_id': batch_id,\n   661→                        'success': False,\n   662→                        'error': str(e),\n   663→                        'type': 'text_to_image'\n   664→                    }\n   665→                    results.append(error_result)\n   666→                    completed_count += 1\n   667→                    \n   668→                    if progress_callback:\n   669→                        try:\n   670→                            progress_callback(completed_count, count, error_result)\n   671→                        except Exception as e:\n   672→                            logger.warning(f\"进度回调执行失败: {e}\")\n   673→                    \n   674→                    # 避免在日志中显示可能包含base64数据的异常信息\n   675→                    error_msg = str(e)\n   676→                    if len(error_msg) > 200:\n   677→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   678→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   679→        \n   680→        # 按task_index排序\n   681→        results.sort(key=lambda x: x.get('task_index', 0))\n   682→        \n   683→        # 统计结果\n   684→        success_count = sum(1 for r in results if r.get('success', False))\n   685→        total_time = time.time() - start_time\n   686→        \n   687→        batch_result = {\n   688→            'batch_id': batch_id,\n   689→            'success': True,\n   690→            'prompt': prompt,\n   691→            'total_count': count,\n   692→            'success_count': success_count,\n   693→            'failed_count': count - success_count,\n   694→            'total_time': round(total_time, 2),\n   695→            'average_time': round(total_time / count, 2),\n   696→            'results': results,\n   697→            'parameters': {\n   698→                'size': size,\n   699→                'guidance_scale': guidance_scale,\n   700→                'seed': seed,\n   701→                'max_workers': max_workers\n   702→            },\n   703→            'derived_ids': per_ids,\n   704→            'created_at': datetime.now().isoformat()\n   705→        }\n   706→        \n   707→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   708→        return batch_result\n   709→\n   710→    def concurrent_generate_image_to_image(\n   711→        self,\n   712→        prompt: str,\n   713→        image: str,\n   714→        count: int = 4,\n   715→        guidance_scale: float = 5.5,\n   716→        seed: int = -1,\n   717→        save_local: bool = True,\n   718→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   719→        max_workers: int = 5,\n   720→        derived_ids: Optional[List[str]] = None,\n   721→        generation_id: Optional[str] = None,\n   722→    ) -> Dict[str, Any]:\n   723→        \"\"\"\n   724→        并发生成多张图生图\n   725→\n   726→        Args:\n   727→            prompt: 编辑提示词\n   728→            image: 输入图像路径或URL\n   729→            count: 生成图片数量，默认4张，最多10张\n   730→            guidance_scale: 引导强度\n   731→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   732→            save_local: 是否保存到本地\n   733→            progress_callback: 进度回调函数\n   734→            max_workers: 最大并发数\n   735→\n   736→        Returns:\n   737→            Dict: 包含所有任务结果的字典\n   738→        \"\"\"\n   739→        # 验证参数\n   740→        if count < 1 or count > 10:\n   741→            raise ValueError(\"生成数量必须在1-10之间\")\n   742→        \n   743→        if max_workers > count:\n   744→            max_workers = count\n   745→        \n   746→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   747→        \n   748→        # 生成批次ID\n   749→        batch_id = str(uuid.uuid4())\n   750→        start_time = time.time()\n   751→        \n   752→        slots = max(1, count)\n   753→        per_ids: List[str] = list(derived_ids or [])\n   754→        if len(per_ids) < slots:\n   755→            base = generation_id or batch_id\n   756→            for idx in range(len(per_ids), slots):\n   757→                per_ids.append(f\"{base}_{idx + 1}\")\n   758→        \n   759→        # 准备输入图像\n   760→        image_data = self._prepare_input_image(image)\n   761→        if not image_data:\n   762→            return {\n   763→                'batch_id': batch_id,\n   764→                'success': False,\n   765→                'error': '无法处理输入图像',\n   766→                'type': 'image_to_image'\n   767→            }\n   768→        \n   769→        # 准备任务参数\n   770→        tasks = []\n   771→        for i in range(count):\n   772→            task_seed = seed if seed != -1 else None\n   773→            gen_id = per_ids[i] if i < len(per_ids) else None\n   774→            tasks.append({\n   775→                'prompt': prompt,\n   776→                'image': image_data,\n   777→                'guidance_scale': guidance_scale,\n   778→                'seed': task_seed,\n   779→                'save_local': save_local,\n   780→                'task_index': i + 1,\n   781→                'generation_id': gen_id\n   782→            })\n   783→        \n   784→        # 使用线程池并发执行\n   785→        results = []\n   786→        completed_count = 0\n   787→        \n   788→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   789→            # 提交所有任务\n   790→            future_to_task = {\n   791→                executor.submit(self._execute_single_image_to_image_task, task): task \n   792→                for task in tasks\n   793→            }\n   794→            \n   795→            # 收集结果\n   796→            for future in as_completed(future_to_task):\n   797→                task = future_to_task[future]\n   798→                try:\n   799→                    result = future.result()\n   800→                    result['task_index'] = task['task_index']\n   801→                    result['batch_id'] = batch_id\n   802→                    results.append(result)\n   803→                    \n   804→                    completed_count += 1\n   805→                    \n   806→                    # 调用进度回调\n   807→                    if progress_callback:\n   808→                        try:\n   809→                            progress_callback(completed_count, count, result)\n   810→                        except Exception as e:\n   811→                            logger.warning(f\"进度回调执行失败: {e}\")\n   812→                    \n   813→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   814→                    \n   815→                except Exception as e:\n   816→                    error_result = {\n   817→                        'task_index': task['task_index'],\n   818→                        'batch_id': batch_id,\n   819→                        'success': False,\n   820→                        'error': str(e),\n   821→                        'type': 'image_to_image'\n   822→                    }\n   823→                    results.append(error_result)\n   824→                    completed_count += 1\n   825→                    \n   826→                    if progress_callback:\n   827→                        try:\n   828→                            progress_callback(completed_count, count, error_result)\n   829→                        except Exception as e:\n   830→                            logger.warning(f\"进度回调执行失败: {e}\")\n   831→                    \n   832→                    # 避免在日志中显示可能包含base64数据的异常信息\n   833→                    error_msg = str(e)\n   834→                    if len(error_msg) > 200:\n   835→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   836→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   837→        \n   838→        # 按task_index排序\n   839→        results.sort(key=lambda x: x.get('task_index', 0))\n   840→        \n   841→        # 统计结果\n   842→        success_count = sum(1 for r in results if r.get('success', False))\n   843→        total_time = time.time() - start_time\n   844→        \n   845→        # 处理input_image字段，避免在日志中输出大量base64数据\n   846→        input_image_info = \"[图像数据]\"\n   847→        if image:\n   848→            if image.startswith(\"data:image/\"):\n   849→                # 如果是base64数据，只保留格式信息\n   850→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   851→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   852→            elif image.startswith((\"http://\", \"https://\")):\n   853→                # 如果是URL，保留URL\n   854→                input_image_info = image\n   855→            else:\n   856→                # 如果是文件路径，只保留文件名\n   857→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   858→        \n   859→        batch_result = {\n   860→            'batch_id': batch_id,\n   861→            'success': True,\n   862→            'prompt': prompt,\n   863→            'input_image': input_image_info,\n   864→            'total_count': count,\n   865→            'success_count': success_count,\n   866→            'failed_count': count - success_count,\n   867→            'total_time': round(total_time, 2),\n   868→            'average_time': round(total_time / count, 2),\n   869→            'results': results,\n   870→            'parameters': {\n   871→                'guidance_scale': guidance_scale,\n   872→                'seed': seed,\n   873→                'max_workers': max_workers\n   874→            },\n   875→            'derived_ids': per_ids,\n   876→            'created_at': datetime.now().isoformat()\n   877→        }\n   878→        \n   879→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   880→        return batch_result\n   881→\n   882→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   883→        \"\"\"\n   884→        执行单个文生图任务\n   885→        \n   886→        Args:\n   887→            task: 任务参数字典\n   888→            \n   889→        Returns:\n   890→            Dict: 任务执行结果\n   891→        \"\"\"\n   892→        return self.generate_text_to_image(\n   893→            prompt=task['prompt'],\n   894→            size=task['size'],\n   895→            guidance_scale=task['guidance_scale'],\n   896→            seed=task['seed'],\n   897→            save_local=task['save_local'],\n   898→            generation_id=task.get('generation_id'),\n   899→            model_variant=task.get('model_variant'),\n   900→        )\n   901→    \n   902→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   903→        \"\"\"\n   904→        执行单个图生图任务\n   905→        \n   906→        Args:\n   907→            task: 任务参数字典\n   908→            \n   909→        Returns:\n   910→            Dict: 任务执行结果\n   911→        \"\"\"\n   912→        # 生成唯一ID，优先使用外部传入的generation_id\n   913→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   914→        \n   915→        try:\n   916→            # 直接使用已经处理好的图片数据，避免重复处理\n   917→            image_data = task['image']\n   918→            \n   919→            # 调用API生成图像\n   920→            api_result = self.client.image_to_image(\n   921→                prompt=task['prompt'], \n   922→                image=image_data, \n   923→                guidance_scale=task['guidance_scale'], \n   924→                seed=task['seed']\n   925→            )\n   926→            \n   927→            result = {\n   928→                \"task_id\": task_id,\n   929→                \"success\": True,\n   930→                \"type\": \"image_to_image\",\n   931→                \"prompt\": task['prompt'],\n   932→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   933→                \"parameters\": {\n   934→                    \"guidance_scale\": task['guidance_scale'], \n   935→                    \"seed\": task['seed'], \n   936→                    \"response_format\": \"url\",\n   937→                    \"watermark\": False,\n   938→                    \"size\": \"adaptive\",\n   939→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   940→                },\n   941→                \"created_at\": datetime.now().isoformat(),\n   942→                \"usage\": api_result.get(\"usage\", {}),\n   943→            }\n   944→            \n   945→            # 保存到本地\n   946→            if task['save_local'] and result.get(\"image_url\"):\n   947→                local_result = self._save_image_locally(result)\n   948→                result.update(local_result)\n   949→            \n   950→            return result\n   951→            \n   952→        except Exception as e:\n   953→            # 避免在日志中显示可能包含base64数据的异常信息\n   954→            error_msg = str(e)\n   955→            if len(error_msg) > 200:\n   956→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   957→            return {\n   958→                \"task_id\": task_id,\n   959→                \"success\": False,\n   960→                \"error\": error_msg,\n   961→                \"type\": \"image_to_image\"\n   962→            }\n   963→\n   964→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   965→        \"\"\"\n   966→        保存图像到本地并记录元数据\n   967→\n   968→        Args:\n   969→            result: API生成结果\n   970→\n   971→        Returns:\n   972→            Dict: 包含本地文件信息的字典\n   973→        \"\"\"\n   974→        try:\n   975→            # 下载图像\n   976→            image_url = result[\"image_url\"]\n   977→            response = safe_requests_get(image_url, timeout=30)\n   978→\n   979→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   980→            from io import BytesIO\n   981→            real_w, real_h = None, None\n   982→            try:\n   983→                with Image.open(BytesIO(response.content)) as img:\n   984→                    real_w, real_h = int(img.width), int(img.height)\n   985→            except Exception as _e:\n   986→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n   987→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   988→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   989→\n   990→            # 组装元数据（适配UnifiedStorageManager的格式）\n   991→            params = result.get(\"parameters\", {}) or {}\n   992→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n   993→            try:\n   994→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n   995→                    from math import gcd\n   996→                    g = gcd(real_w, real_h)\n   997→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n   998→            except Exception:\n   999→                pass\n  1000→\n  1001→            metadata = {\n  1002→                'generation_id': result.get(\"task_id\", \"\"),\n  1003→                'prompt': result.get(\"prompt\", \"\"),\n  1004→                'parameters': params,\n  1005→                'model': params.get(\"model\", \"seedream\"),\n  1006→                'width': real_w,\n  1007→                'height': real_h,\n  1008→                'generation_time': result.get(\"generation_time\", 0),\n  1009→                'batch_id': result.get(\"batch_id\", \"\"),\n  1010→                'status': 'completed'\n  1011→            }\n  1012→            \n  1013→            # 使用统一存储管理器保存文件\n  1014→            save_result = self.storage_manager.save_content_file(\n  1015→                content_type='images',\n  1016→                file_data=response.content,\n  1017→                url=image_url,\n  1018→                metadata=metadata\n  1019→            )\n  1020→\n  1021→            # 获取图像信息（再次确认像素尺寸）\n  1022→            image_info = self._get_image_info(Path(save_result['local_path']))\n  1023→            file_size = Path(save_result['local_path']).stat().st_size\n  1024→\n  1025→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n  1026→\n  1027→            result_obj = {\n  1028→                \"local_path\": save_result['local_path'],\n  1029→                \"filename\": Path(save_result['local_path']).name,\n  1030→                \"file_size\": file_size,\n  1031→                \"image_info\": image_info,\n  1032→                \"file_path\": save_result['local_path'],  # 保持兼容性\n  1033→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n  1034→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n  1035→                \"file_id\": save_result.get('file_id'),\n  1036→                \"relative_path\": save_result.get('relative_path'),\n  1037→            }\n  1038→            try:\n  1039→                w = image_info.get('width') if isinstance(image_info, dict) else None\n  1040→                h = image_info.get('height') if isinstance(image_info, dict) else None\n  1041→                logger.info(\n  1042→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n  1043→                )\n  1044→            except Exception:\n  1045→                pass\n  1046→\n  1047→            # 体验版本地图片水印（使用统一水印服务）\n  1048→            if should_add_watermark():\n  1049→                try:\n  1050→                    from edition.watermark_service import WatermarkService\n  1051→\n  1052→                    watermark_text = get_watermark_text() or \"PIGEON\"\n  1053→                    try:\n  1054→                        opacity = get_watermark_opacity()\n  1055→                    except Exception:\n  1056→                        opacity = 0.3\n  1057→                    opacity = max(0.0, min(opacity, 1.0))\n  1058→\n  1059→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n  1060→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n  1061→                    if watermark_applied:\n  1062→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n  1063→                        result_obj[\"watermark_applied\"] = True\n  1064→                    else:\n  1065→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n  1066→                        result_obj[\"watermark_applied\"] = False\n  1067→                except Exception as e:\n  1068→                    logger.warning(f\"添加图片水印时出错: {e}\")\n  1069→                    result_obj[\"watermark_applied\"] = False\n  1070→\n  1071→            return result_obj\n  1072→\n  1073→        except Exception as e:\n  1074→            logger.error(f\"保存图像到本地失败: {e}\")\n  1075→            try:\n  1076→                logger.info(\"摘要|operation=save_image status=failed\")\n  1077→            except Exception:\n  1078→                pass\n  1079→            return {\"local_save_error\": str(e)}\n  1080→\n  1081→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1082→        checksum = hashlib.sha1(file_data).hexdigest()\n  1083→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1084→        return f\"ref_{ts}_{checksum[:8]}\"\n  1085→\n  1086→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1087→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1088→        source_meta: Dict[str, Any] = {}\n  1089→        raw = ref\n  1090→        if isinstance(ref, dict):\n  1091→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1092→                if ref.get(key) is not None:\n  1093→                    source_meta[key] = ref.get(key)\n  1094→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1095→        if raw is None:\n  1096→            return None\n  1097→\n  1098→        extension = source_meta.get('extension')\n  1099→        data = None\n  1100→        source_repr = source_meta.get('source')\n  1101→\n  1102→        try:\n  1103→            if isinstance(raw, bytes):\n  1104→                data = raw\n  1105→            elif isinstance(raw, str):\n  1106→                stripped = raw.strip()\n  1107→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1108→                    header, payload = stripped.split(';base64,', 1)\n  1109→                    mime_part = header[5:]\n  1110→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n  1111→                    data = base64.b64decode(payload)\n  1112→                    source_repr = source_repr or mime_part\n  1113→                    source_meta.setdefault('type', 'image')\n  1114→                elif stripped.startswith(('http://', 'https://')):\n  1115→                    resp = safe_requests_get(stripped, timeout=15)\n  1116→                    data = resp.content\n  1117→                    parsed = urlparse(stripped)\n  1118→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1119→                    source_repr = source_repr or stripped\n  1120→                    source_meta.setdefault('source_url', stripped)\n  1121→                else:\n  1122→                    path = Path(stripped)\n  1123→                    if not path.exists():\n  1124→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1125→                        return None\n  1126→                    data = path.read_bytes()\n  1127→                    extension = extension or path.suffix or '.png'\n  1128→                    source_repr = source_repr or path.name\n  1129→                    source_meta.setdefault('source_path', str(path))\n  1130→            else:\n  1131→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1132→                return None\n  1133→        except Exception as exc:\n  1134→            logger.warning(f\"加载参考图失败: {exc}\")\n  1135→            return None\n  1136→\n  1137→        if data is None:\n  1138→            return None\n  1139→\n  1140→        width = source_meta.get('width')\n  1141→        height = source_meta.get('height')\n  1142→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1143→            try:\n  1144→                from io import BytesIO\n  1145→\n  1146→                with Image.open(BytesIO(data)) as img:\n  1147→                    width = img.width\n  1148→                    height = img.height\n  1149→            except Exception:\n  1150→                pass\n  1151→\n  1152→        source_meta['width'] = width\n  1153→        source_meta['height'] = height\n  1154→        source_meta.setdefault('type', 'image')\n  1155→        source_meta['source'] = source_repr or source_meta.get('source')\n  1156→\n  1157→        return data, extension, source_meta\n  1158→\n  1159→    def _process_reference_assets(\n  1160→        self,\n  1161→        references: Optional[List[Any]],\n  1162→        *,\n  1163→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1164→        expected_outputs: int = 1,\n  1165→    ) -> Dict[str, Any]:\n  1166→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1167→        stored: List[Dict[str, Any]] = []\n  1168→        absolute_paths: List[str] = []\n  1169→        errors: List[str] = []\n  1170→        warnings: List[str] = []\n  1171→\n  1172→        if not references:\n  1173→            return {\n  1174→                'assets': stored,\n  1175→                'paths': absolute_paths,\n  1176→                'errors': errors,\n  1177→                'warnings': warnings,\n  1178→            }\n  1179→\n  1180→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1181→            warnings.append(\n  1182→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1183→            )\n  1184→            references = references[:max_refs]\n  1185→\n  1186→        for order, item in enumerate(references):\n  1187→            load_result = self._load_reference_source(item)\n  1188→            if not load_result:\n  1189→                errors.append(f\"ref[{order}] 加载失败\")\n  1190→                continue\n  1191→\n  1192→            file_data, extension, meta = load_result\n  1193→            meta.setdefault('order', order)\n  1194→            meta.setdefault('kind', meta.get('type', 'image'))\n  1195→\n  1196→            try:\n  1197→                asset_id = self._generate_reference_asset_id(file_data)\n  1198→                record = self.storage_manager.save_reference_asset(\n  1199→                    'images',\n  1200→                    file_data,\n  1201→                    asset_id=asset_id,\n  1202→                    extension=extension,\n  1203→                    metadata=meta,\n  1204→                )\n  1205→                try:\n  1206→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1207→                except Exception:\n  1208→                    record['_payload_b64'] = None\n  1209→                record['_source_meta'] = meta\n  1210→                stored.append(record)\n  1211→                if record.get('absolute_path'):\n  1212→                    absolute_paths.append(record['absolute_path'])\n  1213→            except Exception as exc:\n  1214→                logger.warning(f\"保存参考图失败: {exc}\")\n  1215→                errors.append(f\"ref[{order}] 保存失败\")\n  1216→\n  1217→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1218→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1219→            if len(stored) > allowed:\n  1220→                warnings.append(\n  1221→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1222→                )\n  1223→                stored = stored[:allowed]\n  1224→                absolute_paths = absolute_paths[:allowed]\n  1225→\n  1226→        return {\n  1227→            'assets': stored,\n  1228→            'paths': absolute_paths,\n  1229→            'errors': errors,\n  1230→            'warnings': warnings,\n  1231→        }\n  1232→\n  1233→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1234→        payloads: List[str] = []\n  1235→        for asset in assets or []:\n  1236→            payload = asset.get('_payload_b64')\n  1237→            if not payload:\n  1238→                continue\n  1239→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1240→            mime = 'image/png'\n  1241→            try:\n  1242→                if path_hint:\n  1243→                    suffix = Path(path_hint).suffix.lower()\n  1244→                    if suffix in {'.jpg', '.jpeg'}:\n  1245→                        mime = 'image/jpeg'\n  1246→                    elif suffix == '.webp':\n  1247→                        mime = 'image/webp'\n  1248→                    elif suffix == '.bmp':\n  1249→                        mime = 'image/bmp'\n  1250→                    elif suffix == '.gif':\n  1251→                        mime = 'image/gif'\n  1252→            except Exception:\n  1253→                pass\n  1254→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1255→        return payloads\n  1256→\n  1257→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1258→        provider = (self.client.last_provider() or \"\").lower()\n  1259→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1260→            return v4_5_model or v4_model\n  1261→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1262→            return v4_model\n  1263→        return default_model\n  1264→\n  1265→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1266→        cleaned: List[Dict[str, Any]] = []\n  1267→        for rec in assets or []:\n  1268→            rec.pop('_payload_b64', None)\n  1269→            rec.pop('_source_meta', None)\n  1270→            rec.pop('absolute_path', None)\n  1271→            cleaned.append({\n  1272→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1273→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1274→                'type': rec.get('type'),\n  1275→                'kind': rec.get('kind'),\n  1276→                'source': rec.get('source'),\n  1277→                'order': rec.get('order'),\n  1278→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1279→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1280→                'width': rec.get('width'),\n  1281→                'height': rec.get('height'),\n  1282→                'created_at': rec.get('created_at'),\n  1283→            })\n  1284→        return cleaned\n  1285→\n  1286→    @staticmethod\n  1287→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1288→        masked: List[str] = []\n  1289→        for rec in assets or []:\n  1290→            rid = rec.get('id') or ''\n  1291→            if not rid:\n  1292→                continue\n  1293→            masked.append(f\"{rid[:6]}***\")\n  1294→        return \",\".join(masked)\n  1295→\n  1296→    @staticmethod\n  1297→    def _provider_hint() -> str:\n  1298→        try:\n  1299→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1300→        except Exception:\n  1301→            return \"unknown\"\n  1302→\n  1303→    def _provider_used(self) -> str:\n  1304→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1305→        if provider:\n  1306→            return provider\n  1307→        return self._provider_hint()\n  1308→\n  1309→    @staticmethod\n  1310→    def _cleanup_reference_paths(paths: List[str]):\n  1311→        for path in paths or []:\n  1312→            try:\n  1313→                if path and Path(path).exists():\n  1314→                    Path(path).unlink(missing_ok=True)\n  1315→            except Exception as exc:\n  1316→                logger.debug(f\"参考图清理失败: {exc}\")\n  1317→\n  1318→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1319→        \"\"\"\n  1320→        准备输入图像，支持本地文件和URL\n  1321→        \n  1322→        Args:\n  1323→            image_path: 图像路径（本地路径或URL）\n  1324→            \n  1325→        Returns:\n  1326→            str: 图像URL、base64数据或None\n  1327→        \"\"\"\n  1328→        try:\n  1329→            # 如果是URL，直接返回\n  1330→            if image_path.startswith((\"http://\", \"https://\")):\n  1331→                return image_path\n  1332→\n  1333→            # 如果是本地文件，转换为Base64\n  1334→            local_path = Path(image_path)\n  1335→            if local_path.exists():\n  1336→                with open(local_path, \"rb\") as f:\n  1337→                    image_data = f.read()\n  1338→\n  1339→                # 检测图像格式\n  1340→                image = Image.open(local_path)\n  1341→                format_name = image.format.lower()\n  1342→\n  1343→                # 转换为Base64\n  1344→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1345→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1346→\n  1347→            logger.error(f\"图像文件不存在: {image_path}\")\n  1348→            return None\n  1349→\n  1350→        except Exception as e:\n  1351→            logger.error(f\"处理输入图像失败: {e}\")\n  1352→            return None\n  1353→\n  1354→    def _extract_width_from_size(self, size: str) -> int:\n  1355→        \"\"\"\n  1356→        从尺寸字符串中提取宽度\n  1357→        \n  1358→        Args:\n  1359→            size: 尺寸字符串，如 \"1024x1024\"\n  1360→            \n  1361→        Returns:\n  1362→            int: 宽度值\n  1363→        \"\"\"\n  1364→        try:\n  1365→            return int(size.split('x')[0])\n  1366→        except (ValueError, IndexError):\n  1367→            return 1024  # 默认值\n  1368→    \n  1369→    def _extract_height_from_size(self, size: str) -> int:\n  1370→        \"\"\"\n  1371→        从尺寸字符串中提取高度\n  1372→        \n  1373→        Args:\n  1374→            size: 尺寸字符串，如 \"1024x1024\"\n  1375→            \n  1376→        Returns:\n  1377→            int: 高度值\n  1378→        \"\"\"\n  1379→        try:\n  1380→            return int(size.split('x')[1])\n  1381→        except (ValueError, IndexError):\n  1382→            return 1024  # 默认值\n  1383→\n  1384→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1385→        \"\"\"\n  1386→        获取图像信息\n  1387→\n  1388→        Args:\n  1389→            image_path: 图像文件路径\n  1390→\n  1391→        Returns:\n  1392→            Dict: 图像信息\n  1393→        \"\"\"\n  1394→        try:\n  1395→            with Image.open(image_path) as img:\n  1396→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1397→        except Exception as e:\n  1398→            logger.error(f\"获取图像信息失败: {e}\")\n  1399→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1400→\n  1401→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1402→        \"\"\"\n  1403→        获取图像生成历史记录\n  1404→\n  1405→        Args:\n  1406→            limit: 返回记录数量限制\n  1407→\n  1408→        Returns:\n  1409→            List[Dict]: 历史记录列表\n  1410→        \"\"\"\n  1411→        return self.storage_manager.load_history('images', limit=limit)\n  1412→\n  1413→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1414→        \"\"\"\n  1415→        根据提示词关键字搜索历史记录\n  1416→\n  1417→        Args:\n  1418→            keyword: 搜索关键字\n  1419→\n  1420→        Returns:\n  1421→            List[Dict]: 匹配的记录列表\n  1422→        \"\"\"\n  1423→        # 获取所有历史记录并在内存中过滤\n  1424→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1425→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1426→\n  1427→    def get_statistics(self) -> Dict[str, Any]:\n  1428→        \"\"\"\n  1429→        获取生成统计信息\n  1430→\n  1431→        Returns:\n  1432→            Dict: 统计信息\n  1433→        \"\"\"\n  1434→        try:\n  1435→            # 使用统一存储管理器获取存储统计\n  1436→            storage_stats = self.storage_manager.get_storage_stats()\n  1437→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1438→            \n  1439→            # 获取历史记录进行详细统计\n  1440→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1441→            \n  1442→            if not all_records:\n  1443→                return {\n  1444→                    \"total_images\": 0,\n  1445→                    \"text_to_image_count\": 0,\n  1446→                    \"image_to_image_count\": 0,\n  1447→                    \"total_file_size\": 0,\n  1448→                    \"average_file_size\": 0,\n  1449→                    \"most_common_size\": \"unknown\"\n  1450→                }\n  1451→\n  1452→            # 统计不同类型的图片数量\n  1453→            text_to_image_count = 0\n  1454→            image_to_image_count = 0\n  1455→            total_file_size = 0\n  1456→            sizes = []\n  1457→            \n  1458→            for record in all_records:\n  1459→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1460→                if 'input_image' in record.get('parameters', {}):\n  1461→                    image_to_image_count += 1\n  1462→                else:\n  1463→                    text_to_image_count += 1\n  1464→                \n  1465→                # 计算文件大小\n  1466→                file_size = record.get('file_size', 0)\n  1467→                if isinstance(file_size, str) and file_size.isdigit():\n  1468→                    file_size = int(file_size)\n  1469→                elif not isinstance(file_size, (int, float)):\n  1470→                    file_size = 0\n  1471→                total_file_size += file_size\n  1472→                \n  1473→                # 收集尺寸信息\n  1474→                width = record.get('width', 0)\n  1475→                height = record.get('height', 0)\n  1476→                if width and height:\n  1477→                    sizes.append(f\"{width}x{height}\")\n  1478→\n  1479→            stats = {\n  1480→                \"total_images\": len(all_records),\n  1481→                \"text_to_image_count\": text_to_image_count,\n  1482→                \"image_to_image_count\": image_to_image_count,\n  1483→                \"total_file_size\": total_file_size,\n  1484→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1485→                \"most_common_size\": \"unknown\",\n  1486→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1487→            }\n  1488→\n  1489→            # 最常用的尺寸\n  1490→            if sizes:\n  1491→                from collections import Counter\n  1492→                size_counts = Counter(sizes)\n  1493→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1494→\n  1495→            return stats\n  1496→\n  1497→        except Exception as e:\n  1498→            logger.error(f\"获取统计信息失败: {e}\")\n  1499→            return {\n  1500→                \"total_images\": 0,\n  1501→                \"text_to_image_count\": 0,\n  1502→                \"image_to_image_count\": 0,\n  1503→                \"total_file_size\": 0,\n  1504→                \"average_file_size\": 0,\n  1505→                \"most_common_size\": \"unknown\"\n  1506→            }\n  1507→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e3c240b8-30ee-48dd-b38e-b84157715a96","timestamp":"2025-12-13T13:22:15.753Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config_api import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n        count: int = 1,\n        sequential_mode: bool = False,\n        derived_ids: Optional[List[str]] = None,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            count: 生成图片数量（组图模式下生效）\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n            derived_ids: 组图生成的ID列表（用于关联）\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n\n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n        \n        # 根据 model_variant 设置环境变量\n        if model_variant == 'seedream_v4':\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4\"\n        elif model_variant == 'seedream_v4_5':\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4_5\"\n        else:\n            # 默认使用 volc_v3\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v3\"\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            actual_count = max(1, count)\n            use_group_mode = bool(sequential_mode and actual_count > 1)\n\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n                n=actual_count if use_group_mode else 1,\n                sequential_mode=sequential_mode,\n            )\n\n            # 组图模式：API 返回多张图，需要逐一保存\n            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n            images_count = len(images_list)\n            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n\n            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n            if use_group_mode and images_count < actual_count:\n                logger.warning(\n                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n                )\n\n            if use_group_mode and images_count > 1:\n                results_batch = []\n                success_count = 0\n                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n                total_images = len(images_list)\n\n                for idx, img_data in enumerate(images_list):\n                    # 发送下载进度（每张图开始下载时）\n                    if progress_callback:\n                        try:\n                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n                        except Exception:\n                            pass\n\n                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n                    per_result = {\n                        \"task_id\": per_id,\n                        \"success\": True,\n                        \"type\": \"text_to_image\",\n                        \"prompt\": prompt,\n                        \"image_url\": img_data[\"url\"],\n                        \"parameters\": {\n                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            \"seed\": seed,\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,\n                        },\n                        \"created_at\": datetime.now().isoformat(),\n                        \"usage\": api_result.get(\"usage\", {}),\n                    }\n\n                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n                    if sanitized_refs:\n                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                        per_result[\"reference_assets\"] = sanitized_refs\n\n                    if save_local and per_result.get(\"image_url\"):\n                        local_result = self._save_image_locally(per_result)\n                        per_result.update(local_result)\n                        if not local_result.get('local_save_error'):\n                            success_count += 1\n\n                    results_batch.append(per_result)\n\n                    # 发送下载完成进度\n                    if progress_callback:\n                        try:\n                            progress_callback(idx + 1, total_images, per_result)\n                        except Exception:\n                            pass\n\n                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n                return {\n                    \"batch\": True,\n                    \"results\": results_batch,\n                    \"success_count\": success_count,\n                    \"total_count\": len(results_batch),\n                    \"derived_ids\": group_ids,\n                }\n\n            # 单图模式（默认）\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    \"seed\": seed,\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale, \n                    \"seed\": seed, \n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        sequential_mode: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n        max_allowed = 15 if sequential_mode else 10\n        if count < 1 or count > max_allowed:\n            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n\n        # 组图模式：单次 API 调用返回多张图\n        if sequential_mode:\n            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n            return self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=save_local,\n                model_variant=model_variant,\n                generation_id=generation_id,\n                count=count,\n                sequential_mode=True,\n                derived_ids=derived_ids,\n                progress_callback=progress_callback,\n            )\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1507,"startLine":1,"totalLines":1507}}}
{"parentUuid":"e3c240b8-30ee-48dd-b38e-b84157715a96","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KYb7SxcrfSvuUmmTGQ58pw","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看 sqlite_handler.py 和关键的参考图处理逻辑："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":123,"cache_creation_input_tokens":40290,"cache_read_input_tokens":20983,"cache_creation":{"ephemeral_5m_input_tokens":40290,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9b771773-35b3-4875-8ade-dfdf91e52341","timestamp":"2025-12-13T13:22:19.766Z"}
{"parentUuid":"9b771773-35b3-4875-8ade-dfdf91e52341","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KYb7SxcrfSvuUmmTGQ58pw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XSh5AQyYLf9xvqUvjs2E73","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":123,"cache_creation_input_tokens":40290,"cache_read_input_tokens":20983,"cache_creation":{"ephemeral_5m_input_tokens":40290,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f68bf45f-623b-4b15-9515-58b36629b28a","timestamp":"2025-12-13T13:22:20.040Z"}
{"parentUuid":"f68bf45f-623b-4b15-9515-58b36629b28a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KYb7SxcrfSvuUmmTGQ58pw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G7qDsqFkZoJFBxfhnFSDcj","name":"Grep","input":{"pattern":"reference_assets|generation_id.*foreign|FK.*generation","path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":123,"cache_creation_input_tokens":40290,"cache_read_input_tokens":20983,"cache_creation":{"ephemeral_5m_input_tokens":40290,"ephemeral_1h_input_tokens":0},"output_tokens":185,"service_tier":"standard"}},"type":"assistant","uuid":"63bc67f9-1450-4169-92b9-6044c2541f86","timestamp":"2025-12-13T13:22:20.562Z"}
{"parentUuid":"63bc67f9-1450-4169-92b9-6044c2541f86","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XSh5AQyYLf9xvqUvjs2E73","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import json\n     8→import sqlite3\n     9→from datetime import datetime\n    10→from pathlib import Path\n    11→from typing import Any, Dict, List, Optional\n    12→\n    13→from loguru import logger\n    14→\n    15→\n    16→class SQLiteHandler:\n    17→    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n    18→\n    19→    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n    20→        \"\"\"初始化数据库连接并创建所需表结构.\n    21→\n    22→        Args:\n    23→            db_path: 数据库文件路径\n    24→            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n    25→        \"\"\"\n    26→\n    27→        self.db_path = Path(db_path)\n    28→        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n    29→        self.storage_root = storage_root\n    30→\n    31→        try:\n    32→            self.connection = sqlite3.connect(self.db_path, check_same_thread=False)\n    33→            self.connection.row_factory = sqlite3.Row\n    34→            self.connection.execute(\"PRAGMA foreign_keys = ON;\")\n    35→            self._create_tables()\n    36→        except sqlite3.Error as exc:\n    37→            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n    38→            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n    39→\n    40→    def _create_tables(self) -> None:\n    41→        \"\"\"初始化数据库表结构.\"\"\"\n    42→\n    43→        schema = \"\"\"\n    44→        CREATE TABLE IF NOT EXISTS generations (\n    45→            id TEXT PRIMARY KEY,\n    46→            content_type TEXT NOT NULL,\n    47→            prompt TEXT,\n    48→            model TEXT,\n    49→            status TEXT DEFAULT 'completed',\n    50→            file_path TEXT,\n    51→            relative_path TEXT,\n    52→            thumbnail_path TEXT,\n    53→            parameters TEXT,\n    54→            metadata TEXT,\n    55→            created_at TEXT,\n    56→            updated_at TEXT\n    57→        );\n    58→\n    59→        CREATE TABLE IF NOT EXISTS reference_assets (\n    60→            id TEXT PRIMARY KEY,\n    61→            generation_id TEXT NOT NULL,\n    62→            asset_path TEXT,\n    63→            relative_path TEXT,\n    64→            asset_type TEXT,\n    65→            order_index INTEGER DEFAULT 0,\n    66→            metadata TEXT,\n    67→            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n    68→        );\n    69→\n    70→        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n    71→        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n    72→        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n    73→        \"\"\"\n    74→\n    75→        try:\n    76→            with self.connection:\n    77→                self.connection.executescript(schema)\n    78→        except sqlite3.Error as exc:\n    79→            logger.error(\"Failed to create initial tables: {}\", exc)\n    80→            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n    81→\n    82→    @staticmethod\n    83→    def _now() -> str:\n    84→        return datetime.utcnow().isoformat()\n    85→\n    86→    @staticmethod\n    87→    def _dump_json(data: Any) -> Optional[str]:\n    88→        if data is None:\n    89→            return None\n    90→\n    91→        try:\n    92→            return json.dumps(data)\n    93→        except (TypeError, ValueError) as exc:\n    94→            logger.error(\"Failed to serialize JSON field: {}\", exc)\n    95→            return None\n    96→\n    97→    @staticmethod\n    98→    def _load_json(payload: Optional[str]) -> Optional[Any]:\n    99→        if not payload:\n   100→            return None\n   101→\n   102→        try:\n   103→            return json.loads(payload)\n   104→        except json.JSONDecodeError as exc:\n   105→            logger.error(\"Failed to decode JSON payload: {}\", exc)\n   106→            return None\n   107→\n   108→    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n   109→        result = dict(row)\n   110→        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n   111→        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n   112→\n   113→        # 将相对路径转换为绝对路径\n   114→        if self.storage_root:\n   115→            import os\n   116→            # file_path / relative_path -> absolute_path\n   117→            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n   118→            if rel_path:\n   119→                # 统一路径分隔符\n   120→                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n   121→                abs_path = self.storage_root / rel_path\n   122→                result[\"absolute_path\"] = str(abs_path)\n   123→\n   124→            # thumbnail_path -> absolute thumbnail path\n   125→            thumb_path = result.get(\"thumbnail_path\")\n   126→            if thumb_path:\n   127→                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n   128→                abs_thumb = self.storage_root / thumb_path\n   129→                result[\"thumbnail_path\"] = str(abs_thumb)\n   130→\n   131→        return result\n   132→\n   133→    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n   134→        result = dict(row)\n   135→        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n   136→\n   137→        # 将相对路径转换为绝对路径\n   138→        if self.storage_root:\n   139→            import os\n   140→            rel_path = result.get(\"asset_path\") or result.get(\"relative_path\")\n   141→            if rel_path:\n   142→                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n   143→                abs_path = self.storage_root / rel_path\n   144→                result[\"absolute_path\"] = str(abs_path)\n   145→\n   146→        return result\n   147→\n   148→    def add_record(self, record_id: str, content_type: str, data: Dict) -> bool:\n   149→        \"\"\"添加或更新生成记录（UPSERT）.\"\"\"\n   150→\n   151→        timestamp = self._now()\n   152→        record = {\n   153→            \"id\": record_id,\n   154→            \"content_type\": content_type,\n   155→            \"prompt\": data.get(\"prompt\"),\n   156→            \"model\": data.get(\"model\"),\n   157→            \"status\": data.get(\"status\", \"completed\"),\n   158→            \"file_path\": data.get(\"file_path\"),\n   159→            \"relative_path\": data.get(\"relative_path\"),\n   160→            \"thumbnail_path\": data.get(\"thumbnail_path\"),\n   161→            \"parameters\": self._dump_json(data.get(\"parameters\")),\n   162→            \"metadata\": self._dump_json(data.get(\"metadata\")),\n   163→            \"created_at\": data.get(\"created_at\", timestamp),\n   164→            \"updated_at\": timestamp,\n   165→        }\n   166→\n   167→        sql = \"\"\"\n   168→        INSERT INTO generations (id, content_type, prompt, model, status, file_path,\n   169→            relative_path, thumbnail_path, parameters, metadata, created_at, updated_at)\n   170→        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n   171→        ON CONFLICT(id) DO UPDATE SET\n   172→            content_type = excluded.content_type,\n   173→            prompt = COALESCE(excluded.prompt, prompt),\n   174→            model = COALESCE(excluded.model, model),\n   175→            status = CASE\n   176→                WHEN excluded.status IS NULL OR excluded.status = '' THEN status\n   177→                ELSE excluded.status\n   178→            END,\n   179→            file_path = COALESCE(excluded.file_path, file_path),\n   180→            relative_path = COALESCE(excluded.relative_path, relative_path),\n   181→            thumbnail_path = COALESCE(excluded.thumbnail_path, thumbnail_path),\n   182→            parameters = COALESCE(excluded.parameters, parameters),\n   183→            metadata = COALESCE(excluded.metadata, metadata),\n   184→            updated_at = excluded.updated_at\n   185→        \"\"\"\n   186→\n   187→        try:\n   188→            with self.connection:\n   189→                self.connection.execute(sql, (\n   190→                    record[\"id\"],\n   191→                    record[\"content_type\"],\n   192→                    record[\"prompt\"],\n   193→                    record[\"model\"],\n   194→                    record[\"status\"],\n   195→                    record[\"file_path\"],\n   196→                    record[\"relative_path\"],\n   197→                    record[\"thumbnail_path\"],\n   198→                    record[\"parameters\"],\n   199→                    record[\"metadata\"],\n   200→                    record[\"created_at\"],\n   201→                    record[\"updated_at\"],\n   202→                ))\n   203→            return True\n   204→        except sqlite3.Error as exc:\n   205→            logger.error(\"Failed to upsert generation record {}: {}\", record_id, exc)\n   206→            return False\n   207→\n   208→    def get_records(self, content_type: str, limit: int, offset: int) -> List[Dict]:\n   209→        \"\"\"分页获取记录，按 created_at DESC 排序.\"\"\"\n   210→\n   211→        try:\n   212→            cursor = self.connection.execute(\n   213→                \"\"\"\n   214→                SELECT * FROM generations\n   215→                WHERE content_type = ?\n   216→                ORDER BY created_at DESC, updated_at DESC\n   217→                LIMIT ? OFFSET ?\n   218→                \"\"\",\n   219→                (content_type, limit, offset),\n   220→            )\n   221→            return [self._row_to_dict(row) for row in cursor.fetchall()]\n   222→        except sqlite3.Error as exc:\n   223→            logger.error(\"Failed to fetch generation records: {}\", exc)\n   224→            return []\n   225→\n   226→    def get_record_by_id(self, record_id: str) -> Optional[Dict]:\n   227→        \"\"\"根据ID获取单条记录.\"\"\"\n   228→\n   229→        try:\n   230→            cursor = self.connection.execute(\n   231→                \"SELECT * FROM generations WHERE id = ?\", (record_id,)\n   232→            )\n   233→            row = cursor.fetchone()\n   234→            return self._row_to_dict(row) if row else None\n   235→        except sqlite3.Error as exc:\n   236→            logger.error(\"Failed to fetch generation record {}: {}\", record_id, exc)\n   237→            return None\n   238→\n   239→    def update_record(self, record_id: str, data: Dict) -> bool:\n   240→        \"\"\"更新记录.\"\"\"\n   241→\n   242→        if not data:\n   243→            return False\n   244→\n   245→        allowed_columns = [\n   246→            \"content_type\",\n   247→            \"prompt\",\n   248→            \"model\",\n   249→            \"status\",\n   250→            \"file_path\",\n   251→            \"relative_path\",\n   252→            \"thumbnail_path\",\n   253→            \"parameters\",\n   254→            \"metadata\",\n   255→            \"created_at\",\n   256→        ]\n   257→\n   258→        set_clauses: List[str] = []\n   259→        values: List[Any] = []\n   260→\n   261→        for column in allowed_columns:\n   262→            if column in data:\n   263→                value = data[column]\n   264→                if column in {\"parameters\", \"metadata\"}:\n   265→                    value = self._dump_json(value)\n   266→                set_clauses.append(f\"{column} = ?\")\n   267→                values.append(value)\n   268→\n   269→        if not set_clauses:\n   270→            return False\n   271→\n   272→        set_clauses.append(\"updated_at = ?\")\n   273→        values.append(self._now())\n   274→\n   275→        values.append(record_id)\n   276→        sql = f\"UPDATE generations SET {', '.join(set_clauses)} WHERE id = ?\"\n   277→\n   278→        try:\n   279→            with self.connection:\n   280→                cursor = self.connection.execute(sql, values)\n   281→            return cursor.rowcount > 0\n   282→        except sqlite3.Error as exc:\n   283→            logger.error(\"Failed to update generation record {}: {}\", record_id, exc)\n   284→            return False\n   285→\n   286→    def delete_record(self, record_id: str) -> bool:\n   287→        \"\"\"删除记录.\"\"\"\n   288→\n   289→        try:\n   290→            with self.connection:\n   291→                cursor = self.connection.execute(\n   292→                    \"DELETE FROM generations WHERE id = ?\", (record_id,)\n   293→                )\n   294→            return cursor.rowcount > 0\n   295→        except sqlite3.Error as exc:\n   296→            logger.error(\"Failed to delete generation record {}: {}\", record_id, exc)\n   297→            return False\n   298→\n   299→    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n   300→        \"\"\"清理超时的 pending 记录（无文件路径的孤立占位符）\n   301→\n   302→        Args:\n   303→            timeout_hours: 超时时间（小时）\n   304→\n   305→        Returns:\n   306→            删除的记录数量\n   307→        \"\"\"\n   308→        from datetime import datetime, timedelta\n   309→\n   310→        try:\n   311→            cutoff = datetime.now() - timedelta(hours=timeout_hours)\n   312→            cutoff_str = cutoff.isoformat()\n   313→\n   314→            with self.connection:\n   315→                cursor = self.connection.execute(\n   316→                    \"\"\"\n   317→                    DELETE FROM generations\n   318→                    WHERE status = 'pending'\n   319→                      AND file_path IS NULL\n   320→                      AND created_at < ?\n   321→                    \"\"\",\n   322→                    (cutoff_str,),\n   323→                )\n   324→            deleted = cursor.rowcount\n   325→            if deleted > 0:\n   326→                logger.info(f\"已清理 {deleted} 条过期的 pending 记录\")\n   327→            return deleted\n   328→        except sqlite3.Error as exc:\n   329→            logger.error(\"Failed to cleanup stale pending records: {}\", exc)\n   330→            return 0\n   331→\n   332→    def get_total_count(self, content_type: str) -> int:\n   333→        \"\"\"获取某类型总数.\"\"\"\n   334→\n   335→        try:\n   336→            cursor = self.connection.execute(\n   337→                \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",\n   338→                (content_type,),\n   339→            )\n   340→            row = cursor.fetchone()\n   341→            return int(row[0]) if row else 0\n   342→        except sqlite3.Error as exc:\n   343→            logger.error(\"Failed to count generation records: {}\", exc)\n   344→            return 0\n   345→\n   346→    def search_records(\n   347→        self, keyword: str, content_type: Optional[str], limit: int\n   348→    ) -> List[Dict]:\n   349→        \"\"\"搜索记录（prompt、model、file_path）.\"\"\"\n   350→\n   351→        if not keyword:\n   352→            return []\n   353→\n   354→        pattern = f\"%{keyword}%\"\n   355→        where_clauses = [\n   356→            \"(prompt LIKE ? OR model LIKE ? OR file_path LIKE ?)\"\n   357→        ]\n   358→        params: List[Any] = [pattern, pattern, pattern]\n   359→\n   360→        if content_type:\n   361→            where_clauses.append(\"content_type = ?\")\n   362→            params.append(content_type)\n   363→\n   364→        params.append(limit)\n   365→\n   366→        query = (\n   367→            \"SELECT * FROM generations WHERE \"\n   368→            + \" AND \".join(where_clauses)\n   369→            + \" ORDER BY created_at DESC, updated_at DESC LIMIT ?\"\n   370→        )\n   371→\n   372→        try:\n   373→            cursor = self.connection.execute(query, params)\n   374→            return [self._row_to_dict(row) for row in cursor.fetchall()]\n   375→        except sqlite3.Error as exc:\n   376→            logger.error(\"Failed to search generation records: {}\", exc)\n   377→            return []\n   378→\n   379→    def add_reference_asset(self, generation_id: str, asset_data: Dict) -> bool:\n   380→        \"\"\"添加参考图资产.\"\"\"\n   381→\n   382→        asset_id = asset_data.get(\"id\") or asset_data.get(\"asset_id\")\n   383→        if not asset_id:\n   384→            logger.error(\"Reference asset requires an 'id' field\")\n   385→            return False\n   386→\n   387→        payload = {\n   388→            \"id\": asset_id,\n   389→            \"generation_id\": generation_id,\n   390→            \"asset_path\": asset_data.get(\"asset_path\"),\n   391→            \"relative_path\": asset_data.get(\"relative_path\"),\n   392→            \"asset_type\": asset_data.get(\"asset_type\"),\n   393→            \"order_index\": asset_data.get(\"order_index\", 0),\n   394→            \"metadata\": self._dump_json(asset_data.get(\"metadata\")),\n   395→        }\n   396→\n   397→        sql = (\n   398→            \"INSERT INTO reference_assets (id, generation_id, asset_path, relative_path, \"\n   399→            \"asset_type, order_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?)\"\n   400→        )\n   401→\n   402→        try:\n   403→            with self.connection:\n   404→                self.connection.execute(\n   405→                    sql,\n   406→                    (\n   407→                        payload[\"id\"],\n   408→                        payload[\"generation_id\"],\n   409→                        payload[\"asset_path\"],\n   410→                        payload[\"relative_path\"],\n   411→                        payload[\"asset_type\"],\n   412→                        payload[\"order_index\"],\n   413→                        payload[\"metadata\"],\n   414→                    ),\n   415→                )\n   416→            return True\n   417→        except sqlite3.Error as exc:\n   418→            logger.error(\n   419→                \"Failed to insert reference asset {} for generation {}: {}\",\n   420→                asset_id,\n   421→                generation_id,\n   422→                exc,\n   423→            )\n   424→            return False\n   425→\n   426→    def get_reference_assets(self, generation_id: str) -> List[Dict]:\n   427→        \"\"\"获取参考图资产.\"\"\"\n   428→\n   429→        try:\n   430→            cursor = self.connection.execute(\n   431→                \"\"\"\n   432→                SELECT * FROM reference_assets\n   433→                WHERE generation_id = ?\n   434→                ORDER BY order_index ASC\n   435→                \"\"\",\n   436→                (generation_id,),\n   437→            )\n   438→            return [self._reference_row_to_dict(row) for row in cursor.fetchall()]\n   439→        except sqlite3.Error as exc:\n   440→            logger.error(\n   441→                \"Failed to fetch reference assets for generation {}: {}\",\n   442→                generation_id,\n   443→                exc,\n   444→            )\n   445→            return []\n   446→\n   447→    def close(self) -> None:\n   448→        \"\"\"关闭数据库连接.\"\"\"\n   449→\n   450→        try:\n   451→            self.connection.close()\n   452→        except sqlite3.Error as exc:\n   453→            logger.error(\"Failed to close SQLite connection: {}\", exc)\n   454→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d16d7cd5-93a4-4202-bf5c-6d25b0aeeeef","timestamp":"2025-12-13T13:22:20.604Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sqlite3\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom loguru import logger\n\n\nclass SQLiteHandler:\n    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n\n    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n        \"\"\"初始化数据库连接并创建所需表结构.\n\n        Args:\n            db_path: 数据库文件路径\n            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n        \"\"\"\n\n        self.db_path = Path(db_path)\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n        self.storage_root = storage_root\n\n        try:\n            self.connection = sqlite3.connect(self.db_path, check_same_thread=False)\n            self.connection.row_factory = sqlite3.Row\n            self.connection.execute(\"PRAGMA foreign_keys = ON;\")\n            self._create_tables()\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n\n    def _create_tables(self) -> None:\n        \"\"\"初始化数据库表结构.\"\"\"\n\n        schema = \"\"\"\n        CREATE TABLE IF NOT EXISTS generations (\n            id TEXT PRIMARY KEY,\n            content_type TEXT NOT NULL,\n            prompt TEXT,\n            model TEXT,\n            status TEXT DEFAULT 'completed',\n            file_path TEXT,\n            relative_path TEXT,\n            thumbnail_path TEXT,\n            parameters TEXT,\n            metadata TEXT,\n            created_at TEXT,\n            updated_at TEXT\n        );\n\n        CREATE TABLE IF NOT EXISTS reference_assets (\n            id TEXT PRIMARY KEY,\n            generation_id TEXT NOT NULL,\n            asset_path TEXT,\n            relative_path TEXT,\n            asset_type TEXT,\n            order_index INTEGER DEFAULT 0,\n            metadata TEXT,\n            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n        \"\"\"\n\n        try:\n            with self.connection:\n                self.connection.executescript(schema)\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to create initial tables: {}\", exc)\n            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n\n    @staticmethod\n    def _now() -> str:\n        return datetime.utcnow().isoformat()\n\n    @staticmethod\n    def _dump_json(data: Any) -> Optional[str]:\n        if data is None:\n            return None\n\n        try:\n            return json.dumps(data)\n        except (TypeError, ValueError) as exc:\n            logger.error(\"Failed to serialize JSON field: {}\", exc)\n            return None\n\n    @staticmethod\n    def _load_json(payload: Optional[str]) -> Optional[Any]:\n        if not payload:\n            return None\n\n        try:\n            return json.loads(payload)\n        except json.JSONDecodeError as exc:\n            logger.error(\"Failed to decode JSON payload: {}\", exc)\n            return None\n\n    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n        result = dict(row)\n        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n\n        # 将相对路径转换为绝对路径\n        if self.storage_root:\n            import os\n            # file_path / relative_path -> absolute_path\n            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n            if rel_path:\n                # 统一路径分隔符\n                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_path = self.storage_root / rel_path\n                result[\"absolute_path\"] = str(abs_path)\n\n            # thumbnail_path -> absolute thumbnail path\n            thumb_path = result.get(\"thumbnail_path\")\n            if thumb_path:\n                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_thumb = self.storage_root / thumb_path\n                result[\"thumbnail_path\"] = str(abs_thumb)\n\n        return result\n\n    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n        result = dict(row)\n        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n\n        # 将相对路径转换为绝对路径\n        if self.storage_root:\n            import os\n            rel_path = result.get(\"asset_path\") or result.get(\"relative_path\")\n            if rel_path:\n                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_path = self.storage_root / rel_path\n                result[\"absolute_path\"] = str(abs_path)\n\n        return result\n\n    def add_record(self, record_id: str, content_type: str, data: Dict) -> bool:\n        \"\"\"添加或更新生成记录（UPSERT）.\"\"\"\n\n        timestamp = self._now()\n        record = {\n            \"id\": record_id,\n            \"content_type\": content_type,\n            \"prompt\": data.get(\"prompt\"),\n            \"model\": data.get(\"model\"),\n            \"status\": data.get(\"status\", \"completed\"),\n            \"file_path\": data.get(\"file_path\"),\n            \"relative_path\": data.get(\"relative_path\"),\n            \"thumbnail_path\": data.get(\"thumbnail_path\"),\n            \"parameters\": self._dump_json(data.get(\"parameters\")),\n            \"metadata\": self._dump_json(data.get(\"metadata\")),\n            \"created_at\": data.get(\"created_at\", timestamp),\n            \"updated_at\": timestamp,\n        }\n\n        sql = \"\"\"\n        INSERT INTO generations (id, content_type, prompt, model, status, file_path,\n            relative_path, thumbnail_path, parameters, metadata, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ON CONFLICT(id) DO UPDATE SET\n            content_type = excluded.content_type,\n            prompt = COALESCE(excluded.prompt, prompt),\n            model = COALESCE(excluded.model, model),\n            status = CASE\n                WHEN excluded.status IS NULL OR excluded.status = '' THEN status\n                ELSE excluded.status\n            END,\n            file_path = COALESCE(excluded.file_path, file_path),\n            relative_path = COALESCE(excluded.relative_path, relative_path),\n            thumbnail_path = COALESCE(excluded.thumbnail_path, thumbnail_path),\n            parameters = COALESCE(excluded.parameters, parameters),\n            metadata = COALESCE(excluded.metadata, metadata),\n            updated_at = excluded.updated_at\n        \"\"\"\n\n        try:\n            with self.connection:\n                self.connection.execute(sql, (\n                    record[\"id\"],\n                    record[\"content_type\"],\n                    record[\"prompt\"],\n                    record[\"model\"],\n                    record[\"status\"],\n                    record[\"file_path\"],\n                    record[\"relative_path\"],\n                    record[\"thumbnail_path\"],\n                    record[\"parameters\"],\n                    record[\"metadata\"],\n                    record[\"created_at\"],\n                    record[\"updated_at\"],\n                ))\n            return True\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to upsert generation record {}: {}\", record_id, exc)\n            return False\n\n    def get_records(self, content_type: str, limit: int, offset: int) -> List[Dict]:\n        \"\"\"分页获取记录，按 created_at DESC 排序.\"\"\"\n\n        try:\n            cursor = self.connection.execute(\n                \"\"\"\n                SELECT * FROM generations\n                WHERE content_type = ?\n                ORDER BY created_at DESC, updated_at DESC\n                LIMIT ? OFFSET ?\n                \"\"\",\n                (content_type, limit, offset),\n            )\n            return [self._row_to_dict(row) for row in cursor.fetchall()]\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to fetch generation records: {}\", exc)\n            return []\n\n    def get_record_by_id(self, record_id: str) -> Optional[Dict]:\n        \"\"\"根据ID获取单条记录.\"\"\"\n\n        try:\n            cursor = self.connection.execute(\n                \"SELECT * FROM generations WHERE id = ?\", (record_id,)\n            )\n            row = cursor.fetchone()\n            return self._row_to_dict(row) if row else None\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to fetch generation record {}: {}\", record_id, exc)\n            return None\n\n    def update_record(self, record_id: str, data: Dict) -> bool:\n        \"\"\"更新记录.\"\"\"\n\n        if not data:\n            return False\n\n        allowed_columns = [\n            \"content_type\",\n            \"prompt\",\n            \"model\",\n            \"status\",\n            \"file_path\",\n            \"relative_path\",\n            \"thumbnail_path\",\n            \"parameters\",\n            \"metadata\",\n            \"created_at\",\n        ]\n\n        set_clauses: List[str] = []\n        values: List[Any] = []\n\n        for column in allowed_columns:\n            if column in data:\n                value = data[column]\n                if column in {\"parameters\", \"metadata\"}:\n                    value = self._dump_json(value)\n                set_clauses.append(f\"{column} = ?\")\n                values.append(value)\n\n        if not set_clauses:\n            return False\n\n        set_clauses.append(\"updated_at = ?\")\n        values.append(self._now())\n\n        values.append(record_id)\n        sql = f\"UPDATE generations SET {', '.join(set_clauses)} WHERE id = ?\"\n\n        try:\n            with self.connection:\n                cursor = self.connection.execute(sql, values)\n            return cursor.rowcount > 0\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to update generation record {}: {}\", record_id, exc)\n            return False\n\n    def delete_record(self, record_id: str) -> bool:\n        \"\"\"删除记录.\"\"\"\n\n        try:\n            with self.connection:\n                cursor = self.connection.execute(\n                    \"DELETE FROM generations WHERE id = ?\", (record_id,)\n                )\n            return cursor.rowcount > 0\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to delete generation record {}: {}\", record_id, exc)\n            return False\n\n    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n        \"\"\"清理超时的 pending 记录（无文件路径的孤立占位符）\n\n        Args:\n            timeout_hours: 超时时间（小时）\n\n        Returns:\n            删除的记录数量\n        \"\"\"\n        from datetime import datetime, timedelta\n\n        try:\n            cutoff = datetime.now() - timedelta(hours=timeout_hours)\n            cutoff_str = cutoff.isoformat()\n\n            with self.connection:\n                cursor = self.connection.execute(\n                    \"\"\"\n                    DELETE FROM generations\n                    WHERE status = 'pending'\n                      AND file_path IS NULL\n                      AND created_at < ?\n                    \"\"\",\n                    (cutoff_str,),\n                )\n            deleted = cursor.rowcount\n            if deleted > 0:\n                logger.info(f\"已清理 {deleted} 条过期的 pending 记录\")\n            return deleted\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to cleanup stale pending records: {}\", exc)\n            return 0\n\n    def get_total_count(self, content_type: str) -> int:\n        \"\"\"获取某类型总数.\"\"\"\n\n        try:\n            cursor = self.connection.execute(\n                \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",\n                (content_type,),\n            )\n            row = cursor.fetchone()\n            return int(row[0]) if row else 0\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to count generation records: {}\", exc)\n            return 0\n\n    def search_records(\n        self, keyword: str, content_type: Optional[str], limit: int\n    ) -> List[Dict]:\n        \"\"\"搜索记录（prompt、model、file_path）.\"\"\"\n\n        if not keyword:\n            return []\n\n        pattern = f\"%{keyword}%\"\n        where_clauses = [\n            \"(prompt LIKE ? OR model LIKE ? OR file_path LIKE ?)\"\n        ]\n        params: List[Any] = [pattern, pattern, pattern]\n\n        if content_type:\n            where_clauses.append(\"content_type = ?\")\n            params.append(content_type)\n\n        params.append(limit)\n\n        query = (\n            \"SELECT * FROM generations WHERE \"\n            + \" AND \".join(where_clauses)\n            + \" ORDER BY created_at DESC, updated_at DESC LIMIT ?\"\n        )\n\n        try:\n            cursor = self.connection.execute(query, params)\n            return [self._row_to_dict(row) for row in cursor.fetchall()]\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to search generation records: {}\", exc)\n            return []\n\n    def add_reference_asset(self, generation_id: str, asset_data: Dict) -> bool:\n        \"\"\"添加参考图资产.\"\"\"\n\n        asset_id = asset_data.get(\"id\") or asset_data.get(\"asset_id\")\n        if not asset_id:\n            logger.error(\"Reference asset requires an 'id' field\")\n            return False\n\n        payload = {\n            \"id\": asset_id,\n            \"generation_id\": generation_id,\n            \"asset_path\": asset_data.get(\"asset_path\"),\n            \"relative_path\": asset_data.get(\"relative_path\"),\n            \"asset_type\": asset_data.get(\"asset_type\"),\n            \"order_index\": asset_data.get(\"order_index\", 0),\n            \"metadata\": self._dump_json(asset_data.get(\"metadata\")),\n        }\n\n        sql = (\n            \"INSERT INTO reference_assets (id, generation_id, asset_path, relative_path, \"\n            \"asset_type, order_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?)\"\n        )\n\n        try:\n            with self.connection:\n                self.connection.execute(\n                    sql,\n                    (\n                        payload[\"id\"],\n                        payload[\"generation_id\"],\n                        payload[\"asset_path\"],\n                        payload[\"relative_path\"],\n                        payload[\"asset_type\"],\n                        payload[\"order_index\"],\n                        payload[\"metadata\"],\n                    ),\n                )\n            return True\n        except sqlite3.Error as exc:\n            logger.error(\n                \"Failed to insert reference asset {} for generation {}: {}\",\n                asset_id,\n                generation_id,\n                exc,\n            )\n            return False\n\n    def get_reference_assets(self, generation_id: str) -> List[Dict]:\n        \"\"\"获取参考图资产.\"\"\"\n\n        try:\n            cursor = self.connection.execute(\n                \"\"\"\n                SELECT * FROM reference_assets\n                WHERE generation_id = ?\n                ORDER BY order_index ASC\n                \"\"\",\n                (generation_id,),\n            )\n            return [self._reference_row_to_dict(row) for row in cursor.fetchall()]\n        except sqlite3.Error as exc:\n            logger.error(\n                \"Failed to fetch reference assets for generation {}: {}\",\n                generation_id,\n                exc,\n            )\n            return []\n\n    def close(self) -> None:\n        \"\"\"关闭数据库连接.\"\"\"\n\n        try:\n            self.connection.close()\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to close SQLite connection: {}\", exc)\n","numLines":454,"startLine":1,"totalLines":454}}}
{"parentUuid":"d16d7cd5-93a4-4202-bf5c-6d25b0aeeeef","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G7qDsqFkZoJFBxfhnFSDcj","type":"tool_result","content":"Found 2 files\nmodules/repository/manager.py\nmodules/repository/sqlite_handler.py"}]},"uuid":"7b500aaf-df2f-4125-aad4-1e619b3438c1","timestamp":"2025-12-13T13:22:20.614Z","toolUseResult":{"mode":"files_with_matches","filenames":["modules/repository/manager.py","modules/repository/sqlite_handler.py"],"numFiles":2}}
{"parentUuid":"7b500aaf-df2f-4125-aad4-1e619b3438c1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019TW77by72x1fRb4hcpYrtA","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看存储管理器如何处理参考图文件的保存："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":6147,"cache_read_input_tokens":61273,"cache_creation":{"ephemeral_5m_input_tokens":6147,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"0581d206-1e0f-45f7-b93a-2468ade9718c","timestamp":"2025-12-13T13:22:24.008Z"}
{"parentUuid":"0581d206-1e0f-45f7-b93a-2468ade9718c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019TW77by72x1fRb4hcpYrtA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CStgx5pmvZNYNJqn8CWvUm","name":"Bash","input":{"command":"find /Users/yunchang/Documents/GitHub/gemeng2/modules/storage -type f -name \"*.py\" | head -10"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":6147,"cache_read_input_tokens":61273,"cache_creation":{"ephemeral_5m_input_tokens":6147,"ephemeral_1h_input_tokens":0},"output_tokens":108,"service_tier":"standard"},"context_management":{"applied_edits":[]}},"type":"assistant","uuid":"57063c2f-e88e-4fbc-b982-5b134a3ee27b","timestamp":"2025-12-13T13:22:24.649Z"}
{"parentUuid":"57063c2f-e88e-4fbc-b982-5b134a3ee27b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CStgx5pmvZNYNJqn8CWvUm","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/storage_manager_factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","is_error":false}]},"uuid":"3af04cff-ce0c-41e0-921e-39b28c543b17","timestamp":"2025-12-13T13:22:24.717Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/storage_manager_factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"3af04cff-ce0c-41e0-921e-39b28c543b17","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Pkcrzbn2u9yq15K52bE9bt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FSnMLMepBe1XgzNnruQR6g","name":"Grep","input":{"pattern":"save_reference_asset|_generate_reference_asset_id|reference.*path","path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","output_mode":"content","head_limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":481,"cache_read_input_tokens":67420,"cache_creation":{"ephemeral_5m_input_tokens":481,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"}},"type":"assistant","uuid":"5975dfc0-689c-44d8-998e-4cd6e25f6d30","timestamp":"2025-12-13T13:22:30.329Z"}
{"parentUuid":"5975dfc0-689c-44d8-998e-4cd6e25f6d30","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FSnMLMepBe1XgzNnruQR6g","type":"tool_result","content":"14:- Interfaces kept compatible with existing callers (save_content_file, save_reference_asset, load_history, get_storage_stats).\n42:        self.references_images_dir = self.root_path / \"references\" / \"images\"\n43:        self.references_videos_dir = self.root_path / \"references\" / \"videos\"\n205:    def save_reference_asset(\n\n[Showing results with pagination = limit: 100, offset: 0]"}]},"uuid":"e4eda718-a6de-44f4-91d7-986978cba70d","timestamp":"2025-12-13T13:22:30.426Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"14:- Interfaces kept compatible with existing callers (save_content_file, save_reference_asset, load_history, get_storage_stats).\n42:        self.references_images_dir = self.root_path / \"references\" / \"images\"\n43:        self.references_videos_dir = self.root_path / \"references\" / \"videos\"\n205:    def save_reference_asset(","numLines":4,"appliedLimit":100}}
{"parentUuid":"e4eda718-a6de-44f4-91d7-986978cba70d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DY4LZHDsxRg7FWn5sv4Ej9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DNVkbUArk7Gig3UuAHDvL7","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","offset":205,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":417,"cache_read_input_tokens":67901,"cache_creation":{"ephemeral_5m_input_tokens":417,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"type":"assistant","uuid":"42dcdb8a-b1ad-4d40-8b0b-3902379c745d","timestamp":"2025-12-13T13:22:33.614Z"}
{"parentUuid":"42dcdb8a-b1ad-4d40-8b0b-3902379c745d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DNVkbUArk7Gig3UuAHDvL7","type":"tool_result","content":"   205→    def save_reference_asset(\n   206→        self,\n   207→        content_type: str,\n   208→        file_data: bytes,\n   209→        url: Optional[str] = None,\n   210→        metadata: Optional[Dict[str, Any]] = None,\n   211→        *,\n   212→        asset_id: Optional[str] = None,\n   213→        extension: Optional[str] = None,\n   214→    ) -> Dict[str, Any]:\n   215→        \"\"\"\n   216→        Save a reference asset (image/video). Does not persist to repository table by default.\n   217→        Accepts optional asset_id/extension for callers that pre-generate IDs.\n   218→        \"\"\"\n   219→        metadata = metadata or {}\n   220→        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n   221→\n   222→        ref_id = str(asset_id or metadata.get(\"reference_id\") or uuid.uuid4().hex)\n   223→        ext = extension or self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n   224→        filename = f\"{ref_id}{ext}\"\n   225→        target_dir = self.references_images_dir if ctype == \"images\" else self.references_videos_dir\n   226→        target_path = target_dir / filename\n   227→\n   228→        self._save_file(target_path, file_data)\n   229→\n   230→        width: Optional[int] = metadata.get(\"width\")\n   231→        height: Optional[int] = metadata.get(\"height\")\n   232→        thumbnail_path: Optional[Path] = None\n   233→        if ctype == \"images\":\n   234→            try:\n   235→                with Image.open(io.BytesIO(file_data)) as img:\n   236→                    width = width or img.width\n   237→                    height = height or img.height\n   238→            except Exception as exc:\n   239→                logger.warning(f\"Failed to inspect reference image size: {exc}\")\n   240→            thumbnail_path = self._make_image_thumbnail(file_data, ref_id, ext)\n   241→\n   242→        rel_path = str(target_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\")\n   243→        rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\") if thumbnail_path else None\n   244→        record = {\n   245→            \"id\": ref_id,\n   246→            \"reference_id\": ref_id,\n   247→            \"path\": rel_path,\n   248→            \"relative_path\": rel_path,\n   249→            \"absolute_path\": str(target_path),\n   250→            \"content_type\": ctype,\n   251→            \"type\": metadata.get(\"type\") or metadata.get(\"kind\") or (\"image\" if ctype == \"images\" else \"video\"),\n   252→            \"kind\": metadata.get(\"kind\") or metadata.get(\"type\") or (\"image\" if ctype == \"images\" else \"video\"),\n   253→            \"source\": metadata.get(\"source\") or metadata.get(\"source_path\") or metadata.get(\"source_url\"),\n   254→            \"order\": metadata.get(\"order\"),\n   255→            \"size\": len(file_data),\n   256→            \"checksum\": metadata.get(\"checksum\"),\n   257→            \"width\": width,\n   258→            \"height\": height,\n   259→            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n   260→            \"thumbnail_path\": rel_thumb,\n   261→            \"thumbnail_local_path\": str(thumbnail_path) if thumbnail_path else None,\n   262→        }\n   263→        return record\n   264→\n   265→    def load_history(self, content_type: str, limit: int = 100) -> List[Dict[str, Any]]:\n   266→        ctype = \"image\" if content_type in (\"image\", \"images\") else \"video\"\n   267→        try:\n   268→            records = self._repository_manager.get_records_batch(\n   269→                start_index=0,\n   270→                batch_size=limit,\n   271→                record_type=ctype,\n   272→            )\n   273→            return records or []\n   274→        except Exception as exc:\n   275→            logger.error(f\"Failed to load history: {exc}\")\n   276→            return []\n   277→\n   278→    def get_storage_stats(self) -> Dict[str, Any]:\n   279→        try:\n   280→            images = self._repository_manager.get_total_count('image')\n   281→            videos = self._repository_manager.get_total_count('video')\n   282→        except Exception:\n   283→            images = videos = 0\n   284→        return {\n   285→            \"images\": images,\n   286→            \"videos\": videos,\n   287→            \"total\": images + videos,\n   288→            \"root_path\": str(self.root_path),\n   289→        }\n   290→\n   291→    # Compatibility alias\n   292→    def clear_cache(self) -> None:\n   293→        return\n   294→\n   295→\n   296→__all__ = [\"UnifiedStorageManagerV2\"]\n   297→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4e47fbd1-f558-4f31-a898-0380a367fca6","timestamp":"2025-12-13T13:22:33.682Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","content":"    def save_reference_asset(\n        self,\n        content_type: str,\n        file_data: bytes,\n        url: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        *,\n        asset_id: Optional[str] = None,\n        extension: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Save a reference asset (image/video). Does not persist to repository table by default.\n        Accepts optional asset_id/extension for callers that pre-generate IDs.\n        \"\"\"\n        metadata = metadata or {}\n        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n\n        ref_id = str(asset_id or metadata.get(\"reference_id\") or uuid.uuid4().hex)\n        ext = extension or self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n        filename = f\"{ref_id}{ext}\"\n        target_dir = self.references_images_dir if ctype == \"images\" else self.references_videos_dir\n        target_path = target_dir / filename\n\n        self._save_file(target_path, file_data)\n\n        width: Optional[int] = metadata.get(\"width\")\n        height: Optional[int] = metadata.get(\"height\")\n        thumbnail_path: Optional[Path] = None\n        if ctype == \"images\":\n            try:\n                with Image.open(io.BytesIO(file_data)) as img:\n                    width = width or img.width\n                    height = height or img.height\n            except Exception as exc:\n                logger.warning(f\"Failed to inspect reference image size: {exc}\")\n            thumbnail_path = self._make_image_thumbnail(file_data, ref_id, ext)\n\n        rel_path = str(target_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\")\n        rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\") if thumbnail_path else None\n        record = {\n            \"id\": ref_id,\n            \"reference_id\": ref_id,\n            \"path\": rel_path,\n            \"relative_path\": rel_path,\n            \"absolute_path\": str(target_path),\n            \"content_type\": ctype,\n            \"type\": metadata.get(\"type\") or metadata.get(\"kind\") or (\"image\" if ctype == \"images\" else \"video\"),\n            \"kind\": metadata.get(\"kind\") or metadata.get(\"type\") or (\"image\" if ctype == \"images\" else \"video\"),\n            \"source\": metadata.get(\"source\") or metadata.get(\"source_path\") or metadata.get(\"source_url\"),\n            \"order\": metadata.get(\"order\"),\n            \"size\": len(file_data),\n            \"checksum\": metadata.get(\"checksum\"),\n            \"width\": width,\n            \"height\": height,\n            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n            \"thumbnail_path\": rel_thumb,\n            \"thumbnail_local_path\": str(thumbnail_path) if thumbnail_path else None,\n        }\n        return record\n\n    def load_history(self, content_type: str, limit: int = 100) -> List[Dict[str, Any]]:\n        ctype = \"image\" if content_type in (\"image\", \"images\") else \"video\"\n        try:\n            records = self._repository_manager.get_records_batch(\n                start_index=0,\n                batch_size=limit,\n                record_type=ctype,\n            )\n            return records or []\n        except Exception as exc:\n            logger.error(f\"Failed to load history: {exc}\")\n            return []\n\n    def get_storage_stats(self) -> Dict[str, Any]:\n        try:\n            images = self._repository_manager.get_total_count('image')\n            videos = self._repository_manager.get_total_count('video')\n        except Exception:\n            images = videos = 0\n        return {\n            \"images\": images,\n            \"videos\": videos,\n            \"total\": images + videos,\n            \"root_path\": str(self.root_path),\n        }\n\n    # Compatibility alias\n    def clear_cache(self) -> None:\n        return\n\n\n__all__ = [\"UnifiedStorageManagerV2\"]\n","numLines":93,"startLine":205,"totalLines":297}}}
{"parentUuid":"4e47fbd1-f558-4f31-a898-0380a367fca6","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014DqzDvBaBwLBjWpm7GEdFH","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看参考图ID的生成逻辑，以及如何检查参考图是否被多个记录共享："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1590,"cache_read_input_tokens":68318,"cache_creation":{"ephemeral_5m_input_tokens":1590,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"fa0377b2-d29d-4a14-acb5-d6d979805fa0","timestamp":"2025-12-13T13:22:39.280Z"}
{"parentUuid":"fa0377b2-d29d-4a14-acb5-d6d979805fa0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014DqzDvBaBwLBjWpm7GEdFH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AKyUjM3zd9h9wmjfiUd2Zg","name":"Bash","input":{"command":"grep -r \"reference_asset\" --include=\"*.py\" modules/ | grep -E \"checksum|hash|dedup\" | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1590,"cache_read_input_tokens":68318,"cache_creation":{"ephemeral_5m_input_tokens":1590,"ephemeral_1h_input_tokens":0},"output_tokens":139,"service_tier":"standard"}},"type":"assistant","uuid":"382ddb5a-5709-4180-b7bd-71f134743486","timestamp":"2025-12-13T13:22:39.881Z"}
{"parentUuid":"382ddb5a-5709-4180-b7bd-71f134743486","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AKyUjM3zd9h9wmjfiUd2Zg","type":"tool_result","content":"","is_error":false}]},"uuid":"24ab47fc-c5e1-45ce-b082-05e0c1eae958","timestamp":"2025-12-13T13:22:39.959Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"24ab47fc-c5e1-45ce-b082-05e0c1eae958","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HswzGPCrjJkheAoGnh6V5k","type":"message","role":"assistant","content":[{"type":"text","text":"让我检查是否有查询多个记录引用同一个参考图的逻辑："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":272,"cache_read_input_tokens":69908,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"4026e394-647b-484c-90cc-a589f2ae5ed8","timestamp":"2025-12-13T13:22:43.399Z"}
{"parentUuid":"4026e394-647b-484c-90cc-a589f2ae5ed8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HswzGPCrjJkheAoGnh6V5k","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X6GP7XoQaDyYZoeRssJaH2","name":"Bash","input":{"command":"grep -n \"COUNT\\|check\\|shared\\|multiple\" /Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":272,"cache_read_input_tokens":69908,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":118,"service_tier":"standard"}},"type":"assistant","uuid":"b16b41a3-2f62-4e49-b1fa-354da21ed613","timestamp":"2025-12-13T13:22:44.060Z"}
{"parentUuid":"b16b41a3-2f62-4e49-b1fa-354da21ed613","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X6GP7XoQaDyYZoeRssJaH2","type":"tool_result","content":"32:            self.connection = sqlite3.connect(self.db_path, check_same_thread=False)\n337:                \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",","is_error":false}]},"uuid":"225e00d1-11e7-45c1-8b83-2ff8a7d562ee","timestamp":"2025-12-13T13:22:44.118Z","toolUseResult":{"stdout":"32:            self.connection = sqlite3.connect(self.db_path, check_same_thread=False)\n337:                \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"225e00d1-11e7-45c1-8b83-2ff8a7d562ee","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01N3vCMHTCD3mMB2NrmazZEc","type":"message","role":"assistant","content":[{"type":"text","text":"让我查看最近的记录删除相关的提交来了解当前的实现状态："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":455,"cache_read_input_tokens":70180,"cache_creation":{"ephemeral_5m_input_tokens":455,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"02f219e8-d55e-4119-b675-9384a911a689","timestamp":"2025-12-13T13:22:47.914Z"}
{"parentUuid":"02f219e8-d55e-4119-b675-9384a911a689","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01N3vCMHTCD3mMB2NrmazZEc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TE26utaPn4GBHdyiqK2aWg","name":"Bash","input":{"command":"git log --oneline -20 | head -15"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":455,"cache_read_input_tokens":70180,"cache_creation":{"ephemeral_5m_input_tokens":455,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"7ef4020d-7491-4430-b8c0-fc68fc7ea446","timestamp":"2025-12-13T13:22:48.178Z"}
{"parentUuid":"7ef4020d-7491-4430-b8c0-fc68fc7ea446","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TE26utaPn4GBHdyiqK2aWg","type":"tool_result","content":"f87cc11 feat: Add delete record functionality in detail dialogs\n20de152 docs: Update README with latest development status (Seedream 4.5, Seedance Pro-fast, UI optimizations)\ne248eae Fix: Video mode status label placeholder text (??? -> 已加载 0 个视频)\n31e1de7 Fix: Restore 1080p restriction for ALL models in reference mode (not just Lite)\n834b74f Fix: Only restrict 1080p for Lite model in reference mode (Pro supports 1080p+ref)\n20b57dc Fix: Remove 🔥 emoji from 4.0 resolution options\n2967dbf Fix: Increase delete button size to 22x22 and font to 16px for visible ×\n1b259bd Fix: Use ID selector to override global QPushButton styles for 3.0 delete button\n525250f Fix: Remove duplicate _update_ui_state (Counter Bug) & Style 3.0 Button\ne12088a Fix: Route 'Add to Reference' intelligently based on Model Version (Plan Psi)\n4de6c39 Fix: Revert Counter raise() and polish UI (Plan Chi)\nf6774e1 Fix: IntegratedReferencePanel Counter Visibility (Z-Order) and Typography Centering (Plan Phi)\n2ea00ae Fix: Restore missing title/subtitle variables in paintEvent\n551a56f UI: Final Polish Typography (Plan Upsilon - Centered 15pt Title)\n588ba2d UI: Polish Reference Gallery Typography and Disable Tooltip (Plan Tau)","is_error":false}]},"uuid":"855b454e-3125-4b16-b872-76fd91e9961e","timestamp":"2025-12-13T13:22:48.257Z","toolUseResult":{"stdout":"f87cc11 feat: Add delete record functionality in detail dialogs\n20de152 docs: Update README with latest development status (Seedream 4.5, Seedance Pro-fast, UI optimizations)\ne248eae Fix: Video mode status label placeholder text (??? -> 已加载 0 个视频)\n31e1de7 Fix: Restore 1080p restriction for ALL models in reference mode (not just Lite)\n834b74f Fix: Only restrict 1080p for Lite model in reference mode (Pro supports 1080p+ref)\n20b57dc Fix: Remove 🔥 emoji from 4.0 resolution options\n2967dbf Fix: Increase delete button size to 22x22 and font to 16px for visible ×\n1b259bd Fix: Use ID selector to override global QPushButton styles for 3.0 delete button\n525250f Fix: Remove duplicate _update_ui_state (Counter Bug) & Style 3.0 Button\ne12088a Fix: Route 'Add to Reference' intelligently based on Model Version (Plan Psi)\n4de6c39 Fix: Revert Counter raise() and polish UI (Plan Chi)\nf6774e1 Fix: IntegratedReferencePanel Counter Visibility (Z-Order) and Typography Centering (Plan Phi)\n2ea00ae Fix: Restore missing title/subtitle variables in paintEvent\n551a56f UI: Final Polish Typography (Plan Upsilon - Centered 15pt Title)\n588ba2d UI: Polish Reference Gallery Typography and Disable Tooltip (Plan Tau)","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"855b454e-3125-4b16-b872-76fd91e9961e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017ST13evGN5WsymgUX7PgpW","type":"message","role":"assistant","content":[{"type":"text","text":"让我查看最新的删除功能提交："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":619,"cache_read_input_tokens":70635,"cache_creation":{"ephemeral_5m_input_tokens":619,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"688ae950-6593-424e-8053-bab869a872e4","timestamp":"2025-12-13T13:22:51.551Z"}
{"parentUuid":"688ae950-6593-424e-8053-bab869a872e4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017ST13evGN5WsymgUX7PgpW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RnHPL1vvDS6QyTixTKJFx5","name":"Bash","input":{"command":"git show f87cc11 --stat"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":619,"cache_read_input_tokens":70635,"cache_creation":{"ephemeral_5m_input_tokens":619,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"056f44bb-adff-4c53-9a37-9e2726b474cf","timestamp":"2025-12-13T13:22:51.733Z"}
{"parentUuid":"056f44bb-adff-4c53-9a37-9e2726b474cf","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RnHPL1vvDS6QyTixTKJFx5","type":"tool_result","content":"commit f87cc11ff373e0e0899a1be2309023972b28e423\nAuthor: yunchang <yunchang0612@gmail.com>\nDate:   Sat Dec 13 21:03:03 2025 +0800\n\n    feat: Add delete record functionality in detail dialogs\n    \n    - Add delete_record_with_files method to RepositoryManager\n    - Replace 'Copy All Info' with 'Delete Record' button in ImageDetailDialog\n    - Add 'Delete Record' button to VideoDetailDialog\n    - Auto-navigate to previous record after deletion\n    - Close dialog if last record is deleted\n\n components/dialogs/image_detail_dialog.py | 56 +++++++++++++++++++++++-\n components/dialogs/video_detail_dialog.py | 63 +++++++++++++++++++++++++++\n modules/repository/manager.py             | 72 +++++++++++++++++++++++++++++++\n 3 files changed, 189 insertions(+), 2 deletions(-)","is_error":false}]},"uuid":"c5a01742-728d-42f7-a3f0-5a011b463d4a","timestamp":"2025-12-13T13:22:51.805Z","toolUseResult":{"stdout":"commit f87cc11ff373e0e0899a1be2309023972b28e423\nAuthor: yunchang <yunchang0612@gmail.com>\nDate:   Sat Dec 13 21:03:03 2025 +0800\n\n    feat: Add delete record functionality in detail dialogs\n    \n    - Add delete_record_with_files method to RepositoryManager\n    - Replace 'Copy All Info' with 'Delete Record' button in ImageDetailDialog\n    - Add 'Delete Record' button to VideoDetailDialog\n    - Auto-navigate to previous record after deletion\n    - Close dialog if last record is deleted\n\n components/dialogs/image_detail_dialog.py | 56 +++++++++++++++++++++++-\n components/dialogs/video_detail_dialog.py | 63 +++++++++++++++++++++++++++\n modules/repository/manager.py             | 72 +++++++++++++++++++++++++++++++\n 3 files changed, 189 insertions(+), 2 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"c5a01742-728d-42f7-a3f0-5a011b463d4a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Fz2TSg4fXEir85aiyvuQut","type":"message","role":"assistant","content":[{"type":"text","text":"让我检查参考图的实际引用关系。需要查找是否存在通过ID去重的逻辑："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":373,"cache_read_input_tokens":71254,"cache_creation":{"ephemeral_5m_input_tokens":373,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"708037ca-c88b-4c77-80e5-27a77a14ff2c","timestamp":"2025-12-13T13:22:55.133Z"}
{"parentUuid":"708037ca-c88b-4c77-80e5-27a77a14ff2c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Fz2TSg4fXEir85aiyvuQut","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GDXhYvMpg6hqE1rvEyeqqo","name":"Grep","input":{"pattern":"references/images|references/videos|ref_.*\\.png|reference_assets","path":"/Users/yunchang/Documents/GitHub/gemeng2/modules","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":373,"cache_read_input_tokens":71254,"cache_creation":{"ephemeral_5m_input_tokens":373,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"43faf7b6-aa80-4691-b3b5-6e7d000066db","timestamp":"2025-12-13T13:22:55.878Z"}
{"parentUuid":"43faf7b6-aa80-4691-b3b5-6e7d000066db","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GDXhYvMpg6hqE1rvEyeqqo","type":"tool_result","content":"Found 5 files\nmodules/repository/manager.py\nmodules/provider/schema.py\nmodules/seedance/manager.py\nmodules/seedream/manager.py\nmodules/repository/sqlite_handler.py"}]},"uuid":"82774f02-04cb-4616-8c13-342a31ee9fdf","timestamp":"2025-12-13T13:22:55.956Z","toolUseResult":{"mode":"files_with_matches","filenames":["modules/repository/manager.py","modules/provider/schema.py","modules/seedance/manager.py","modules/seedream/manager.py","modules/repository/sqlite_handler.py"],"numFiles":5}}
{"parentUuid":"82774f02-04cb-4616-8c13-342a31ee9fdf","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JNaewaEWBYj9vFevVup2bm","type":"message","role":"assistant","content":[{"type":"text","text":"让我找参考图ID生成的完整逻辑，看是否有去重机制："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":604,"cache_read_input_tokens":71627,"cache_creation":{"ephemeral_5m_input_tokens":604,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"86165ad6-9024-4a9b-ac3a-b16caf434dfc","timestamp":"2025-12-13T13:22:58.976Z"}
{"parentUuid":"86165ad6-9024-4a9b-ac3a-b16caf434dfc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JNaewaEWBYj9vFevVup2bm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HxABmcgQNBug6b8i4YnnLu","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","offset":1081,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":604,"cache_read_input_tokens":71627,"cache_creation":{"ephemeral_5m_input_tokens":604,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"a2bb0ff7-f011-4cef-b401-5f0ef71fd549","timestamp":"2025-12-13T13:22:59.412Z"}
{"parentUuid":"a2bb0ff7-f011-4cef-b401-5f0ef71fd549","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HxABmcgQNBug6b8i4YnnLu","type":"tool_result","content":"  1081→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1082→        checksum = hashlib.sha1(file_data).hexdigest()\n  1083→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1084→        return f\"ref_{ts}_{checksum[:8]}\"\n  1085→\n  1086→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1087→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1088→        source_meta: Dict[str, Any] = {}\n  1089→        raw = ref\n  1090→        if isinstance(ref, dict):\n  1091→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1092→                if ref.get(key) is not None:\n  1093→                    source_meta[key] = ref.get(key)\n  1094→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1095→        if raw is None:\n  1096→            return None\n  1097→\n  1098→        extension = source_meta.get('extension')\n  1099→        data = None\n  1100→        source_repr = source_meta.get('source')\n  1101→\n  1102→        try:\n  1103→            if isinstance(raw, bytes):\n  1104→                data = raw\n  1105→            elif isinstance(raw, str):\n  1106→                stripped = raw.strip()\n  1107→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1108→                    header, payload = stripped.split(';base64,', 1)\n  1109→                    mime_part = header[5:]\n  1110→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b9e148f1-8bcd-4356-871b-2825b7bb00f4","timestamp":"2025-12-13T13:22:59.470Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'","numLines":30,"startLine":1081,"totalLines":1507}}}
{"parentUuid":"b9e148f1-8bcd-4356-871b-2825b7bb00f4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A23LRmguu6FFVbjdLQbgWs","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看删除记录时参考图的具体处理逻辑："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":796,"cache_read_input_tokens":72231,"cache_creation":{"ephemeral_5m_input_tokens":796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e9769629-8e07-4bdf-835f-78c12b5ab3cd","timestamp":"2025-12-13T13:23:03.069Z"}
{"parentUuid":"e9769629-8e07-4bdf-835f-78c12b5ab3cd","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A23LRmguu6FFVbjdLQbgWs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014NsCKwvyhziCc3Ri8v3rvq","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","offset":430,"limit":75}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":796,"cache_read_input_tokens":72231,"cache_creation":{"ephemeral_5m_input_tokens":796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f2c5216c-f698-450f-948a-e6a9145cc165","timestamp":"2025-12-13T13:23:03.413Z"}
{"parentUuid":"f2c5216c-f698-450f-948a-e6a9145cc165","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014NsCKwvyhziCc3Ri8v3rvq","type":"tool_result","content":"   430→    def delete_record_with_files(self, record_id: str) -> bool:\n   431→        \"\"\"删除记录及其所有关联文件\n   432→        \n   433→        Args:\n   434→            record_id: 记录ID\n   435→            \n   436→        Returns:\n   437→            bool: 是否删除成功\n   438→        \"\"\"\n   439→        if not record_id:\n   440→            return False\n   441→            \n   442→        try:\n   443→            # 1. 获取记录详情\n   444→            record = self.get_record_by_id(record_id)\n   445→            if not record:\n   446→                logger.warning(f\"删除记录: 未找到记录 {record_id}\")\n   447→                return False\n   448→            \n   449→            # 2. 收集需要删除的文件路径\n   450→            files_to_delete = []\n   451→            \n   452→            # 主文件（图片/视频）\n   453→            file_path = record.get('absolute_path') or record.get('file_path')\n   454→            if file_path:\n   455→                files_to_delete.append(file_path)\n   456→            \n   457→            # 缩略图\n   458→            thumb_path = record.get('thumbnail_local_path')\n   459→            if thumb_path:\n   460→                files_to_delete.append(thumb_path)\n   461→            \n   462→            # 参考图资产\n   463→            ref_info = record.get('_reference_info') or {}\n   464→            ref_assets = ref_info.get('assets', [])\n   465→            if not ref_assets:\n   466→                # 尝试从 parameters 中获取\n   467→                params = record.get('parameters') or {}\n   468→                ref_assets = params.get('reference_assets', [])\n   469→            \n   470→            for ref in ref_assets:\n   471→                if isinstance(ref, dict):\n   472→                    ref_path = ref.get('absolute_path') or ref.get('path')\n   473→                    if ref_path and str(ref_path) not in [str(f) for f in files_to_delete]:\n   474→                        # 转换相对路径为绝对路径\n   475→                        if not Path(ref_path).is_absolute():\n   476→                            ref_path = str(self.storage_root / ref_path)\n   477→                        files_to_delete.append(ref_path)\n   478→            \n   479→            # 3. 删除数据库记录\n   480→            if not self.delete_record(record_id):\n   481→                logger.error(f\"删除记录失败: 数据库删除失败 {record_id}\")\n   482→                return False\n   483→            \n   484→            # 4. 删除文件（忽略不存在的文件）\n   485→            deleted_files = []\n   486→            for path in files_to_delete:\n   487→                try:\n   488→                    if path and Path(path).exists():\n   489→                        Path(path).unlink()\n   490→                        deleted_files.append(path)\n   491→                        logger.debug(f\"已删除文件: {path}\")\n   492→                except Exception as e:\n   493→                    logger.warning(f\"删除文件失败: {path}, {e}\")\n   494→            \n   495→            logger.info(f\"删除记录完成: {record_id}, 删除了 {len(deleted_files)} 个文件\")\n   496→            return True\n   497→            \n   498→        except Exception as e:\n   499→            logger.error(f\"删除记录及文件失败: {record_id}, {e}\")\n   500→            return False\n   501→\n   502→    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n   503→        \"\"\"清理超时的 pending 记录\n   504→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"43184a64-61ef-4c85-92e7-b18c439dd90c","timestamp":"2025-12-13T13:23:03.462Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","content":"    def delete_record_with_files(self, record_id: str) -> bool:\n        \"\"\"删除记录及其所有关联文件\n        \n        Args:\n            record_id: 记录ID\n            \n        Returns:\n            bool: 是否删除成功\n        \"\"\"\n        if not record_id:\n            return False\n            \n        try:\n            # 1. 获取记录详情\n            record = self.get_record_by_id(record_id)\n            if not record:\n                logger.warning(f\"删除记录: 未找到记录 {record_id}\")\n                return False\n            \n            # 2. 收集需要删除的文件路径\n            files_to_delete = []\n            \n            # 主文件（图片/视频）\n            file_path = record.get('absolute_path') or record.get('file_path')\n            if file_path:\n                files_to_delete.append(file_path)\n            \n            # 缩略图\n            thumb_path = record.get('thumbnail_local_path')\n            if thumb_path:\n                files_to_delete.append(thumb_path)\n            \n            # 参考图资产\n            ref_info = record.get('_reference_info') or {}\n            ref_assets = ref_info.get('assets', [])\n            if not ref_assets:\n                # 尝试从 parameters 中获取\n                params = record.get('parameters') or {}\n                ref_assets = params.get('reference_assets', [])\n            \n            for ref in ref_assets:\n                if isinstance(ref, dict):\n                    ref_path = ref.get('absolute_path') or ref.get('path')\n                    if ref_path and str(ref_path) not in [str(f) for f in files_to_delete]:\n                        # 转换相对路径为绝对路径\n                        if not Path(ref_path).is_absolute():\n                            ref_path = str(self.storage_root / ref_path)\n                        files_to_delete.append(ref_path)\n            \n            # 3. 删除数据库记录\n            if not self.delete_record(record_id):\n                logger.error(f\"删除记录失败: 数据库删除失败 {record_id}\")\n                return False\n            \n            # 4. 删除文件（忽略不存在的文件）\n            deleted_files = []\n            for path in files_to_delete:\n                try:\n                    if path and Path(path).exists():\n                        Path(path).unlink()\n                        deleted_files.append(path)\n                        logger.debug(f\"已删除文件: {path}\")\n                except Exception as e:\n                    logger.warning(f\"删除文件失败: {path}, {e}\")\n            \n            logger.info(f\"删除记录完成: {record_id}, 删除了 {len(deleted_files)} 个文件\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"删除记录及文件失败: {record_id}, {e}\")\n            return False\n\n    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n        \"\"\"清理超时的 pending 记录\n","numLines":75,"startLine":430,"totalLines":1227}}}
{"parentUuid":"43184a64-61ef-4c85-92e7-b18c439dd90c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Kxb5NBkMC8Rz7mj26KgzVz","type":"message","role":"assistant","content":[{"type":"text","text":"完美！现在让我获取完整的存储管理器代码来理解参考图ID生成："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1425,"cache_read_input_tokens":73027,"cache_creation":{"ephemeral_5m_input_tokens":1425,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"88d9c32a-67e5-4c8c-8761-03fc32a1e4cc","timestamp":"2025-12-13T13:23:06.296Z"}
{"parentUuid":"88d9c32a-67e5-4c8c-8761-03fc32a1e4cc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Kxb5NBkMC8Rz7mj26KgzVz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016vydj2ViuJ1xMekUW52Mma","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","limit":250}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1425,"cache_read_input_tokens":73027,"cache_creation":{"ephemeral_5m_input_tokens":1425,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"53aef622-3368-45e2-9e8f-933490a16755","timestamp":"2025-12-13T13:23:06.828Z"}
{"parentUuid":"53aef622-3368-45e2-9e8f-933490a16755","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016vydj2ViuJ1xMekUW52Mma","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Unified storage manager (V2) - SQLite-backed implementation.\n     5→\n     6→Responsibilities:\n     7→- Manage root_path and subdirectories (images, videos, references, thumbnails, metadata, repository).\n     8→- Persist generation records into SQLite (repository/gemeng.db) for history views.\n     9→- Save content files and reference assets; generate image thumbnails (up to 1080p, no upscale).\n    10→- Provide history loading and basic storage stats.\n    11→\n    12→Notes:\n    13→- Video thumbnail generation is skipped (ffmpeg unavailable by default); placeholder None is returned.\n    14→- Interfaces kept compatible with existing callers (save_content_file, save_reference_asset, load_history, get_storage_stats).\n    15→\"\"\"\n    16→\n    17→from __future__ import annotations\n    18→\n    19→import io\n    20→import uuid\n    21→from datetime import datetime\n    22→from pathlib import Path\n    23→from typing import Any, Dict, List, Optional\n    24→\n    25→from loguru import logger\n    26→from PIL import Image\n    27→\n    28→\n    29→def _now_iso() -> str:\n    30→    return datetime.utcnow().isoformat()\n    31→\n    32→\n    33→class UnifiedStorageManagerV2:\n    34→    def __init__(self, base_path: str):\n    35→        from modules.repository.manager import RepositoryManager  # lazy import to avoid circular init in frozen mode\n    36→        self.root_path = Path(base_path).expanduser().resolve()\n    37→        self.root_path.mkdir(parents=True, exist_ok=True)\n    38→\n    39→        # Directory layout\n    40→        self.images_dir = self.root_path / \"images\"\n    41→        self.videos_dir = self.root_path / \"videos\"\n    42→        self.references_images_dir = self.root_path / \"references\" / \"images\"\n    43→        self.references_videos_dir = self.root_path / \"references\" / \"videos\"\n    44→        self.thumbnails_images_dir = self.root_path / \"thumbnails\" / \"images\"\n    45→        self.thumbnails_videos_dir = self.root_path / \"thumbnails\" / \"videos\"\n    46→        self.metadata_dir = self.root_path / \"metadata\"\n    47→        self.repository_dir = self.root_path / \"repository\"\n    48→\n    49→        for d in [\n    50→            self.images_dir,\n    51→            self.videos_dir,\n    52→            self.references_images_dir,\n    53→            self.references_videos_dir,\n    54→            self.thumbnails_images_dir,\n    55→            self.thumbnails_videos_dir,\n    56→            self.metadata_dir,\n    57→            self.repository_dir,\n    58→        ]:\n    59→            d.mkdir(parents=True, exist_ok=True)\n    60→\n    61→        # SQLite-backed repository manager\n    62→        self._repository_manager = RepositoryManager(self.root_path)\n    63→\n    64→    # ------------------------------------------------------------------ helpers\n    65→    @staticmethod\n    66→    def _guess_ext(url: Optional[str], default: str) -> str:\n    67→        if not url:\n    68→            return default\n    69→        lowered = url.lower()\n    70→        for ext in (\".png\", \".jpg\", \".jpeg\", \".webp\", \".mp4\", \".mov\", \".avi\"):\n    71→            if lowered.endswith(ext):\n    72→                return ext\n    73→        return default\n    74→\n    75→    def _save_file(self, target_path: Path, data: bytes) -> None:\n    76→        target_path.parent.mkdir(parents=True, exist_ok=True)\n    77→        target_path.write_bytes(data)\n    78→\n    79→    def _make_image_thumbnail(self, src_bytes: bytes, file_id: str, ext: str) -> Optional[Path]:\n    80→        try:\n    81→            with Image.open(io.BytesIO(src_bytes)) as img:\n    82→                img = img.convert(\"RGB\")\n    83→                # Maintain clarity: cap longest side at 1080px, do not upscale if smaller\n    84→                max_side = 1080\n    85→                w, h = img.size\n    86→                if max(w, h) > max_side:\n    87→                    img.thumbnail((max_side, max_side), Image.LANCZOS)\n    88→                thumb_name = f\"{file_id}_thumb.jpg\"\n    89→                thumb_path = self.thumbnails_images_dir / thumb_name\n    90→                thumb_path.parent.mkdir(parents=True, exist_ok=True)\n    91→                img.save(thumb_path, format=\"JPEG\", quality=92)\n    92→                return thumb_path\n    93→        except Exception as exc:\n    94→            logger.warning(f\"Failed to generate image thumbnail: {exc}\")\n    95→            return None\n    96→        return None\n    97→\n    98→    def _persist_record(\n    99→        self,\n   100→        record_id: str,\n   101→        content_type: str,\n   102→        file_path: Path,\n   103→        relative_path: str,\n   104→        thumbnail_path: Optional[Path],\n   105→        prompt: Optional[str],\n   106→        model: Optional[str],\n   107→        parameters: Dict[str, Any],\n   108→        metadata: Dict[str, Any],\n   109→        status: str = \"completed\",\n   110→    ) -> None:\n   111→        # 计算缩略图的相对路径\n   112→        rel_thumb = None\n   113→        if thumbnail_path:\n   114→            try:\n   115→                rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace('\\\\', '/')\n   116→            except ValueError:\n   117→                # 如果无法计算相对路径，使用文件名\n   118→                rel_thumb = f\"thumbnails/{thumbnail_path.name}\"\n   119→\n   120→        # 统一使用正斜杠，确保跨平台兼容\n   121→        rel_path_normalized = relative_path.replace('\\\\', '/') if relative_path else None\n   122→\n   123→        repo_data = {\n   124→            \"file_id\": record_id,\n   125→            \"generation_id\": parameters.get(\"generation_id\") or metadata.get(\"generation_id\") or record_id,\n   126→            \"prompt\": prompt,\n   127→            \"model\": model,\n   128→            \"status\": status,\n   129→            \"file_path\": rel_path_normalized,  # 存储相对路径（跨平台兼容）\n   130→            \"relative_path\": rel_path_normalized,\n   131→            \"thumbnail_path\": rel_thumb,  # 存储相对路径（跨平台兼容）\n   132→            \"parameters\": parameters,\n   133→            \"metadata\": metadata,\n   134→            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n   135→        }\n   136→        try:\n   137→            self._repository_manager.add_content(record_id, content_type, repo_data)\n   138→        except Exception as exc:\n   139→            logger.error(f\"Failed to persist record to repository: {exc}\")\n   140→\n   141→    # ------------------------------------------------------------------ public\n   142→    def save_content_file(\n   143→        self,\n   144→        content_type: str,\n   145→        file_data: bytes,\n   146→        url: Optional[str] = None,\n   147→        metadata: Optional[Dict[str, Any]] = None,\n   148→    ) -> Dict[str, Any]:\n   149→        \"\"\"\n   150→        Save a generated content file (image/video) and persist metadata to SQLite.\n   151→        Returns a record dict containing local paths and identifiers.\n   152→        \"\"\"\n   153→        metadata = metadata or {}\n   154→        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n   155→\n   156→        file_id = str(metadata.get(\"generation_id\") or metadata.get(\"file_id\") or uuid.uuid4().hex)\n   157→        ext = self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n   158→        filename = f\"{file_id}{ext}\"\n   159→        target_dir = self.images_dir if ctype == \"images\" else self.videos_dir\n   160→        target_path = target_dir / filename\n   161→\n   162→        self._save_file(target_path, file_data)\n   163→\n   164→        thumbnail_path: Optional[Path] = None\n   165→        if ctype == \"images\":\n   166→            thumbnail_path = self._make_image_thumbnail(file_data, file_id, ext)\n   167→            try:\n   168→                with Image.open(io.BytesIO(file_data)) as img:\n   169→                    metadata.setdefault(\"width\", img.width)\n   170→                    metadata.setdefault(\"height\", img.height)\n   171→            except Exception as exc:\n   172→                logger.debug(f\"Failed to inspect image size: {exc}\")\n   173→\n   174→        rel_path = str(target_path.relative_to(self.root_path))\n   175→        rel_thumb = str(thumbnail_path.relative_to(self.root_path)) if thumbnail_path else None\n   176→\n   177→        parameters = metadata.get(\"parameters\") or {}\n   178→        # ensure prompt/model at top-level for repository\n   179→        prompt = metadata.get(\"prompt\") or parameters.get(\"prompt\")\n   180→        model = metadata.get(\"model\") or parameters.get(\"model\")\n   181→\n   182→        self._persist_record(\n   183→            record_id=file_id,\n   184→            content_type=ctype,\n   185→            file_path=target_path,\n   186→            relative_path=rel_path,\n   187→            thumbnail_path=thumbnail_path,\n   188→            prompt=prompt,\n   189→            model=model,\n   190→            parameters=parameters if isinstance(parameters, dict) else {},\n   191→            metadata=metadata if isinstance(metadata, dict) else {},\n   192→            status=str(metadata.get(\"status\") or \"completed\"),\n   193→        )\n   194→\n   195→        return {\n   196→            \"file_id\": file_id,\n   197→            \"local_path\": str(target_path),\n   198→            \"relative_path\": rel_path,\n   199→            \"thumbnail_path\": str(thumbnail_path) if thumbnail_path else None,\n   200→            \"content_type\": ctype,\n   201→            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n   202→            \"status\": metadata.get(\"status\") or \"completed\",\n   203→        }\n   204→\n   205→    def save_reference_asset(\n   206→        self,\n   207→        content_type: str,\n   208→        file_data: bytes,\n   209→        url: Optional[str] = None,\n   210→        metadata: Optional[Dict[str, Any]] = None,\n   211→        *,\n   212→        asset_id: Optional[str] = None,\n   213→        extension: Optional[str] = None,\n   214→    ) -> Dict[str, Any]:\n   215→        \"\"\"\n   216→        Save a reference asset (image/video). Does not persist to repository table by default.\n   217→        Accepts optional asset_id/extension for callers that pre-generate IDs.\n   218→        \"\"\"\n   219→        metadata = metadata or {}\n   220→        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n   221→\n   222→        ref_id = str(asset_id or metadata.get(\"reference_id\") or uuid.uuid4().hex)\n   223→        ext = extension or self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n   224→        filename = f\"{ref_id}{ext}\"\n   225→        target_dir = self.references_images_dir if ctype == \"images\" else self.references_videos_dir\n   226→        target_path = target_dir / filename\n   227→\n   228→        self._save_file(target_path, file_data)\n   229→\n   230→        width: Optional[int] = metadata.get(\"width\")\n   231→        height: Optional[int] = metadata.get(\"height\")\n   232→        thumbnail_path: Optional[Path] = None\n   233→        if ctype == \"images\":\n   234→            try:\n   235→                with Image.open(io.BytesIO(file_data)) as img:\n   236→                    width = width or img.width\n   237→                    height = height or img.height\n   238→            except Exception as exc:\n   239→                logger.warning(f\"Failed to inspect reference image size: {exc}\")\n   240→            thumbnail_path = self._make_image_thumbnail(file_data, ref_id, ext)\n   241→\n   242→        rel_path = str(target_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\")\n   243→        rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\") if thumbnail_path else None\n   244→        record = {\n   245→            \"id\": ref_id,\n   246→            \"reference_id\": ref_id,\n   247→            \"path\": rel_path,\n   248→            \"relative_path\": rel_path,\n   249→            \"absolute_path\": str(target_path),\n   250→            \"content_type\": ctype,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b7686380-0a6e-43af-9e5b-e63123a7a326","timestamp":"2025-12-13T13:23:06.896Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nUnified storage manager (V2) - SQLite-backed implementation.\n\nResponsibilities:\n- Manage root_path and subdirectories (images, videos, references, thumbnails, metadata, repository).\n- Persist generation records into SQLite (repository/gemeng.db) for history views.\n- Save content files and reference assets; generate image thumbnails (up to 1080p, no upscale).\n- Provide history loading and basic storage stats.\n\nNotes:\n- Video thumbnail generation is skipped (ffmpeg unavailable by default); placeholder None is returned.\n- Interfaces kept compatible with existing callers (save_content_file, save_reference_asset, load_history, get_storage_stats).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport uuid\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom loguru import logger\nfrom PIL import Image\n\n\ndef _now_iso() -> str:\n    return datetime.utcnow().isoformat()\n\n\nclass UnifiedStorageManagerV2:\n    def __init__(self, base_path: str):\n        from modules.repository.manager import RepositoryManager  # lazy import to avoid circular init in frozen mode\n        self.root_path = Path(base_path).expanduser().resolve()\n        self.root_path.mkdir(parents=True, exist_ok=True)\n\n        # Directory layout\n        self.images_dir = self.root_path / \"images\"\n        self.videos_dir = self.root_path / \"videos\"\n        self.references_images_dir = self.root_path / \"references\" / \"images\"\n        self.references_videos_dir = self.root_path / \"references\" / \"videos\"\n        self.thumbnails_images_dir = self.root_path / \"thumbnails\" / \"images\"\n        self.thumbnails_videos_dir = self.root_path / \"thumbnails\" / \"videos\"\n        self.metadata_dir = self.root_path / \"metadata\"\n        self.repository_dir = self.root_path / \"repository\"\n\n        for d in [\n            self.images_dir,\n            self.videos_dir,\n            self.references_images_dir,\n            self.references_videos_dir,\n            self.thumbnails_images_dir,\n            self.thumbnails_videos_dir,\n            self.metadata_dir,\n            self.repository_dir,\n        ]:\n            d.mkdir(parents=True, exist_ok=True)\n\n        # SQLite-backed repository manager\n        self._repository_manager = RepositoryManager(self.root_path)\n\n    # ------------------------------------------------------------------ helpers\n    @staticmethod\n    def _guess_ext(url: Optional[str], default: str) -> str:\n        if not url:\n            return default\n        lowered = url.lower()\n        for ext in (\".png\", \".jpg\", \".jpeg\", \".webp\", \".mp4\", \".mov\", \".avi\"):\n            if lowered.endswith(ext):\n                return ext\n        return default\n\n    def _save_file(self, target_path: Path, data: bytes) -> None:\n        target_path.parent.mkdir(parents=True, exist_ok=True)\n        target_path.write_bytes(data)\n\n    def _make_image_thumbnail(self, src_bytes: bytes, file_id: str, ext: str) -> Optional[Path]:\n        try:\n            with Image.open(io.BytesIO(src_bytes)) as img:\n                img = img.convert(\"RGB\")\n                # Maintain clarity: cap longest side at 1080px, do not upscale if smaller\n                max_side = 1080\n                w, h = img.size\n                if max(w, h) > max_side:\n                    img.thumbnail((max_side, max_side), Image.LANCZOS)\n                thumb_name = f\"{file_id}_thumb.jpg\"\n                thumb_path = self.thumbnails_images_dir / thumb_name\n                thumb_path.parent.mkdir(parents=True, exist_ok=True)\n                img.save(thumb_path, format=\"JPEG\", quality=92)\n                return thumb_path\n        except Exception as exc:\n            logger.warning(f\"Failed to generate image thumbnail: {exc}\")\n            return None\n        return None\n\n    def _persist_record(\n        self,\n        record_id: str,\n        content_type: str,\n        file_path: Path,\n        relative_path: str,\n        thumbnail_path: Optional[Path],\n        prompt: Optional[str],\n        model: Optional[str],\n        parameters: Dict[str, Any],\n        metadata: Dict[str, Any],\n        status: str = \"completed\",\n    ) -> None:\n        # 计算缩略图的相对路径\n        rel_thumb = None\n        if thumbnail_path:\n            try:\n                rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace('\\\\', '/')\n            except ValueError:\n                # 如果无法计算相对路径，使用文件名\n                rel_thumb = f\"thumbnails/{thumbnail_path.name}\"\n\n        # 统一使用正斜杠，确保跨平台兼容\n        rel_path_normalized = relative_path.replace('\\\\', '/') if relative_path else None\n\n        repo_data = {\n            \"file_id\": record_id,\n            \"generation_id\": parameters.get(\"generation_id\") or metadata.get(\"generation_id\") or record_id,\n            \"prompt\": prompt,\n            \"model\": model,\n            \"status\": status,\n            \"file_path\": rel_path_normalized,  # 存储相对路径（跨平台兼容）\n            \"relative_path\": rel_path_normalized,\n            \"thumbnail_path\": rel_thumb,  # 存储相对路径（跨平台兼容）\n            \"parameters\": parameters,\n            \"metadata\": metadata,\n            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n        }\n        try:\n            self._repository_manager.add_content(record_id, content_type, repo_data)\n        except Exception as exc:\n            logger.error(f\"Failed to persist record to repository: {exc}\")\n\n    # ------------------------------------------------------------------ public\n    def save_content_file(\n        self,\n        content_type: str,\n        file_data: bytes,\n        url: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Save a generated content file (image/video) and persist metadata to SQLite.\n        Returns a record dict containing local paths and identifiers.\n        \"\"\"\n        metadata = metadata or {}\n        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n\n        file_id = str(metadata.get(\"generation_id\") or metadata.get(\"file_id\") or uuid.uuid4().hex)\n        ext = self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n        filename = f\"{file_id}{ext}\"\n        target_dir = self.images_dir if ctype == \"images\" else self.videos_dir\n        target_path = target_dir / filename\n\n        self._save_file(target_path, file_data)\n\n        thumbnail_path: Optional[Path] = None\n        if ctype == \"images\":\n            thumbnail_path = self._make_image_thumbnail(file_data, file_id, ext)\n            try:\n                with Image.open(io.BytesIO(file_data)) as img:\n                    metadata.setdefault(\"width\", img.width)\n                    metadata.setdefault(\"height\", img.height)\n            except Exception as exc:\n                logger.debug(f\"Failed to inspect image size: {exc}\")\n\n        rel_path = str(target_path.relative_to(self.root_path))\n        rel_thumb = str(thumbnail_path.relative_to(self.root_path)) if thumbnail_path else None\n\n        parameters = metadata.get(\"parameters\") or {}\n        # ensure prompt/model at top-level for repository\n        prompt = metadata.get(\"prompt\") or parameters.get(\"prompt\")\n        model = metadata.get(\"model\") or parameters.get(\"model\")\n\n        self._persist_record(\n            record_id=file_id,\n            content_type=ctype,\n            file_path=target_path,\n            relative_path=rel_path,\n            thumbnail_path=thumbnail_path,\n            prompt=prompt,\n            model=model,\n            parameters=parameters if isinstance(parameters, dict) else {},\n            metadata=metadata if isinstance(metadata, dict) else {},\n            status=str(metadata.get(\"status\") or \"completed\"),\n        )\n\n        return {\n            \"file_id\": file_id,\n            \"local_path\": str(target_path),\n            \"relative_path\": rel_path,\n            \"thumbnail_path\": str(thumbnail_path) if thumbnail_path else None,\n            \"content_type\": ctype,\n            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n            \"status\": metadata.get(\"status\") or \"completed\",\n        }\n\n    def save_reference_asset(\n        self,\n        content_type: str,\n        file_data: bytes,\n        url: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        *,\n        asset_id: Optional[str] = None,\n        extension: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Save a reference asset (image/video). Does not persist to repository table by default.\n        Accepts optional asset_id/extension for callers that pre-generate IDs.\n        \"\"\"\n        metadata = metadata or {}\n        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n\n        ref_id = str(asset_id or metadata.get(\"reference_id\") or uuid.uuid4().hex)\n        ext = extension or self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n        filename = f\"{ref_id}{ext}\"\n        target_dir = self.references_images_dir if ctype == \"images\" else self.references_videos_dir\n        target_path = target_dir / filename\n\n        self._save_file(target_path, file_data)\n\n        width: Optional[int] = metadata.get(\"width\")\n        height: Optional[int] = metadata.get(\"height\")\n        thumbnail_path: Optional[Path] = None\n        if ctype == \"images\":\n            try:\n                with Image.open(io.BytesIO(file_data)) as img:\n                    width = width or img.width\n                    height = height or img.height\n            except Exception as exc:\n                logger.warning(f\"Failed to inspect reference image size: {exc}\")\n            thumbnail_path = self._make_image_thumbnail(file_data, ref_id, ext)\n\n        rel_path = str(target_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\")\n        rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\") if thumbnail_path else None\n        record = {\n            \"id\": ref_id,\n            \"reference_id\": ref_id,\n            \"path\": rel_path,\n            \"relative_path\": rel_path,\n            \"absolute_path\": str(target_path),\n            \"content_type\": ctype,","numLines":250,"startLine":1,"totalLines":297}}}
{"parentUuid":"b7686380-0a6e-43af-9e5b-e63123a7a326","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"03f7f2d0-b1b2-4f2c-af62-3102a2a50e1c","version":"2.0.69","gitBranch":"main","agentId":"a6f714f","slug":"groovy-launching-raccoon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013wYbg1Krk6vNxGYY1WRMwx","type":"message","role":"assistant","content":[{"type":"text","text":"现在我有足够的信息了。让我生成详细的分析报告。\n\n## 详细分析报告：参考图共享机制与删除逻辑\n\n### 1. 参考图 ID 生成逻辑\n\n**文件位置：** `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py`（第1081-1084行）\n\n```python\ndef _generate_reference_asset_id(self, file_data: bytes) -> str:\n    checksum = hashlib.sha1(file_data).hexdigest()\n    ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n    return f\"ref_{ts}_{checksum[:8]}\"\n```\n\n**关键发现：**\n- **参考图 ID = `ref_{时间戳}_{SHA1校验码前8位}`**\n- 包含**时间戳**（微秒精度），每次生成都不同\n- 校验码仅用于内部识别，**不用于去重**\n\n**风险：** 同一张图片多次使用会创建**独立副本**，而非共享同一文件\n\n---\n\n### 2. 参考图文件存储\n\n**文件位置：** `/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py`（第205-263行）\n\n```python\ndef save_reference_asset(self, content_type, file_data, url=None, metadata=None, \n                        *, asset_id=None, extension=None) -> Dict[str, Any]:\n    # 第222行\n    ref_id = str(asset_id or metadata.get(\"reference_id\") or uuid.uuid4().hex)\n    # 第224-226行\n    filename = f\"{ref_id}{ext}\"\n    target_dir = self.references_images_dir if ctype == \"images\" else self.references_videos_dir\n    target_path = target_dir / filename\n    # 第228行：直接保存文件\n    self._save_file(target_path, file_data)\n```\n\n**关键发现：**\n- 参考图存储在 `storage_root/references/images/` 或 `storage_root/references/videos/`\n- **每个参考图都以独立文件形式保存**，使用唯一 ID 作为文件名\n- **没有去重机制**：同一图片使用多次 → 多份副本占用空间\n\n**存储结构示例：**\n```\nstorage/\n├── references/\n│   └── images/\n│       ├── ref_20251213210301234567_a1b2c3d4.png  (记录A)\n│       ├── ref_20251213210302345678_a1b2c3d4.png  (记录B，同一图片)\n│       └── ref_20251213210303456789_different.png (记录C，不同图片)\n├── images/\n│   ├── generation_a.png\n│   ├── generation_b.png\n│   └── generation_c.png\n```\n\n---\n\n### 3. 数据库参考图关系设计\n\n**文件位置：** `/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py`（第40-73行）\n\n```sql\nCREATE TABLE IF NOT EXISTS reference_assets (\n    id TEXT PRIMARY KEY,\n    generation_id TEXT NOT NULL,\n    asset_path TEXT,\n    relative_path TEXT,\n    asset_type TEXT,\n    order_index INTEGER DEFAULT 0,\n    metadata TEXT,\n    FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n);\n```\n\n**关键发现：**\n- **外键约束：** `ON DELETE CASCADE` — 删除记录时自动删除关联的参考图\n- **primary key 是 `id`（参考图本身的ID）**，非 generation_id\n- **无法直接查询：\"某个参考图被多少个记录引用\"**\n- **没有引用计数机制**\n\n**外键逻辑：**\n```\ngeneration 表\n    ↓ (1:N)\nreference_assets 表 (generation_id FK)\n    → 删除 generation 记录 → 自动删除对应 reference_assets 行\n```\n\n---\n\n### 4. 删除记录逻辑（`delete_record_with_files`）\n\n**文件位置：** `/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py`（第430-500行）\n\n```python\ndef delete_record_with_files(self, record_id: str) -> bool:\n    # 第443-447行：获取记录\n    record = self.get_record_by_id(record_id)\n    if not record:\n        logger.warning(f\"删除记录: 未找到记录 {record_id}\")\n        return False\n    \n    # 第449-477行：收集需要删除的文件\n    files_to_delete = []\n    \n    # 主文件\n    file_path = record.get('absolute_path') or record.get('file_path')\n    if file_path:\n        files_to_delete.append(file_path)\n    \n    # 缩略图\n    thumb_path = record.get('thumbnail_local_path')\n    if thumb_path:\n        files_to_delete.append(thumb_path)\n    \n    # 参考图 - 关键部分\n    ref_info = record.get('_reference_info') or {}\n    ref_assets = ref_info.get('assets', [])\n    if not ref_assets:\n        params = record.get('parameters') or {}\n        ref_assets = params.get('reference_assets', [])\n    \n    for ref in ref_assets:\n        if isinstance(ref, dict):\n            ref_path = ref.get('absolute_path') or ref.get('path')\n            if ref_path and str(ref_path) not in [str(f) for f in files_to_delete]:\n                if not Path(ref_path).is_absolute():\n                    ref_path = str(self.storage_root / ref_path)\n                files_to_delete.append(ref_path)\n    \n    # 第479-482行：删除数据库记录\n    if not self.delete_record(record_id):\n        logger.error(f\"删除记录失败: 数据库删除失败 {record_id}\")\n        return False\n    \n    # 第484-494行：删除文件（忽略不存在的文件）\n    deleted_files = []\n    for path in files_to_delete:\n        try:\n            if path and Path(path).exists():\n                Path(path).unlink()  # 直接删除！\n                deleted_files.append(path)\n                logger.debug(f\"已删除文件: {path}\")\n        except Exception as e:\n            logger.warning(f\"删除文件失败: {path}, {e}\")\n    \n    logger.info(f\"删除记录完成: {record_id}, 删除了 {len(deleted_files)} 个文件\")\n    return True\n```\n\n**核心流程：**\n1. 获取记录及其参考图列表\n2. 删除数据库记录（SQLite cascade 删除 reference_assets 行）\n3. **直接删除磁盘文件**（无共享检查）\n\n---\n\n### 5. 共享风险分析\n\n**风险场景 1：参考图被多记录引用**\n\n```\n场景：用户选择同一张参考图生成 2 张图片\n↓\nRecord A (generation_a)\n    ├── reference_assets: [ref_20251213_a1b2c3d4.png]\n    \nRecord B (generation_b)\n    ├── reference_assets: [ref_20251213_a1b2c3d4.png]  ← 同一 ID\n\n问题：\n- 删除 Record A 时，会删除磁盘文件 ref_20251213_a1b2c3d4.png\n- Record B 的参考图引用变成死链（文件不存在）\n```\n\n**实际情况：**\n根据代码分析，**不会出现同ID共享的情况**，因为：\n- 每次调用 `_generate_reference_asset_id()` 都产生**不同的ID**（包含时间戳）\n- 即使图片内容完全相同，也会分别保存为：\n  - `ref_20251213_a1b2c3d4.png` (Record A)\n  - `ref_20251213_a1b2c3d5.png` (Record B)\n\n**风险场景 2：独立副本导致的存储浪费**\n\n```\n用户 10 次使用同一参考图：\n├── 占用磁盘空间：10 × (图片大小)\n├── 数据库行数：10 × (reference_assets 表)\n└── 删除时：每个记录独立删除，无影响\n\n优点：删除简单（无去重复杂度）\n缺点：存储浪费（无法检测重复）\n```\n\n---\n\n### 6. 数据库外键约束验证\n\n**SQLite 配置（第34行）：**\n```python\nself.connection.execute(\"PRAGMA foreign_keys = ON;\")\n```\n\n**验证过程：**\n- ✓ 外键约束已启用\n- ✓ `reference_assets.generation_id` → `generations.id` 有 FK\n- ✓ 删除 generation 时自动删除关联的 reference_assets 记录\n- ✗ 但**磁盘文件不会自动删除**（FK 只作用于数据库）\n\n---\n\n### 7. 当前实现的完整流程\n\n```\n生成记录时：\n1. SeedreamManager._process_reference_assets()\n   → _generate_reference_asset_id()  生成唯一 ID（含时间戳）\n   → storage_manager.save_reference_asset()  保存文件\n   → reference_assets 表插入记录\n\n删除记录时：\n1. RepositoryManager.delete_record_with_files()\n   → get_record_by_id()  获取参考图列表\n   → sqlite DELETE  删除 generation 和级联 reference_assets\n   → Path.unlink()  删除磁盘文件（无共享检查）\n```\n\n---\n\n### 8. 潜在问题总结\n\n| 问题 | 严重程度 | 说明 |\n|------|--------|------|\n| **无参考图去重** | 中 | 同一图片多用 → 浪费存储空间 |\n| **无引用计数** | 中 | 无法查询\"参考图被几个记录使用\" |\n| **删除时无共享检查** | 低 | 因为实际不存在 ID 共享，所以无风险 |\n| **磁盘和数据库不同步** | 低 | FK 级联只删数据库，但代码手动删文件 |\n| **参考图孤立可能** | 低 | 如果文件删除失败，记录仍被清除 |\n\n---\n\n## 建议\n\n1. **如需去重**：在 `_generate_reference_asset_id()` 中使用纯校验码：\n   ```python\n   return f\"ref_{checksum[:8]}\"  # 相同图片 → 相同 ID\n   ```\n   然后在 `save_reference_asset()` 中检查文件是否已存在\n\n2. **查询共享情况**：添加方法\n   ```sql\n   SELECT asset_id, COUNT(*) as usage_count\n   FROM reference_assets\n   GROUP BY asset_id\n   HAVING usage_count > 1;\n   ```\n\n3. **安全删除**：在删除文件前检查是否被其他记录使用\n\n---\n\n**最终结论：当前实现下，参考图不存在共享风险，但存在存储浪费的可能性。删除逻辑安全，因为每个参考图有唯一 ID。**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4104,"cache_read_input_tokens":74452,"cache_creation":{"ephemeral_5m_input_tokens":4104,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e87041b7-cd28-43f9-a9c3-3ff11d3d1eba","timestamp":"2025-12-13T13:23:34.231Z"}
