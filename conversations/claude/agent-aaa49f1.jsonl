{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":"探索这个项目中参考图（reference image）的处理流程：\n\n1. 查找参考图相关的代码，特别是：\n   - 参考图如何被选择/上传\n   - 参考图如何被发送到 API\n   - 是否有任何图片处理/转换逻辑\n\n2. 查找火山引擎 API 调用相关代码，看看：\n   - 图片是如何编码发送的（base64？）\n   - 有没有现有的图片大小检查或处理\n\n3. 查找任何与图片压缩、格式转换相关的现有代码\n\n重点关注 modules/seedream/ 和 modules/seedance/ 目录"},"uuid":"c6733776-5f9e-4f06-abcf-98606dc42ef6","timestamp":"2026-01-08T08:39:15.033Z"}
{"parentUuid":"c6733776-5f9e-4f06-abcf-98606dc42ef6","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TJ22mHBXrHYShj59x1RV14","type":"message","role":"assistant","content":[{"type":"text","text":"I'll help you explore the reference image handling flow in this project. Let me search systematically through the codebase."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20354,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20354,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"048b49a3-4958-424e-9389-1c0d0865b139","timestamp":"2026-01-08T08:39:17.213Z"}
{"parentUuid":"048b49a3-4958-424e-9389-1c0d0865b139","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TJ22mHBXrHYShj59x1RV14","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NdKZqZqLCkMfaNPpC6dsGi","name":"Glob","input":{"pattern":"**/*seedream* **/*seedance*","path":"/Users/yunchang/Documents/GitHub/gemeng2"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20354,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20354,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a34b7486-4c46-4f54-8135-81ea0fdaab56","timestamp":"2026-01-08T08:39:17.768Z"}
{"parentUuid":"a34b7486-4c46-4f54-8135-81ea0fdaab56","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TJ22mHBXrHYShj59x1RV14","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y2yKD1aRtdpLLhkL78KvhP","name":"Glob","input":{"pattern":"**/*reference* **/*image*","path":"/Users/yunchang/Documents/GitHub/gemeng2"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20354,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20354,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"52751e9c-bf4c-4045-a9d8-7e3f247f1bb2","timestamp":"2026-01-08T08:39:18.173Z"}
{"parentUuid":"52751e9c-bf4c-4045-a9d8-7e3f247f1bb2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TJ22mHBXrHYShj59x1RV14","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QDFNjK9mmZTs8eVHqapQc7","name":"Grep","input":{"pattern":"reference_image|ref_image|reference","path":"/Users/yunchang/Documents/GitHub/gemeng2","type":"py","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20354,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20354,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"82e30ec0-1b0d-43fe-a61f-65d31d4bfd13","timestamp":"2026-01-08T08:39:18.773Z"}
{"parentUuid":"82e30ec0-1b0d-43fe-a61f-65d31d4bfd13","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QDFNjK9mmZTs8eVHqapQc7","type":"tool_result","content":"Found 76 files\ncomponents/dialogs/video_detail_dialog.py\ncomponents/modes/shared/video/mode_widget_impl.py\ncomponents/models/video_history_model.py\ncomponents/models/image_history_model.py\nmodules/repository/manager.py\ncomponents/modes/shared/image/mode_widget_impl.py\nutils/reference_display.py\nmodules/provider/schema.py\ncomponents/widgets/reference_assets_panel.py\ncomponents/widgets/video_image_upload_panel.py\ntools/rebuild_asset_index.py\nversion.py\nmodules/storage/unified_storage_manager_v2.py\nmodules/seedream/manager.py\ncomponents/widgets/integrated_reference_panel.py\ncomponents/modes/shared/video/parameter_logic.py\ncomponents/modes/shared/image/parameter_logic.py\ncomponents/creation_components.py\nutils/reference_assets.py\ntools/quick_test_reference.py\ntools/phase5/verify_phase5.py\ntools/phase4/verify_phase4.py\ntools/fix_reference_display_logic.py\ntools/diagnose_video_reference_storage.py\ntools/diagnose_reference_display_issue.py\nscripts/run_seedance_watermark_test2.py\nscripts/run_seedance_watermark_test.py\nmodules/seedream/client.py\nmodules/seedance/manager.py\nmodules/repository/sqlite_handler.py\ncomponents/modes/shared/video/generation_logic.py\ncomponents/modes/shared/image/generation_logic.py\ncomponents/modes/shared/controllers/parameter_controller.py\ncomponents/dialogs/image_detail_dialog.py\nmodules/seedance/client.py\nutils/style_system.py\nservices/video_service.py\nmodules/provider/volc.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/creation_components.py\ncomponents/reference_assets/gallery.py\ntools/csv_to_sqlite_migration.py\nthreads/image_generation_thread.py\ncomponents/reference_assets/actions.py\ncomponents/reference_assets/__init__.py\ncomponents/delegates/video_card_delegate.py\ncomponents/delegates/image_card_delegate.py\ncomponents/adapters/reference_adapter.py\ncomponents/widgets/__init__.py\nmodules/provider/volc_v4_5.py\nservices/image_service.py\nmodules/provider/volc_v4.py\nutils/image_format_validator.py\ntools/system_diagnosis.py\ntools/performance_benchmark.py\ntools/memory_leak_detector.py\ntools/final_fixes_summary.py\ntools/diagnose_visibility_rules.py\ntools/diagnose_video_reference_panel.py\ntools/diagnose_reference_display.py\ntools/diagnose_detail_dialog_issue.py\nmodules/repository/csv_handler.py\nconfig/project_manager.py\ncomponents/adapters/__init__.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/video_card_delegate.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/image_card_delegate.py\n.style_backup/qt_app.py\n.style_backup/components/widgets/reference_assets_panel.py\n.style_backup/components/views/history_view_optimized.py\n.style_backup/components/generation/image_mode_widget.py\n.style_backup/components/delegates/video_card_delegate.py\n.style_backup/components/delegates/image_card_delegate.py\n.style_backup/components/creation_components.py\n.style_backup/components/cards/video_card.py\n.style_backup/components/cards/image_card.py"}]},"uuid":"f8f56ea4-3b90-4d05-aad2-6ad2ff924d6a","timestamp":"2026-01-08T08:39:18.871Z","toolUseResult":{"mode":"files_with_matches","filenames":["components/dialogs/video_detail_dialog.py","components/modes/shared/video/mode_widget_impl.py","components/models/video_history_model.py","components/models/image_history_model.py","modules/repository/manager.py","components/modes/shared/image/mode_widget_impl.py","utils/reference_display.py","modules/provider/schema.py","components/widgets/reference_assets_panel.py","components/widgets/video_image_upload_panel.py","tools/rebuild_asset_index.py","version.py","modules/storage/unified_storage_manager_v2.py","modules/seedream/manager.py","components/widgets/integrated_reference_panel.py","components/modes/shared/video/parameter_logic.py","components/modes/shared/image/parameter_logic.py","components/creation_components.py","utils/reference_assets.py","tools/quick_test_reference.py","tools/phase5/verify_phase5.py","tools/phase4/verify_phase4.py","tools/fix_reference_display_logic.py","tools/diagnose_video_reference_storage.py","tools/diagnose_reference_display_issue.py","scripts/run_seedance_watermark_test2.py","scripts/run_seedance_watermark_test.py","modules/seedream/client.py","modules/seedance/manager.py","modules/repository/sqlite_handler.py","components/modes/shared/video/generation_logic.py","components/modes/shared/image/generation_logic.py","components/modes/shared/controllers/parameter_controller.py","components/dialogs/image_detail_dialog.py","modules/seedance/client.py","utils/style_system.py","services/video_service.py","modules/provider/volc.py",".style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py",".style_backup/备份（界面正确版）/鸽梦 9.24/components/creation_components.py","components/reference_assets/gallery.py","tools/csv_to_sqlite_migration.py","threads/image_generation_thread.py","components/reference_assets/actions.py","components/reference_assets/__init__.py","components/delegates/video_card_delegate.py","components/delegates/image_card_delegate.py","components/adapters/reference_adapter.py","components/widgets/__init__.py","modules/provider/volc_v4_5.py","services/image_service.py","modules/provider/volc_v4.py","utils/image_format_validator.py","tools/system_diagnosis.py","tools/performance_benchmark.py","tools/memory_leak_detector.py","tools/final_fixes_summary.py","tools/diagnose_visibility_rules.py","tools/diagnose_video_reference_panel.py","tools/diagnose_reference_display.py","tools/diagnose_detail_dialog_issue.py","modules/repository/csv_handler.py","config/project_manager.py","components/adapters/__init__.py",".style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py",".style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/video_card_delegate.py",".style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/image_card_delegate.py",".style_backup/qt_app.py",".style_backup/components/widgets/reference_assets_panel.py",".style_backup/components/views/history_view_optimized.py",".style_backup/components/generation/image_mode_widget.py",".style_backup/components/delegates/video_card_delegate.py",".style_backup/components/delegates/image_card_delegate.py",".style_backup/components/creation_components.py",".style_backup/components/cards/video_card.py",".style_backup/components/cards/image_card.py"],"numFiles":76},"sourceToolAssistantUUID":"82e30ec0-1b0d-43fe-a61f-65d31d4bfd13"}
{"parentUuid":"a34b7486-4c46-4f54-8135-81ea0fdaab56","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NdKZqZqLCkMfaNPpC6dsGi","type":"tool_result","content":"No files found"}]},"uuid":"57223429-a049-4843-9d50-f6298e2872c3","timestamp":"2026-01-08T08:39:18.889Z","toolUseResult":{"filenames":[],"durationMs":49,"numFiles":0,"truncated":false},"sourceToolAssistantUUID":"a34b7486-4c46-4f54-8135-81ea0fdaab56"}
{"parentUuid":"52751e9c-bf4c-4045-a9d8-7e3f247f1bb2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y2yKD1aRtdpLLhkL78KvhP","type":"tool_result","content":"No files found"}]},"uuid":"ed8b136a-1570-4278-aed3-4f4d66435947","timestamp":"2026-01-08T08:39:18.889Z","toolUseResult":{"filenames":[],"durationMs":50,"numFiles":0,"truncated":false},"sourceToolAssistantUUID":"52751e9c-bf4c-4045-a9d8-7e3f247f1bb2"}
{"parentUuid":"ed8b136a-1570-4278-aed3-4f4d66435947","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019XdWLBN9WnoGhJpCbUFkre","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me search for the key files related to reference image handling:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1032,"cache_creation_input_tokens":646,"cache_read_input_tokens":20354,"cache_creation":{"ephemeral_5m_input_tokens":646,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"edd331c3-8306-4cb3-8e11-2d80bb763ca5","timestamp":"2026-01-08T08:39:20.877Z"}
{"parentUuid":"edd331c3-8306-4cb3-8e11-2d80bb763ca5","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019XdWLBN9WnoGhJpCbUFkre","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PSLGhH5R8dYN7YRmSgRGaT","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1032,"cache_creation_input_tokens":646,"cache_read_input_tokens":20354,"cache_creation":{"ephemeral_5m_input_tokens":646,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"545cae47-36ce-4eaa-a508-dff639c69221","timestamp":"2026-01-08T08:39:21.451Z"}
{"parentUuid":"545cae47-36ce-4eaa-a508-dff639c69221","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019XdWLBN9WnoGhJpCbUFkre","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012goiBaUJ5cPmKeKhbEFL5i","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1032,"cache_creation_input_tokens":646,"cache_read_input_tokens":20354,"cache_creation":{"ephemeral_5m_input_tokens":646,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"eac59ea2-7ae8-45a7-9dff-41f1119aacab","timestamp":"2026-01-08T08:39:21.577Z"}
{"parentUuid":"eac59ea2-7ae8-45a7-9dff-41f1119aacab","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019XdWLBN9WnoGhJpCbUFkre","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AcqK1D5tHNWkJPPzrN1huj","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/utils/reference_assets.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1032,"cache_creation_input_tokens":646,"cache_read_input_tokens":20354,"cache_creation":{"ephemeral_5m_input_tokens":646,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"ac7deed0-e79b-4e7e-8d3a-8aa05b35be6b","timestamp":"2026-01-08T08:39:21.804Z"}
{"parentUuid":"ac7deed0-e79b-4e7e-8d3a-8aa05b35be6b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019XdWLBN9WnoGhJpCbUFkre","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HLbHsL1EkNVijAA217nS4d","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/reference_assets_panel.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1032,"cache_creation_input_tokens":646,"cache_read_input_tokens":20354,"cache_creation":{"ephemeral_5m_input_tokens":646,"ephemeral_1h_input_tokens":0},"output_tokens":268,"service_tier":"standard"}},"type":"assistant","uuid":"177b5837-a338-486c-babb-e6db74050007","timestamp":"2026-01-08T08:39:22.136Z"}
{"parentUuid":"ac7deed0-e79b-4e7e-8d3a-8aa05b35be6b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AcqK1D5tHNWkJPPzrN1huj","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"Utility helpers for handling reference assets metadata.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import json\n     8→import os\n     9→from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple\n    10→\n    11→__all__ = [\n    12→    \"collect_reference_assets\",\n    13→    \"summarize_reference_assets\",\n    14→    \"resolve_asset_path\",\n    15→]\n    16→\n    17→\n    18→def resolve_asset_path(asset: Dict[str, Any]) -> Optional[str]:\n    19→    \"\"\"\n    20→    统一解析参考图资产的文件路径。\n    21→\n    22→    优先级：file_path > absolute_path > path > relative_path\n    23→    自动处理相对路径，返回绝对路径。\n    24→\n    25→    Args:\n    26→        asset: 参考图数据字典\n    27→\n    28→    Returns:\n    29→        解析后的文件路径，或 None 如果路径无效/不存在\n    30→    \"\"\"\n    31→    if not isinstance(asset, dict):\n    32→        return None\n    33→\n    34→    path = (\n    35→        asset.get('file_path') or\n    36→        asset.get('absolute_path') or\n    37→        asset.get('path') or\n    38→        asset.get('relative_path')\n    39→    )\n    40→\n    41→    if not path:\n    42→        return None\n    43→\n    44→    path = str(path)\n    45→\n    46→    # 如果是相对路径，拼接存储目录\n    47→    if not os.path.isabs(path):\n    48→        try:\n    49→            from config import get_storage_dir\n    50→            storage_root = get_storage_dir()\n    51→            if storage_root:\n    52→                path = os.path.join(storage_root, path)\n    53→        except Exception:\n    54→            pass\n    55→\n    56→    return path if os.path.exists(path) else None\n    57→\n    58→\n    59→def _ensure_dict(value: Any) -> Dict[str, Any]:\n    60→    if isinstance(value, dict):\n    61→        return value\n    62→    if isinstance(value, str):\n    63→        try:\n    64→            parsed = json.loads(value)\n    65→            if isinstance(parsed, dict):\n    66→                return parsed\n    67→        except json.JSONDecodeError:\n    68→            return {}\n    69→    return {}\n    70→\n    71→\n    72→def _ensure_sequence(value: Any) -> Sequence[Any]:\n    73→    if isinstance(value, (list, tuple)):\n    74→        return value  # type: ignore[return-value]\n    75→    return []\n    76→\n    77→\n    78→def _normalize_asset(item: Any, index: int) -> Dict[str, Any] | None:\n    79→    if not isinstance(item, dict):\n    80→        return None\n    81→\n    82→    normalized: Dict[str, Any] = {}\n    83→\n    84→    asset_id = item.get(\"id\")\n    85→    if asset_id not in (None, \"\"):\n    86→        normalized[\"id\"] = str(asset_id)\n    87→\n    88→    order_raw = item.get(\"order\")\n    89→    if isinstance(order_raw, (int, float)):\n    90→        order = int(order_raw)\n    91→    else:\n    92→        try:\n    93→            order = int(str(order_raw))\n    94→        except Exception:\n    95→            order = index\n    96→    if order < 0:\n    97→        order = index\n    98→    normalized[\"order\"] = order\n    99→\n   100→    kind = item.get(\"kind\") or item.get(\"type\")\n   101→    if isinstance(kind, str):\n   102→        kind = kind.strip()\n   103→        if kind:\n   104→            normalized[\"kind\"] = kind\n   105→    content_type = item.get(\"type\") or item.get(\"kind\")\n   106→    if isinstance(content_type, str):\n   107→        content_type = content_type.strip()\n   108→        if content_type:\n   109→            normalized[\"type\"] = content_type\n   110→\n   111→    for key in (\"path\", \"relative_path\", \"absolute_path\", \"checksum\", \"width\", \"height\", \"size\", \"source\"):\n   112→        value = item.get(key)\n   113→        if value not in (None, \"\"):\n   114→            normalized[key] = value\n   115→\n   116→    normalized[\"__source_index\"] = index\n   117→    return normalized\n   118→\n   119→\n   120→def collect_reference_assets(record: Dict[str, Any]) -> List[Dict[str, Any]]:\n   121→    \"\"\"Extract reference asset entries from a history record.\n   122→\n   123→    Preference order: `_resolved_reference_assets` -> `reference_assets` ->\n   124→    `parameters['reference_assets']`. Returned list is sorted by `order`\n   125→    (ascending) with stable fallback to original position. Returned dicts do\n   126→    not modify the original record.\n   127→    \"\"\"\n   128→\n   129→    if not isinstance(record, dict):\n   130→        return []\n   131→\n   132→    candidates: Iterable[Any]\n   133→    for key in (\"_resolved_reference_assets\", \"reference_assets\"):\n   134→        value = record.get(key)\n   135→        if value:\n   136→            candidates = _ensure_sequence(value)\n   137→            break\n   138→    else:\n   139→        params = record.get(\"parameters\")\n   140→        params_dict = _ensure_dict(params)\n   141→        candidates = _ensure_sequence(params_dict.get(\"reference_assets\"))\n   142→\n   143→    normalized: List[Tuple[int, int, Dict[str, Any]]] = []\n   144→    for idx, item in enumerate(candidates):\n   145→        normalized_item = _normalize_asset(item, idx)\n   146→        if normalized_item is None:\n   147→            continue\n   148→        order = normalized_item.get(\"order\", idx)\n   149→        source_idx = normalized_item.pop(\"__source_index\", idx)\n   150→        normalized.append((order, source_idx, normalized_item))\n   151→\n   152→    normalized.sort(key=lambda comp: (comp[0], comp[1]))\n   153→    return [entry[2] for entry in normalized]\n   154→\n   155→\n   156→def summarize_reference_assets(record: Dict[str, Any], *, max_preview: int = 5) -> Dict[str, Any]:\n   157→    \"\"\"Return a sanitized summary for UI usage.\n   158→\n   159→    Result structure:\n   160→        {\n   161→            'count': int,\n   162→            'summary': str,\n   163→            'labels': List[str],\n   164→            'assets': List[Dict[str, Any]],\n   165→        }\n   166→    \"\"\"\n   167→\n   168→    assets = collect_reference_assets(record)\n   169→    count = len(assets)\n   170→\n   171→    labels: List[str] = []\n   172→    for idx, asset in enumerate(assets):\n   173→        order = asset.get(\"order\")\n   174→        if isinstance(order, (int, float)):\n   175→            ordinal = int(order) + 1\n   176→        else:\n   177→            ordinal = idx + 1\n   178→        if ordinal < 1:\n   179→            ordinal = idx + 1\n   180→\n   181→        label = f\"#{ordinal:02d}\"\n   182→        kind = asset.get(\"kind\")\n   183→        if isinstance(kind, str) and kind.strip():\n   184→            label = f\"{label}({kind.strip()})\"\n   185→        labels.append(label)\n   186→\n   187→    if count:\n   188→        preview = \"、\".join(labels[:max_preview])\n   189→        summary = f\"参考图 {count} 张：{preview}\"\n   190→        if count > max_preview:\n   191→            summary += \"...\"\n   192→    else:\n   193→        summary = \"\"\n   194→\n   195→    return {\n   196→        \"count\": count,\n   197→        \"summary\": summary,\n   198→        \"labels\": labels,\n   199→        \"assets\": assets,\n   200→    }\n   201→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c6fae690-e599-483c-ac71-20a86f425e0c","timestamp":"2026-01-08T08:39:22.196Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/utils/reference_assets.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Utility helpers for handling reference assets metadata.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport os\nfrom typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple\n\n__all__ = [\n    \"collect_reference_assets\",\n    \"summarize_reference_assets\",\n    \"resolve_asset_path\",\n]\n\n\ndef resolve_asset_path(asset: Dict[str, Any]) -> Optional[str]:\n    \"\"\"\n    统一解析参考图资产的文件路径。\n\n    优先级：file_path > absolute_path > path > relative_path\n    自动处理相对路径，返回绝对路径。\n\n    Args:\n        asset: 参考图数据字典\n\n    Returns:\n        解析后的文件路径，或 None 如果路径无效/不存在\n    \"\"\"\n    if not isinstance(asset, dict):\n        return None\n\n    path = (\n        asset.get('file_path') or\n        asset.get('absolute_path') or\n        asset.get('path') or\n        asset.get('relative_path')\n    )\n\n    if not path:\n        return None\n\n    path = str(path)\n\n    # 如果是相对路径，拼接存储目录\n    if not os.path.isabs(path):\n        try:\n            from config import get_storage_dir\n            storage_root = get_storage_dir()\n            if storage_root:\n                path = os.path.join(storage_root, path)\n        except Exception:\n            pass\n\n    return path if os.path.exists(path) else None\n\n\ndef _ensure_dict(value: Any) -> Dict[str, Any]:\n    if isinstance(value, dict):\n        return value\n    if isinstance(value, str):\n        try:\n            parsed = json.loads(value)\n            if isinstance(parsed, dict):\n                return parsed\n        except json.JSONDecodeError:\n            return {}\n    return {}\n\n\ndef _ensure_sequence(value: Any) -> Sequence[Any]:\n    if isinstance(value, (list, tuple)):\n        return value  # type: ignore[return-value]\n    return []\n\n\ndef _normalize_asset(item: Any, index: int) -> Dict[str, Any] | None:\n    if not isinstance(item, dict):\n        return None\n\n    normalized: Dict[str, Any] = {}\n\n    asset_id = item.get(\"id\")\n    if asset_id not in (None, \"\"):\n        normalized[\"id\"] = str(asset_id)\n\n    order_raw = item.get(\"order\")\n    if isinstance(order_raw, (int, float)):\n        order = int(order_raw)\n    else:\n        try:\n            order = int(str(order_raw))\n        except Exception:\n            order = index\n    if order < 0:\n        order = index\n    normalized[\"order\"] = order\n\n    kind = item.get(\"kind\") or item.get(\"type\")\n    if isinstance(kind, str):\n        kind = kind.strip()\n        if kind:\n            normalized[\"kind\"] = kind\n    content_type = item.get(\"type\") or item.get(\"kind\")\n    if isinstance(content_type, str):\n        content_type = content_type.strip()\n        if content_type:\n            normalized[\"type\"] = content_type\n\n    for key in (\"path\", \"relative_path\", \"absolute_path\", \"checksum\", \"width\", \"height\", \"size\", \"source\"):\n        value = item.get(key)\n        if value not in (None, \"\"):\n            normalized[key] = value\n\n    normalized[\"__source_index\"] = index\n    return normalized\n\n\ndef collect_reference_assets(record: Dict[str, Any]) -> List[Dict[str, Any]]:\n    \"\"\"Extract reference asset entries from a history record.\n\n    Preference order: `_resolved_reference_assets` -> `reference_assets` ->\n    `parameters['reference_assets']`. Returned list is sorted by `order`\n    (ascending) with stable fallback to original position. Returned dicts do\n    not modify the original record.\n    \"\"\"\n\n    if not isinstance(record, dict):\n        return []\n\n    candidates: Iterable[Any]\n    for key in (\"_resolved_reference_assets\", \"reference_assets\"):\n        value = record.get(key)\n        if value:\n            candidates = _ensure_sequence(value)\n            break\n    else:\n        params = record.get(\"parameters\")\n        params_dict = _ensure_dict(params)\n        candidates = _ensure_sequence(params_dict.get(\"reference_assets\"))\n\n    normalized: List[Tuple[int, int, Dict[str, Any]]] = []\n    for idx, item in enumerate(candidates):\n        normalized_item = _normalize_asset(item, idx)\n        if normalized_item is None:\n            continue\n        order = normalized_item.get(\"order\", idx)\n        source_idx = normalized_item.pop(\"__source_index\", idx)\n        normalized.append((order, source_idx, normalized_item))\n\n    normalized.sort(key=lambda comp: (comp[0], comp[1]))\n    return [entry[2] for entry in normalized]\n\n\ndef summarize_reference_assets(record: Dict[str, Any], *, max_preview: int = 5) -> Dict[str, Any]:\n    \"\"\"Return a sanitized summary for UI usage.\n\n    Result structure:\n        {\n            'count': int,\n            'summary': str,\n            'labels': List[str],\n            'assets': List[Dict[str, Any]],\n        }\n    \"\"\"\n\n    assets = collect_reference_assets(record)\n    count = len(assets)\n\n    labels: List[str] = []\n    for idx, asset in enumerate(assets):\n        order = asset.get(\"order\")\n        if isinstance(order, (int, float)):\n            ordinal = int(order) + 1\n        else:\n            ordinal = idx + 1\n        if ordinal < 1:\n            ordinal = idx + 1\n\n        label = f\"#{ordinal:02d}\"\n        kind = asset.get(\"kind\")\n        if isinstance(kind, str) and kind.strip():\n            label = f\"{label}({kind.strip()})\"\n        labels.append(label)\n\n    if count:\n        preview = \"、\".join(labels[:max_preview])\n        summary = f\"参考图 {count} 张：{preview}\"\n        if count > max_preview:\n            summary += \"...\"\n    else:\n        summary = \"\"\n\n    return {\n        \"count\": count,\n        \"summary\": summary,\n        \"labels\": labels,\n        \"assets\": assets,\n    }\n","numLines":201,"startLine":1,"totalLines":201}},"sourceToolAssistantUUID":"ac7deed0-e79b-4e7e-8d3a-8aa05b35be6b"}
{"parentUuid":"177b5837-a338-486c-babb-e6db74050007","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HLbHsL1EkNVijAA217nS4d","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"Reusable panel for managing reference assets (images).\"\"\"\n     4→\n     5→from pathlib import Path\n     6→from typing import Any, Dict, List, Optional, Sequence\n     7→\n     8→import tempfile\n     9→import time as import_time\n    10→\n    11→from PySide6.QtCore import Qt, QSize, Signal, QRect\n    12→from PySide6.QtGui import QDragEnterEvent, QDropEvent, QPixmap, QIcon, QPainter, QColor, QFont, QBrush, QPen, QShortcut, QKeySequence\n    13→from PySide6.QtWidgets import (\n    14→    QApplication,\n    15→    QFileDialog,\n    16→    QHBoxLayout,\n    17→    QLabel,\n    18→    QListWidget,\n    19→    QListWidgetItem,\n    20→    QPushButton,\n    21→    QSizePolicy,\n    22→    QVBoxLayout,\n    23→    QWidget,\n    24→    QDialog,\n    25→    QStyledItemDelegate,\n    26→    QStyle\n    27→)\n    28→\n    29→from modules.provider.schema import MAX_REFERENCE_BUNDLE, MAX_REFERENCE_IMAGES\n    30→from utils.style_system import unified_style_system\n    31→from utils.theme_engine import theme_engine\n    32→from utils.font_scaler import font_scaler\n    33→\n    34→from components.widgets.image_preview_dialog import ImagePreviewDialog\n    35→\n    36→import logging\n    37→\n    38→logger = logging.getLogger(__name__)\n    39→\n    40→\n    41→class ReferenceItemDelegate(QStyledItemDelegate):\n    42→    def __init__(self, parent=None):\n    43→        super().__init__(parent)\n    44→        self._padding = 4\n    45→\n    46→        # 连接主题切换信号\n    47→        unified_style_system.styleChanged.connect(self._on_theme_changed)\n    48→\n    49→    def _on_theme_changed(self):\n    50→        \"\"\"主题切换时刷新视图\"\"\"\n    51→        if self.parent() and hasattr(self.parent(), 'viewport'):\n    52→            self.parent().viewport().update()\n    53→\n    54→    def paint(self, painter: QPainter, option, index):\n    55→        \"\"\"Custom paint to show icon and badge only (no text label below)\"\"\"\n    56→        # Save painter state\n    57→        painter.save()\n    58→\n    59→        # 获取主题颜色（避免 QColor(\"rgba(...)\") 在部分平台下解析失败 -> 回退黑色）\n    60→        colors = unified_style_system.get_colors()\n    61→\n    62→        # Draw background if selected or hovered\n    63→        if option.state & QStyle.State_Selected:\n    64→            selection_fallback = (\n    65→                colors.get('palette.semantic.success_subtle')\n    66→                or colors.get('palette.neutral.bg_hover')\n    67→                or \"#00000000\"\n    68→            )\n    69→            painter.fillRect(\n    70→                option.rect,\n    71→                theme_engine.get_qcolor(\"palette.brand.subtle\", default=selection_fallback),\n    72→            )\n    73→        elif option.state & QStyle.State_MouseOver:\n    74→            hover_fallback = (\n    75→                colors.get('palette.neutral.bg_input')\n    76→                or colors.get('palette.neutral.bg_card')\n    77→                or \"#00000000\"\n    78→            )\n    79→            painter.fillRect(\n    80→                option.rect,\n    81→                theme_engine.get_qcolor(\"palette.neutral.bg_hover\", default=hover_fallback),\n    82→            )\n    83→\n    84→        # Get data\n    85→        icon = index.data(Qt.DecorationRole)\n    86→        # Ensure icon is valid\n    87→        if icon and not icon.isNull():\n    88→             # Draw Icon centered\n    89→            rect = option.rect\n    90→            # Calculate icon rect (centered)\n    91→            icon_size = option.decorationSize\n    92→            \n    93→            # Center the icon in the rect\n    94→            x = rect.x() + (rect.width() - icon_size.width()) // 2\n    95→            y = rect.y() + (rect.height() - icon_size.height()) // 2\n    96→            target_rect = QRect(x, y, icon_size.width(), icon_size.height())\n    97→            \n    98→            icon.paint(painter, target_rect, Qt.AlignCenter)\n    99→        \n   100→        # Draw Sequence Badge (Top-Left)\n   101→        # Index is 0-based, so display index + 1\n   102→        seq_num = index.row() + 1\n   103→        badge_text = str(seq_num)\n   104→        \n   105→        # Badge config\n   106→        badge_size = 18\n   107→        badge_margin = 4\n   108→        badge_rect = QRect(\n   109→            option.rect.x() + badge_margin, \n   110→            option.rect.y() + badge_margin, \n   111→            badge_size, \n   112→            badge_size\n   113→        )\n   114→        \n   115→        # Draw Badge Background (Semi-transparent black)\n   116→        painter.setPen(Qt.NoPen)\n   117→        badge_bg = theme_engine.get_qcolor(\"palette.overlay.dark\")\n   118→        badge_bg.setAlpha(180)\n   119→        painter.setBrush(badge_bg)\n   120→        painter.setRenderHint(QPainter.Antialiasing)\n   121→        painter.drawRoundedRect(badge_rect, 4, 4)\n   122→        \n   123→        # Draw Badge Text (White)\n   124→        painter.setPen(theme_engine.get_qcolor(\"palette.text.on_brand\"))\n   125→        font = painter.font()\n   126→        font.setPixelSize(11)\n   127→        font.setBold(True)\n   128→        painter.setFont(font)\n   129→        painter.drawText(badge_rect, Qt.AlignCenter, badge_text)\n   130→\n   131→        painter.restore()\n   132→        \n   133→    def sizeHint(self, option, index):\n   134→        return option.decorationSize + QSize(8, 8)  # Add some padding\n   135→\n   136→\n   137→class _ReferenceListWidget(QListWidget):\n   138→    \"\"\"\n   139→    Custom ListWidget that handles drag & drop of files and displays them in a grid.\n   140→    \"\"\"\n   141→    filesDropped = Signal(list)\n   142→\n   143→    def __init__(self, parent: Optional[QWidget] = None):\n   144→        super().__init__(parent)\n   145→        self.setAcceptDrops(True)\n   146→        self.setDragDropMode(QListWidget.DragDrop)\n   147→        self.setSelectionMode(QListWidget.ExtendedSelection)\n   148→        self.setIconSize(QSize(60, 60))\n   149→        \n   150→        # Grid Mode Settings\n   151→        self.setViewMode(QListWidget.IconMode)\n   152→        self.setResizeMode(QListWidget.Adjust)  # Auto-reflow\n   153→        self.setMovement(QListWidget.Static)    # Keep sorted order, don't allow arbitrary position\n   154→        self.setFlow(QListWidget.LeftToRight)   # Left to right flow\n   155→        self.setWrapping(True)                  # Auto wrap\n   156→        self.setSpacing(4)                      # Small spacing\n   157→        \n   158→        # Use custom delegate for badges\n   159→        self.setItemDelegate(ReferenceItemDelegate(self))\n   160→        \n   161→        # Hide default text (we draw badges manually)\n   162→        # Note: We still set text in items for sorting/searching if needed, \n   163→        # but the Delegate ignores it during paint.\n   164→\n   165→    def dragEnterEvent(self, event: QDragEnterEvent):\n   166→        if event.mimeData().hasUrls():\n   167→            event.accept()\n   168→        else:\n   169→            super().dragEnterEvent(event)\n   170→\n   171→    def dragMoveEvent(self, event: QDragEnterEvent):  # type: ignore[override]\n   172→        if event.mimeData().hasUrls():\n   173→            event.accept()\n   174→        else:\n   175→            super().dragMoveEvent(event)\n   176→\n   177→    def dropEvent(self, event: QDropEvent):\n   178→        if event.mimeData().hasUrls():\n   179→            event.accept()\n   180→            paths = []\n   181→            for url in event.mimeData().urls():\n   182→                path = url.toLocalFile()\n   183→                if path:\n   184→                    paths.append(path)\n   185→            if paths:\n   186→                self.filesDropped.emit(paths)\n   187→        else:\n   188→            super().dropEvent(event)\n   189→\n   190→\n   191→class ReferenceAssetsPanel(QWidget):\n   192→    \"\"\"UI widget for uploading and ordering reference images.\"\"\"\n   193→\n   194→    filesChanged = Signal()\n   195→    warningEmitted = Signal(str)\n   196→\n   197→    def __init__(\n   198→        self,\n   199→        parent: Optional[QWidget] = None,\n   200→        *,\n   201→        max_count: int = MAX_REFERENCE_IMAGES,\n   202→        bundle_limit: int = MAX_REFERENCE_BUNDLE,\n   203→        accept_mime_types: Optional[Sequence[str]] = None,\n   204→    ):\n   205→        super().__init__(parent)\n   206→        self._max_count = max_count\n   207→        self._bundle_limit = bundle_limit\n   208→        self._accept_mime_types = list(accept_mime_types or [\"image/png\", \"image/jpeg\"])\n   209→        self._auto_compress_enabled = True\n   210→        self._default_hint = \"支持拖拽排序；参考图 + 生成数 ≤ 15\"\n   211→\n   212→        self._allowed_suffixes = self._derive_suffixes(self._accept_mime_types)\n   213→\n   214→        layout = QVBoxLayout(self)\n   215→        layout.setContentsMargins(0, 0, 0, 0)\n   216→        layout.setSpacing(6)\n   217→\n   218→        # 画廊区域放在顶部（获得更多垂直空间）\n   219→        self._list_widget = _ReferenceListWidget(self)\n   220→        self._list_widget.filesDropped.connect(self._add_paths)\n   221→        self._list_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n   222→        self._list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n   223→        self._list_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n   224→        # 绑定双击预览\n   225→        self._list_widget.itemDoubleClicked.connect(self._show_preview)\n   226→        unified_style_system.apply_to_widget(self._list_widget)\n   227→        layout.addWidget(self._list_widget)\n   228→\n   229→        # 底部操作栏：计数 + 按钮\n   230→        footer_layout = QHBoxLayout()\n   231→        footer_layout.setContentsMargins(0, 0, 0, 0)\n   232→        footer_layout.setSpacing(8)\n   233→\n   234→        # 简化的计数标签：0/14 格式\n   235→        self._title_label = QLabel(\"0/{}\".format(self._max_count))\n   236→        self._title_label.setObjectName(\"referencePanelTitle\")\n   237→        self._apply_title_style(enabled=True)\n   238→        footer_layout.addWidget(self._title_label)\n   239→\n   240→        # 连接主题切换信号\n   241→        unified_style_system.styleChanged.connect(self._on_theme_changed)\n   242→        footer_layout.addStretch(1)\n   243→\n   244→        self._add_button = QPushButton(\"添加参考图\")\n   245→        self._add_button.setObjectName(\"referencePanelAdd\")\n   246→        self._add_button.clicked.connect(self._select_files)\n   247→        unified_style_system.apply_to_widget(self._add_button)\n   248→        footer_layout.addWidget(self._add_button)\n   249→\n   250→        self._remove_button = QPushButton(\"移除所选\")\n   251→        self._remove_button.setObjectName(\"referencePanelRemove\")\n   252→        self._remove_button.clicked.connect(self._remove_selected)\n   253→        unified_style_system.apply_to_widget(self._remove_button)\n   254→        footer_layout.addWidget(self._remove_button)\n   255→\n   256→        self._clear_button = QPushButton(\"清空\")\n   257→        self._clear_button.setObjectName(\"referencePanelClear\")\n   258→        self._clear_button.clicked.connect(self.clear)\n   259→        unified_style_system.apply_to_widget(self._clear_button)\n   260→        footer_layout.addWidget(self._clear_button)\n   261→\n   262→        layout.addLayout(footer_layout)\n   263→\n   264→        # 删除原有的 hint_label（信息已合并到计数标签）\n   265→\n   266→        self.setAcceptDrops(True)\n   267→\n   268→        self._base_icon_side = 60\n   269→        self._base_hint_offset = 48\n   270→        self._base_button_height = 32\n   271→        self._current_icon_side = self._base_icon_side\n   272→\n   273→        self._apply_scale(font_scaler.current_scale)\n   274→        try:\n   275→            font_scaler.scale_changed.connect(self._on_font_scale_changed)  # type: ignore[arg-type]\n   276→        except Exception:\n   277→            pass\n   278→\n   279→        self._setup_shortcuts()\n   280→\n   281→    # ------------------------------------------------------------------\n   282→    # Public API\n   283→    # ------------------------------------------------------------------\n   284→\n   285→    def set_limits(self, *, max_count: Optional[int] = None, bundle_limit: Optional[int] = None):\n   286→        if max_count is not None:\n   287→            self._max_count = max_count\n   288→        if bundle_limit is not None:\n   289→            self._bundle_limit = bundle_limit\n   290→        self._update_title()\n   291→\n   292→    def set_auto_compress_enabled(self, enabled: bool):\n   293→        self._auto_compress_enabled = bool(enabled)\n   294→\n   295→    def auto_compress_enabled(self) -> bool:\n   296→        return self._auto_compress_enabled\n   297→\n   298→    def set_accept_mime_types(self, mime_types: Optional[Sequence[str]]):\n   299→        self._accept_mime_types = list(mime_types or [\"image/png\", \"image/jpeg\"])\n   300→        self._allowed_suffixes = self._derive_suffixes(self._accept_mime_types)\n   301→\n   302→    def set_hint_text(self, text: Optional[str]):\n   303→        \"\"\"设置提示文本（显示为标题的 Tooltip）\"\"\"\n   304→        if text and str(text).strip():\n   305→            self._title_label.setToolTip(str(text))\n   306→        else:\n   307→            self._title_label.setToolTip(self._default_hint)\n   308→\n   309→    def set_panel_enabled(self, enabled: bool):\n   310→        self.setVisible(bool(enabled))\n   311→        self._add_button.setEnabled(enabled)\n   312→        self._remove_button.setEnabled(enabled)\n   313→        self._clear_button.setEnabled(enabled)\n   314→        self._panel_enabled = enabled\n   315→        if enabled:\n   316→            self.setAcceptDrops(True)\n   317→        else:\n   318→            self.setAcceptDrops(False)\n   319→        self._apply_title_style(enabled)\n   320→\n   321→    def _apply_title_style(self, enabled: bool = True):\n   322→        \"\"\"应用标题样式（使用主题颜色）\"\"\"\n   323→        colors = unified_style_system.get_colors()\n   324→        if enabled:\n   325→            text_color = colors.get('palette.text.secondary') or colors.get('text_secondary') or colors.get('palette.text.primary') or colors.get('text')\n   326→        else:\n   327→            text_color = colors.get('palette.text.disabled') or colors.get('palette.text.tertiary') or colors.get('palette.text.secondary') or colors.get('text_secondary')\n   328→        self._title_label.setStyleSheet(f\"color: {text_color}; font-size: 12px;\")\n   329→\n   330→    def _on_theme_changed(self):\n   331→        \"\"\"主题切换时更新样式\"\"\"\n   332→        enabled = getattr(self, '_panel_enabled', True)\n   333→        self._apply_title_style(enabled)\n   334→\n   335→    def load_from_records(self, records: Sequence[Dict[str, Any]]):\n   336→        self.clear()\n   337→        for record in records:\n   338→            path = record.get(\"absolute_path\") or record.get(\"path\")\n   339→            if path:\n   340→                self._add_paths([path], suppress_limit_warning=True)\n   341→        self._update_title()\n   342→\n   343→    def current_count(self) -> int:\n   344→        return self._list_widget.count()\n   345→\n   346→    def collect_assets(self) -> List[Dict[str, Any]]:\n   347→        assets: List[Dict[str, Any]] = []\n   348→        for order in range(self._list_widget.count()):\n   349→            item = self._list_widget.item(order)\n   350→            if not item:\n   351→                continue\n   352→            path = item.data(Qt.UserRole)\n   353→            if not path:\n   354→                continue\n   355→            file_path = Path(path)\n   356→            assets.append(\n   357→                {\n   358→                    \"path\": str(file_path),\n   359→                    \"order\": order,\n   360→                    \"source\": file_path.name,\n   361→                    \"auto_compress\": self._auto_compress_enabled,\n   362→                    \"size\": file_path.stat().st_size if file_path.exists() else None,\n   363→                }\n   364→            )\n   365→        return assets\n   366→\n   367→    def check_limits(self, expected_outputs: int = 1) -> Dict[str, Any]:\n   368→        assets = self.collect_assets()\n   369→        count = len(assets)\n   370→        result = {\n   371→            \"valid\": True,\n   372→            \"errors\": [],\n   373→            \"can_trim\": False,\n   374→            \"trim_to\": None,\n   375→        }\n   376→\n   377→        if count == 0:\n   378→            return result\n   379→\n   380→        if count > self._max_count:\n   381→            result[\"valid\"] = False\n   382→            result[\"errors\"].append(\n   383→                f\"参考图数量超过限制（{count}/{self._max_count}），需要裁剪\",\n   384→            )\n   385→            result[\"can_trim\"] = True\n   386→            result[\"trim_to\"] = self._max_count\n   387→\n   388→        allowed_by_bundle = max(0, self._bundle_limit - max(0, expected_outputs))\n   389→        if allowed_by_bundle < count:\n   390→            result[\"valid\"] = False\n   391→            result[\"errors\"].append(\n   392→                f\"参考图与生成数量之和超过 {self._bundle_limit}，需保留前 {allowed_by_bundle} 张\",\n   393→            )\n   394→            result[\"can_trim\"] = True\n   395→            result[\"trim_to\"] = (\n   396→                allowed_by_bundle\n   397→                if result[\"trim_to\"] is None\n   398→                else min(result[\"trim_to\"], allowed_by_bundle)\n   399→            )\n   400→\n   401→        if result[\"trim_to\"] is not None and result[\"trim_to\"] < 0:\n   402→            result[\"trim_to\"] = 0\n   403→        return result\n   404→\n   405→    def validate(self, expected_outputs: int = 1) -> Dict[str, Any]:\n   406→        \"\"\"Return limit-check result (alias of check_limits for clarity).\"\"\"\n   407→        return self.check_limits(expected_outputs=expected_outputs)\n   408→\n   409→    def trim_to(self, keep: int):\n   410→        keep = max(0, min(keep, self._list_widget.count()))\n   411→        while self._list_widget.count() > keep:\n   412→            item = self._list_widget.takeItem(self._list_widget.count() - 1)\n   413→            if item:\n   414→                del item\n   415→        self._update_title()\n   416→        self.filesChanged.emit()\n   417→\n   418→    def clear(self):\n   419→        self._list_widget.clear()\n   420→        self._update_title()\n   421→        self.filesChanged.emit()\n   422→\n   423→    # ------------------------------------------------------------------\n   424→    # Internal helpers\n   425→    # ------------------------------------------------------------------\n   426→\n   427→    def _show_preview(self, item):\n   428→        \"\"\"Show full size image preview dialog\"\"\"\n   429→        if not item:\n   430→            return\n   431→            \n   432→        current_index = self._list_widget.row(item)\n   433→        paths = []\n   434→        \n   435→        # Collect all valid paths\n   436→        for i in range(self._list_widget.count()):\n   437→            it = self._list_widget.item(i)\n   438→            path = it.data(Qt.UserRole)\n   439→            if path:\n   440→                paths.append(path)\n   441→                \n   442→        if not paths:\n   443→            return\n   444→            \n   445→        # Show dialog\n   446→        dialog = ImagePreviewDialog(paths, current_index, self)\n   447→        dialog.exec()\n   448→\n   449→    def _select_files(self):\n   450→        # ... (unchanged)\n   451→        suffix_filter = \"图片文件 (*.png *.jpg *.jpeg *.webp *.bmp)\"\n   452→        files, _ = QFileDialog.getOpenFileNames(self, \"选择参考图\", \"\", suffix_filter)\n   453→        if files:\n   454→            self._add_paths(files)\n   455→\n   456→    def _add_paths(self, paths: Sequence[str], suppress_limit_warning: bool = False):\n   457→        added = 0\n   458→        for raw_path in paths:\n   459→            path = Path(raw_path).expanduser()\n   460→            if not path.exists():\n   461→                continue\n   462→            if not self._is_allowed_suffix(path):\n   463→                self.warningEmitted.emit(f\"已跳过不支持的格式: {path.name}\")\n   464→                continue\n   465→            if self._contains_path(str(path)):\n   466→                continue\n   467→            if self._list_widget.count() >= self._max_count:\n   468→                if not suppress_limit_warning:\n   469→                    self.warningEmitted.emit(f\"最多可添加 {self._max_count} 张参考图\")\n   470→                break\n   471→\n   472→            item = QListWidgetItem()\n   473→            item.setData(Qt.UserRole, str(path))\n   474→            item.setToolTip(str(path))\n   475→            pixmap = QPixmap(str(path))\n   476→            if not pixmap.isNull():\n   477→                icon_pixmap = pixmap.scaled(\n   478→                    self._current_icon_side,\n   479→                    self._current_icon_side,\n   480→                    Qt.KeepAspectRatio,\n   481→                    Qt.SmoothTransformation,\n   482→                )\n   483→                item.setIcon(QIcon(icon_pixmap))\n   484→            item.setText(path.name)\n   485→            self._list_widget.addItem(item)\n   486→            added += 1\n   487→\n   488→        if added:\n   489→            self._update_title()\n   490→            self.filesChanged.emit()\n   491→\n   492→    def _remove_selected(self):\n   493→        selected_items = self._list_widget.selectedItems()\n   494→        if not selected_items:\n   495→            return\n   496→        for item in selected_items:\n   497→            row = self._list_widget.row(item)\n   498→            self._list_widget.takeItem(row)\n   499→        self._update_title()\n   500→        self.filesChanged.emit()\n   501→\n   502→    def _contains_path(self, path: str) -> bool:\n   503→        for i in range(self._list_widget.count()):\n   504→            item = self._list_widget.item(i)\n   505→            if item and item.data(Qt.UserRole) == path:\n   506→                return True\n   507→        return False\n   508→\n   509→    def _derive_suffixes(self, mime_types: Sequence[str]) -> List[str]:\n   510→        suffixes: List[str] = []\n   511→        for mime in mime_types:\n   512→            lower = mime.lower()\n   513→            if lower.endswith(\"png\"):\n   514→                suffixes.append(\".png\")\n   515→            elif lower.endswith(\"jpeg\") or lower.endswith(\"jpg\"):\n   516→                suffixes.extend([\".jpg\", \".jpeg\"])\n   517→            elif lower.endswith(\"webp\"):\n   518→                suffixes.append(\".webp\")\n   519→            elif lower.endswith(\"bmp\"):\n   520→                suffixes.append(\".bmp\")\n   521→        return suffixes or [\".png\", \".jpg\", \".jpeg\"]\n   522→\n   523→    def _on_font_scale_changed(self, scale: float) -> None:\n   524→        self._apply_scale(scale)\n   525→\n   526→    def _apply_scale(self, scale: float) -> None:\n   527→        icon_side = max(40, int(round(self._base_icon_side * scale)))\n   528→        self._current_icon_side = icon_side\n   529→        self._list_widget.setIconSize(QSize(icon_side, icon_side))\n   530→        self._list_widget.setSpacing(max(6, int(round(8 * scale))))\n   531→        self._list_widget.setMaximumHeight(icon_side + int(round(self._base_hint_offset * scale)))\n   532→\n   533→        min_button_height = max(28, int(round(self._base_button_height * scale)))\n   534→        for button in (self._add_button, self._remove_button, self._clear_button):\n   535→            button.setMinimumHeight(min_button_height)\n   536→\n   537→\n   538→\n   539→        self._refresh_item_icons(icon_side)\n   540→\n   541→    def _refresh_item_icons(self, icon_side: int) -> None:\n   542→        for index in range(self._list_widget.count()):\n   543→            item = self._list_widget.item(index)\n   544→            if not item:\n   545→                continue\n   546→            path = item.data(Qt.UserRole)\n   547→            if not path:\n   548→                continue\n   549→            pixmap = QPixmap(path)\n   550→            if pixmap.isNull():\n   551→                continue\n   552→            item.setIcon(\n   553→                QIcon(\n   554→                    pixmap.scaled(\n   555→                        icon_side,\n   556→                        icon_side,\n   557→                        Qt.KeepAspectRatio,\n   558→                        Qt.SmoothTransformation,\n   559→                    )\n   560→                )\n   561→            )\n   562→\n   563→    def _is_allowed_suffix(self, path: Path) -> bool:\n   564→        if not self._allowed_suffixes:\n   565→            return True\n   566→        return path.suffix.lower() in self._allowed_suffixes\n   567→\n   568→    def _update_title(self):\n   569→        count = self._list_widget.count()\n   570→        self._title_label.setText(f\"参考图 ({count}/{self._max_count})\")\n   571→\n   572→    # ------------------------------------------------------------------\n   573→    # Drag & drop forwarding to inner list\n   574→    # ------------------------------------------------------------------\n   575→\n   576→    def dragEnterEvent(self, event: QDragEnterEvent):\n   577→        self._list_widget.dragEnterEvent(event)\n   578→\n   579→    def dragMoveEvent(self, event: QDragEnterEvent):  # type: ignore[override]\n   580→        self._list_widget.dragMoveEvent(event)\n   581→\n   582→    def dropEvent(self, event: QDropEvent):\n   583→        self._list_widget.dropEvent(event)\n   584→\n   585→    # ------------------------------------------------------------------\n   586→    # 快捷键支持\n   587→    # ------------------------------------------------------------------\n   588→\n   589→    def _setup_shortcuts(self):\n   590→        \"\"\"设置快捷键\"\"\"\n   591→        self._paste_shortcut = QShortcut(QKeySequence.StandardKey.Paste, self)\n   592→        self._paste_shortcut.activated.connect(self._handle_paste)\n   593→\n   594→    def _handle_paste(self):\n   595→        \"\"\"处理粘贴操作\"\"\"\n   596→        clipboard = QApplication.clipboard()\n   597→        mime_data = clipboard.mimeData()\n   598→\n   599→        if mime_data.hasImage():\n   600→            img = clipboard.image()\n   601→            if not img.isNull():\n   602→                sender_dir = Path(tempfile.gettempdir()) / \"gemeng_pasted\"\n   603→                sender_dir.mkdir(exist_ok=True)\n   604→                timestamp = int(import_time.time() * 1000)\n   605→                temp_path = sender_dir / f\"pasted_ref_{timestamp}.png\"\n   606→                img.save(str(temp_path))\n   607→                if self._list_widget.count() < self._max_count:\n   608→                    self._add_paths([str(temp_path)])\n   609→                return\n   610→\n   611→        if mime_data.hasUrls():\n   612→            paths = [u.toLocalFile() for u in mime_data.urls() if u.isLocalFile()]\n   613→            if paths:\n   614→                self._add_paths(paths)\n   615→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f64a355f-3a79-4a42-8e97-eca37d74e0df","timestamp":"2026-01-08T08:39:22.196Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/reference_assets_panel.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Reusable panel for managing reference assets (images).\"\"\"\n\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional, Sequence\n\nimport tempfile\nimport time as import_time\n\nfrom PySide6.QtCore import Qt, QSize, Signal, QRect\nfrom PySide6.QtGui import QDragEnterEvent, QDropEvent, QPixmap, QIcon, QPainter, QColor, QFont, QBrush, QPen, QShortcut, QKeySequence\nfrom PySide6.QtWidgets import (\n    QApplication,\n    QFileDialog,\n    QHBoxLayout,\n    QLabel,\n    QListWidget,\n    QListWidgetItem,\n    QPushButton,\n    QSizePolicy,\n    QVBoxLayout,\n    QWidget,\n    QDialog,\n    QStyledItemDelegate,\n    QStyle\n)\n\nfrom modules.provider.schema import MAX_REFERENCE_BUNDLE, MAX_REFERENCE_IMAGES\nfrom utils.style_system import unified_style_system\nfrom utils.theme_engine import theme_engine\nfrom utils.font_scaler import font_scaler\n\nfrom components.widgets.image_preview_dialog import ImagePreviewDialog\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass ReferenceItemDelegate(QStyledItemDelegate):\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self._padding = 4\n\n        # 连接主题切换信号\n        unified_style_system.styleChanged.connect(self._on_theme_changed)\n\n    def _on_theme_changed(self):\n        \"\"\"主题切换时刷新视图\"\"\"\n        if self.parent() and hasattr(self.parent(), 'viewport'):\n            self.parent().viewport().update()\n\n    def paint(self, painter: QPainter, option, index):\n        \"\"\"Custom paint to show icon and badge only (no text label below)\"\"\"\n        # Save painter state\n        painter.save()\n\n        # 获取主题颜色（避免 QColor(\"rgba(...)\") 在部分平台下解析失败 -> 回退黑色）\n        colors = unified_style_system.get_colors()\n\n        # Draw background if selected or hovered\n        if option.state & QStyle.State_Selected:\n            selection_fallback = (\n                colors.get('palette.semantic.success_subtle')\n                or colors.get('palette.neutral.bg_hover')\n                or \"#00000000\"\n            )\n            painter.fillRect(\n                option.rect,\n                theme_engine.get_qcolor(\"palette.brand.subtle\", default=selection_fallback),\n            )\n        elif option.state & QStyle.State_MouseOver:\n            hover_fallback = (\n                colors.get('palette.neutral.bg_input')\n                or colors.get('palette.neutral.bg_card')\n                or \"#00000000\"\n            )\n            painter.fillRect(\n                option.rect,\n                theme_engine.get_qcolor(\"palette.neutral.bg_hover\", default=hover_fallback),\n            )\n\n        # Get data\n        icon = index.data(Qt.DecorationRole)\n        # Ensure icon is valid\n        if icon and not icon.isNull():\n             # Draw Icon centered\n            rect = option.rect\n            # Calculate icon rect (centered)\n            icon_size = option.decorationSize\n            \n            # Center the icon in the rect\n            x = rect.x() + (rect.width() - icon_size.width()) // 2\n            y = rect.y() + (rect.height() - icon_size.height()) // 2\n            target_rect = QRect(x, y, icon_size.width(), icon_size.height())\n            \n            icon.paint(painter, target_rect, Qt.AlignCenter)\n        \n        # Draw Sequence Badge (Top-Left)\n        # Index is 0-based, so display index + 1\n        seq_num = index.row() + 1\n        badge_text = str(seq_num)\n        \n        # Badge config\n        badge_size = 18\n        badge_margin = 4\n        badge_rect = QRect(\n            option.rect.x() + badge_margin, \n            option.rect.y() + badge_margin, \n            badge_size, \n            badge_size\n        )\n        \n        # Draw Badge Background (Semi-transparent black)\n        painter.setPen(Qt.NoPen)\n        badge_bg = theme_engine.get_qcolor(\"palette.overlay.dark\")\n        badge_bg.setAlpha(180)\n        painter.setBrush(badge_bg)\n        painter.setRenderHint(QPainter.Antialiasing)\n        painter.drawRoundedRect(badge_rect, 4, 4)\n        \n        # Draw Badge Text (White)\n        painter.setPen(theme_engine.get_qcolor(\"palette.text.on_brand\"))\n        font = painter.font()\n        font.setPixelSize(11)\n        font.setBold(True)\n        painter.setFont(font)\n        painter.drawText(badge_rect, Qt.AlignCenter, badge_text)\n\n        painter.restore()\n        \n    def sizeHint(self, option, index):\n        return option.decorationSize + QSize(8, 8)  # Add some padding\n\n\nclass _ReferenceListWidget(QListWidget):\n    \"\"\"\n    Custom ListWidget that handles drag & drop of files and displays them in a grid.\n    \"\"\"\n    filesDropped = Signal(list)\n\n    def __init__(self, parent: Optional[QWidget] = None):\n        super().__init__(parent)\n        self.setAcceptDrops(True)\n        self.setDragDropMode(QListWidget.DragDrop)\n        self.setSelectionMode(QListWidget.ExtendedSelection)\n        self.setIconSize(QSize(60, 60))\n        \n        # Grid Mode Settings\n        self.setViewMode(QListWidget.IconMode)\n        self.setResizeMode(QListWidget.Adjust)  # Auto-reflow\n        self.setMovement(QListWidget.Static)    # Keep sorted order, don't allow arbitrary position\n        self.setFlow(QListWidget.LeftToRight)   # Left to right flow\n        self.setWrapping(True)                  # Auto wrap\n        self.setSpacing(4)                      # Small spacing\n        \n        # Use custom delegate for badges\n        self.setItemDelegate(ReferenceItemDelegate(self))\n        \n        # Hide default text (we draw badges manually)\n        # Note: We still set text in items for sorting/searching if needed, \n        # but the Delegate ignores it during paint.\n\n    def dragEnterEvent(self, event: QDragEnterEvent):\n        if event.mimeData().hasUrls():\n            event.accept()\n        else:\n            super().dragEnterEvent(event)\n\n    def dragMoveEvent(self, event: QDragEnterEvent):  # type: ignore[override]\n        if event.mimeData().hasUrls():\n            event.accept()\n        else:\n            super().dragMoveEvent(event)\n\n    def dropEvent(self, event: QDropEvent):\n        if event.mimeData().hasUrls():\n            event.accept()\n            paths = []\n            for url in event.mimeData().urls():\n                path = url.toLocalFile()\n                if path:\n                    paths.append(path)\n            if paths:\n                self.filesDropped.emit(paths)\n        else:\n            super().dropEvent(event)\n\n\nclass ReferenceAssetsPanel(QWidget):\n    \"\"\"UI widget for uploading and ordering reference images.\"\"\"\n\n    filesChanged = Signal()\n    warningEmitted = Signal(str)\n\n    def __init__(\n        self,\n        parent: Optional[QWidget] = None,\n        *,\n        max_count: int = MAX_REFERENCE_IMAGES,\n        bundle_limit: int = MAX_REFERENCE_BUNDLE,\n        accept_mime_types: Optional[Sequence[str]] = None,\n    ):\n        super().__init__(parent)\n        self._max_count = max_count\n        self._bundle_limit = bundle_limit\n        self._accept_mime_types = list(accept_mime_types or [\"image/png\", \"image/jpeg\"])\n        self._auto_compress_enabled = True\n        self._default_hint = \"支持拖拽排序；参考图 + 生成数 ≤ 15\"\n\n        self._allowed_suffixes = self._derive_suffixes(self._accept_mime_types)\n\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(6)\n\n        # 画廊区域放在顶部（获得更多垂直空间）\n        self._list_widget = _ReferenceListWidget(self)\n        self._list_widget.filesDropped.connect(self._add_paths)\n        self._list_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n        self._list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        self._list_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        # 绑定双击预览\n        self._list_widget.itemDoubleClicked.connect(self._show_preview)\n        unified_style_system.apply_to_widget(self._list_widget)\n        layout.addWidget(self._list_widget)\n\n        # 底部操作栏：计数 + 按钮\n        footer_layout = QHBoxLayout()\n        footer_layout.setContentsMargins(0, 0, 0, 0)\n        footer_layout.setSpacing(8)\n\n        # 简化的计数标签：0/14 格式\n        self._title_label = QLabel(\"0/{}\".format(self._max_count))\n        self._title_label.setObjectName(\"referencePanelTitle\")\n        self._apply_title_style(enabled=True)\n        footer_layout.addWidget(self._title_label)\n\n        # 连接主题切换信号\n        unified_style_system.styleChanged.connect(self._on_theme_changed)\n        footer_layout.addStretch(1)\n\n        self._add_button = QPushButton(\"添加参考图\")\n        self._add_button.setObjectName(\"referencePanelAdd\")\n        self._add_button.clicked.connect(self._select_files)\n        unified_style_system.apply_to_widget(self._add_button)\n        footer_layout.addWidget(self._add_button)\n\n        self._remove_button = QPushButton(\"移除所选\")\n        self._remove_button.setObjectName(\"referencePanelRemove\")\n        self._remove_button.clicked.connect(self._remove_selected)\n        unified_style_system.apply_to_widget(self._remove_button)\n        footer_layout.addWidget(self._remove_button)\n\n        self._clear_button = QPushButton(\"清空\")\n        self._clear_button.setObjectName(\"referencePanelClear\")\n        self._clear_button.clicked.connect(self.clear)\n        unified_style_system.apply_to_widget(self._clear_button)\n        footer_layout.addWidget(self._clear_button)\n\n        layout.addLayout(footer_layout)\n\n        # 删除原有的 hint_label（信息已合并到计数标签）\n\n        self.setAcceptDrops(True)\n\n        self._base_icon_side = 60\n        self._base_hint_offset = 48\n        self._base_button_height = 32\n        self._current_icon_side = self._base_icon_side\n\n        self._apply_scale(font_scaler.current_scale)\n        try:\n            font_scaler.scale_changed.connect(self._on_font_scale_changed)  # type: ignore[arg-type]\n        except Exception:\n            pass\n\n        self._setup_shortcuts()\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n\n    def set_limits(self, *, max_count: Optional[int] = None, bundle_limit: Optional[int] = None):\n        if max_count is not None:\n            self._max_count = max_count\n        if bundle_limit is not None:\n            self._bundle_limit = bundle_limit\n        self._update_title()\n\n    def set_auto_compress_enabled(self, enabled: bool):\n        self._auto_compress_enabled = bool(enabled)\n\n    def auto_compress_enabled(self) -> bool:\n        return self._auto_compress_enabled\n\n    def set_accept_mime_types(self, mime_types: Optional[Sequence[str]]):\n        self._accept_mime_types = list(mime_types or [\"image/png\", \"image/jpeg\"])\n        self._allowed_suffixes = self._derive_suffixes(self._accept_mime_types)\n\n    def set_hint_text(self, text: Optional[str]):\n        \"\"\"设置提示文本（显示为标题的 Tooltip）\"\"\"\n        if text and str(text).strip():\n            self._title_label.setToolTip(str(text))\n        else:\n            self._title_label.setToolTip(self._default_hint)\n\n    def set_panel_enabled(self, enabled: bool):\n        self.setVisible(bool(enabled))\n        self._add_button.setEnabled(enabled)\n        self._remove_button.setEnabled(enabled)\n        self._clear_button.setEnabled(enabled)\n        self._panel_enabled = enabled\n        if enabled:\n            self.setAcceptDrops(True)\n        else:\n            self.setAcceptDrops(False)\n        self._apply_title_style(enabled)\n\n    def _apply_title_style(self, enabled: bool = True):\n        \"\"\"应用标题样式（使用主题颜色）\"\"\"\n        colors = unified_style_system.get_colors()\n        if enabled:\n            text_color = colors.get('palette.text.secondary') or colors.get('text_secondary') or colors.get('palette.text.primary') or colors.get('text')\n        else:\n            text_color = colors.get('palette.text.disabled') or colors.get('palette.text.tertiary') or colors.get('palette.text.secondary') or colors.get('text_secondary')\n        self._title_label.setStyleSheet(f\"color: {text_color}; font-size: 12px;\")\n\n    def _on_theme_changed(self):\n        \"\"\"主题切换时更新样式\"\"\"\n        enabled = getattr(self, '_panel_enabled', True)\n        self._apply_title_style(enabled)\n\n    def load_from_records(self, records: Sequence[Dict[str, Any]]):\n        self.clear()\n        for record in records:\n            path = record.get(\"absolute_path\") or record.get(\"path\")\n            if path:\n                self._add_paths([path], suppress_limit_warning=True)\n        self._update_title()\n\n    def current_count(self) -> int:\n        return self._list_widget.count()\n\n    def collect_assets(self) -> List[Dict[str, Any]]:\n        assets: List[Dict[str, Any]] = []\n        for order in range(self._list_widget.count()):\n            item = self._list_widget.item(order)\n            if not item:\n                continue\n            path = item.data(Qt.UserRole)\n            if not path:\n                continue\n            file_path = Path(path)\n            assets.append(\n                {\n                    \"path\": str(file_path),\n                    \"order\": order,\n                    \"source\": file_path.name,\n                    \"auto_compress\": self._auto_compress_enabled,\n                    \"size\": file_path.stat().st_size if file_path.exists() else None,\n                }\n            )\n        return assets\n\n    def check_limits(self, expected_outputs: int = 1) -> Dict[str, Any]:\n        assets = self.collect_assets()\n        count = len(assets)\n        result = {\n            \"valid\": True,\n            \"errors\": [],\n            \"can_trim\": False,\n            \"trim_to\": None,\n        }\n\n        if count == 0:\n            return result\n\n        if count > self._max_count:\n            result[\"valid\"] = False\n            result[\"errors\"].append(\n                f\"参考图数量超过限制（{count}/{self._max_count}），需要裁剪\",\n            )\n            result[\"can_trim\"] = True\n            result[\"trim_to\"] = self._max_count\n\n        allowed_by_bundle = max(0, self._bundle_limit - max(0, expected_outputs))\n        if allowed_by_bundle < count:\n            result[\"valid\"] = False\n            result[\"errors\"].append(\n                f\"参考图与生成数量之和超过 {self._bundle_limit}，需保留前 {allowed_by_bundle} 张\",\n            )\n            result[\"can_trim\"] = True\n            result[\"trim_to\"] = (\n                allowed_by_bundle\n                if result[\"trim_to\"] is None\n                else min(result[\"trim_to\"], allowed_by_bundle)\n            )\n\n        if result[\"trim_to\"] is not None and result[\"trim_to\"] < 0:\n            result[\"trim_to\"] = 0\n        return result\n\n    def validate(self, expected_outputs: int = 1) -> Dict[str, Any]:\n        \"\"\"Return limit-check result (alias of check_limits for clarity).\"\"\"\n        return self.check_limits(expected_outputs=expected_outputs)\n\n    def trim_to(self, keep: int):\n        keep = max(0, min(keep, self._list_widget.count()))\n        while self._list_widget.count() > keep:\n            item = self._list_widget.takeItem(self._list_widget.count() - 1)\n            if item:\n                del item\n        self._update_title()\n        self.filesChanged.emit()\n\n    def clear(self):\n        self._list_widget.clear()\n        self._update_title()\n        self.filesChanged.emit()\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n\n    def _show_preview(self, item):\n        \"\"\"Show full size image preview dialog\"\"\"\n        if not item:\n            return\n            \n        current_index = self._list_widget.row(item)\n        paths = []\n        \n        # Collect all valid paths\n        for i in range(self._list_widget.count()):\n            it = self._list_widget.item(i)\n            path = it.data(Qt.UserRole)\n            if path:\n                paths.append(path)\n                \n        if not paths:\n            return\n            \n        # Show dialog\n        dialog = ImagePreviewDialog(paths, current_index, self)\n        dialog.exec()\n\n    def _select_files(self):\n        # ... (unchanged)\n        suffix_filter = \"图片文件 (*.png *.jpg *.jpeg *.webp *.bmp)\"\n        files, _ = QFileDialog.getOpenFileNames(self, \"选择参考图\", \"\", suffix_filter)\n        if files:\n            self._add_paths(files)\n\n    def _add_paths(self, paths: Sequence[str], suppress_limit_warning: bool = False):\n        added = 0\n        for raw_path in paths:\n            path = Path(raw_path).expanduser()\n            if not path.exists():\n                continue\n            if not self._is_allowed_suffix(path):\n                self.warningEmitted.emit(f\"已跳过不支持的格式: {path.name}\")\n                continue\n            if self._contains_path(str(path)):\n                continue\n            if self._list_widget.count() >= self._max_count:\n                if not suppress_limit_warning:\n                    self.warningEmitted.emit(f\"最多可添加 {self._max_count} 张参考图\")\n                break\n\n            item = QListWidgetItem()\n            item.setData(Qt.UserRole, str(path))\n            item.setToolTip(str(path))\n            pixmap = QPixmap(str(path))\n            if not pixmap.isNull():\n                icon_pixmap = pixmap.scaled(\n                    self._current_icon_side,\n                    self._current_icon_side,\n                    Qt.KeepAspectRatio,\n                    Qt.SmoothTransformation,\n                )\n                item.setIcon(QIcon(icon_pixmap))\n            item.setText(path.name)\n            self._list_widget.addItem(item)\n            added += 1\n\n        if added:\n            self._update_title()\n            self.filesChanged.emit()\n\n    def _remove_selected(self):\n        selected_items = self._list_widget.selectedItems()\n        if not selected_items:\n            return\n        for item in selected_items:\n            row = self._list_widget.row(item)\n            self._list_widget.takeItem(row)\n        self._update_title()\n        self.filesChanged.emit()\n\n    def _contains_path(self, path: str) -> bool:\n        for i in range(self._list_widget.count()):\n            item = self._list_widget.item(i)\n            if item and item.data(Qt.UserRole) == path:\n                return True\n        return False\n\n    def _derive_suffixes(self, mime_types: Sequence[str]) -> List[str]:\n        suffixes: List[str] = []\n        for mime in mime_types:\n            lower = mime.lower()\n            if lower.endswith(\"png\"):\n                suffixes.append(\".png\")\n            elif lower.endswith(\"jpeg\") or lower.endswith(\"jpg\"):\n                suffixes.extend([\".jpg\", \".jpeg\"])\n            elif lower.endswith(\"webp\"):\n                suffixes.append(\".webp\")\n            elif lower.endswith(\"bmp\"):\n                suffixes.append(\".bmp\")\n        return suffixes or [\".png\", \".jpg\", \".jpeg\"]\n\n    def _on_font_scale_changed(self, scale: float) -> None:\n        self._apply_scale(scale)\n\n    def _apply_scale(self, scale: float) -> None:\n        icon_side = max(40, int(round(self._base_icon_side * scale)))\n        self._current_icon_side = icon_side\n        self._list_widget.setIconSize(QSize(icon_side, icon_side))\n        self._list_widget.setSpacing(max(6, int(round(8 * scale))))\n        self._list_widget.setMaximumHeight(icon_side + int(round(self._base_hint_offset * scale)))\n\n        min_button_height = max(28, int(round(self._base_button_height * scale)))\n        for button in (self._add_button, self._remove_button, self._clear_button):\n            button.setMinimumHeight(min_button_height)\n\n\n\n        self._refresh_item_icons(icon_side)\n\n    def _refresh_item_icons(self, icon_side: int) -> None:\n        for index in range(self._list_widget.count()):\n            item = self._list_widget.item(index)\n            if not item:\n                continue\n            path = item.data(Qt.UserRole)\n            if not path:\n                continue\n            pixmap = QPixmap(path)\n            if pixmap.isNull():\n                continue\n            item.setIcon(\n                QIcon(\n                    pixmap.scaled(\n                        icon_side,\n                        icon_side,\n                        Qt.KeepAspectRatio,\n                        Qt.SmoothTransformation,\n                    )\n                )\n            )\n\n    def _is_allowed_suffix(self, path: Path) -> bool:\n        if not self._allowed_suffixes:\n            return True\n        return path.suffix.lower() in self._allowed_suffixes\n\n    def _update_title(self):\n        count = self._list_widget.count()\n        self._title_label.setText(f\"参考图 ({count}/{self._max_count})\")\n\n    # ------------------------------------------------------------------\n    # Drag & drop forwarding to inner list\n    # ------------------------------------------------------------------\n\n    def dragEnterEvent(self, event: QDragEnterEvent):\n        self._list_widget.dragEnterEvent(event)\n\n    def dragMoveEvent(self, event: QDragEnterEvent):  # type: ignore[override]\n        self._list_widget.dragMoveEvent(event)\n\n    def dropEvent(self, event: QDropEvent):\n        self._list_widget.dropEvent(event)\n\n    # ------------------------------------------------------------------\n    # 快捷键支持\n    # ------------------------------------------------------------------\n\n    def _setup_shortcuts(self):\n        \"\"\"设置快捷键\"\"\"\n        self._paste_shortcut = QShortcut(QKeySequence.StandardKey.Paste, self)\n        self._paste_shortcut.activated.connect(self._handle_paste)\n\n    def _handle_paste(self):\n        \"\"\"处理粘贴操作\"\"\"\n        clipboard = QApplication.clipboard()\n        mime_data = clipboard.mimeData()\n\n        if mime_data.hasImage():\n            img = clipboard.image()\n            if not img.isNull():\n                sender_dir = Path(tempfile.gettempdir()) / \"gemeng_pasted\"\n                sender_dir.mkdir(exist_ok=True)\n                timestamp = int(import_time.time() * 1000)\n                temp_path = sender_dir / f\"pasted_ref_{timestamp}.png\"\n                img.save(str(temp_path))\n                if self._list_widget.count() < self._max_count:\n                    self._add_paths([str(temp_path)])\n                return\n\n        if mime_data.hasUrls():\n            paths = [u.toLocalFile() for u in mime_data.urls() if u.isLocalFile()]\n            if paths:\n                self._add_paths(paths)\n","numLines":615,"startLine":1,"totalLines":615}},"sourceToolAssistantUUID":"177b5837-a338-486c-babb-e6db74050007"}
{"parentUuid":"545cae47-36ce-4eaa-a508-dff639c69221","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PSLGhH5R8dYN7YRmSgRGaT","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config.unified_config import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        storage_dir = get_storage_dir()\n    59→        if not storage_dir:\n    60→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    61→        self.storage_manager = get_v2_storage_manager(storage_dir)\n    62→        \n    63→        # 保持兼容性别名\n    64→        self.file_manager = self.storage_manager\n    65→        self.metadata_manager = self.storage_manager\n    66→        self.image_storage_manager = self.storage_manager\n    67→        \n    68→        # 保留原有的目录属性以保持兼容性\n    69→        self.data_dir = Path(self.storage_manager.root_path)\n    70→        self.images_dir = self.data_dir / \"images\"\n    71→        self.metadata_dir = self.data_dir / \"metadata\"\n    72→\n    73→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    74→\n    75→    def generate_text_to_image(\n    76→        self,\n    77→        prompt: str,\n    78→        size: str = \"1024x1024\",\n    79→        guidance_scale: float = 2.5,\n    80→        seed: int = -1,\n    81→        save_local: bool = True,\n    82→        reference_images: Optional[List[Any]] = None,\n    83→        model_variant: Optional[str] = None,\n    84→        generation_id: Optional[str] = None,\n    85→        count: int = 1,\n    86→        sequential_mode: bool = False,\n    87→        derived_ids: Optional[List[str]] = None,\n    88→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    89→    ) -> Dict[str, Any]:\n    90→        \"\"\"\n    91→        生成文生图并保存到本地\n    92→\n    93→        Args:\n    94→            prompt: 图像生成提示词\n    95→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    96→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    97→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    98→            response_format: 返回格式，\"url\"或\"b64_json\"\n    99→            save_local: 是否保存到本地\n   100→            reference_images: 参考图列表\n   101→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   102→            count: 生成图片数量（组图模式下生效）\n   103→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   104→            derived_ids: 组图生成的ID列表（用于关联）\n   105→\n   106→        Returns:\n   107→            Dict: 生成结果，包含本地文件路径\n   108→\n   109→        Note:\n   110→            model和watermark参数已固定，不再需要前端控制\n   111→        \"\"\"\n   112→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   113→\n   114→        # 根据 model_variant 选择 provider（并发安全：不写 env）\n   115→        seedream_provider: Optional[str] = None\n   116→        try:\n   117→            mv = (model_variant or \"\").strip().lower()\n   118→            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n   119→                seedream_provider = \"volc_v4\"\n   120→            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n   121→                seedream_provider = \"volc_v4_5\"\n   122→            elif mv.startswith(\"volc_\"):\n   123→                seedream_provider = mv\n   124→        except Exception:\n   125→            seedream_provider = None\n   126→\n   127→        # 生成唯一ID，优先使用外部传入的generation_id\n   128→        task_id = generation_id or str(uuid.uuid4())\n   129→\n   130→        ref_assets: List[Dict[str, Any]] = []\n   131→        ref_paths: List[str] = []\n   132→        ref_summary: Dict[str, Any] = {}\n   133→        ref_payloads: List[str] = []\n   134→\n   135→        try:\n   136→            if reference_images:\n   137→                ref_summary = self._process_reference_assets(\n   138→                    reference_images,\n   139→                    max_refs=MAX_REFERENCE_IMAGES,\n   140→                    expected_outputs=1,\n   141→                )\n   142→                ref_assets = list(ref_summary.get('assets', []))\n   143→                ref_paths = list(ref_summary.get('paths', []))\n   144→                ref_payloads = self._build_reference_payloads(ref_assets)\n   145→\n   146→                if ref_summary.get('errors'):\n   147→                    logger.warning(\n   148→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   149→                    )\n   150→                if ref_summary.get('warnings'):\n   151→                    for warn in ref_summary['warnings']:\n   152→                        logger.warning(f\"参考图提示: {warn}\")\n   153→\n   154→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   155→            try:\n   156→                norm, fb, reason = validate_and_normalize_t2i(\n   157→                    TextToImageParams(\n   158→                        prompt=prompt,\n   159→                        size=size,\n   160→                        guidance_scale=guidance_scale,\n   161→                        seed=(None if seed == -1 else seed),\n   162→                    )\n   163→                )\n   164→                logger.info(\n   165→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   166→                )\n   167→                if fb:\n   168→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   169→            except Exception as _e:\n   170→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   171→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   172→            actual_count = max(1, count)\n   173→            use_group_mode = bool(sequential_mode and actual_count > 1)\n   174→\n   175→            api_result = self.client.text_to_image(\n   176→                prompt=prompt,\n   177→                size=size,\n   178→                guidance_scale=guidance_scale,\n   179→                seed=seed,\n   180→                reference_images=ref_payloads or None,\n   181→                n=actual_count if use_group_mode else 1,\n   182→                sequential_mode=sequential_mode,\n   183→                seedream_provider=seedream_provider,\n   184→            )\n   185→\n   186→            # 组图模式：API 返回多张图，需要逐一保存\n   187→            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n   188→            images_count = len(images_list)\n   189→            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n   190→\n   191→            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n   192→            if use_group_mode and images_count < actual_count:\n   193→                logger.warning(\n   194→                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n   195→                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n   196→                )\n   197→\n   198→            if use_group_mode and images_count > 1:\n   199→                results_batch = []\n   200→                success_count = 0\n   201→                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n   202→                total_images = len(images_list)\n   203→\n   204→                for idx, img_data in enumerate(images_list):\n   205→                    # 发送下载进度（每张图开始下载时）\n   206→                    if progress_callback:\n   207→                        try:\n   208→                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n   209→                        except Exception:\n   210→                            pass\n   211→\n   212→                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n   213→                    per_result = {\n   214→                        \"task_id\": per_id,\n   215→                        \"success\": True,\n   216→                        \"type\": \"text_to_image\",\n   217→                        \"prompt\": prompt,\n   218→                        \"image_url\": img_data[\"url\"],\n   219→                        \"parameters\": {\n   220→                            \"size\": size,\n   221→                            \"guidance_scale\": guidance_scale,\n   222→                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   223→                            **(({\"seed\": seed} if seedream_provider is None else {})),\n   224→                            \"response_format\": \"url\",\n   225→                            \"watermark\": False,\n   226→                            \"model\": self._resolve_model_id(\n   227→                                \"doubao-seedream-3-0-t2i-250415\",\n   228→                                \"doubao-seedream-4-0-250828\",\n   229→                                \"doubao-seedream-4-5-251128\",\n   230→                            ),\n   231→                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   232→                            \"sequential_mode\": True,\n   233→                            \"group_index\": idx + 1,\n   234→                            \"group_total\": total_images,\n   235→                        },\n   236→                        \"created_at\": datetime.now().isoformat(),\n   237→                        \"usage\": api_result.get(\"usage\", {}),\n   238→                    }\n   239→\n   240→                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   241→                    if sanitized_refs:\n   242→                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   243→                        per_result[\"reference_assets\"] = sanitized_refs\n   244→\n   245→                    if save_local and per_result.get(\"image_url\"):\n   246→                        local_result = self._save_image_locally(per_result)\n   247→                        per_result.update(local_result)\n   248→                        if not local_result.get('local_save_error'):\n   249→                            success_count += 1\n   250→\n   251→                    results_batch.append(per_result)\n   252→\n   253→                    # 发送下载完成进度\n   254→                    if progress_callback:\n   255→                        try:\n   256→                            progress_callback(idx + 1, total_images, per_result)\n   257→                        except Exception:\n   258→                            pass\n   259→\n   260→                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n   261→                return {\n   262→                    \"batch\": True,\n   263→                    \"results\": results_batch,\n   264→                    \"success_count\": success_count,\n   265→                    \"total_count\": len(results_batch),\n   266→                    \"derived_ids\": group_ids,\n   267→                }\n   268→\n   269→            # 单图模式（默认）\n   270→            result = {\n   271→                \"task_id\": task_id,\n   272→                \"success\": True,\n   273→                \"type\": \"text_to_image\",\n   274→                \"prompt\": prompt,\n   275→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   276→                \"parameters\": {\n   277→                    \"size\": size,\n   278→                    \"guidance_scale\": guidance_scale,\n   279→                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   280→                    **(({\"seed\": seed} if seedream_provider is None else {})),\n   281→                    \"response_format\": \"url\",  # 固定值\n   282→                    \"watermark\": False,  # 固定值\n   283→                    \"model\": self._resolve_model_id(\n   284→                        \"doubao-seedream-3-0-t2i-250415\",\n   285→                        \"doubao-seedream-4-0-250828\",\n   286→                        \"doubao-seedream-4-5-251128\",\n   287→                    ),\n   288→                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   289→                },\n   290→                \"created_at\": datetime.now().isoformat(),\n   291→                \"usage\": api_result.get(\"usage\", {}),\n   292→            }\n   293→\n   294→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   295→            if sanitized_refs:\n   296→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   297→                result[\"reference_assets\"] = sanitized_refs\n   298→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   299→                logger.info(\n   300→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   301→                    len(sanitized_refs),\n   302→                    masked_ids or \"-\",\n   303→                    self._provider_used(),\n   304→                )\n   305→            else:\n   306→                result[\"parameters\"][\"reference_assets\"] = []\n   307→                result[\"reference_assets\"] = []\n   308→\n   309→            # 保存到本地\n   310→            if save_local and result.get(\"image_url\"):\n   311→                local_result = self._save_image_locally(result)\n   312→                result.update(local_result)\n   313→                if local_result.get('local_save_error') and sanitized_refs:\n   314→                    self._cleanup_reference_paths(ref_paths)\n   315→                    result[\"parameters\"][\"reference_assets\"] = []\n   316→                    result[\"reference_assets\"] = []\n   317→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   318→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   319→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   320→\n   321→            logger.success(f\"文生图任务完成: {task_id}\")\n   322→            return result\n   323→\n   324→        except Exception as e:\n   325→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   326→            self._cleanup_reference_paths(ref_paths)\n   327→            return {\n   328→                \"task_id\": task_id,\n   329→                \"success\": False,\n   330→                \"error\": str(e),\n   331→                \"type\": \"text_to_image\"\n   332→            }\n   333→\n   334→    def generate_image_to_image(\n   335→        self,\n   336→        prompt: str,\n   337→        image: str,\n   338→        guidance_scale: float = 5.5,\n   339→        seed: int = -1,\n   340→        save_local: bool = True,\n   341→        reference_images: Optional[List[Any]] = None,\n   342→        generation_id: Optional[str] = None,\n   343→    ) -> Dict[str, Any]:\n   344→        \"\"\"\n   345→        生成图生图并保存到本地\n   346→\n   347→        Args:\n   348→            prompt: 编辑提示词\n   349→            image_path: 原始图像路径（本地路径或URL）\n   350→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   351→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   352→            response_format: 返回格式，\"url\"或\"b64_json\"\n   353→            save_local: 是否保存到本地\n   354→\n   355→        Returns:\n   356→            Dict: 生成结果\n   357→        \n   358→        Note:\n   359→            model、size、watermark参数已固定，不再需要前端控制\n   360→        \"\"\"\n   361→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   362→\n   363→        # 生成唯一ID，优先使用外部传入的generation_id\n   364→        task_id = generation_id or str(uuid.uuid4())\n   365→\n   366→        ref_paths: List[str] = []\n   367→\n   368→        try:\n   369→            # 处理输入图像\n   370→            image_data = self._prepare_input_image(image)\n   371→            if not image_data:\n   372→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   373→\n   374→            # 处理参考图（复制到 references 并准备 API 载荷）\n   375→            ref_summary = self._process_reference_assets(\n   376→                reference_images,\n   377→                max_refs=MAX_REFERENCE_IMAGES,\n   378→                expected_outputs=1,\n   379→            )\n   380→            ref_assets = ref_summary.get('assets', [])\n   381→            ref_paths = list(ref_summary.get('paths', []))\n   382→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   383→            if ref_summary.get('errors'):\n   384→                logger.warning(\n   385→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   386→                )\n   387→            if ref_summary.get('warnings'):\n   388→                for warn in ref_summary['warnings']:\n   389→                    logger.warning(f\"参考图提示: {warn}\")\n   390→\n   391→            # 前置参数校验（不改变流程，仅记录摘要）\n   392→            fb = False\n   393→            reason = \"\"\n   394→            try:\n   395→                norm, fb, reason = validate_and_normalize_i2i(\n   396→                    ImageToImageParams(\n   397→                        prompt=prompt,\n   398→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   399→                        guidance_scale=guidance_scale,\n   400→                        seed=(None if seed == -1 else seed),\n   401→                        reference_images=ref_payloads,\n   402→                    )\n   403→                )\n   404→                logger.info(\n   405→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   406→                )\n   407→                if fb:\n   408→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   409→            except Exception as _e:\n   410→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   411→\n   412→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   413→            api_result = self.client.image_to_image(\n   414→                prompt=prompt,\n   415→                image=image_data,\n   416→                guidance_scale=guidance_scale,\n   417→                seed=seed,\n   418→                reference_images=(ref_payloads or None),\n   419→            )\n   420→\n   421→            # 处理input_image字段，避免在日志中输出大量base64数据\n   422→            input_image_info = \"[图像数据]\"\n   423→            if image:\n   424→                if image.startswith(\"data:image/\"):\n   425→                    # 如果是base64数据，只保留格式信息\n   426→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   427→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   428→                elif image.startswith((\"http://\", \"https://\")):\n   429→                    # 如果是URL，保留URL\n   430→                    input_image_info = image\n   431→                else:\n   432→                    # 如果是文件路径，只保留文件名\n   433→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   434→            \n   435→            result = {\n   436→                \"task_id\": task_id,\n   437→                \"success\": True,\n   438→                \"type\": \"image_to_image\",\n   439→                \"prompt\": prompt,\n   440→                \"input_image\": input_image_info,\n   441→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   442→                \"parameters\": {\n   443→                    \"guidance_scale\": guidance_scale,\n   444→                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   445→                    **({\"seed\": seed} if (self.client.last_provider() or \"\").lower() not in {\"volc_v4\", \"volc_v4_5\", \"volcengine_v4\", \"volcengine_v4_5\"} else {}),\n   446→                    \"response_format\": \"url\",  # 固定值\n   447→                    \"watermark\": False,  # 固定值\n   448→                    \"size\": \"adaptive\",  # 固定值\n   449→                    \"model\": self._resolve_model_id(\n   450→                        \"doubao-seededit-3-0-i2i-250628\",\n   451→                        \"doubao-seedream-4-0-250828\",\n   452→                        \"doubao-seedream-4-5-251128\",\n   453→                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n   454→                },\n   455→                \"created_at\": datetime.now().isoformat(),\n   456→                \"usage\": api_result.get(\"usage\", {}),\n   457→            }\n   458→\n   459→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   460→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   461→            result[\"reference_assets\"] = sanitized_refs\n   462→            if ref_summary.get('errors'):\n   463→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   464→            if ref_summary.get('warnings'):\n   465→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   466→            if fb and reason:\n   467→                result[\"fallback_applied\"] = True\n   468→                result[\"fallback_reason\"] = reason\n   469→\n   470→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   471→            logger.info(\n   472→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   473→                len(sanitized_refs),\n   474→                masked_ids or \"-\",\n   475→                self._provider_used(),\n   476→            )\n   477→\n   478→            # 保存到本地\n   479→            if save_local and result.get(\"image_url\"):\n   480→                local_result = self._save_image_locally(result)\n   481→                result.update(local_result)\n   482→                if local_result.get('local_save_error'):\n   483→                    self._cleanup_reference_paths(ref_paths)\n   484→                    result[\"parameters\"][\"reference_assets\"] = []\n   485→                    result[\"reference_assets\"] = []\n   486→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   487→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   488→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   489→\n   490→            logger.success(f\"图生图任务完成: {task_id}\")\n   491→            return result\n   492→\n   493→        except Exception as e:\n   494→            # 避免在日志中显示可能包含base64数据的异常信息\n   495→            error_msg = str(e)\n   496→            if len(error_msg) > 200:\n   497→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   498→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   499→            self._cleanup_reference_paths(ref_paths)\n   500→            return {\n   501→                \"task_id\": task_id,\n   502→                \"success\": False,\n   503→                \"error\": error_msg,\n   504→                \"type\": \"image_to_image\"\n   505→            }\n   506→\n   507→    def batch_generate_text_to_image(\n   508→        self,\n   509→        prompts: List[str],\n   510→        size: str = \"1024x1024\",\n   511→        guidance_scale: float = 2.5,\n   512→        save_local: bool = True,\n   513→    ) -> List[Dict[str, Any]]:\n   514→        \"\"\"\n   515→        批量生成文生图（顺序执行，保持向后兼容）\n   516→\n   517→        Args:\n   518→            prompts: 提示词列表\n   519→            size: 图像尺寸\n   520→            guidance_scale: 提示词一致性\n   521→            save_local: 是否保存到本地\n   522→\n   523→        Returns:\n   524→            List[Dict]: 生成结果列表\n   525→        \n   526→        Note:\n   527→            水印参数已固定为False，不再需要前端控制\n   528→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   529→        \"\"\"\n   530→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   531→\n   532→        results = []\n   533→        for i, prompt in enumerate(prompts, 1):\n   534→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   535→\n   536→            result = self.generate_text_to_image(\n   537→                prompt=prompt,\n   538→                size=size,\n   539→                guidance_scale=guidance_scale,\n   540→                save_local=save_local,\n   541→                generation_id=None,\n   542→            )\n   543→\n   544→            results.append(result)\n   545→\n   546→        success_count = sum(1 for r in results if r[\"success\"])\n   547→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   548→\n   549→        return results\n   550→\n   551→    def concurrent_generate_text_to_image(\n   552→        self,\n   553→        prompt: str,\n   554→        count: int = 4,\n   555→        size: str = \"1024x1024\",\n   556→        guidance_scale: float = 2.5,\n   557→        seed: int = -1,\n   558→        save_local: bool = True,\n   559→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   560→        max_workers: int = 5,\n   561→        derived_ids: Optional[List[str]] = None,\n   562→        generation_id: Optional[str] = None,\n   563→        model_variant: Optional[str] = None,\n   564→        sequential_mode: bool = False,\n   565→    ) -> Dict[str, Any]:\n   566→        \"\"\"\n   567→        并发生成多张文生图\n   568→\n   569→        Args:\n   570→            prompt: 图像生成提示词\n   571→            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n   572→            size: 图像尺寸\n   573→            guidance_scale: 引导强度\n   574→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   575→            save_local: 是否保存到本地\n   576→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   577→            max_workers: 最大并发数\n   578→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   579→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   580→\n   581→        Returns:\n   582→            Dict: 包含所有任务结果的字典\n   583→        \"\"\"\n   584→        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n   585→        max_allowed = 15 if sequential_mode else 10\n   586→        if count < 1 or count > max_allowed:\n   587→            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n   588→\n   589→        # 组图模式：单次 API 调用返回多张图\n   590→        if sequential_mode:\n   591→            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n   592→            return self.generate_text_to_image(\n   593→                prompt=prompt,\n   594→                size=size,\n   595→                guidance_scale=guidance_scale,\n   596→                seed=seed,\n   597→                save_local=save_local,\n   598→                model_variant=model_variant,\n   599→                generation_id=generation_id,\n   600→                count=count,\n   601→                sequential_mode=True,\n   602→                derived_ids=derived_ids,\n   603→                progress_callback=progress_callback,\n   604→            )\n   605→        \n   606→        if max_workers > count:\n   607→            max_workers = count\n   608→        \n   609→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   610→        \n   611→        # 生成批次ID\n   612→        batch_id = str(uuid.uuid4())\n   613→        start_time = time.time()\n   614→\n   615→        slots = max(1, count)\n   616→        per_ids: List[str] = list(derived_ids or [])\n   617→        if len(per_ids) < slots:\n   618→            base = generation_id or batch_id\n   619→            for idx in range(len(per_ids), slots):\n   620→                per_ids.append(f\"{base}_{idx + 1}\")\n   621→        \n   622→        # 准备任务参数\n   623→        tasks = []\n   624→        for i in range(count):\n   625→            # 为每个任务生成不同的种子（如果seed为-1）\n   626→            task_seed = seed if seed != -1 else None\n   627→            gen_id = per_ids[i] if i < len(per_ids) else None\n   628→            tasks.append({\n   629→                'prompt': prompt,\n   630→                'size': size,\n   631→                'guidance_scale': guidance_scale,\n   632→                'seed': task_seed,\n   633→                'save_local': save_local,\n   634→                'task_index': i + 1,\n   635→                'generation_id': gen_id,\n   636→                'model_variant': model_variant,\n   637→            })\n   638→        \n   639→        # 使用线程池并发执行\n   640→        results = []\n   641→        completed_count = 0\n   642→        \n   643→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   644→            # 提交所有任务\n   645→            future_to_task = {\n   646→                executor.submit(self._execute_single_text_to_image_task, task): task \n   647→                for task in tasks\n   648→            }\n   649→            \n   650→            # 收集结果\n   651→            for future in as_completed(future_to_task):\n   652→                task = future_to_task[future]\n   653→                try:\n   654→                    result = future.result()\n   655→                    result['task_index'] = task['task_index']\n   656→                    result['batch_id'] = batch_id\n   657→                    results.append(result)\n   658→                    \n   659→                    completed_count += 1\n   660→                    \n   661→                    # 调用进度回调\n   662→                    if progress_callback:\n   663→                        try:\n   664→                            progress_callback(completed_count, count, result)\n   665→                        except Exception as e:\n   666→                            logger.warning(f\"进度回调执行失败: {e}\")\n   667→                    \n   668→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   669→                    \n   670→                except Exception as e:\n   671→                    error_result = {\n   672→                        'task_index': task['task_index'],\n   673→                        'batch_id': batch_id,\n   674→                        'success': False,\n   675→                        'error': str(e),\n   676→                        'type': 'text_to_image'\n   677→                    }\n   678→                    results.append(error_result)\n   679→                    completed_count += 1\n   680→                    \n   681→                    if progress_callback:\n   682→                        try:\n   683→                            progress_callback(completed_count, count, error_result)\n   684→                        except Exception as e:\n   685→                            logger.warning(f\"进度回调执行失败: {e}\")\n   686→                    \n   687→                    # 避免在日志中显示可能包含base64数据的异常信息\n   688→                    error_msg = str(e)\n   689→                    if len(error_msg) > 200:\n   690→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   691→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   692→        \n   693→        # 按task_index排序\n   694→        results.sort(key=lambda x: x.get('task_index', 0))\n   695→        \n   696→        # 统计结果\n   697→        success_count = sum(1 for r in results if r.get('success', False))\n   698→        total_time = time.time() - start_time\n   699→        \n   700→        batch_result = {\n   701→            'batch_id': batch_id,\n   702→            'success': True,\n   703→            'prompt': prompt,\n   704→            'total_count': count,\n   705→            'success_count': success_count,\n   706→            'failed_count': count - success_count,\n   707→            'total_time': round(total_time, 2),\n   708→            'average_time': round(total_time / count, 2),\n   709→            'results': results,\n   710→            'parameters': {\n   711→                'size': size,\n   712→                'guidance_scale': guidance_scale,\n   713→                'seed': seed,\n   714→                'max_workers': max_workers\n   715→            },\n   716→            'derived_ids': per_ids,\n   717→            'created_at': datetime.now().isoformat()\n   718→        }\n   719→        \n   720→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   721→        return batch_result\n   722→\n   723→    def concurrent_generate_image_to_image(\n   724→        self,\n   725→        prompt: str,\n   726→        image: str,\n   727→        count: int = 4,\n   728→        guidance_scale: float = 5.5,\n   729→        seed: int = -1,\n   730→        save_local: bool = True,\n   731→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   732→        max_workers: int = 5,\n   733→        derived_ids: Optional[List[str]] = None,\n   734→        generation_id: Optional[str] = None,\n   735→    ) -> Dict[str, Any]:\n   736→        \"\"\"\n   737→        并发生成多张图生图\n   738→\n   739→        Args:\n   740→            prompt: 编辑提示词\n   741→            image: 输入图像路径或URL\n   742→            count: 生成图片数量，默认4张，最多10张\n   743→            guidance_scale: 引导强度\n   744→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   745→            save_local: 是否保存到本地\n   746→            progress_callback: 进度回调函数\n   747→            max_workers: 最大并发数\n   748→\n   749→        Returns:\n   750→            Dict: 包含所有任务结果的字典\n   751→        \"\"\"\n   752→        # 验证参数\n   753→        if count < 1 or count > 10:\n   754→            raise ValueError(\"生成数量必须在1-10之间\")\n   755→        \n   756→        if max_workers > count:\n   757→            max_workers = count\n   758→        \n   759→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   760→        \n   761→        # 生成批次ID\n   762→        batch_id = str(uuid.uuid4())\n   763→        start_time = time.time()\n   764→        \n   765→        slots = max(1, count)\n   766→        per_ids: List[str] = list(derived_ids or [])\n   767→        if len(per_ids) < slots:\n   768→            base = generation_id or batch_id\n   769→            for idx in range(len(per_ids), slots):\n   770→                per_ids.append(f\"{base}_{idx + 1}\")\n   771→        \n   772→        # 准备输入图像\n   773→        image_data = self._prepare_input_image(image)\n   774→        if not image_data:\n   775→            return {\n   776→                'batch_id': batch_id,\n   777→                'success': False,\n   778→                'error': '无法处理输入图像',\n   779→                'type': 'image_to_image'\n   780→            }\n   781→        \n   782→        # 准备任务参数\n   783→        tasks = []\n   784→        for i in range(count):\n   785→            task_seed = seed if seed != -1 else None\n   786→            gen_id = per_ids[i] if i < len(per_ids) else None\n   787→            tasks.append({\n   788→                'prompt': prompt,\n   789→                'image': image_data,\n   790→                'guidance_scale': guidance_scale,\n   791→                'seed': task_seed,\n   792→                'save_local': save_local,\n   793→                'task_index': i + 1,\n   794→                'generation_id': gen_id\n   795→            })\n   796→        \n   797→        # 使用线程池并发执行\n   798→        results = []\n   799→        completed_count = 0\n   800→        \n   801→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   802→            # 提交所有任务\n   803→            future_to_task = {\n   804→                executor.submit(self._execute_single_image_to_image_task, task): task \n   805→                for task in tasks\n   806→            }\n   807→            \n   808→            # 收集结果\n   809→            for future in as_completed(future_to_task):\n   810→                task = future_to_task[future]\n   811→                try:\n   812→                    result = future.result()\n   813→                    result['task_index'] = task['task_index']\n   814→                    result['batch_id'] = batch_id\n   815→                    results.append(result)\n   816→                    \n   817→                    completed_count += 1\n   818→                    \n   819→                    # 调用进度回调\n   820→                    if progress_callback:\n   821→                        try:\n   822→                            progress_callback(completed_count, count, result)\n   823→                        except Exception as e:\n   824→                            logger.warning(f\"进度回调执行失败: {e}\")\n   825→                    \n   826→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   827→                    \n   828→                except Exception as e:\n   829→                    error_result = {\n   830→                        'task_index': task['task_index'],\n   831→                        'batch_id': batch_id,\n   832→                        'success': False,\n   833→                        'error': str(e),\n   834→                        'type': 'image_to_image'\n   835→                    }\n   836→                    results.append(error_result)\n   837→                    completed_count += 1\n   838→                    \n   839→                    if progress_callback:\n   840→                        try:\n   841→                            progress_callback(completed_count, count, error_result)\n   842→                        except Exception as e:\n   843→                            logger.warning(f\"进度回调执行失败: {e}\")\n   844→                    \n   845→                    # 避免在日志中显示可能包含base64数据的异常信息\n   846→                    error_msg = str(e)\n   847→                    if len(error_msg) > 200:\n   848→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   849→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   850→        \n   851→        # 按task_index排序\n   852→        results.sort(key=lambda x: x.get('task_index', 0))\n   853→        \n   854→        # 统计结果\n   855→        success_count = sum(1 for r in results if r.get('success', False))\n   856→        total_time = time.time() - start_time\n   857→        \n   858→        # 处理input_image字段，避免在日志中输出大量base64数据\n   859→        input_image_info = \"[图像数据]\"\n   860→        if image:\n   861→            if image.startswith(\"data:image/\"):\n   862→                # 如果是base64数据，只保留格式信息\n   863→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   864→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   865→            elif image.startswith((\"http://\", \"https://\")):\n   866→                # 如果是URL，保留URL\n   867→                input_image_info = image\n   868→            else:\n   869→                # 如果是文件路径，只保留文件名\n   870→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   871→        \n   872→        batch_result = {\n   873→            'batch_id': batch_id,\n   874→            'success': True,\n   875→            'prompt': prompt,\n   876→            'input_image': input_image_info,\n   877→            'total_count': count,\n   878→            'success_count': success_count,\n   879→            'failed_count': count - success_count,\n   880→            'total_time': round(total_time, 2),\n   881→            'average_time': round(total_time / count, 2),\n   882→            'results': results,\n   883→            'parameters': {\n   884→                'guidance_scale': guidance_scale,\n   885→                'seed': seed,\n   886→                'max_workers': max_workers\n   887→            },\n   888→            'derived_ids': per_ids,\n   889→            'created_at': datetime.now().isoformat()\n   890→        }\n   891→        \n   892→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   893→        return batch_result\n   894→\n   895→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   896→        \"\"\"\n   897→        执行单个文生图任务\n   898→        \n   899→        Args:\n   900→            task: 任务参数字典\n   901→            \n   902→        Returns:\n   903→            Dict: 任务执行结果\n   904→        \"\"\"\n   905→        return self.generate_text_to_image(\n   906→            prompt=task['prompt'],\n   907→            size=task['size'],\n   908→            guidance_scale=task['guidance_scale'],\n   909→            seed=task['seed'],\n   910→            save_local=task['save_local'],\n   911→            generation_id=task.get('generation_id'),\n   912→            model_variant=task.get('model_variant'),\n   913→        )\n   914→    \n   915→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   916→        \"\"\"\n   917→        执行单个图生图任务\n   918→        \n   919→        Args:\n   920→            task: 任务参数字典\n   921→            \n   922→        Returns:\n   923→            Dict: 任务执行结果\n   924→        \"\"\"\n   925→        # 生成唯一ID，优先使用外部传入的generation_id\n   926→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   927→        \n   928→        try:\n   929→            # 直接使用已经处理好的图片数据，避免重复处理\n   930→            image_data = task['image']\n   931→            \n   932→            # 调用API生成图像\n   933→            api_result = self.client.image_to_image(\n   934→                prompt=task['prompt'], \n   935→                image=image_data, \n   936→                guidance_scale=task['guidance_scale'], \n   937→                seed=task['seed']\n   938→            )\n   939→            \n   940→            result = {\n   941→                \"task_id\": task_id,\n   942→                \"success\": True,\n   943→                \"type\": \"image_to_image\",\n   944→                \"prompt\": task['prompt'],\n   945→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   946→                \"parameters\": {\n   947→                    \"guidance_scale\": task['guidance_scale'], \n   948→                    \"seed\": task['seed'], \n   949→                    \"response_format\": \"url\",\n   950→                    \"watermark\": False,\n   951→                    \"size\": \"adaptive\",\n   952→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   953→                },\n   954→                \"created_at\": datetime.now().isoformat(),\n   955→                \"usage\": api_result.get(\"usage\", {}),\n   956→            }\n   957→            \n   958→            # 保存到本地\n   959→            if task['save_local'] and result.get(\"image_url\"):\n   960→                local_result = self._save_image_locally(result)\n   961→                result.update(local_result)\n   962→            \n   963→            return result\n   964→            \n   965→        except Exception as e:\n   966→            # 避免在日志中显示可能包含base64数据的异常信息\n   967→            error_msg = str(e)\n   968→            if len(error_msg) > 200:\n   969→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   970→            return {\n   971→                \"task_id\": task_id,\n   972→                \"success\": False,\n   973→                \"error\": error_msg,\n   974→                \"type\": \"image_to_image\"\n   975→            }\n   976→\n   977→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   978→        \"\"\"\n   979→        保存图像到本地并记录元数据\n   980→\n   981→        Args:\n   982→            result: API生成结果\n   983→\n   984→        Returns:\n   985→            Dict: 包含本地文件信息的字典\n   986→        \"\"\"\n   987→        try:\n   988→            # 下载图像\n   989→            image_url = result[\"image_url\"]\n   990→            response = safe_requests_get(image_url, timeout=30)\n   991→\n   992→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   993→            from io import BytesIO\n   994→            real_w, real_h = None, None\n   995→            try:\n   996→                with Image.open(BytesIO(response.content)) as img:\n   997→                    real_w, real_h = int(img.width), int(img.height)\n   998→            except Exception as _e:\n   999→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n  1000→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n  1001→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n  1002→\n  1003→            # 组装元数据（适配UnifiedStorageManager的格式）\n  1004→            params = result.get(\"parameters\", {}) or {}\n  1005→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n  1006→            try:\n  1007→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n  1008→                    from math import gcd\n  1009→                    g = gcd(real_w, real_h)\n  1010→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n  1011→            except Exception:\n  1012→                pass\n  1013→\n  1014→            metadata = {\n  1015→                'generation_id': result.get(\"task_id\", \"\"),\n  1016→                'prompt': result.get(\"prompt\", \"\"),\n  1017→                'parameters': params,\n  1018→                'model': params.get(\"model\", \"seedream\"),\n  1019→                'width': real_w,\n  1020→                'height': real_h,\n  1021→                'generation_time': result.get(\"generation_time\", 0),\n  1022→                'batch_id': result.get(\"batch_id\", \"\"),\n  1023→                'status': 'completed'\n  1024→            }\n  1025→            \n  1026→            # 使用统一存储管理器保存文件\n  1027→            save_result = self.storage_manager.save_content_file(\n  1028→                content_type='images',\n  1029→                file_data=response.content,\n  1030→                url=image_url,\n  1031→                metadata=metadata\n  1032→            )\n  1033→\n  1034→            # 获取图像信息（再次确认像素尺寸）\n  1035→            image_info = self._get_image_info(Path(save_result['local_path']))\n  1036→            file_size = Path(save_result['local_path']).stat().st_size\n  1037→\n  1038→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n  1039→\n  1040→            result_obj = {\n  1041→                \"local_path\": save_result['local_path'],\n  1042→                \"filename\": Path(save_result['local_path']).name,\n  1043→                \"file_size\": file_size,\n  1044→                \"image_info\": image_info,\n  1045→                \"file_path\": save_result['local_path'],  # 保持兼容性\n  1046→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n  1047→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n  1048→                \"file_id\": save_result.get('file_id'),\n  1049→                \"relative_path\": save_result.get('relative_path'),\n  1050→            }\n  1051→            try:\n  1052→                w = image_info.get('width') if isinstance(image_info, dict) else None\n  1053→                h = image_info.get('height') if isinstance(image_info, dict) else None\n  1054→                logger.info(\n  1055→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n  1056→                )\n  1057→            except Exception:\n  1058→                pass\n  1059→\n  1060→            # 体验版本地图片水印（使用统一水印服务）\n  1061→            if should_add_watermark():\n  1062→                try:\n  1063→                    from edition.watermark_service import WatermarkService\n  1064→\n  1065→                    watermark_text = get_watermark_text() or \"PIGEON\"\n  1066→                    try:\n  1067→                        opacity = get_watermark_opacity()\n  1068→                    except Exception:\n  1069→                        opacity = 0.3\n  1070→                    opacity = max(0.0, min(opacity, 1.0))\n  1071→\n  1072→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n  1073→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n  1074→                    if watermark_applied:\n  1075→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n  1076→                        result_obj[\"watermark_applied\"] = True\n  1077→                    else:\n  1078→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n  1079→                        result_obj[\"watermark_applied\"] = False\n  1080→                except Exception as e:\n  1081→                    logger.warning(f\"添加图片水印时出错: {e}\")\n  1082→                    result_obj[\"watermark_applied\"] = False\n  1083→\n  1084→            return result_obj\n  1085→\n  1086→        except Exception as e:\n  1087→            logger.error(f\"保存图像到本地失败: {e}\")\n  1088→            try:\n  1089→                logger.info(\"摘要|operation=save_image status=failed\")\n  1090→            except Exception:\n  1091→                pass\n  1092→            return {\"local_save_error\": str(e)}\n  1093→\n  1094→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1095→        checksum = hashlib.sha1(file_data).hexdigest()\n  1096→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1097→        return f\"ref_{ts}_{checksum[:8]}\"\n  1098→\n  1099→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1100→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1101→        source_meta: Dict[str, Any] = {}\n  1102→        raw = ref\n  1103→        if isinstance(ref, dict):\n  1104→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1105→                if ref.get(key) is not None:\n  1106→                    source_meta[key] = ref.get(key)\n  1107→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1108→        if raw is None:\n  1109→            return None\n  1110→\n  1111→        extension = source_meta.get('extension')\n  1112→        data = None\n  1113→        source_repr = source_meta.get('source')\n  1114→\n  1115→        try:\n  1116→            if isinstance(raw, bytes):\n  1117→                data = raw\n  1118→            elif isinstance(raw, str):\n  1119→                stripped = raw.strip()\n  1120→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1121→                    header, payload = stripped.split(';base64,', 1)\n  1122→                    mime_part = header[5:]\n  1123→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n  1124→                    data = base64.b64decode(payload)\n  1125→                    source_repr = source_repr or mime_part\n  1126→                    source_meta.setdefault('type', 'image')\n  1127→                elif stripped.startswith(('http://', 'https://')):\n  1128→                    resp = safe_requests_get(stripped, timeout=15)\n  1129→                    data = resp.content\n  1130→                    parsed = urlparse(stripped)\n  1131→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1132→                    source_repr = source_repr or stripped\n  1133→                    source_meta.setdefault('source_url', stripped)\n  1134→                else:\n  1135→                    path = Path(stripped)\n  1136→                    if not path.exists():\n  1137→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1138→                        return None\n  1139→                    data = path.read_bytes()\n  1140→                    extension = extension or path.suffix or '.png'\n  1141→                    source_repr = source_repr or path.name\n  1142→                    source_meta.setdefault('source_path', str(path))\n  1143→            else:\n  1144→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1145→                return None\n  1146→        except Exception as exc:\n  1147→            logger.warning(f\"加载参考图失败: {exc}\")\n  1148→            return None\n  1149→\n  1150→        if data is None:\n  1151→            return None\n  1152→\n  1153→        width = source_meta.get('width')\n  1154→        height = source_meta.get('height')\n  1155→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1156→            try:\n  1157→                from io import BytesIO\n  1158→\n  1159→                with Image.open(BytesIO(data)) as img:\n  1160→                    width = img.width\n  1161→                    height = img.height\n  1162→            except Exception:\n  1163→                pass\n  1164→\n  1165→        source_meta['width'] = width\n  1166→        source_meta['height'] = height\n  1167→        source_meta.setdefault('type', 'image')\n  1168→        source_meta['source'] = source_repr or source_meta.get('source')\n  1169→\n  1170→        return data, extension, source_meta\n  1171→\n  1172→    def _process_reference_assets(\n  1173→        self,\n  1174→        references: Optional[List[Any]],\n  1175→        *,\n  1176→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1177→        expected_outputs: int = 1,\n  1178→    ) -> Dict[str, Any]:\n  1179→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1180→        stored: List[Dict[str, Any]] = []\n  1181→        absolute_paths: List[str] = []\n  1182→        errors: List[str] = []\n  1183→        warnings: List[str] = []\n  1184→\n  1185→        if not references:\n  1186→            return {\n  1187→                'assets': stored,\n  1188→                'paths': absolute_paths,\n  1189→                'errors': errors,\n  1190→                'warnings': warnings,\n  1191→            }\n  1192→\n  1193→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1194→            warnings.append(\n  1195→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1196→            )\n  1197→            references = references[:max_refs]\n  1198→\n  1199→        for order, item in enumerate(references):\n  1200→            load_result = self._load_reference_source(item)\n  1201→            if not load_result:\n  1202→                errors.append(f\"ref[{order}] 加载失败\")\n  1203→                continue\n  1204→\n  1205→            file_data, extension, meta = load_result\n  1206→            meta.setdefault('order', order)\n  1207→            meta.setdefault('kind', meta.get('type', 'image'))\n  1208→\n  1209→            try:\n  1210→                asset_id = self._generate_reference_asset_id(file_data)\n  1211→                record = self.storage_manager.save_reference_asset(\n  1212→                    'images',\n  1213→                    file_data,\n  1214→                    asset_id=asset_id,\n  1215→                    extension=extension,\n  1216→                    metadata=meta,\n  1217→                )\n  1218→                try:\n  1219→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1220→                except Exception:\n  1221→                    record['_payload_b64'] = None\n  1222→                record['_source_meta'] = meta\n  1223→                stored.append(record)\n  1224→                if record.get('absolute_path'):\n  1225→                    absolute_paths.append(record['absolute_path'])\n  1226→            except Exception as exc:\n  1227→                logger.warning(f\"保存参考图失败: {exc}\")\n  1228→                errors.append(f\"ref[{order}] 保存失败\")\n  1229→\n  1230→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1231→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1232→            if len(stored) > allowed:\n  1233→                warnings.append(\n  1234→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1235→                )\n  1236→                stored = stored[:allowed]\n  1237→                absolute_paths = absolute_paths[:allowed]\n  1238→\n  1239→        return {\n  1240→            'assets': stored,\n  1241→            'paths': absolute_paths,\n  1242→            'errors': errors,\n  1243→            'warnings': warnings,\n  1244→        }\n  1245→\n  1246→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1247→        payloads: List[str] = []\n  1248→        for asset in assets or []:\n  1249→            payload = asset.get('_payload_b64')\n  1250→            if not payload:\n  1251→                continue\n  1252→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1253→            mime = 'image/png'\n  1254→            try:\n  1255→                if path_hint:\n  1256→                    suffix = Path(path_hint).suffix.lower()\n  1257→                    if suffix in {'.jpg', '.jpeg'}:\n  1258→                        mime = 'image/jpeg'\n  1259→                    elif suffix == '.webp':\n  1260→                        mime = 'image/webp'\n  1261→                    elif suffix == '.bmp':\n  1262→                        mime = 'image/bmp'\n  1263→                    elif suffix == '.gif':\n  1264→                        mime = 'image/gif'\n  1265→            except Exception:\n  1266→                pass\n  1267→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1268→        return payloads\n  1269→\n  1270→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1271→        provider = (self.client.last_provider() or \"\").lower()\n  1272→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1273→            return v4_5_model or v4_model\n  1274→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1275→            return v4_model\n  1276→        return default_model\n  1277→\n  1278→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1279→        cleaned: List[Dict[str, Any]] = []\n  1280→        for rec in assets or []:\n  1281→            rec.pop('_payload_b64', None)\n  1282→            rec.pop('_source_meta', None)\n  1283→            rec.pop('absolute_path', None)\n  1284→            cleaned.append({\n  1285→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1286→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1287→                'type': rec.get('type'),\n  1288→                'kind': rec.get('kind'),\n  1289→                'source': rec.get('source'),\n  1290→                'order': rec.get('order'),\n  1291→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1292→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1293→                'width': rec.get('width'),\n  1294→                'height': rec.get('height'),\n  1295→                'created_at': rec.get('created_at'),\n  1296→            })\n  1297→        return cleaned\n  1298→\n  1299→    @staticmethod\n  1300→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1301→        masked: List[str] = []\n  1302→        for rec in assets or []:\n  1303→            rid = rec.get('id') or ''\n  1304→            if not rid:\n  1305→                continue\n  1306→            masked.append(f\"{rid[:6]}***\")\n  1307→        return \",\".join(masked)\n  1308→\n  1309→    @staticmethod\n  1310→    def _provider_hint() -> str:\n  1311→        try:\n  1312→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1313→        except Exception:\n  1314→            return \"unknown\"\n  1315→\n  1316→    def _provider_used(self) -> str:\n  1317→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1318→        if provider:\n  1319→            return provider\n  1320→        return self._provider_hint()\n  1321→\n  1322→    @staticmethod\n  1323→    def _cleanup_reference_paths(paths: List[str]):\n  1324→        for path in paths or []:\n  1325→            try:\n  1326→                if path and Path(path).exists():\n  1327→                    Path(path).unlink(missing_ok=True)\n  1328→            except Exception as exc:\n  1329→                logger.debug(f\"参考图清理失败: {exc}\")\n  1330→\n  1331→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1332→        \"\"\"\n  1333→        准备输入图像，支持本地文件和URL\n  1334→        \n  1335→        Args:\n  1336→            image_path: 图像路径（本地路径或URL）\n  1337→            \n  1338→        Returns:\n  1339→            str: 图像URL、base64数据或None\n  1340→        \"\"\"\n  1341→        try:\n  1342→            # 如果是URL，直接返回\n  1343→            if image_path.startswith((\"http://\", \"https://\")):\n  1344→                return image_path\n  1345→\n  1346→            # 如果是本地文件，转换为Base64\n  1347→            local_path = Path(image_path)\n  1348→            if local_path.exists():\n  1349→                with open(local_path, \"rb\") as f:\n  1350→                    image_data = f.read()\n  1351→\n  1352→                # 检测图像格式\n  1353→                image = Image.open(local_path)\n  1354→                format_name = image.format.lower()\n  1355→\n  1356→                # 转换为Base64\n  1357→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1358→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1359→\n  1360→            logger.error(f\"图像文件不存在: {image_path}\")\n  1361→            return None\n  1362→\n  1363→        except Exception as e:\n  1364→            logger.error(f\"处理输入图像失败: {e}\")\n  1365→            return None\n  1366→\n  1367→    def _extract_width_from_size(self, size: str) -> int:\n  1368→        \"\"\"\n  1369→        从尺寸字符串中提取宽度\n  1370→        \n  1371→        Args:\n  1372→            size: 尺寸字符串，如 \"1024x1024\"\n  1373→            \n  1374→        Returns:\n  1375→            int: 宽度值\n  1376→        \"\"\"\n  1377→        try:\n  1378→            return int(size.split('x')[0])\n  1379→        except (ValueError, IndexError):\n  1380→            return 1024  # 默认值\n  1381→    \n  1382→    def _extract_height_from_size(self, size: str) -> int:\n  1383→        \"\"\"\n  1384→        从尺寸字符串中提取高度\n  1385→        \n  1386→        Args:\n  1387→            size: 尺寸字符串，如 \"1024x1024\"\n  1388→            \n  1389→        Returns:\n  1390→            int: 高度值\n  1391→        \"\"\"\n  1392→        try:\n  1393→            return int(size.split('x')[1])\n  1394→        except (ValueError, IndexError):\n  1395→            return 1024  # 默认值\n  1396→\n  1397→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1398→        \"\"\"\n  1399→        获取图像信息\n  1400→\n  1401→        Args:\n  1402→            image_path: 图像文件路径\n  1403→\n  1404→        Returns:\n  1405→            Dict: 图像信息\n  1406→        \"\"\"\n  1407→        try:\n  1408→            with Image.open(image_path) as img:\n  1409→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1410→        except Exception as e:\n  1411→            logger.error(f\"获取图像信息失败: {e}\")\n  1412→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1413→\n  1414→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1415→        \"\"\"\n  1416→        获取图像生成历史记录\n  1417→\n  1418→        Args:\n  1419→            limit: 返回记录数量限制\n  1420→\n  1421→        Returns:\n  1422→            List[Dict]: 历史记录列表\n  1423→        \"\"\"\n  1424→        return self.storage_manager.load_history('images', limit=limit)\n  1425→\n  1426→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1427→        \"\"\"\n  1428→        根据提示词关键字搜索历史记录\n  1429→\n  1430→        Args:\n  1431→            keyword: 搜索关键字\n  1432→\n  1433→        Returns:\n  1434→            List[Dict]: 匹配的记录列表\n  1435→        \"\"\"\n  1436→        # 获取所有历史记录并在内存中过滤\n  1437→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1438→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1439→\n  1440→    def get_statistics(self) -> Dict[str, Any]:\n  1441→        \"\"\"\n  1442→        获取生成统计信息\n  1443→\n  1444→        Returns:\n  1445→            Dict: 统计信息\n  1446→        \"\"\"\n  1447→        try:\n  1448→            # 使用统一存储管理器获取存储统计\n  1449→            storage_stats = self.storage_manager.get_storage_stats()\n  1450→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1451→            \n  1452→            # 获取历史记录进行详细统计\n  1453→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1454→            \n  1455→            if not all_records:\n  1456→                return {\n  1457→                    \"total_images\": 0,\n  1458→                    \"text_to_image_count\": 0,\n  1459→                    \"image_to_image_count\": 0,\n  1460→                    \"total_file_size\": 0,\n  1461→                    \"average_file_size\": 0,\n  1462→                    \"most_common_size\": \"unknown\"\n  1463→                }\n  1464→\n  1465→            # 统计不同类型的图片数量\n  1466→            text_to_image_count = 0\n  1467→            image_to_image_count = 0\n  1468→            total_file_size = 0\n  1469→            sizes = []\n  1470→            \n  1471→            for record in all_records:\n  1472→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1473→                if 'input_image' in record.get('parameters', {}):\n  1474→                    image_to_image_count += 1\n  1475→                else:\n  1476→                    text_to_image_count += 1\n  1477→                \n  1478→                # 计算文件大小\n  1479→                file_size = record.get('file_size', 0)\n  1480→                if isinstance(file_size, str) and file_size.isdigit():\n  1481→                    file_size = int(file_size)\n  1482→                elif not isinstance(file_size, (int, float)):\n  1483→                    file_size = 0\n  1484→                total_file_size += file_size\n  1485→                \n  1486→                # 收集尺寸信息\n  1487→                width = record.get('width', 0)\n  1488→                height = record.get('height', 0)\n  1489→                if width and height:\n  1490→                    sizes.append(f\"{width}x{height}\")\n  1491→\n  1492→            stats = {\n  1493→                \"total_images\": len(all_records),\n  1494→                \"text_to_image_count\": text_to_image_count,\n  1495→                \"image_to_image_count\": image_to_image_count,\n  1496→                \"total_file_size\": total_file_size,\n  1497→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1498→                \"most_common_size\": \"unknown\",\n  1499→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1500→            }\n  1501→\n  1502→            # 最常用的尺寸\n  1503→            if sizes:\n  1504→                from collections import Counter\n  1505→                size_counts = Counter(sizes)\n  1506→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1507→\n  1508→            return stats\n  1509→\n  1510→        except Exception as e:\n  1511→            logger.error(f\"获取统计信息失败: {e}\")\n  1512→            return {\n  1513→                \"total_images\": 0,\n  1514→                \"text_to_image_count\": 0,\n  1515→                \"image_to_image_count\": 0,\n  1516→                \"total_file_size\": 0,\n  1517→                \"average_file_size\": 0,\n  1518→                \"most_common_size\": \"unknown\"\n  1519→            }\n  1520→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9e5f1cb3-3aad-4e8d-a2ae-cc42e9e0fa6c","timestamp":"2026-01-08T08:39:23.000Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config.unified_config import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        storage_dir = get_storage_dir()\n        if not storage_dir:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        self.storage_manager = get_v2_storage_manager(storage_dir)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n        count: int = 1,\n        sequential_mode: bool = False,\n        derived_ids: Optional[List[str]] = None,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            count: 生成图片数量（组图模式下生效）\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n            derived_ids: 组图生成的ID列表（用于关联）\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n\n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n\n        # 根据 model_variant 选择 provider（并发安全：不写 env）\n        seedream_provider: Optional[str] = None\n        try:\n            mv = (model_variant or \"\").strip().lower()\n            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n                seedream_provider = \"volc_v4\"\n            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n                seedream_provider = \"volc_v4_5\"\n            elif mv.startswith(\"volc_\"):\n                seedream_provider = mv\n        except Exception:\n            seedream_provider = None\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            actual_count = max(1, count)\n            use_group_mode = bool(sequential_mode and actual_count > 1)\n\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n                n=actual_count if use_group_mode else 1,\n                sequential_mode=sequential_mode,\n                seedream_provider=seedream_provider,\n            )\n\n            # 组图模式：API 返回多张图，需要逐一保存\n            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n            images_count = len(images_list)\n            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n\n            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n            if use_group_mode and images_count < actual_count:\n                logger.warning(\n                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n                )\n\n            if use_group_mode and images_count > 1:\n                results_batch = []\n                success_count = 0\n                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n                total_images = len(images_list)\n\n                for idx, img_data in enumerate(images_list):\n                    # 发送下载进度（每张图开始下载时）\n                    if progress_callback:\n                        try:\n                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n                        except Exception:\n                            pass\n\n                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n                    per_result = {\n                        \"task_id\": per_id,\n                        \"success\": True,\n                        \"type\": \"text_to_image\",\n                        \"prompt\": prompt,\n                        \"image_url\": img_data[\"url\"],\n                        \"parameters\": {\n                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                            **(({\"seed\": seed} if seedream_provider is None else {})),\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,\n                        },\n                        \"created_at\": datetime.now().isoformat(),\n                        \"usage\": api_result.get(\"usage\", {}),\n                    }\n\n                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n                    if sanitized_refs:\n                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                        per_result[\"reference_assets\"] = sanitized_refs\n\n                    if save_local and per_result.get(\"image_url\"):\n                        local_result = self._save_image_locally(per_result)\n                        per_result.update(local_result)\n                        if not local_result.get('local_save_error'):\n                            success_count += 1\n\n                    results_batch.append(per_result)\n\n                    # 发送下载完成进度\n                    if progress_callback:\n                        try:\n                            progress_callback(idx + 1, total_images, per_result)\n                        except Exception:\n                            pass\n\n                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n                return {\n                    \"batch\": True,\n                    \"results\": results_batch,\n                    \"success_count\": success_count,\n                    \"total_count\": len(results_batch),\n                    \"derived_ids\": group_ids,\n                }\n\n            # 单图模式（默认）\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                    **(({\"seed\": seed} if seedream_provider is None else {})),\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    ),\n                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale,\n                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                    **({\"seed\": seed} if (self.client.last_provider() or \"\").lower() not in {\"volc_v4\", \"volc_v4_5\", \"volcengine_v4\", \"volcengine_v4_5\"} else {}),\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        sequential_mode: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n        max_allowed = 15 if sequential_mode else 10\n        if count < 1 or count > max_allowed:\n            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n\n        # 组图模式：单次 API 调用返回多张图\n        if sequential_mode:\n            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n            return self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=save_local,\n                model_variant=model_variant,\n                generation_id=generation_id,\n                count=count,\n                sequential_mode=True,\n                derived_ids=derived_ids,\n                progress_callback=progress_callback,\n            )\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1520,"startLine":1,"totalLines":1520}},"sourceToolAssistantUUID":"545cae47-36ce-4eaa-a508-dff639c69221"}
{"parentUuid":"eac59ea2-7ae8-45a7-9dff-41f1119aacab","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012goiBaUJ5cPmKeKhbEFL5i","type":"tool_result","content":"     1→# Seedream图像生成客户端\n     2→# 封装火山引擎Seedream3.0 API调用\n     3→\n     4→import json\n     5→import os\n     6→import requests\n     7→from requests.exceptions import Timeout, ReadTimeout, ConnectTimeout\n     8→import time\n     9→import random\n    10→from typing import Dict, Any, Optional, List\n    11→from pathlib import Path\n    12→from loguru import logger\n    13→from urllib3.util.retry import Retry\n    14→from requests.adapters import HTTPAdapter\n    15→\n    16→# 导入配置管理器和错误处理\n    17→from config.unified_config import get_unified_config\n    18→from utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n    19→\n    20→\n    21→class SeedreamClient:\n    22→    \"\"\"火山引擎Seedream图片生成客户端\n    23→\n    24→    提供文生图和图生图功能\n    25→    \"\"\"\n    26→\n    27→    def __init__(\n    28→        self,\n    29→        api_key: Optional[str] = None,\n    30→        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n    31→        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n    32→        timeout: int = 60,\n    33→        max_retries: int = 3,\n    34→    ):\n    35→        \"\"\"初始化Seedream客户端\n    36→\n    37→        Args:\n    38→            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n    39→            base_url: API基础URL\n    40→            timeout: 请求超时时间（秒）\n    41→            max_retries: 最大重试次数\n    42→        \"\"\"\n    43→        # 获取API密钥\n    44→        if api_key is None:\n    45→            try:\n    46→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    47→            except Exception as exc:\n    48→                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n    49→\n    50→        self.api_key = api_key\n    51→        self.base_url = base_url.rstrip(\"/\")\n    52→        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n    53→        self.timeout = timeout\n    54→        self.max_retries = max_retries\n    55→\n    56→        # 配置会话\n    57→        self.session = requests.Session()\n    58→\n    59→        # 配置重试策略\n    60→        retry_strategy = Retry(\n    61→            total=max_retries,\n    62→            status_forcelist=[429, 500, 502, 503, 504],\n    63→            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n    64→            backoff_factor=1\n    65→        )\n    66→\n    67→        adapter = HTTPAdapter(max_retries=retry_strategy)\n    68→        self.session.mount(\"http://\", adapter)\n    69→        self.session.mount(\"https://\", adapter)\n    70→\n    71→        logger.info(\"Seedream客户端初始化完成\")\n    72→\n    73→        # 初始化性能监控与错误缓存（统一结构）\n    74→        self._performance_stats = {\n    75→            \"total_requests\": 0,\n    76→            \"successful_requests\": 0,\n    77→            \"failed_requests\": 0,\n    78→            \"total_response_time\": 0.0,\n    79→            \"last_request_time\": None,\n    80→        }\n    81→        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n    82→        self._last_provider: Optional[str] = None\n    83→        self._last_endpoint: Optional[str] = None\n    84→\n    85→    def _encode_image(self, image_path: str) -> str:\n    86→        \"\"\"将图像文件编码为base64字符串\n    87→        \n    88→        Args:\n    89→            image_path: 图像文件路径\n    90→            \n    91→        Returns:\n    92→            base64编码的图像字符串\n    93→        \"\"\"\n    94→        import base64\n    95→        \n    96→        try:\n    97→            with open(image_path, 'rb') as image_file:\n    98→                image_data = image_file.read()\n    99→                base64_string = base64.b64encode(image_data).decode('utf-8')\n   100→                return base64_string\n   101→        except Exception as e:\n   102→            # 避免在日志中显示可能包含base64数据的异常信息\n   103→            error_msg = str(e)\n   104→            if len(error_msg) > 200:\n   105→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   106→            logger.error(f\"图像编码失败: {error_msg}\")\n   107→            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n   108→\n   109→    def _get_headers(self) -> Dict[str, str]:\n   110→        \"\"\"获取请求头\"\"\"\n   111→        # 验证API密钥，防止尺寸配置被错误使用\n   112→        api_key = str(self.api_key).strip()\n   113→\n   114→        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n   115→        try:\n   116→            api_key.encode('ascii')\n   117→        except UnicodeEncodeError:\n   118→            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n   119→\n   120→        # 检查是否包含尺寸信息或换行符\n   121→        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n   122→            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n   123→\n   124→        # 检查API密钥长度\n   125→        if len(api_key) < 10 or len(api_key) > 200:\n   126→            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n   127→        \n   128→        return {\n   129→            \"Authorization\": f\"Bearer {api_key}\",\n   130→            \"Content-Type\": \"application/json; charset=utf-8\",\n   131→            \"User-Agent\": \"Seedream-Client/1.0.0\",\n   132→        }\n   133→\n   134→    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n   135→        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\n   136→\n   137→        注意：当 timeout > 120 时，使用独立的 requests.post() 而不是 session.post()。\n   138→        这是因为 Session 配置了 Retry 策略，会在超时后自动重试，导致：\n   139→        1. 实际等待时间 = timeout × (1 + retry_count)，可能长达数十分钟\n   140→        2. 重试期间没有日志输出，用户看起来像\"卡住\"\n   141→\n   142→        对于组图等长时间请求，我们需要精确控制超时，不希望自动重试。\n   143→        \"\"\"\n   144→        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   145→        start = time.time()\n   146→\n   147→        # 长超时请求（组图模式）：绕过 Session 重试机制\n   148→        if timeout > 120:\n   149→            logger.info(f\"[HTTP POST] 长时间请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s (无重试)\")\n   150→            try:\n   151→                # 直接使用 requests.post，不经过 session 的重试策略\n   152→                resp = requests.post(url, headers=headers, data=body, timeout=(30, timeout))\n   153→                elapsed = time.time() - start\n   154→                logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n   155→                return resp\n   156→            except Exception as e:\n   157→                elapsed = time.time() - start\n   158→                logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n   159→                raise\n   160→\n   161→        # 普通请求：使用 session（带重试机制）\n   162→        logger.info(f\"[HTTP POST] 开始请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s\")\n   163→        try:\n   164→            resp = self.session.post(url, headers=headers, data=body, timeout=(30, timeout))\n   165→            elapsed = time.time() - start\n   166→            logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n   167→            return resp\n   168→        except Exception as e:\n   169→            elapsed = time.time() - start\n   170→            logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n   171→            raise\n   172→\n   173→    def _is_large_size(self, size: str) -> bool:\n   174→        \"\"\"判断是否是 v4.5 大尺寸（超过 v3 的 2048 限制）\"\"\"\n   175→        if not size:\n   176→            return False\n   177→        try:\n   178→            if \"x\" in size.lower():\n   179→                w, h = size.lower().split(\"x\")\n   180→                return int(w) > 2048 or int(h) > 2048\n   181→            # 处理 2K/4K 格式\n   182→            if size.upper() in (\"2K\", \"4K\"):\n   183→                return True\n   184→        except Exception:\n   185→            pass\n   186→        return False\n   187→\n   188→    def _provider_enabled(self) -> bool:\n   189→        try:\n   190→            import os\n   191→            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n   192→            return v not in {\"0\", \"false\", \"no\"}\n   193→        except Exception:\n   194→            return True\n   195→\n   196→    def _get_seedream_provider_order(self, preferred_provider: Optional[str] = None) -> List[str]:\n   197→        \"\"\"计算 Seedream provider 调用顺序。\n   198→\n   199→        规则：\n   200→        - 优先使用调用方传入的 preferred_provider（并发安全）\n   201→        - 其次允许通过环境变量 GEMENG_SEEDREAM_PROVIDER 启动覆盖（只读）\n   202→        - 最后兜底 volc_v3\n   203→        \"\"\"\n   204→        order: List[str] = []\n   205→\n   206→        candidates: List[Optional[str]] = []\n   207→        if preferred_provider:\n   208→            candidates.append(preferred_provider)\n   209→        try:\n   210→            candidates.append(os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\"))\n   211→        except Exception:\n   212→            candidates.append(None)\n   213→\n   214→        for candidate in candidates:\n   215→            if not candidate:\n   216→                continue\n   217→            name = candidate.strip().lower()\n   218→            if not name:\n   219→                continue\n   220→            if name not in order:\n   221→                order.append(name)\n   222→\n   223→        if \"volc_v3\" not in order:\n   224→            order.append(\"volc_v3\")\n   225→        return order\n   226→\n   227→    def _call_seedream_provider(\n   228→        self,\n   229→        headers: Dict[str, str],\n   230→        mapper,\n   231→        operation: str,\n   232→        preferred_provider: Optional[str] = None,\n   233→    ):\n   234→        from modules.provider.factory import get_default_provider\n   235→        default_endpoint = \"/images/generations\"\n   236→        base_url = self.base_url.rstrip(\"/\")\n   237→        first_choice = None\n   238→        last_error: Optional[BaseException] = None\n   239→        order = self._get_seedream_provider_order(preferred_provider)\n   240→        if order:\n   241→            first_choice = order[0]\n   242→        for idx, name in enumerate(order):\n   243→            try:\n   244→                provider = get_default_provider(name)\n   245→            except Exception as e:\n   246→                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n   247→                last_error = e\n   248→                continue\n   249→            try:\n   250→                mapped = mapper(provider)\n   251→                if not isinstance(mapped, tuple):\n   252→                    raise ValueError(\"provider mapper 返回值异常\")\n   253→                if len(mapped) == 4:\n   254→                    payload, fb, reason, endpoint = mapped\n   255→                elif len(mapped) == 3:\n   256→                    payload, fb, reason = mapped\n   257→                    endpoint = default_endpoint\n   258→                else:\n   259→                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n   260→            except Exception as e:\n   261→                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n   262→                last_error = e\n   263→                continue\n   264→            start_time = time.time()\n   265→            try:\n   266→                endpoint_path = endpoint or default_endpoint\n   267→                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n   268→                    request_url = endpoint_path\n   269→                else:\n   270→                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   271→                    if not normalized.startswith(\"/\"):\n   272→                        normalized = f\"/{normalized}\"\n   273→                    request_url = f\"{base_url}{normalized}\"\n   274→\n   275→                # 动态超时：组图模式需要更长时间\n   276→                # 实测：5 张 4096x4096 约需 8 分钟（458 秒）\n   277→                timeout = 120\n   278→                seq_options = payload.get(\"sequential_image_generation_options\")\n   279→                max_images = seq_options.get(\"max_images\", 1) if seq_options else 1\n   280→                if max_images > 1:\n   281→                    # 组图模式：基础 120 秒 + 每张图 60 秒，最大 20 分钟\n   282→                    # 实测：15 张 4096x4096 约需 14.5 分钟（869 秒）\n   283→                    timeout = min(120 + max_images * 60, 1200)\n   284→                    logger.info(f\"组图模式: {max_images} 张图，超时设置为 {timeout} 秒\")\n   285→\n   286→                response = self._safe_json_post(request_url, headers, payload, timeout=timeout)\n   287→                result = self._handle_response(response)\n   288→                elapsed = time.time() - start_time\n   289→                if idx > 0 and first_choice:\n   290→                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n   291→                if fb and reason:\n   292→                    logger.warning(f\"参数回退: {reason}\")\n   293→                logger.info(\n   294→                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n   295→                )\n   296→                self._last_provider = name\n   297→                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   298→                return result, payload, endpoint_path, name, fb, reason, elapsed\n   299→            except AppError as e:\n   300→                last_error = e\n   301→                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n   302→                # v4.5 特有功能失败时不回退到 v3（参数不兼容）\n   303→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   304→                    is_v45_feature = (\n   305→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   306→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   307→                    )\n   308→                    if is_v45_feature:\n   309→                        logger.error(f\"v4.5 特有功能失败，不回退: {e.message}\")\n   310→                        raise\n   311→                continue\n   312→            except (Timeout, ReadTimeout, ConnectTimeout) as e:\n   313→                elapsed = time.time() - start_time\n   314→                last_error = e\n   315→                logger.error(f\"Seedream provider {name} 请求超时 ({elapsed:.1f}s): {e}\")\n   316→                # v4.5 特有功能超时时直接报错，不回退\n   317→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   318→                    is_v45_feature = (\n   319→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   320→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   321→                    )\n   322→                    if is_v45_feature:\n   323→                        raise AppError(\n   324→                            f\"组图生成超时 ({elapsed:.0f}秒)，请减少生成数量或稍后重试\",\n   325→                            ErrorType.NETWORK_ERROR\n   326→                        )\n   327→                continue\n   328→            except Exception as e:\n   329→                last_error = e\n   330→                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n   331→                # v4.5 特有功能异常时也不回退\n   332→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   333→                    is_v45_feature = (\n   334→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   335→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   336→                    )\n   337→                    if is_v45_feature:\n   338→                        logger.error(f\"v4.5 特有功能异常，不回退: {e}\")\n   339→                        raise\n   340→                continue\n   341→        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n   342→\n   343→    def _log_seedream_event(\n   344→        self,\n   345→        operation: str,\n   346→        status: str,\n   347→        provider: Optional[str],\n   348→        endpoint: Optional[str],\n   349→        elapsed: float,\n   350→        fallback_applied: bool,\n   351→        fallback_reason: Optional[str] = None,\n   352→        extra: Optional[Dict[str, Any]] = None,\n   353→    ) -> None:\n   354→        try:\n   355→            provider_name = provider or \"unknown\"\n   356→            endpoint_text = endpoint or \"/images/generations\"\n   357→            parts = [\n   358→                f\"operation={operation}\",\n   359→                f\"status={status}\",\n   360→                f\"provider={provider_name}\",\n   361→                f\"endpoint={endpoint_text}\",\n   362→                f\"elapsed={elapsed:.2f}s\",\n   363→                f\"fallback={'yes' if fallback_applied else 'no'}\",\n   364→            ]\n   365→            if fallback_applied and fallback_reason:\n   366→                safe_reason = str(fallback_reason)\n   367→                if len(safe_reason) > 120:\n   368→                    safe_reason = safe_reason[:120] + \"...\"\n   369→                parts.append(f\"fallback_reason={safe_reason}\")\n   370→            if extra:\n   371→                for key, value in extra.items():\n   372→                    if value is None:\n   373→                        continue\n   374→                    parts.append(f\"{key}={value}\")\n   375→            logger.info(\"摘要|\" + \" \".join(parts))\n   376→        except Exception:\n   377→            # 保证日志逻辑不会影响主流程\n   378→            pass\n   379→\n   380→    @staticmethod\n   381→    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n   382→        mime = \"image/png\"\n   383→        try:\n   384→            if path_hint:\n   385→                suffix = Path(path_hint).suffix.lower()\n   386→                if suffix in {\".jpg\", \".jpeg\"}:\n   387→                    mime = \"image/jpeg\"\n   388→                elif suffix == \".webp\":\n   389→                    mime = \"image/webp\"\n   390→                elif suffix == \".bmp\":\n   391→                    mime = \"image/bmp\"\n   392→                elif suffix == \".gif\":\n   393→                    mime = \"image/gif\"\n   394→        except Exception:\n   395→            pass\n   396→        return f\"data:{mime};base64,{b64_data}\"\n   397→\n   398→    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n   399→        \"\"\"处理API响应\n   400→\n   401→        Args:\n   402→            response: HTTP响应对象\n   403→\n   404→        Returns:\n   405→            解析后的响应数据\n   406→\n   407→        Raises:\n   408→            AppError: 当API返回错误时\n   409→        \"\"\"\n   410→        try:\n   411→            if not response.ok:\n   412→                try:\n   413→                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n   414→                except Exception:\n   415→                    error_text = str(response.content[:500])\n   416→                # 避免在日志中显示可能包含base64数据的完整响应\n   417→                if len(error_text) > 500:\n   418→                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n   419→                else:\n   420→                    error_summary = error_text\n   421→                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n   422→                raise AppError(\n   423→                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n   424→                    ErrorType.API_ERROR,\n   425→                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n   426→                )\n   427→\n   428→            # 解析响应（增强容错：包括编码问题回退）\n   429→            try:\n   430→                result = response.json()\n   431→            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n   432→                raw = response.content or b\"\"\n   433→                tried = set()\n   434→                result = None\n   435→                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n   436→                    if not enc or enc in tried:\n   437→                        continue\n   438→                    tried.add(enc)\n   439→                    try:\n   440→                        text = raw.decode(enc, errors=\"strict\")\n   441→                        result = json.loads(text)\n   442→                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n   443→                        break\n   444→                    except Exception:\n   445→                        continue\n   446→                if result is None:\n   447→                    try:\n   448→                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n   449→                    except Exception:\n   450→                        preview = str(raw[:200])\n   451→                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n   452→                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n   453→\n   454→            # OpenAI格式的响应检查\n   455→            if \"data\" not in result:\n   456→                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n   457→                logger.error(f\"Seedream API错误: {error_msg}\")\n   458→                raise AppError(\n   459→                    f\"API错误: {error_msg}\",\n   460→                    ErrorType.API_ERROR,\n   461→                    {\"response_data\": result},\n   462→                )\n   463→\n   464→            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n   465→            images = []\n   466→            for item in result[\"data\"]:\n   467→                if \"url\" in item:\n   468→                    images.append({\n   469→                        \"url\": item[\"url\"]\n   470→                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n   471→                    })\n   472→\n   473→            # 调试日志：输出组图返回的图片数量\n   474→            logger.debug(f\"API 返回 {len(images)} 张图片\")\n   475→\n   476→            return {\n   477→                \"code\": 200,\n   478→                \"message\": \"success\",\n   479→                \"data\": {\n   480→                    \"images\": images\n   481→                },\n   482→                \"created\": result.get(\"created\"),\n   483→                \"usage\": result.get(\"usage\", {})\n   484→            }\n   485→\n   486→        except requests.exceptions.RequestException as e:\n   487→            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n   488→        except json.JSONDecodeError as e:\n   489→            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n   490→\n   491→    def _record_request_stats(\n   492→        self,\n   493→        operation: str,\n   494→        success: bool,\n   495→        response_time: float,\n   496→        error_code: Optional[str] = None,\n   497→        error_message: Optional[str] = None,\n   498→    ) -> None:\n   499→        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n   500→        try:\n   501→            self._performance_stats[\"total_requests\"] += 1\n   502→            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n   503→            self._performance_stats[\"last_request_time\"] = time.time()\n   504→            if success:\n   505→                self._performance_stats[\"successful_requests\"] += 1\n   506→            else:\n   507→                self._performance_stats[\"failed_requests\"] += 1\n   508→                if error_code or error_message:\n   509→                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n   510→\n   511→            # 调试日志（安全版）\n   512→            total = max(1, self._performance_stats[\"total_requests\"])\n   513→            avg = self._performance_stats[\"total_response_time\"] / total\n   514→            succ = self._performance_stats[\"successful_requests\"]\n   515→            success_rate = (succ / total) * 100.0\n   516→            logger.debug(\n   517→                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n   518→            )\n   519→        except Exception:\n   520→            # 统计不应影响业务流程\n   521→            pass\n   522→\n   523→    def get_performance_stats(self) -> Dict[str, Any]:\n   524→        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n   525→        stats = dict(self._performance_stats)\n   526→        total = stats.get(\"total_requests\", 0) or 0\n   527→        if total > 0:\n   528→            avg = stats.get(\"total_response_time\", 0.0) / total\n   529→            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n   530→        else:\n   531→            avg = 0.0\n   532→            success_rate = 0.0\n   533→        return {\n   534→            \"total_requests\": total,\n   535→            \"successful_requests\": stats.get(\"successful_requests\", 0),\n   536→            \"failed_requests\": stats.get(\"failed_requests\", 0),\n   537→            \"avg_response_time\": avg,\n   538→            \"success_rate\": success_rate,\n   539→            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n   540→        }\n   541→\n   542→    def dump_metrics(self) -> Dict[str, Any]:\n   543→        \"\"\"导出诊断可读的统一指标。\"\"\"\n   544→        m = self.get_performance_stats()\n   545→        m.update({\n   546→            \"client\": \"Seedream\",\n   547→            \"model\": self.model_id,\n   548→            \"base_url\": self.base_url,\n   549→        })\n   550→        return m\n   551→\n   552→    def last_provider(self) -> Optional[str]:\n   553→        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n   554→        return self._last_provider\n   555→\n   556→    def last_endpoint(self) -> Optional[str]:\n   557→        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n   558→        return self._last_endpoint\n   559→\n   560→    @error_handler(\"Seedream文生图\")\n   561→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   562→    def text_to_image(\n   563→        self,\n   564→        prompt: str,\n   565→        size: str = \"1024x1024\",\n   566→        guidance_scale: float = 2.5,\n   567→        seed: Optional[int] = None,\n   568→        reference_images: Optional[List[Any]] = None,\n   569→        n: int = 1,\n   570→        sequential_mode: bool = False,\n   571→        seedream_provider: Optional[str] = None,\n   572→    ) -> Dict[str, Any]:\n   573→        \"\"\"\n   574→        文生图API调用\n   575→\n   576→        Args:\n   577→            prompt: 图片描述提示词\n   578→            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n   579→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   580→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   581→            reference_images: 参考图列表（路径或URL），最多10张\n   582→            n: 生成图片数量，组图模式下生效（1-15）\n   583→            sequential_mode: 是否启用组图模式\n   584→            response_format: 返回格式，\"url\"或\"b64_json\"\n   585→\n   586→        Returns:\n   587→            API响应结果\n   588→\n   589→        Raises:\n   590→            AppError: 当API调用失败时\n   591→        \"\"\"\n   592→        headers = self._get_headers()\n   593→\n   594→        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n   595→\n   596→        if self._provider_enabled():\n   597→            try:\n   598→                from modules.provider.schema import TextToImageParams\n   599→\n   600→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   601→                    headers,\n   602→                    lambda provider: provider.map_t2i(TextToImageParams(\n   603→                        prompt=prompt,\n   604→                        size=size,\n   605→                        guidance_scale=guidance_scale,\n   606→                        seed=(None if (seed is None or seed == -1) else seed),\n   607→                        reference_images=reference_images or [],\n   608→                        sequential_mode=sequential_mode,\n   609→                        count=n\n   610→                    )),\n   611→                    \"text_to_image\",\n   612→                    preferred_provider=seedream_provider,\n   613→                )\n   614→                self._log_seedream_event(\n   615→                    \"text_to_image\",\n   616→                    \"success\",\n   617→                    provider_used,\n   618→                    endpoint_used,\n   619→                    response_time,\n   620→                    fallback_applied,\n   621→                    fallback_reason,\n   622→                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   623→                )\n   624→                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n   625→                return result\n   626→            except Exception as provider_exc:\n   627→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   628→\n   629→        success = False\n   630→        err_code: Optional[str] = None\n   631→        err_msg: Optional[str] = None\n   632→        start_time = time.time()\n   633→        try:\n   634→            if not self.validate_image_size(size):\n   635→                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n   636→            if not (1.0 <= guidance_scale <= 10.0):\n   637→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   638→            if seed is not None and not (-1 <= seed <= 2147483647):\n   639→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   640→\n   641→            data = {\n   642→                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n   643→                \"prompt\": prompt,\n   644→                \"size\": size,\n   645→                \"response_format\": \"url\",\n   646→                \"watermark\": False,  # 正式版固定禁用水印\n   647→                \"guidance_scale\": guidance_scale,\n   648→            }\n   649→            if seed is not None:\n   650→                data[\"seed\"] = seed\n   651→\n   652→            if reference_images:\n   653→                images_payload = []\n   654→                for item in reference_images:\n   655→                    try:\n   656→                        if isinstance(item, str):\n   657→                            if item.startswith(\"data:image/\"):\n   658→                                images_payload.append(item)\n   659→                                continue\n   660→                            p = Path(item)\n   661→                            if p.exists():\n   662→                                encoded = self._encode_image(str(p))\n   663→                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   664→                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n   665→                                images_payload.append(item)\n   666→                        elif isinstance(item, dict):\n   667→                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n   668→                            path_hint = item.get('path') or item.get('source')\n   669→                            if payload:\n   670→                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n   671→                            else:\n   672→                                path_val = item.get('path')\n   673→                                if path_val:\n   674→                                    p = Path(path_val)\n   675→                                    if p.exists():\n   676→                                        encoded = self._encode_image(str(p))\n   677→                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   678→                    except Exception as exc:\n   679→                        logger.warning(f\"参考图处理失败: {exc}\")\n   680→                if images_payload:\n   681→                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n   682→                    data[\"sequential_image_generation\"] = \"disabled\"\n   683→\n   684→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   685→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   686→            result = self._handle_response(response)\n   687→            success = True\n   688→            elapsed = time.time() - start_time\n   689→            self._last_provider = \"legacy_v3\"\n   690→            self._last_endpoint = \"/images/generations\"\n   691→            self._log_seedream_event(\n   692→                \"text_to_image\",\n   693→                \"success\",\n   694→                \"legacy_v3\",\n   695→                \"/images/generations\",\n   696→                elapsed,\n   697→                False,\n   698→                None,\n   699→                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   700→            )\n   701→            return result\n   702→        except AppError as e:\n   703→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   704→            err_msg = e.message\n   705→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   706→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   707→            raise\n   708→        except Exception as e:\n   709→            err_code = \"UNKNOWN_ERROR\"\n   710→            err_msg = str(e)\n   711→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   712→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   713→            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n   714→        finally:\n   715→            elapsed = time.time() - start_time\n   716→            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n   717→\n   718→    @error_handler(\"Seedream图生图\")\n   719→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   720→    def image_to_image(\n   721→        self,\n   722→        prompt: str,\n   723→        image: str,\n   724→        guidance_scale: float = 5.5,\n   725→        seed: Optional[int] = None,\n   726→        reference_images: Optional[List[str]] = None,\n   727→        seedream_provider: Optional[str] = None,\n   728→    ) -> Dict[str, Any]:\n   729→        \"\"\"\n   730→        图生图API调用\n   731→\n   732→        Args:\n   733→            prompt: 图片编辑提示词\n   734→            image: 输入图像URL或Base64编码\n   735→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   736→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   737→            reference_images: 参考图列表（路径或URL），最多10张\n   738→            response_format: 返回格式，\"url\"或\"b64_json\"\n   739→            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n   740→\n   741→        Returns:\n   742→            API响应结果\n   743→\n   744→        Raises:\n   745→            AppError: 当API调用失败时\n   746→        \"\"\"\n   747→        headers = self._get_headers()\n   748→\n   749→        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n   750→\n   751→        if self._provider_enabled():\n   752→            try:\n   753→                from modules.provider.schema import ImageToImageParams\n   754→\n   755→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   756→                    headers,\n   757→                    lambda provider: provider.map_i2i(ImageToImageParams(\n   758→                        prompt=prompt,\n   759→                        image=image,\n   760→                        guidance_scale=guidance_scale,\n   761→                        seed=(None if (seed is None or seed == -1) else seed),\n   762→                        reference_images=(reference_images or []),\n   763→                    )),\n   764→                    \"image_to_image\",\n   765→                    preferred_provider=seedream_provider,\n   766→                )\n   767→                self._log_seedream_event(\n   768→                    \"image_to_image\",\n   769→                    \"success\",\n   770→                    provider_used,\n   771→                    endpoint_used,\n   772→                    response_time,\n   773→                    fallback_applied,\n   774→                    fallback_reason,\n   775→                    {\"seed\": data.get(\"seed\")},\n   776→                )\n   777→                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n   778→                return result\n   779→            except Exception as provider_exc:\n   780→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   781→\n   782→        success = False\n   783→        err_code: Optional[str] = None\n   784→        err_msg: Optional[str] = None\n   785→        start_time = time.time()\n   786→        try:\n   787→            if not (1.0 <= guidance_scale <= 10.0):\n   788→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   789→            if seed is not None and not (-1 <= seed <= 2147483647):\n   790→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   791→\n   792→            data = {\n   793→                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n   794→                \"prompt\": prompt,\n   795→                \"image\": image,\n   796→                \"size\": \"adaptive\",\n   797→                \"response_format\": \"url\",\n   798→                \"watermark\": False,  # 正式版固定禁用水印\n   799→                \"guidance_scale\": guidance_scale,\n   800→            }\n   801→            if seed is not None:\n   802→                data[\"seed\"] = seed\n   803→            if reference_images:\n   804→                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n   805→\n   806→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   807→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   808→            result = self._handle_response(response)\n   809→            success = True\n   810→            elapsed = time.time() - start_time\n   811→            self._last_provider = \"legacy_v3\"\n   812→            self._last_endpoint = \"/images/generations\"\n   813→            self._log_seedream_event(\n   814→                \"image_to_image\",\n   815→                \"success\",\n   816→                \"legacy_v3\",\n   817→                \"/images/generations\",\n   818→                elapsed,\n   819→                False,\n   820→                None,\n   821→                {\"seed\": data.get(\"seed\")},\n   822→            )\n   823→            return result\n   824→        except AppError as e:\n   825→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   826→            err_msg = e.message\n   827→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   828→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   829→            raise\n   830→        except Exception as e:\n   831→            err_code = \"UNKNOWN_ERROR\"\n   832→            err_msg = str(e)\n   833→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   834→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   835→            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n   836→        finally:\n   837→            elapsed = time.time() - start_time\n   838→            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n   839→\n   840→    def batch_text_to_image(\n   841→        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n   842→    ) -> List[Dict[str, Any]]:\n   843→        \"\"\"\n   844→        批量文生图：同时生成多张图片\n   845→\n   846→        Args:\n   847→            prompts: 提示词列表\n   848→            width: 图像宽度\n   849→            height: 图像高度\n   850→            guidance_scale: 提示词一致性\n   851→\n   852→        Returns:\n   853→            List[Dict]: 生成结果列表\n   854→        \"\"\"\n   855→        results = []\n   856→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   857→\n   858→        for i, prompt in enumerate(prompts, 1):\n   859→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   860→\n   861→            try:\n   862→                # 为每个任务生成不同的随机种子\n   863→                seed = random.randint(1, 2147483647)\n   864→\n   865→                result = self.text_to_image(\n   866→                    prompt=prompt, \n   867→                    width=width, \n   868→                    height=height, \n   869→                    guidance_scale=guidance_scale, \n   870→                    seed=seed\n   871→                )\n   872→\n   873→                results.append({\n   874→                    \"success\": True,\n   875→                    \"result\": result,\n   876→                    \"prompt\": prompt\n   877→                })\n   878→\n   879→            except Exception as e:\n   880→                # 避免在日志中显示过长的异常信息\n   881→                error_msg = str(e)\n   882→                if len(error_msg) > 200:\n   883→                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   884→                logger.error(f\"第{i}个任务失败: {error_msg}\")\n   885→                results.append({\n   886→                    \"success\": False,\n   887→                    \"error\": error_msg,\n   888→                    \"prompt\": prompt\n   889→                })\n   890→\n   891→            # 避免请求过于频繁\n   892→            if i < len(prompts):\n   893→                time.sleep(0.5)\n   894→\n   895→        success_count = sum(1 for r in results if r[\"success\"])\n   896→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   897→        return results\n   898→\n   899→    def validate_image_size(self, size: str) -> bool:\n   900→        \"\"\"\n   901→        验证图像尺寸是否支持\n   902→\n   903→        Args:\n   904→            size: 图像尺寸字符串，如 \"1024x1024\"\n   905→\n   906→        Returns:\n   907→            bool: 是否支持该尺寸\n   908→        \"\"\"\n   909→        try:\n   910→            # 解析尺寸字符串\n   911→            if 'x' not in size:\n   912→                return False\n   913→                \n   914→            width_str, height_str = size.split('x', 1)\n   915→            width = int(width_str)\n   916→            height = int(height_str)\n   917→            \n   918→            # 验证范围：Seedream 4.0 支持 512-4096像素\n   919→            return (512 <= width <= 4096) and (512 <= height <= 4096)\n   920→            \n   921→        except (ValueError, AttributeError):\n   922→            return False\n   923→\n   924→    def get_supported_sizes(self) -> List[str]:\n   925→        \"\"\"\n   926→        获取常用的图像尺寸列表\n   927→        \n   928→        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n   929→\n   930→        Returns:\n   931→            List[str]: 常用尺寸列表，包含官方推荐尺寸\n   932→        \"\"\"\n   933→        return [\n   934→            # 官方推荐尺寸 (Seedream 4.0)\n   935→            \"2048x2048\",   # 1:1 官方推荐\n   936→            \"2304x1728\",   # 4:3 官方推荐\n   937→            \"1728x2304\",   # 3:4 官方推荐\n   938→            \"2560x1440\",   # 16:9 官方推荐\n   939→            \"1440x2560\",   # 9:16 官方推荐\n   940→            \"2496x1664\",   # 3:2 官方推荐\n   941→            \"1664x2496\",   # 2:3 官方推荐\n   942→            \"3024x1296\",   # 21:9 官方推荐\n   943→            \n   944→            # 兼容性尺寸\n   945→            \"1920x1080\",   # 16:9 兼容\n   946→            \"1080x1920\",   # 9:16 兼容\n   947→            \"1536x1024\",   # 3:2 兼容\n   948→            \"1024x1536\",   # 2:3 兼容\n   949→            \"1512x648\",    # 21:9 兼容\n   950→            \"1280x720\",    # 16:9 小尺寸\n   951→            \"720x1280\",    # 9:16 小尺寸\n   952→            \"1024x1024\",   # 1:1 兼容\n   953→            \"768x768\",     # 1:1 小尺寸\n   954→            \"512x512\",     # 1:1 最小尺寸\n   955→        ]\n   956→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b8c42fda-4390-48e4-bf2e-6f3b2c032f7c","timestamp":"2026-01-08T08:39:23.651Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py","content":"# Seedream图像生成客户端\n# 封装火山引擎Seedream3.0 API调用\n\nimport json\nimport os\nimport requests\nfrom requests.exceptions import Timeout, ReadTimeout, ConnectTimeout\nimport time\nimport random\nfrom typing import Dict, Any, Optional, List\nfrom pathlib import Path\nfrom loguru import logger\nfrom urllib3.util.retry import Retry\nfrom requests.adapters import HTTPAdapter\n\n# 导入配置管理器和错误处理\nfrom config.unified_config import get_unified_config\nfrom utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n\n\nclass SeedreamClient:\n    \"\"\"火山引擎Seedream图片生成客户端\n\n    提供文生图和图生图功能\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n        timeout: int = 60,\n        max_retries: int = 3,\n    ):\n        \"\"\"初始化Seedream客户端\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n            base_url: API基础URL\n            timeout: 请求超时时间（秒）\n            max_retries: 最大重试次数\n        \"\"\"\n        # 获取API密钥\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n\n        self.api_key = api_key\n        self.base_url = base_url.rstrip(\"/\")\n        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n        # 配置会话\n        self.session = requests.Session()\n\n        # 配置重试策略\n        retry_strategy = Retry(\n            total=max_retries,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n            backoff_factor=1\n        )\n\n        adapter = HTTPAdapter(max_retries=retry_strategy)\n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        logger.info(\"Seedream客户端初始化完成\")\n\n        # 初始化性能监控与错误缓存（统一结构）\n        self._performance_stats = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"total_response_time\": 0.0,\n            \"last_request_time\": None,\n        }\n        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n        self._last_provider: Optional[str] = None\n        self._last_endpoint: Optional[str] = None\n\n    def _encode_image(self, image_path: str) -> str:\n        \"\"\"将图像文件编码为base64字符串\n        \n        Args:\n            image_path: 图像文件路径\n            \n        Returns:\n            base64编码的图像字符串\n        \"\"\"\n        import base64\n        \n        try:\n            with open(image_path, 'rb') as image_file:\n                image_data = image_file.read()\n                base64_string = base64.b64encode(image_data).decode('utf-8')\n                return base64_string\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图像编码失败: {error_msg}\")\n            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n\n    def _get_headers(self) -> Dict[str, str]:\n        \"\"\"获取请求头\"\"\"\n        # 验证API密钥，防止尺寸配置被错误使用\n        api_key = str(self.api_key).strip()\n\n        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n        try:\n            api_key.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n\n        # 检查是否包含尺寸信息或换行符\n        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n\n        # 检查API密钥长度\n        if len(api_key) < 10 or len(api_key) > 200:\n            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n        \n        return {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"User-Agent\": \"Seedream-Client/1.0.0\",\n        }\n\n    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\n\n        注意：当 timeout > 120 时，使用独立的 requests.post() 而不是 session.post()。\n        这是因为 Session 配置了 Retry 策略，会在超时后自动重试，导致：\n        1. 实际等待时间 = timeout × (1 + retry_count)，可能长达数十分钟\n        2. 重试期间没有日志输出，用户看起来像\"卡住\"\n\n        对于组图等长时间请求，我们需要精确控制超时，不希望自动重试。\n        \"\"\"\n        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n        start = time.time()\n\n        # 长超时请求（组图模式）：绕过 Session 重试机制\n        if timeout > 120:\n            logger.info(f\"[HTTP POST] 长时间请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s (无重试)\")\n            try:\n                # 直接使用 requests.post，不经过 session 的重试策略\n                resp = requests.post(url, headers=headers, data=body, timeout=(30, timeout))\n                elapsed = time.time() - start\n                logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n                return resp\n            except Exception as e:\n                elapsed = time.time() - start\n                logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n                raise\n\n        # 普通请求：使用 session（带重试机制）\n        logger.info(f\"[HTTP POST] 开始请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s\")\n        try:\n            resp = self.session.post(url, headers=headers, data=body, timeout=(30, timeout))\n            elapsed = time.time() - start\n            logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n            return resp\n        except Exception as e:\n            elapsed = time.time() - start\n            logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n            raise\n\n    def _is_large_size(self, size: str) -> bool:\n        \"\"\"判断是否是 v4.5 大尺寸（超过 v3 的 2048 限制）\"\"\"\n        if not size:\n            return False\n        try:\n            if \"x\" in size.lower():\n                w, h = size.lower().split(\"x\")\n                return int(w) > 2048 or int(h) > 2048\n            # 处理 2K/4K 格式\n            if size.upper() in (\"2K\", \"4K\"):\n                return True\n        except Exception:\n            pass\n        return False\n\n    def _provider_enabled(self) -> bool:\n        try:\n            import os\n            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n            return v not in {\"0\", \"false\", \"no\"}\n        except Exception:\n            return True\n\n    def _get_seedream_provider_order(self, preferred_provider: Optional[str] = None) -> List[str]:\n        \"\"\"计算 Seedream provider 调用顺序。\n\n        规则：\n        - 优先使用调用方传入的 preferred_provider（并发安全）\n        - 其次允许通过环境变量 GEMENG_SEEDREAM_PROVIDER 启动覆盖（只读）\n        - 最后兜底 volc_v3\n        \"\"\"\n        order: List[str] = []\n\n        candidates: List[Optional[str]] = []\n        if preferred_provider:\n            candidates.append(preferred_provider)\n        try:\n            candidates.append(os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\"))\n        except Exception:\n            candidates.append(None)\n\n        for candidate in candidates:\n            if not candidate:\n                continue\n            name = candidate.strip().lower()\n            if not name:\n                continue\n            if name not in order:\n                order.append(name)\n\n        if \"volc_v3\" not in order:\n            order.append(\"volc_v3\")\n        return order\n\n    def _call_seedream_provider(\n        self,\n        headers: Dict[str, str],\n        mapper,\n        operation: str,\n        preferred_provider: Optional[str] = None,\n    ):\n        from modules.provider.factory import get_default_provider\n        default_endpoint = \"/images/generations\"\n        base_url = self.base_url.rstrip(\"/\")\n        first_choice = None\n        last_error: Optional[BaseException] = None\n        order = self._get_seedream_provider_order(preferred_provider)\n        if order:\n            first_choice = order[0]\n        for idx, name in enumerate(order):\n            try:\n                provider = get_default_provider(name)\n            except Exception as e:\n                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n                last_error = e\n                continue\n            try:\n                mapped = mapper(provider)\n                if not isinstance(mapped, tuple):\n                    raise ValueError(\"provider mapper 返回值异常\")\n                if len(mapped) == 4:\n                    payload, fb, reason, endpoint = mapped\n                elif len(mapped) == 3:\n                    payload, fb, reason = mapped\n                    endpoint = default_endpoint\n                else:\n                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n            except Exception as e:\n                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n                last_error = e\n                continue\n            start_time = time.time()\n            try:\n                endpoint_path = endpoint or default_endpoint\n                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n                    request_url = endpoint_path\n                else:\n                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                    if not normalized.startswith(\"/\"):\n                        normalized = f\"/{normalized}\"\n                    request_url = f\"{base_url}{normalized}\"\n\n                # 动态超时：组图模式需要更长时间\n                # 实测：5 张 4096x4096 约需 8 分钟（458 秒）\n                timeout = 120\n                seq_options = payload.get(\"sequential_image_generation_options\")\n                max_images = seq_options.get(\"max_images\", 1) if seq_options else 1\n                if max_images > 1:\n                    # 组图模式：基础 120 秒 + 每张图 60 秒，最大 20 分钟\n                    # 实测：15 张 4096x4096 约需 14.5 分钟（869 秒）\n                    timeout = min(120 + max_images * 60, 1200)\n                    logger.info(f\"组图模式: {max_images} 张图，超时设置为 {timeout} 秒\")\n\n                response = self._safe_json_post(request_url, headers, payload, timeout=timeout)\n                result = self._handle_response(response)\n                elapsed = time.time() - start_time\n                if idx > 0 and first_choice:\n                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n                if fb and reason:\n                    logger.warning(f\"参数回退: {reason}\")\n                logger.info(\n                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n                )\n                self._last_provider = name\n                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                return result, payload, endpoint_path, name, fb, reason, elapsed\n            except AppError as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n                # v4.5 特有功能失败时不回退到 v3（参数不兼容）\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        logger.error(f\"v4.5 特有功能失败，不回退: {e.message}\")\n                        raise\n                continue\n            except (Timeout, ReadTimeout, ConnectTimeout) as e:\n                elapsed = time.time() - start_time\n                last_error = e\n                logger.error(f\"Seedream provider {name} 请求超时 ({elapsed:.1f}s): {e}\")\n                # v4.5 特有功能超时时直接报错，不回退\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        raise AppError(\n                            f\"组图生成超时 ({elapsed:.0f}秒)，请减少生成数量或稍后重试\",\n                            ErrorType.NETWORK_ERROR\n                        )\n                continue\n            except Exception as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n                # v4.5 特有功能异常时也不回退\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        logger.error(f\"v4.5 特有功能异常，不回退: {e}\")\n                        raise\n                continue\n        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n\n    def _log_seedream_event(\n        self,\n        operation: str,\n        status: str,\n        provider: Optional[str],\n        endpoint: Optional[str],\n        elapsed: float,\n        fallback_applied: bool,\n        fallback_reason: Optional[str] = None,\n        extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        try:\n            provider_name = provider or \"unknown\"\n            endpoint_text = endpoint or \"/images/generations\"\n            parts = [\n                f\"operation={operation}\",\n                f\"status={status}\",\n                f\"provider={provider_name}\",\n                f\"endpoint={endpoint_text}\",\n                f\"elapsed={elapsed:.2f}s\",\n                f\"fallback={'yes' if fallback_applied else 'no'}\",\n            ]\n            if fallback_applied and fallback_reason:\n                safe_reason = str(fallback_reason)\n                if len(safe_reason) > 120:\n                    safe_reason = safe_reason[:120] + \"...\"\n                parts.append(f\"fallback_reason={safe_reason}\")\n            if extra:\n                for key, value in extra.items():\n                    if value is None:\n                        continue\n                    parts.append(f\"{key}={value}\")\n            logger.info(\"摘要|\" + \" \".join(parts))\n        except Exception:\n            # 保证日志逻辑不会影响主流程\n            pass\n\n    @staticmethod\n    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n        mime = \"image/png\"\n        try:\n            if path_hint:\n                suffix = Path(path_hint).suffix.lower()\n                if suffix in {\".jpg\", \".jpeg\"}:\n                    mime = \"image/jpeg\"\n                elif suffix == \".webp\":\n                    mime = \"image/webp\"\n                elif suffix == \".bmp\":\n                    mime = \"image/bmp\"\n                elif suffix == \".gif\":\n                    mime = \"image/gif\"\n        except Exception:\n            pass\n        return f\"data:{mime};base64,{b64_data}\"\n\n    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n        \"\"\"处理API响应\n\n        Args:\n            response: HTTP响应对象\n\n        Returns:\n            解析后的响应数据\n\n        Raises:\n            AppError: 当API返回错误时\n        \"\"\"\n        try:\n            if not response.ok:\n                try:\n                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n                except Exception:\n                    error_text = str(response.content[:500])\n                # 避免在日志中显示可能包含base64数据的完整响应\n                if len(error_text) > 500:\n                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n                else:\n                    error_summary = error_text\n                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n                raise AppError(\n                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n                    ErrorType.API_ERROR,\n                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n                )\n\n            # 解析响应（增强容错：包括编码问题回退）\n            try:\n                result = response.json()\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                raw = response.content or b\"\"\n                tried = set()\n                result = None\n                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                    if not enc or enc in tried:\n                        continue\n                    tried.add(enc)\n                    try:\n                        text = raw.decode(enc, errors=\"strict\")\n                        result = json.loads(text)\n                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n                        break\n                    except Exception:\n                        continue\n                if result is None:\n                    try:\n                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                    except Exception:\n                        preview = str(raw[:200])\n                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n\n            # OpenAI格式的响应检查\n            if \"data\" not in result:\n                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n                logger.error(f\"Seedream API错误: {error_msg}\")\n                raise AppError(\n                    f\"API错误: {error_msg}\",\n                    ErrorType.API_ERROR,\n                    {\"response_data\": result},\n                )\n\n            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n            images = []\n            for item in result[\"data\"]:\n                if \"url\" in item:\n                    images.append({\n                        \"url\": item[\"url\"]\n                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n                    })\n\n            # 调试日志：输出组图返回的图片数量\n            logger.debug(f\"API 返回 {len(images)} 张图片\")\n\n            return {\n                \"code\": 200,\n                \"message\": \"success\",\n                \"data\": {\n                    \"images\": images\n                },\n                \"created\": result.get(\"created\"),\n                \"usage\": result.get(\"usage\", {})\n            }\n\n        except requests.exceptions.RequestException as e:\n            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n        except json.JSONDecodeError as e:\n            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n\n    def _record_request_stats(\n        self,\n        operation: str,\n        success: bool,\n        response_time: float,\n        error_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n    ) -> None:\n        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n        try:\n            self._performance_stats[\"total_requests\"] += 1\n            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n            self._performance_stats[\"last_request_time\"] = time.time()\n            if success:\n                self._performance_stats[\"successful_requests\"] += 1\n            else:\n                self._performance_stats[\"failed_requests\"] += 1\n                if error_code or error_message:\n                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n\n            # 调试日志（安全版）\n            total = max(1, self._performance_stats[\"total_requests\"])\n            avg = self._performance_stats[\"total_response_time\"] / total\n            succ = self._performance_stats[\"successful_requests\"]\n            success_rate = (succ / total) * 100.0\n            logger.debug(\n                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n            )\n        except Exception:\n            # 统计不应影响业务流程\n            pass\n\n    def get_performance_stats(self) -> Dict[str, Any]:\n        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n        stats = dict(self._performance_stats)\n        total = stats.get(\"total_requests\", 0) or 0\n        if total > 0:\n            avg = stats.get(\"total_response_time\", 0.0) / total\n            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n        else:\n            avg = 0.0\n            success_rate = 0.0\n        return {\n            \"total_requests\": total,\n            \"successful_requests\": stats.get(\"successful_requests\", 0),\n            \"failed_requests\": stats.get(\"failed_requests\", 0),\n            \"avg_response_time\": avg,\n            \"success_rate\": success_rate,\n            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n        }\n\n    def dump_metrics(self) -> Dict[str, Any]:\n        \"\"\"导出诊断可读的统一指标。\"\"\"\n        m = self.get_performance_stats()\n        m.update({\n            \"client\": \"Seedream\",\n            \"model\": self.model_id,\n            \"base_url\": self.base_url,\n        })\n        return m\n\n    def last_provider(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n        return self._last_provider\n\n    def last_endpoint(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n        return self._last_endpoint\n\n    @error_handler(\"Seedream文生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[Any]] = None,\n        n: int = 1,\n        sequential_mode: bool = False,\n        seedream_provider: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        文生图API调用\n\n        Args:\n            prompt: 图片描述提示词\n            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            n: 生成图片数量，组图模式下生效（1-15）\n            sequential_mode: 是否启用组图模式\n            response_format: 返回格式，\"url\"或\"b64_json\"\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import TextToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_t2i(TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=reference_images or [],\n                        sequential_mode=sequential_mode,\n                        count=n\n                    )),\n                    \"text_to_image\",\n                    preferred_provider=seedream_provider,\n                )\n                self._log_seedream_event(\n                    \"text_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not self.validate_image_size(size):\n                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n                \"prompt\": prompt,\n                \"size\": size,\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n\n            if reference_images:\n                images_payload = []\n                for item in reference_images:\n                    try:\n                        if isinstance(item, str):\n                            if item.startswith(\"data:image/\"):\n                                images_payload.append(item)\n                                continue\n                            p = Path(item)\n                            if p.exists():\n                                encoded = self._encode_image(str(p))\n                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n                                images_payload.append(item)\n                        elif isinstance(item, dict):\n                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n                            path_hint = item.get('path') or item.get('source')\n                            if payload:\n                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n                            else:\n                                path_val = item.get('path')\n                                if path_val:\n                                    p = Path(path_val)\n                                    if p.exists():\n                                        encoded = self._encode_image(str(p))\n                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                    except Exception as exc:\n                        logger.warning(f\"参考图处理失败: {exc}\")\n                if images_payload:\n                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n                    data[\"sequential_image_generation\"] = \"disabled\"\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"text_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n\n    @error_handler(\"Seedream图生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n        seedream_provider: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        图生图API调用\n\n        Args:\n            prompt: 图片编辑提示词\n            image: 输入图像URL或Base64编码\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import ImageToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_i2i(ImageToImageParams(\n                        prompt=prompt,\n                        image=image,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=(reference_images or []),\n                    )),\n                    \"image_to_image\",\n                    preferred_provider=seedream_provider,\n                )\n                self._log_seedream_event(\n                    \"image_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n                \"prompt\": prompt,\n                \"image\": image,\n                \"size\": \"adaptive\",\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n            if reference_images:\n                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"image_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n\n    def batch_text_to_image(\n        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量文生图：同时生成多张图片\n\n        Args:\n            prompts: 提示词列表\n            width: 图像宽度\n            height: 图像高度\n            guidance_scale: 提示词一致性\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        results = []\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            try:\n                # 为每个任务生成不同的随机种子\n                seed = random.randint(1, 2147483647)\n\n                result = self.text_to_image(\n                    prompt=prompt, \n                    width=width, \n                    height=height, \n                    guidance_scale=guidance_scale, \n                    seed=seed\n                )\n\n                results.append({\n                    \"success\": True,\n                    \"result\": result,\n                    \"prompt\": prompt\n                })\n\n            except Exception as e:\n                # 避免在日志中显示过长的异常信息\n                error_msg = str(e)\n                if len(error_msg) > 200:\n                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                logger.error(f\"第{i}个任务失败: {error_msg}\")\n                results.append({\n                    \"success\": False,\n                    \"error\": error_msg,\n                    \"prompt\": prompt\n                })\n\n            # 避免请求过于频繁\n            if i < len(prompts):\n                time.sleep(0.5)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n        return results\n\n    def validate_image_size(self, size: str) -> bool:\n        \"\"\"\n        验证图像尺寸是否支持\n\n        Args:\n            size: 图像尺寸字符串，如 \"1024x1024\"\n\n        Returns:\n            bool: 是否支持该尺寸\n        \"\"\"\n        try:\n            # 解析尺寸字符串\n            if 'x' not in size:\n                return False\n                \n            width_str, height_str = size.split('x', 1)\n            width = int(width_str)\n            height = int(height_str)\n            \n            # 验证范围：Seedream 4.0 支持 512-4096像素\n            return (512 <= width <= 4096) and (512 <= height <= 4096)\n            \n        except (ValueError, AttributeError):\n            return False\n\n    def get_supported_sizes(self) -> List[str]:\n        \"\"\"\n        获取常用的图像尺寸列表\n        \n        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n\n        Returns:\n            List[str]: 常用尺寸列表，包含官方推荐尺寸\n        \"\"\"\n        return [\n            # 官方推荐尺寸 (Seedream 4.0)\n            \"2048x2048\",   # 1:1 官方推荐\n            \"2304x1728\",   # 4:3 官方推荐\n            \"1728x2304\",   # 3:4 官方推荐\n            \"2560x1440\",   # 16:9 官方推荐\n            \"1440x2560\",   # 9:16 官方推荐\n            \"2496x1664\",   # 3:2 官方推荐\n            \"1664x2496\",   # 2:3 官方推荐\n            \"3024x1296\",   # 21:9 官方推荐\n            \n            # 兼容性尺寸\n            \"1920x1080\",   # 16:9 兼容\n            \"1080x1920\",   # 9:16 兼容\n            \"1536x1024\",   # 3:2 兼容\n            \"1024x1536\",   # 2:3 兼容\n            \"1512x648\",    # 21:9 兼容\n            \"1280x720\",    # 16:9 小尺寸\n            \"720x1280\",    # 9:16 小尺寸\n            \"1024x1024\",   # 1:1 兼容\n            \"768x768\",     # 1:1 小尺寸\n            \"512x512\",     # 1:1 最小尺寸\n        ]\n","numLines":956,"startLine":1,"totalLines":956}},"sourceToolAssistantUUID":"eac59ea2-7ae8-45a7-9dff-41f1119aacab"}
{"parentUuid":"b8c42fda-4390-48e4-bf2e-6f3b2c032f7c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RJaCcnLfEDooTRW2sib51z","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me search for video-related reference handling and look at the API schema:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10917,"cache_creation_input_tokens":38616,"cache_read_input_tokens":21000,"cache_creation":{"ephemeral_5m_input_tokens":38616,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"b80aaf3d-9340-403e-9c35-c301c0d90fb8","timestamp":"2026-01-08T08:39:29.536Z"}
{"parentUuid":"b80aaf3d-9340-403e-9c35-c301c0d90fb8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RJaCcnLfEDooTRW2sib51z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TK5Qbv1e1wp2nWDCRJdzKT","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10917,"cache_creation_input_tokens":38616,"cache_read_input_tokens":21000,"cache_creation":{"ephemeral_5m_input_tokens":38616,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2a188681-c1e8-4799-8012-36c50c1c6b0a","timestamp":"2026-01-08T08:39:29.850Z"}
{"parentUuid":"2a188681-c1e8-4799-8012-36c50c1c6b0a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RJaCcnLfEDooTRW2sib51z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AfsGtRiBAVh78xEs8ZUq1F","name":"Grep","input":{"output_mode":"content","path":"/Users/yunchang/Documents/GitHub/gemeng2","pattern":"MAX_REFERENCE|compress|size.*limit|image.*format","type":"py","head_limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10917,"cache_creation_input_tokens":38616,"cache_read_input_tokens":21000,"cache_creation":{"ephemeral_5m_input_tokens":38616,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"7087312a-3dce-4585-990e-62943d4ed443","timestamp":"2026-01-08T08:39:30.226Z"}
{"parentUuid":"7087312a-3dce-4585-990e-62943d4ed443","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RJaCcnLfEDooTRW2sib51z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XT7kMBW8ZTJA15qXwkUdEb","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10917,"cache_creation_input_tokens":38616,"cache_read_input_tokens":21000,"cache_creation":{"ephemeral_5m_input_tokens":38616,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"1b957630-1456-42c9-a706-400adeeaac02","timestamp":"2026-01-08T08:39:30.460Z"}
{"parentUuid":"2a188681-c1e8-4799-8012-36c50c1c6b0a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TK5Qbv1e1wp2nWDCRJdzKT","type":"tool_result","content":"     1→﻿#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 参数 Schema 与校验（最小落地）\n     5→\n     6→目标：\n     7→- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n     8→- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n     9→- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n    10→\"\"\"\n    11→\n    12→import copy\n    13→from dataclasses import dataclass, field\n    14→from typing import Any, Optional, Tuple, List, Dict\n    15→\n    16→# 参考图限制（见官方文档 lines 203-204）\n    17→MAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\n    18→MAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n    19→\n    20→\n    21→# 白名单与范围\n    22→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    23→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n    24→\n    25→\n    26→@dataclass\n    27→class TextToImageParams:\n    28→    prompt: str\n    29→    size: str = \"1024x1024\"\n    30→    guidance_scale: float = 2.5\n    31→    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    32→    reference_images: List[str] = field(default_factory=list)\n    33→    sequential_mode: bool = False\n    34→    count: int = 1\n    35→\n    36→\n    37→@dataclass\n    38→class ImageToImageParams:\n    39→    prompt: str\n    40→    image: str  # URL 或 data URL\n    41→    guidance_scale: float = 5.5\n    42→    seed: Optional[int] = None\n    43→    reference_images: List[str] = field(default_factory=list)\n    44→    sequential_mode: bool = False\n    45→    count: int = 1\n    46→\n    47→\n    48→@dataclass\n    49→class VideoParams:\n    50→    prompt: str\n    51→    image_path: Optional[str] = None\n    52→    first_frame_path: Optional[str] = None\n    53→    last_frame_path: Optional[str] = None\n    54→    duration: int = 8\n    55→    fps: int = 24\n    56→    seed: Optional[int] = None\n    57→    camera_fixed: bool = True\n    58→    watermark: bool = False\n    59→    resolution_grade: Optional[str] = None\n    60→    ratio: Optional[str] = None\n    61→    use_pro_model: bool = True\n    62→    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    63→    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    64→    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    65→    reference_images: List[str] = field(default_factory=list)\n    66→\n    67→\n    68→@dataclass(frozen=True)\n    69→class UIOption:\n    70→    value: Any\n    71→    label: str\n    72→    description: Optional[str] = None\n    73→    meta: Dict[str, Any] = field(default_factory=dict)\n    74→\n    75→\n    76→@dataclass(frozen=True)\n    77→class UIDependency:\n    78→    field: str\n    79→    equals: Any = None\n    80→    not_equals: Any = None\n    81→    exists: bool = False\n    82→\n    83→\n    84→@dataclass\n    85→class UISchemaField:\n    86→    name: str\n    87→    field_type: str\n    88→    label: str\n    89→    default: Any = None\n    90→    required: bool = False\n    91→    help_text: Optional[str] = None\n    92→    placeholder: Optional[str] = None\n    93→    options: List[UIOption] = field(default_factory=list)\n    94→    min_value: Optional[float] = None\n    95→    max_value: Optional[float] = None\n    96→    step: Optional[float] = None\n    97→    visible_if: List[UIDependency] = field(default_factory=list)\n    98→    enabled_if: List[UIDependency] = field(default_factory=list)\n    99→    extra: Dict[str, Any] = field(default_factory=dict)\n   100→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9ede9ed5-97b2-430a-b663-849708e7a5cb","timestamp":"2026-01-08T08:39:30.566Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","content":"﻿#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 参数 Schema 与校验（最小落地）\n\n目标：\n- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n\"\"\"\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Any, Optional, Tuple, List, Dict\n\n# 参考图限制（见官方文档 lines 203-204）\nMAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\nMAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n\n\n# 白名单与范围\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n\n\n@dataclass\nclass TextToImageParams:\n    prompt: str\n    size: str = \"1024x1024\"\n    guidance_scale: float = 2.5\n    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass ImageToImageParams:\n    prompt: str\n    image: str  # URL 或 data URL\n    guidance_scale: float = 5.5\n    seed: Optional[int] = None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass VideoParams:\n    prompt: str\n    image_path: Optional[str] = None\n    first_frame_path: Optional[str] = None\n    last_frame_path: Optional[str] = None\n    duration: int = 8\n    fps: int = 24\n    seed: Optional[int] = None\n    camera_fixed: bool = True\n    watermark: bool = False\n    resolution_grade: Optional[str] = None\n    ratio: Optional[str] = None\n    use_pro_model: bool = True\n    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    reference_images: List[str] = field(default_factory=list)\n\n\n@dataclass(frozen=True)\nclass UIOption:\n    value: Any\n    label: str\n    description: Optional[str] = None\n    meta: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass(frozen=True)\nclass UIDependency:\n    field: str\n    equals: Any = None\n    not_equals: Any = None\n    exists: bool = False\n\n\n@dataclass\nclass UISchemaField:\n    name: str\n    field_type: str\n    label: str\n    default: Any = None\n    required: bool = False\n    help_text: Optional[str] = None\n    placeholder: Optional[str] = None\n    options: List[UIOption] = field(default_factory=list)\n    min_value: Optional[float] = None\n    max_value: Optional[float] = None\n    step: Optional[float] = None\n    visible_if: List[UIDependency] = field(default_factory=list)\n    enabled_if: List[UIDependency] = field(default_factory=list)\n    extra: Dict[str, Any] = field(default_factory=dict)\n","numLines":100,"startLine":1,"totalLines":887}},"sourceToolAssistantUUID":"2a188681-c1e8-4799-8012-36c50c1c6b0a"}
{"parentUuid":"7087312a-3dce-4585-990e-62943d4ed443","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AfsGtRiBAVh78xEs8ZUq1F","type":"tool_result","content":"utils/video_thumbnail_generator.py:142:                    qimage = qimage.scaled(new_width, new_height, Qt.KeepAspectRatio, Qt.SmoothTransformation)\nutils/image_format_validator.py:153:    def convert_image_format(self, image_path: str, target_format: str = 'JPEG', \nutils/image_format_validator.py:217:            logger.info(f\"图片格式转换成功: {image_path} -> {output_path} ({target_format})\")\nutils/image_format_validator.py:265:                converted_path = self.convert_image_format(image_path, 'JPEG')\nutils/logger.py:130:            \"compression\": \"zip\",\nmodules/seedance/manager.py:21:from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\r\nmodules/seedance/manager.py:158:            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\r\nmodules/seedance/manager.py:924:        max_refs: int = MAX_REFERENCE_IMAGES,\r\nmodules/seedance/manager.py:977:        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\r\nmodules/seedance/manager.py:978:            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\r\nmodules/seedance/manager.py:981:                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\r\nmodules/seedance/client.py:1267:            from utils.image_format_validator import validate_and_prepare_image\nmodules/seedance/client.py:1301:            from utils.image_format_validator import validate_and_prepare_image\nmodules/seedream/manager.py:32:    MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:33:    MAX_REFERENCE_BUNDLE,\nmodules/seedream/manager.py:139:                    max_refs=MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:377:                max_refs=MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:427:                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\nmodules/seedream/manager.py:864:                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\nmodules/seedream/manager.py:1176:        max_refs: int = MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:1230:        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\nmodules/seedream/manager.py:1231:            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\nmodules/seedream/manager.py:1234:                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\nmodules/seedream/manager.py:1354:                format_name = image.format.lower()\nmodules/seedream/manager.py:1358:                return f\"data:image/{format_name};base64,{base64_data}\"\nmodules/storage/unified_storage_manager_v2.py:300:                batch_size=limit,\ncomponents/widgets/integrated_reference_panel.py:49:from modules.provider.schema import MAX_REFERENCE_BUNDLE, MAX_REFERENCE_IMAGES\ncomponents/widgets/integrated_reference_panel.py:370:        self._auto_compress_enabled = True\ncomponents/widgets/integrated_reference_panel.py:551:    def set_auto_compress_enabled(self, enabled: bool):\ncomponents/widgets/integrated_reference_panel.py:552:        self._auto_compress_enabled = bool(enabled)\n\n[Showing results with pagination = limit: 30, offset: 0]"}]},"uuid":"0c064662-6567-420b-88a9-86baff756e79","timestamp":"2026-01-08T08:39:30.590Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"utils/video_thumbnail_generator.py:142:                    qimage = qimage.scaled(new_width, new_height, Qt.KeepAspectRatio, Qt.SmoothTransformation)\nutils/image_format_validator.py:153:    def convert_image_format(self, image_path: str, target_format: str = 'JPEG', \nutils/image_format_validator.py:217:            logger.info(f\"图片格式转换成功: {image_path} -> {output_path} ({target_format})\")\nutils/image_format_validator.py:265:                converted_path = self.convert_image_format(image_path, 'JPEG')\nutils/logger.py:130:            \"compression\": \"zip\",\nmodules/seedance/manager.py:21:from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\r\nmodules/seedance/manager.py:158:            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\r\nmodules/seedance/manager.py:924:        max_refs: int = MAX_REFERENCE_IMAGES,\r\nmodules/seedance/manager.py:977:        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\r\nmodules/seedance/manager.py:978:            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\r\nmodules/seedance/manager.py:981:                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\r\nmodules/seedance/client.py:1267:            from utils.image_format_validator import validate_and_prepare_image\nmodules/seedance/client.py:1301:            from utils.image_format_validator import validate_and_prepare_image\nmodules/seedream/manager.py:32:    MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:33:    MAX_REFERENCE_BUNDLE,\nmodules/seedream/manager.py:139:                    max_refs=MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:377:                max_refs=MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:427:                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\nmodules/seedream/manager.py:864:                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\nmodules/seedream/manager.py:1176:        max_refs: int = MAX_REFERENCE_IMAGES,\nmodules/seedream/manager.py:1230:        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\nmodules/seedream/manager.py:1231:            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\nmodules/seedream/manager.py:1234:                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\nmodules/seedream/manager.py:1354:                format_name = image.format.lower()\nmodules/seedream/manager.py:1358:                return f\"data:image/{format_name};base64,{base64_data}\"\nmodules/storage/unified_storage_manager_v2.py:300:                batch_size=limit,\ncomponents/widgets/integrated_reference_panel.py:49:from modules.provider.schema import MAX_REFERENCE_BUNDLE, MAX_REFERENCE_IMAGES\ncomponents/widgets/integrated_reference_panel.py:370:        self._auto_compress_enabled = True\ncomponents/widgets/integrated_reference_panel.py:551:    def set_auto_compress_enabled(self, enabled: bool):\ncomponents/widgets/integrated_reference_panel.py:552:        self._auto_compress_enabled = bool(enabled)","numLines":30,"appliedLimit":30},"sourceToolAssistantUUID":"7087312a-3dce-4585-990e-62943d4ed443"}
{"parentUuid":"1b957630-1456-42c9-a706-400adeeaac02","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XT7kMBW8ZTJA15qXwkUdEb","type":"tool_result","content":"     1→# Seedance视频生成管理器\n     2→# 负责视频生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→import base64\n    13→import pandas as pd\n    14→from datetime import datetime\n    15→from pathlib import Path\n    16→from typing import Dict, Any, List, Optional, Tuple\n    17→from urllib.parse import urlparse\n    18→from loguru import logger\n    19→from PIL import Image\n    20→\n    21→from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n    22→\n    23→from .client import SeedanceClient\n    24→from ..storage import get_v2_storage_manager\n    25→from ..provider.schema import (\n    26→    VideoParams,\n    27→    validate_and_normalize_video,\n    28→)\n    29→from config.unified_config import get_unified_config\n    30→from config.unified_config import get_storage_dir\n    31→# 使用统一水印服务（edition/watermark_service.py）\n    32→from edition.watermark_service import (\n    33→    should_add_watermark,\n    34→    get_watermark_text,\n    35→    get_watermark_opacity,\n    36→)\n    37→\n    38→# Q-006 固化策略：\n    39→# - 本地水印由 edition/watermark_service 控制（trial 强制开 / prod 关闭）\n    40→# - API 服务端水印固定关闭（不依赖 config_api）\n    41→\n    42→\n    43→class SeedanceManager:\n    44→    \"\"\"Seedance视频生成管理器\"\"\"\n    45→\n    46→    def __init__(self, api_key: str = None):\n    47→        \"\"\"\n    48→        初始化Seedance管理器\n    49→\n    50→        Args:\n    51→            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n    52→        \"\"\"\n    53→        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n    54→        if api_key is None:\n    55→            try:\n    56→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    57→            except Exception as exc:\n    58→                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n    59→        \n    60→        self.client = SeedanceClient(api_key)\n    61→\n    62→        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n    63→        storage_path = get_storage_dir()\n    64→        if not storage_path:\n    65→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    66→        Path(storage_path).mkdir(parents=True, exist_ok=True)\n    67→\n    68→        # 使用V2统一存储管理器（与单一真源对齐）\n    69→        self.storage_manager = get_v2_storage_manager(storage_path)\n    70→        \n    71→        # 保持兼容性别名\n    72→        self.file_manager = self.storage_manager\n    73→        self.metadata_manager = self.storage_manager\n    74→        self.video_storage_manager = self.storage_manager\n    75→        \n    76→        # 保留原有的目录属性以保持兼容性\n    77→        self.data_dir = Path(self.storage_manager.root_path)\n    78→        self.videos_dir = self.data_dir / \"videos\"\n    79→        self.metadata_dir = self.data_dir / \"metadata\"\n    80→\n    81→        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    82→\n    83→    def generate_video(\n    84→        self,\n    85→        prompt: str,\n    86→        image_path: Optional[str] = None,\n    87→        first_frame_path: Optional[str] = None,\n    88→        last_frame_path: Optional[str] = None,\n    89→        duration: float = 4.0,\n    90→        seed: int = -1,\n    91→        watermark: bool = False,\n    92→        save_local: bool = True,\n    93→        wait_for_completion: bool = True,\n    94→        # 新增参数（P0b）\n    95→        resolution_grade: Optional[str] = None,\n    96→        ratio: Optional[str] = None,\n    97→        fps: int = 24,\n    98→        camera_fixed: bool = True,\n    99→        use_pro_model: bool = True,\n   100→        model_type: Optional[str] = None,\n   101→        model_variant: Optional[str] = None,\n   102→        generate_audio: Optional[bool] = None,\n   103→        reference_images: Optional[List[Any]] = None,\n   104→        generation_id: Optional[str] = None,\n   105→    ) -> Dict[str, Any]:\n   106→        \"\"\"\n   107→        生成视频并保存到本地\n   108→\n   109→        Args:\n   110→            image_path: 输入图像路径\n   111→            duration: 视频时长（秒）\n   112→            motion_strength: 运动强度 (0.1-1.0)\n   113→            seed: 随机种子\n   114→            watermark: 保留参数（服务端水印由配置决定）\n   115→            save_local: 是否保存到本地\n   116→            wait_for_completion: 是否等待任务完成\n   117→\n   118→        Returns:\n   119→            Dict: 生成结果\n   120→        \"\"\"\n   121→        logger.info(\"开始视频生成任务(Manager)\")\n   122→\n   123→        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n   124→        task_id = generation_id or str(uuid.uuid4())\n   125→\n   126→        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n   127→        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n   128→            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n   129→\n   130→        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n   131→        # 构建待处理的图片列表\n   132→        all_input_images = []\n   133→\n   134→        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n   135→        frame_inputs = []\n   136→        if first_frame_path:\n   137→            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n   138→        if last_frame_path:\n   139→            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n   140→        elif image_path and not first_frame_path:\n   141→            frame_inputs.append({'path': image_path, 'type': 'image'})\n   142→\n   143→        all_input_images.extend(frame_inputs)\n   144→\n   145→        # 2. 添加参考图\n   146→        if reference_images:\n   147→            for ref in reference_images:\n   148→                if isinstance(ref, dict):\n   149→                    ref_copy = dict(ref)\n   150→                    ref_copy['type'] = ref_copy.get('type', 'reference')\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8fff7006-9f72-4cd9-9310-8227a17df9e9","timestamp":"2026-01-08T08:39:30.566Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"# Seedance视频生成管理器\n# 负责视频生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nimport base64\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom urllib.parse import urlparse\nfrom loguru import logger\nfrom PIL import Image\n\nfrom ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n\nfrom .client import SeedanceClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    VideoParams,\n    validate_and_normalize_video,\n)\nfrom config.unified_config import get_unified_config\nfrom config.unified_config import get_storage_dir\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n# Q-006 固化策略：\n# - 本地水印由 edition/watermark_service 控制（trial 强制开 / prod 关闭）\n# - API 服务端水印固定关闭（不依赖 config_api）\n\n\nclass SeedanceManager:\n    \"\"\"Seedance视频生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedance管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n        \"\"\"\n        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n        \n        self.client = SeedanceClient(api_key)\n\n        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n        storage_path = get_storage_dir()\n        if not storage_path:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        Path(storage_path).mkdir(parents=True, exist_ok=True)\n\n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(storage_path)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.video_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.videos_dir = self.data_dir / \"videos\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_video(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: float = 4.0,\n        seed: int = -1,\n        watermark: bool = False,\n        save_local: bool = True,\n        wait_for_completion: bool = True,\n        # 新增参数（P0b）\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        fps: int = 24,\n        camera_fixed: bool = True,\n        use_pro_model: bool = True,\n        model_type: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        generate_audio: Optional[bool] = None,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成视频并保存到本地\n\n        Args:\n            image_path: 输入图像路径\n            duration: 视频时长（秒）\n            motion_strength: 运动强度 (0.1-1.0)\n            seed: 随机种子\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            Dict: 生成结果\n        \"\"\"\n        logger.info(\"开始视频生成任务(Manager)\")\n\n        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n        # 构建待处理的图片列表\n        all_input_images = []\n\n        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n        frame_inputs = []\n        if first_frame_path:\n            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n        if last_frame_path:\n            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n        elif image_path and not first_frame_path:\n            frame_inputs.append({'path': image_path, 'type': 'image'})\n\n        all_input_images.extend(frame_inputs)\n\n        # 2. 添加参考图\n        if reference_images:\n            for ref in reference_images:\n                if isinstance(ref, dict):\n                    ref_copy = dict(ref)\n                    ref_copy['type'] = ref_copy.get('type', 'reference')","numLines":150,"startLine":1,"totalLines":1273}},"sourceToolAssistantUUID":"1b957630-1456-42c9-a706-400adeeaac02"}
{"parentUuid":"8fff7006-9f72-4cd9-9310-8227a17df9e9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EHPJN2TN22Ewsmh3uLmA9y","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check for image format validation and compression utilities:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":16261,"cache_read_input_tokens":59616,"cache_creation":{"ephemeral_5m_input_tokens":16261,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"68164adc-1471-46c8-a8d8-a55065c92475","timestamp":"2026-01-08T08:39:36.119Z"}
{"parentUuid":"68164adc-1471-46c8-a8d8-a55065c92475","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EHPJN2TN22Ewsmh3uLmA9y","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gza9uD1U6Dx4U4XdffuWYq","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/utils/image_format_validator.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":16261,"cache_read_input_tokens":59616,"cache_creation":{"ephemeral_5m_input_tokens":16261,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"952ac1b4-d55f-4a89-b937-0c5ad6077e3d","timestamp":"2026-01-08T08:39:36.691Z"}
{"parentUuid":"952ac1b4-d55f-4a89-b937-0c5ad6077e3d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EHPJN2TN22Ewsmh3uLmA9y","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TFbkwk4Gguxm1TMhTUDBaM","name":"Grep","input":{"output_mode":"content","path":"/Users/yunchang/Documents/GitHub/gemeng2","pattern":"compress|resize|quality|optimize.*image","type":"py","head_limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":16261,"cache_read_input_tokens":59616,"cache_creation":{"ephemeral_5m_input_tokens":16261,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"252267e1-2fc2-4612-bb31-4811caaa43f2","timestamp":"2026-01-08T08:39:37.228Z"}
{"parentUuid":"952ac1b4-d55f-4a89-b937-0c5ad6077e3d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gza9uD1U6Dx4U4XdffuWYq","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→图片格式验证和转换工具\n     5→解决火山引擎Seedance API图片格式不支持的问题\n     6→\"\"\"\n     7→\n     8→import os\n     9→import base64\n    10→from pathlib import Path\n    11→from typing import Optional, Tuple, Dict, Any\n    12→from PIL import Image, ImageFile\n    13→from loguru import logger\n    14→\n    15→# 允许加载截断的图片\n    16→ImageFile.LOAD_TRUNCATED_IMAGES = True\n    17→\n    18→\n    19→class ImageFormatValidator:\n    20→    \"\"\"图片格式验证和转换器\"\"\"\n    21→    \n    22→    # 火山引擎API支持的图片格式 <mcreference link=\"https://blog.csdn.net/weixin_44786530/article/details/146113781\" index=\"1\">1</mcreference>\n    23→    SUPPORTED_FORMATS = {\n    24→        '.jpg': 'JPEG',\n    25→        '.jpeg': 'JPEG', \n    26→        '.png': 'PNG',\n    27→        '.webp': 'WEBP'\n    28→    }\n    29→    \n    30→    # MIME类型映射\n    31→    MIME_TYPES = {\n    32→        '.jpg': 'image/jpeg',\n    33→        '.jpeg': 'image/jpeg',\n    34→        '.png': 'image/png', \n    35→        '.webp': 'image/webp'\n    36→    }\n    37→    \n    38→    # 文件大小限制（10MB）\n    39→    MAX_FILE_SIZE = 10 * 1024 * 1024\n    40→    \n    41→    def __init__(self):\n    42→        \"\"\"初始化验证器\"\"\"\n    43→        self.temp_files = []  # 跟踪临时文件\n    44→        \n    45→    def validate_image(self, image_path: str) -> Dict[str, Any]:\n    46→        \"\"\"验证图片文件\n    47→        \n    48→        Args:\n    49→            image_path: 图片文件路径\n    50→            \n    51→        Returns:\n    52→            Dict: 验证结果\n    53→                {\n    54→                    'valid': bool,\n    55→                    'error': str,\n    56→                    'format': str,\n    57→                    'size': int,\n    58→                    'dimensions': tuple,\n    59→                    'needs_conversion': bool\n    60→                }\n    61→        \"\"\"\n    62→        try:\n    63→            image_path = Path(image_path)\n    64→            \n    65→            # 检查文件是否存在\n    66→            if not image_path.exists():\n    67→                return {\n    68→                    'valid': False,\n    69→                    'error': f'图片文件不存在: {image_path}',\n    70→                    'format': None,\n    71→                    'size': 0,\n    72→                    'dimensions': None,\n    73→                    'needs_conversion': False\n    74→                }\n    75→            \n    76→            # 检查文件大小\n    77→            file_size = image_path.stat().st_size\n    78→            if file_size > self.MAX_FILE_SIZE:\n    79→                return {\n    80→                    'valid': False,\n    81→                    'error': f'图片文件过大: {file_size / 1024 / 1024:.1f}MB > 10MB',\n    82→                    'format': None,\n    83→                    'size': file_size,\n    84→                    'dimensions': None,\n    85→                    'needs_conversion': False\n    86→                }\n    87→            \n    88→            # 检查文件扩展名\n    89→            file_ext = image_path.suffix.lower()\n    90→            \n    91→            # 尝试打开图片获取实际格式\n    92→            try:\n    93→                with Image.open(image_path) as img:\n    94→                    actual_format = img.format\n    95→                    dimensions = img.size\n    96→                    \n    97→                    # 检查是否为支持的格式\n    98→                    if file_ext in self.SUPPORTED_FORMATS:\n    99→                        expected_format = self.SUPPORTED_FORMATS[file_ext]\n   100→                        \n   101→                        # 检查实际格式是否与扩展名匹配\n   102→                        if actual_format == expected_format:\n   103→                            return {\n   104→                                'valid': True,\n   105→                                'error': None,\n   106→                                'format': actual_format,\n   107→                                'size': file_size,\n   108→                                'dimensions': dimensions,\n   109→                                'needs_conversion': False\n   110→                            }\n   111→                        else:\n   112→                            # 格式不匹配，需要转换\n   113→                            return {\n   114→                                'valid': True,\n   115→                                'error': f'图片格式不匹配: 文件扩展名为{file_ext}，实际格式为{actual_format}',\n   116→                                'format': actual_format,\n   117→                                'size': file_size,\n   118→                                'dimensions': dimensions,\n   119→                                'needs_conversion': True\n   120→                            }\n   121→                    else:\n   122→                        # 不支持的格式，需要转换\n   123→                        return {\n   124→                            'valid': True,\n   125→                            'error': f'不支持的图片格式: {file_ext}（{actual_format}），将自动转换为JPEG格式',\n   126→                            'format': actual_format,\n   127→                            'size': file_size,\n   128→                            'dimensions': dimensions,\n   129→                            'needs_conversion': True\n   130→                        }\n   131→                        \n   132→            except Exception as e:\n   133→                return {\n   134→                    'valid': False,\n   135→                    'error': f'无法读取图片文件: {str(e)}',\n   136→                    'format': None,\n   137→                    'size': file_size,\n   138→                    'dimensions': None,\n   139→                    'needs_conversion': False\n   140→                }\n   141→                \n   142→        except Exception as e:\n   143→            logger.error(f\"图片验证失败: {str(e)}\")\n   144→            return {\n   145→                'valid': False,\n   146→                'error': f'图片验证失败: {str(e)}',\n   147→                'format': None,\n   148→                'size': 0,\n   149→                'dimensions': None,\n   150→                'needs_conversion': False\n   151→            }\n   152→    \n   153→    def convert_image_format(self, image_path: str, target_format: str = 'JPEG', \n   154→                           quality: int = 95, output_dir: Optional[str] = None) -> Optional[str]:\n   155→        \"\"\"转换图片格式\n   156→        \n   157→        Args:\n   158→            image_path: 原始图片路径\n   159→            target_format: 目标格式 (JPEG, PNG, WEBP)\n   160→            quality: 图片质量 (1-100，仅对JPEG和WEBP有效)\n   161→            output_dir: 输出目录，如果为None则使用临时目录\n   162→            \n   163→        Returns:\n   164→            str: 转换后的图片路径，失败返回None\n   165→        \"\"\"\n   166→        try:\n   167→            image_path = Path(image_path)\n   168→            \n   169→            # 确定输出路径\n   170→            if output_dir:\n   171→                output_dir = Path(output_dir)\n   172→                output_dir.mkdir(parents=True, exist_ok=True)\n   173→            else:\n   174→                # 使用临时目录\n   175→                import tempfile\n   176→                output_dir = Path(tempfile.gettempdir()) / 'seedance_converted_images'\n   177→                output_dir.mkdir(parents=True, exist_ok=True)\n   178→            \n   179→            # 确定输出文件名和扩展名\n   180→            if target_format.upper() == 'JPEG':\n   181→                output_ext = '.jpg'\n   182→            elif target_format.upper() == 'PNG':\n   183→                output_ext = '.png'\n   184→            elif target_format.upper() == 'WEBP':\n   185→                output_ext = '.webp'\n   186→            else:\n   187→                raise ValueError(f\"不支持的目标格式: {target_format}\")\n   188→            \n   189→            output_path = output_dir / f\"{image_path.stem}_converted{output_ext}\"\n   190→            \n   191→            # 打开并转换图片\n   192→            with Image.open(image_path) as img:\n   193→                # 如果是RGBA模式且目标格式是JPEG，需要转换为RGB\n   194→                if img.mode in ('RGBA', 'LA') and target_format.upper() == 'JPEG':\n   195→                    # 创建白色背景\n   196→                    background = Image.new('RGB', img.size, (255, 255, 255))\n   197→                    if img.mode == 'RGBA':\n   198→                        background.paste(img, mask=img.split()[-1])  # 使用alpha通道作为mask\n   199→                    else:\n   200→                        background.paste(img)\n   201→                    img = background\n   202→                elif img.mode not in ('RGB', 'RGBA', 'L'):\n   203→                    # 转换为RGB模式\n   204→                    img = img.convert('RGB')\n   205→                \n   206→                # 保存图片\n   207→                save_kwargs = {}\n   208→                if target_format.upper() in ('JPEG', 'WEBP'):\n   209→                    save_kwargs['quality'] = quality\n   210→                    save_kwargs['optimize'] = True\n   211→                \n   212→                img.save(output_path, format=target_format.upper(), **save_kwargs)\n   213→            \n   214→            # 记录临时文件\n   215→            self.temp_files.append(str(output_path))\n   216→            \n   217→            logger.info(f\"图片格式转换成功: {image_path} -> {output_path} ({target_format})\")\n   218→            return str(output_path)\n   219→            \n   220→        except Exception as e:\n   221→            logger.error(f\"图片格式转换失败: {str(e)}\")\n   222→            return None\n   223→    \n   224→    def prepare_image_for_api(self, image_path: str, auto_convert: bool = True) -> Dict[str, Any]:\n   225→        \"\"\"为API调用准备图片\n   226→        \n   227→        Args:\n   228→            image_path: 图片文件路径\n   229→            auto_convert: 是否自动转换不支持的格式\n   230→            \n   231→        Returns:\n   232→            Dict: 处理结果\n   233→                {\n   234→                    'success': bool,\n   235→                    'image_path': str,  # 处理后的图片路径\n   236→                    'data_url': str,    # base64 data URL\n   237→                    'is_converted': bool,  # 是否进行了转换\n   238→                    'original_format': str,\n   239→                    'final_format': str,\n   240→                    'error': str\n   241→                }\n   242→        \"\"\"\n   243→        try:\n   244→            # 验证图片\n   245→            validation_result = self.validate_image(image_path)\n   246→            \n   247→            if not validation_result['valid']:\n   248→                return {\n   249→                    'success': False,\n   250→                    'image_path': None,\n   251→                    'data_url': None,\n   252→                    'is_converted': False,\n   253→                    'original_format': validation_result['format'],\n   254→                    'final_format': None,\n   255→                    'error': validation_result['error']\n   256→                }\n   257→            \n   258→            original_format = validation_result['format']\n   259→            final_path = image_path\n   260→            is_converted = False\n   261→            \n   262→            # 如果需要转换且允许自动转换\n   263→            if validation_result['needs_conversion'] and auto_convert:\n   264→                logger.info(f\"检测到需要转换的图片格式: {original_format}，正在转换为JPEG...\")\n   265→                converted_path = self.convert_image_format(image_path, 'JPEG')\n   266→                \n   267→                if converted_path:\n   268→                    final_path = converted_path\n   269→                    is_converted = True\n   270→                    final_format = 'JPEG'\n   271→                    logger.info(f\"图片格式转换成功: {original_format} -> JPEG\")\n   272→                else:\n   273→                    return {\n   274→                        'success': False,\n   275→                        'image_path': None,\n   276→                        'data_url': None,\n   277→                        'is_converted': False,\n   278→                        'original_format': original_format,\n   279→                        'final_format': None,\n   280→                        'error': '图片格式转换失败'\n   281→                    }\n   282→            elif validation_result['needs_conversion'] and not auto_convert:\n   283→                return {\n   284→                    'success': False,\n   285→                    'image_path': None,\n   286→                    'data_url': None,\n   287→                    'is_converted': False,\n   288→                    'original_format': original_format,\n   289→                    'final_format': None,\n   290→                    'error': f'图片格式不支持: {original_format}，请使用JPEG、PNG或WEBP格式'\n   291→                }\n   292→            else:\n   293→                final_format = original_format\n   294→            \n   295→            # 生成data URL\n   296→            data_url = self._encode_image_to_data_url(final_path)\n   297→            if not data_url:\n   298→                return {\n   299→                    'success': False,\n   300→                    'image_path': final_path,\n   301→                    'data_url': None,\n   302→                    'is_converted': is_converted,\n   303→                    'original_format': original_format,\n   304→                    'final_format': final_format,\n   305→                    'error': '生成base64编码失败'\n   306→                }\n   307→            \n   308→            return {\n   309→                'success': True,\n   310→                'image_path': final_path,\n   311→                'data_url': data_url,\n   312→                'is_converted': is_converted,\n   313→                'original_format': original_format,\n   314→                'final_format': final_format,\n   315→                'error': None\n   316→            }\n   317→            \n   318→        except Exception as e:\n   319→            logger.error(f\"准备API图片失败: {str(e)}\")\n   320→            return {\n   321→                'success': False,\n   322→                'image_path': None,\n   323→                'data_url': None,\n   324→                'is_converted': False,\n   325→                'original_format': None,\n   326→                'final_format': None,\n   327→                'error': f'处理图片失败: {str(e)}'\n   328→            }\n   329→    \n   330→    def _encode_image_to_data_url(self, image_path: str) -> Optional[str]:\n   331→        \"\"\"将图片编码为data URL格式\n   332→        \n   333→        Args:\n   334→            image_path: 图片文件路径\n   335→            \n   336→        Returns:\n   337→            str: data URL格式的图片字符串，失败返回None\n   338→        \"\"\"\n   339→        try:\n   340→            image_path = Path(image_path)\n   341→            \n   342→            # 获取MIME类型\n   343→            file_ext = image_path.suffix.lower()\n   344→            mime_type = self.MIME_TYPES.get(file_ext, 'image/jpeg')\n   345→            \n   346→            # 读取并编码图片\n   347→            with open(image_path, 'rb') as image_file:\n   348→                image_data = image_file.read()\n   349→                encoded_string = base64.b64encode(image_data).decode('utf-8')\n   350→                return f\"data:{mime_type};base64,{encoded_string}\"\n   351→                \n   352→        except Exception as e:\n   353→            logger.error(f\"图片编码失败: {str(e)}\")\n   354→            return None\n   355→    \n   356→    def cleanup_temp_files(self):\n   357→        \"\"\"清理临时文件\"\"\"\n   358→        for temp_file in self.temp_files:\n   359→            try:\n   360→                if os.path.exists(temp_file):\n   361→                    os.remove(temp_file)\n   362→                    logger.debug(f\"已删除临时文件: {temp_file}\")\n   363→            except Exception as e:\n   364→                logger.warning(f\"删除临时文件失败: {temp_file}, 错误: {str(e)}\")\n   365→        \n   366→        self.temp_files.clear()\n   367→    \n   368→    def __del__(self):\n   369→        \"\"\"析构函数，自动清理临时文件\"\"\"\n   370→        self.cleanup_temp_files()\n   371→\n   372→\n   373→# 全局实例\n   374→image_validator = ImageFormatValidator()\n   375→\n   376→\n   377→def validate_and_prepare_image(image_path: str, auto_convert: bool = True) -> Dict[str, Any]:\n   378→    \"\"\"验证并准备图片的便捷函数\n   379→    \n   380→    Args:\n   381→        image_path: 图片文件路径\n   382→        auto_convert: 是否自动转换不支持的格式\n   383→        \n   384→    Returns:\n   385→        Dict: 处理结果\n   386→    \"\"\"\n   387→    return image_validator.prepare_image_for_api(image_path, auto_convert)\n   388→\n   389→\n   390→def cleanup_converted_images():\n   391→    \"\"\"清理转换后的临时图片文件\"\"\"\n   392→    image_validator.cleanup_temp_files()\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b5f1b430-a133-4d16-9fb2-c2d7b79a0f7c","timestamp":"2026-01-08T08:39:37.417Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/utils/image_format_validator.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n图片格式验证和转换工具\n解决火山引擎Seedance API图片格式不支持的问题\n\"\"\"\n\nimport os\nimport base64\nfrom pathlib import Path\nfrom typing import Optional, Tuple, Dict, Any\nfrom PIL import Image, ImageFile\nfrom loguru import logger\n\n# 允许加载截断的图片\nImageFile.LOAD_TRUNCATED_IMAGES = True\n\n\nclass ImageFormatValidator:\n    \"\"\"图片格式验证和转换器\"\"\"\n    \n    # 火山引擎API支持的图片格式 <mcreference link=\"https://blog.csdn.net/weixin_44786530/article/details/146113781\" index=\"1\">1</mcreference>\n    SUPPORTED_FORMATS = {\n        '.jpg': 'JPEG',\n        '.jpeg': 'JPEG', \n        '.png': 'PNG',\n        '.webp': 'WEBP'\n    }\n    \n    # MIME类型映射\n    MIME_TYPES = {\n        '.jpg': 'image/jpeg',\n        '.jpeg': 'image/jpeg',\n        '.png': 'image/png', \n        '.webp': 'image/webp'\n    }\n    \n    # 文件大小限制（10MB）\n    MAX_FILE_SIZE = 10 * 1024 * 1024\n    \n    def __init__(self):\n        \"\"\"初始化验证器\"\"\"\n        self.temp_files = []  # 跟踪临时文件\n        \n    def validate_image(self, image_path: str) -> Dict[str, Any]:\n        \"\"\"验证图片文件\n        \n        Args:\n            image_path: 图片文件路径\n            \n        Returns:\n            Dict: 验证结果\n                {\n                    'valid': bool,\n                    'error': str,\n                    'format': str,\n                    'size': int,\n                    'dimensions': tuple,\n                    'needs_conversion': bool\n                }\n        \"\"\"\n        try:\n            image_path = Path(image_path)\n            \n            # 检查文件是否存在\n            if not image_path.exists():\n                return {\n                    'valid': False,\n                    'error': f'图片文件不存在: {image_path}',\n                    'format': None,\n                    'size': 0,\n                    'dimensions': None,\n                    'needs_conversion': False\n                }\n            \n            # 检查文件大小\n            file_size = image_path.stat().st_size\n            if file_size > self.MAX_FILE_SIZE:\n                return {\n                    'valid': False,\n                    'error': f'图片文件过大: {file_size / 1024 / 1024:.1f}MB > 10MB',\n                    'format': None,\n                    'size': file_size,\n                    'dimensions': None,\n                    'needs_conversion': False\n                }\n            \n            # 检查文件扩展名\n            file_ext = image_path.suffix.lower()\n            \n            # 尝试打开图片获取实际格式\n            try:\n                with Image.open(image_path) as img:\n                    actual_format = img.format\n                    dimensions = img.size\n                    \n                    # 检查是否为支持的格式\n                    if file_ext in self.SUPPORTED_FORMATS:\n                        expected_format = self.SUPPORTED_FORMATS[file_ext]\n                        \n                        # 检查实际格式是否与扩展名匹配\n                        if actual_format == expected_format:\n                            return {\n                                'valid': True,\n                                'error': None,\n                                'format': actual_format,\n                                'size': file_size,\n                                'dimensions': dimensions,\n                                'needs_conversion': False\n                            }\n                        else:\n                            # 格式不匹配，需要转换\n                            return {\n                                'valid': True,\n                                'error': f'图片格式不匹配: 文件扩展名为{file_ext}，实际格式为{actual_format}',\n                                'format': actual_format,\n                                'size': file_size,\n                                'dimensions': dimensions,\n                                'needs_conversion': True\n                            }\n                    else:\n                        # 不支持的格式，需要转换\n                        return {\n                            'valid': True,\n                            'error': f'不支持的图片格式: {file_ext}（{actual_format}），将自动转换为JPEG格式',\n                            'format': actual_format,\n                            'size': file_size,\n                            'dimensions': dimensions,\n                            'needs_conversion': True\n                        }\n                        \n            except Exception as e:\n                return {\n                    'valid': False,\n                    'error': f'无法读取图片文件: {str(e)}',\n                    'format': None,\n                    'size': file_size,\n                    'dimensions': None,\n                    'needs_conversion': False\n                }\n                \n        except Exception as e:\n            logger.error(f\"图片验证失败: {str(e)}\")\n            return {\n                'valid': False,\n                'error': f'图片验证失败: {str(e)}',\n                'format': None,\n                'size': 0,\n                'dimensions': None,\n                'needs_conversion': False\n            }\n    \n    def convert_image_format(self, image_path: str, target_format: str = 'JPEG', \n                           quality: int = 95, output_dir: Optional[str] = None) -> Optional[str]:\n        \"\"\"转换图片格式\n        \n        Args:\n            image_path: 原始图片路径\n            target_format: 目标格式 (JPEG, PNG, WEBP)\n            quality: 图片质量 (1-100，仅对JPEG和WEBP有效)\n            output_dir: 输出目录，如果为None则使用临时目录\n            \n        Returns:\n            str: 转换后的图片路径，失败返回None\n        \"\"\"\n        try:\n            image_path = Path(image_path)\n            \n            # 确定输出路径\n            if output_dir:\n                output_dir = Path(output_dir)\n                output_dir.mkdir(parents=True, exist_ok=True)\n            else:\n                # 使用临时目录\n                import tempfile\n                output_dir = Path(tempfile.gettempdir()) / 'seedance_converted_images'\n                output_dir.mkdir(parents=True, exist_ok=True)\n            \n            # 确定输出文件名和扩展名\n            if target_format.upper() == 'JPEG':\n                output_ext = '.jpg'\n            elif target_format.upper() == 'PNG':\n                output_ext = '.png'\n            elif target_format.upper() == 'WEBP':\n                output_ext = '.webp'\n            else:\n                raise ValueError(f\"不支持的目标格式: {target_format}\")\n            \n            output_path = output_dir / f\"{image_path.stem}_converted{output_ext}\"\n            \n            # 打开并转换图片\n            with Image.open(image_path) as img:\n                # 如果是RGBA模式且目标格式是JPEG，需要转换为RGB\n                if img.mode in ('RGBA', 'LA') and target_format.upper() == 'JPEG':\n                    # 创建白色背景\n                    background = Image.new('RGB', img.size, (255, 255, 255))\n                    if img.mode == 'RGBA':\n                        background.paste(img, mask=img.split()[-1])  # 使用alpha通道作为mask\n                    else:\n                        background.paste(img)\n                    img = background\n                elif img.mode not in ('RGB', 'RGBA', 'L'):\n                    # 转换为RGB模式\n                    img = img.convert('RGB')\n                \n                # 保存图片\n                save_kwargs = {}\n                if target_format.upper() in ('JPEG', 'WEBP'):\n                    save_kwargs['quality'] = quality\n                    save_kwargs['optimize'] = True\n                \n                img.save(output_path, format=target_format.upper(), **save_kwargs)\n            \n            # 记录临时文件\n            self.temp_files.append(str(output_path))\n            \n            logger.info(f\"图片格式转换成功: {image_path} -> {output_path} ({target_format})\")\n            return str(output_path)\n            \n        except Exception as e:\n            logger.error(f\"图片格式转换失败: {str(e)}\")\n            return None\n    \n    def prepare_image_for_api(self, image_path: str, auto_convert: bool = True) -> Dict[str, Any]:\n        \"\"\"为API调用准备图片\n        \n        Args:\n            image_path: 图片文件路径\n            auto_convert: 是否自动转换不支持的格式\n            \n        Returns:\n            Dict: 处理结果\n                {\n                    'success': bool,\n                    'image_path': str,  # 处理后的图片路径\n                    'data_url': str,    # base64 data URL\n                    'is_converted': bool,  # 是否进行了转换\n                    'original_format': str,\n                    'final_format': str,\n                    'error': str\n                }\n        \"\"\"\n        try:\n            # 验证图片\n            validation_result = self.validate_image(image_path)\n            \n            if not validation_result['valid']:\n                return {\n                    'success': False,\n                    'image_path': None,\n                    'data_url': None,\n                    'is_converted': False,\n                    'original_format': validation_result['format'],\n                    'final_format': None,\n                    'error': validation_result['error']\n                }\n            \n            original_format = validation_result['format']\n            final_path = image_path\n            is_converted = False\n            \n            # 如果需要转换且允许自动转换\n            if validation_result['needs_conversion'] and auto_convert:\n                logger.info(f\"检测到需要转换的图片格式: {original_format}，正在转换为JPEG...\")\n                converted_path = self.convert_image_format(image_path, 'JPEG')\n                \n                if converted_path:\n                    final_path = converted_path\n                    is_converted = True\n                    final_format = 'JPEG'\n                    logger.info(f\"图片格式转换成功: {original_format} -> JPEG\")\n                else:\n                    return {\n                        'success': False,\n                        'image_path': None,\n                        'data_url': None,\n                        'is_converted': False,\n                        'original_format': original_format,\n                        'final_format': None,\n                        'error': '图片格式转换失败'\n                    }\n            elif validation_result['needs_conversion'] and not auto_convert:\n                return {\n                    'success': False,\n                    'image_path': None,\n                    'data_url': None,\n                    'is_converted': False,\n                    'original_format': original_format,\n                    'final_format': None,\n                    'error': f'图片格式不支持: {original_format}，请使用JPEG、PNG或WEBP格式'\n                }\n            else:\n                final_format = original_format\n            \n            # 生成data URL\n            data_url = self._encode_image_to_data_url(final_path)\n            if not data_url:\n                return {\n                    'success': False,\n                    'image_path': final_path,\n                    'data_url': None,\n                    'is_converted': is_converted,\n                    'original_format': original_format,\n                    'final_format': final_format,\n                    'error': '生成base64编码失败'\n                }\n            \n            return {\n                'success': True,\n                'image_path': final_path,\n                'data_url': data_url,\n                'is_converted': is_converted,\n                'original_format': original_format,\n                'final_format': final_format,\n                'error': None\n            }\n            \n        except Exception as e:\n            logger.error(f\"准备API图片失败: {str(e)}\")\n            return {\n                'success': False,\n                'image_path': None,\n                'data_url': None,\n                'is_converted': False,\n                'original_format': None,\n                'final_format': None,\n                'error': f'处理图片失败: {str(e)}'\n            }\n    \n    def _encode_image_to_data_url(self, image_path: str) -> Optional[str]:\n        \"\"\"将图片编码为data URL格式\n        \n        Args:\n            image_path: 图片文件路径\n            \n        Returns:\n            str: data URL格式的图片字符串，失败返回None\n        \"\"\"\n        try:\n            image_path = Path(image_path)\n            \n            # 获取MIME类型\n            file_ext = image_path.suffix.lower()\n            mime_type = self.MIME_TYPES.get(file_ext, 'image/jpeg')\n            \n            # 读取并编码图片\n            with open(image_path, 'rb') as image_file:\n                image_data = image_file.read()\n                encoded_string = base64.b64encode(image_data).decode('utf-8')\n                return f\"data:{mime_type};base64,{encoded_string}\"\n                \n        except Exception as e:\n            logger.error(f\"图片编码失败: {str(e)}\")\n            return None\n    \n    def cleanup_temp_files(self):\n        \"\"\"清理临时文件\"\"\"\n        for temp_file in self.temp_files:\n            try:\n                if os.path.exists(temp_file):\n                    os.remove(temp_file)\n                    logger.debug(f\"已删除临时文件: {temp_file}\")\n            except Exception as e:\n                logger.warning(f\"删除临时文件失败: {temp_file}, 错误: {str(e)}\")\n        \n        self.temp_files.clear()\n    \n    def __del__(self):\n        \"\"\"析构函数，自动清理临时文件\"\"\"\n        self.cleanup_temp_files()\n\n\n# 全局实例\nimage_validator = ImageFormatValidator()\n\n\ndef validate_and_prepare_image(image_path: str, auto_convert: bool = True) -> Dict[str, Any]:\n    \"\"\"验证并准备图片的便捷函数\n    \n    Args:\n        image_path: 图片文件路径\n        auto_convert: 是否自动转换不支持的格式\n        \n    Returns:\n        Dict: 处理结果\n    \"\"\"\n    return image_validator.prepare_image_for_api(image_path, auto_convert)\n\n\ndef cleanup_converted_images():\n    \"\"\"清理转换后的临时图片文件\"\"\"\n    image_validator.cleanup_temp_files()","numLines":392,"startLine":1,"totalLines":392}},"sourceToolAssistantUUID":"952ac1b4-d55f-4a89-b937-0c5ad6077e3d"}
{"parentUuid":"252267e1-2fc2-4612-bb31-4811caaa43f2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TFbkwk4Gguxm1TMhTUDBaM","type":"tool_result","content":"components/widgets/image_preview_dialog.py:88:            # Use lazy scaling: handle resizeEvent for better performance or just scale effectively\ncomponents/widgets/image_preview_dialog.py:118:    def resizeEvent(self, event):\ncomponents/widgets/image_preview_dialog.py:121:        super().resizeEvent(event)\nmodules/storage/unified_storage_manager_v2.py:96:                        save_kwargs = {'quality': 95, 'optimize': True}\nmodules/storage/unified_storage_manager_v2.py:98:                        save_kwargs = {'quality': 95}\nmodules/storage/unified_storage_manager_v2.py:121:                img.save(thumb_path, format=\"JPEG\", quality=92)\ncomponents/widgets/zoomable_image_label.py:124:    def resizeEvent(self, event):\ncomponents/widgets/zoomable_image_label.py:126:        super().resizeEvent(event)\nmodules/repository/csv_handler.py:45:        self.data_quality_file = self.csv_dir / \"data_quality.csv\"\nmodules/repository/csv_handler.py:78:                    'created_at', 'updated_at', 'status', 'quality_score',\nmodules/repository/csv_handler.py:98:                    'size_average', 'quality_average', 'tags_total', 'tags_unique',\nmodules/repository/csv_handler.py:103:        if not self.data_quality_file.exists():\nmodules/repository/csv_handler.py:104:            with open(self.data_quality_file, 'w', newline='', encoding='utf-8') as f:\nmodules/repository/csv_handler.py:167:                'quality_score': str(self._calculate_quality_score(metadata)),\nmodules/repository/csv_handler.py:184:                    record['quality_score'], record['tags_count'], record['references_count'],\nmodules/repository/csv_handler.py:216:    def _calculate_quality_score(self, metadata: Dict[str, Any]) -> float:\nmodules/repository/csv_handler.py:471:            quality_scores = [float(r['quality_score']) for r in type_records if r['quality_score']]\nmodules/repository/csv_handler.py:472:            quality_average = sum(quality_scores) / len(quality_scores) if quality_scores else 0\nmodules/repository/csv_handler.py:486:                'quality_average': quality_average,\nmodules/repository/csv_handler.py:510:                    'size_average', 'quality_average', 'tags_total', 'tags_unique',\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"eea8c823-1ab3-4d69-8673-8a56327d1fd8","timestamp":"2026-01-08T08:39:37.432Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"components/widgets/image_preview_dialog.py:88:            # Use lazy scaling: handle resizeEvent for better performance or just scale effectively\ncomponents/widgets/image_preview_dialog.py:118:    def resizeEvent(self, event):\ncomponents/widgets/image_preview_dialog.py:121:        super().resizeEvent(event)\nmodules/storage/unified_storage_manager_v2.py:96:                        save_kwargs = {'quality': 95, 'optimize': True}\nmodules/storage/unified_storage_manager_v2.py:98:                        save_kwargs = {'quality': 95}\nmodules/storage/unified_storage_manager_v2.py:121:                img.save(thumb_path, format=\"JPEG\", quality=92)\ncomponents/widgets/zoomable_image_label.py:124:    def resizeEvent(self, event):\ncomponents/widgets/zoomable_image_label.py:126:        super().resizeEvent(event)\nmodules/repository/csv_handler.py:45:        self.data_quality_file = self.csv_dir / \"data_quality.csv\"\nmodules/repository/csv_handler.py:78:                    'created_at', 'updated_at', 'status', 'quality_score',\nmodules/repository/csv_handler.py:98:                    'size_average', 'quality_average', 'tags_total', 'tags_unique',\nmodules/repository/csv_handler.py:103:        if not self.data_quality_file.exists():\nmodules/repository/csv_handler.py:104:            with open(self.data_quality_file, 'w', newline='', encoding='utf-8') as f:\nmodules/repository/csv_handler.py:167:                'quality_score': str(self._calculate_quality_score(metadata)),\nmodules/repository/csv_handler.py:184:                    record['quality_score'], record['tags_count'], record['references_count'],\nmodules/repository/csv_handler.py:216:    def _calculate_quality_score(self, metadata: Dict[str, Any]) -> float:\nmodules/repository/csv_handler.py:471:            quality_scores = [float(r['quality_score']) for r in type_records if r['quality_score']]\nmodules/repository/csv_handler.py:472:            quality_average = sum(quality_scores) / len(quality_scores) if quality_scores else 0\nmodules/repository/csv_handler.py:486:                'quality_average': quality_average,\nmodules/repository/csv_handler.py:510:                    'size_average', 'quality_average', 'tags_total', 'tags_unique',","numLines":20,"appliedLimit":20},"sourceToolAssistantUUID":"252267e1-2fc2-4612-bb31-4811caaa43f2"}
{"parentUuid":"eea8c823-1ab3-4d69-8673-8a56327d1fd8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013JhucB59pNehkUjPMeosVS","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me search for how reference images are selected in the UI and any existing image size/compression logic:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6453,"cache_read_input_tokens":75877,"cache_creation":{"ephemeral_5m_input_tokens":6453,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"68420e4f-30f6-4fb4-8fbc-ee24005dbc64","timestamp":"2026-01-08T08:39:45.696Z"}
{"parentUuid":"68420e4f-30f6-4fb4-8fbc-ee24005dbc64","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013JhucB59pNehkUjPMeosVS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FA8W2xgDsgRnayChp3XWtJ","name":"Grep","input":{"head_limit":20,"output_mode":"content","path":"/Users/yunchang/Documents/GitHub/gemeng2","pattern":"reference_images.*=|collect_assets|filesChanged","type":"py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6453,"cache_read_input_tokens":75877,"cache_creation":{"ephemeral_5m_input_tokens":6453,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"ae053591-6700-43f3-89cb-109bc9bb15a0","timestamp":"2026-01-08T08:39:46.620Z"}
{"parentUuid":"ae053591-6700-43f3-89cb-109bc9bb15a0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013JhucB59pNehkUjPMeosVS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nq9kmws295PvSKvw1Ekned","name":"Bash","input":{"command":"find /Users/yunchang/Documents/GitHub/gemeng2/components/modes -name \"*.py\" -type f | head -10","description":"Find mode widget implementation files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6453,"cache_read_input_tokens":75877,"cache_creation":{"ephemeral_5m_input_tokens":6453,"ephemeral_1h_input_tokens":0},"output_tokens":260,"service_tier":"standard"}},"type":"assistant","uuid":"7d130527-75d0-4b25-9c12-00b0d1614689","timestamp":"2026-01-08T08:39:47.104Z"}
{"parentUuid":"ae053591-6700-43f3-89cb-109bc9bb15a0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FA8W2xgDsgRnayChp3XWtJ","type":"tool_result","content":"services/image_service.py:77:        reference_images = params.get(\"reference_images\") or []\nservices/image_service.py:102:                    reference_images=reference_images,\nservices/image_service.py:117:                    reference_images=reference_images,\nservices/image_service.py:175:                reference_images=reference_images or None,\nservices/image_service.py:186:            reference_images=reference_images or None,\nservices/image_service.py:236:                        reference_images=reference_images or None,\nservices/image_service.py:246:                        reference_images=reference_images or None,\nservices/video_service.py:244:        reference_images = params.get(\"reference_images\") or params.get(\"reference_assets\") or []\nservices/video_service.py:267:                reference_images=reference_images,\nservices/video_service.py:361:            reference_images=reference_images,\nmodules/seedance/manager.py:103:        reference_images: Optional[List[Any]] = None,\r\nmodules/seedance/manager.py:212:            create_kwargs['reference_images'] = ref_payloads\r\nmodules/seedance/client.py:510:        reference_images: Optional[List[str]] = None,\nmodules/seedance/client.py:573:                    reference_images=(reference_images or []),\nmodules/seedance/client.py:676:            if reference_images and not image_path and effective_model_type == \"lite\":\nmodules/seedream/manager.py:82:        reference_images: Optional[List[Any]] = None,\nmodules/seedream/manager.py:180:                reference_images=ref_payloads or None,\nmodules/seedream/manager.py:341:        reference_images: Optional[List[Any]] = None,\nmodules/seedream/manager.py:401:                        reference_images=ref_payloads,\nmodules/seedream/manager.py:418:                reference_images=(ref_payloads or None),\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"993b2e16-5458-4583-af99-ae86e813c355","timestamp":"2026-01-08T08:39:47.182Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"services/image_service.py:77:        reference_images = params.get(\"reference_images\") or []\nservices/image_service.py:102:                    reference_images=reference_images,\nservices/image_service.py:117:                    reference_images=reference_images,\nservices/image_service.py:175:                reference_images=reference_images or None,\nservices/image_service.py:186:            reference_images=reference_images or None,\nservices/image_service.py:236:                        reference_images=reference_images or None,\nservices/image_service.py:246:                        reference_images=reference_images or None,\nservices/video_service.py:244:        reference_images = params.get(\"reference_images\") or params.get(\"reference_assets\") or []\nservices/video_service.py:267:                reference_images=reference_images,\nservices/video_service.py:361:            reference_images=reference_images,\nmodules/seedance/manager.py:103:        reference_images: Optional[List[Any]] = None,\r\nmodules/seedance/manager.py:212:            create_kwargs['reference_images'] = ref_payloads\r\nmodules/seedance/client.py:510:        reference_images: Optional[List[str]] = None,\nmodules/seedance/client.py:573:                    reference_images=(reference_images or []),\nmodules/seedance/client.py:676:            if reference_images and not image_path and effective_model_type == \"lite\":\nmodules/seedream/manager.py:82:        reference_images: Optional[List[Any]] = None,\nmodules/seedream/manager.py:180:                reference_images=ref_payloads or None,\nmodules/seedream/manager.py:341:        reference_images: Optional[List[Any]] = None,\nmodules/seedream/manager.py:401:                        reference_images=ref_payloads,\nmodules/seedream/manager.py:418:                reference_images=(ref_payloads or None),","numLines":20,"appliedLimit":20},"sourceToolAssistantUUID":"ae053591-6700-43f3-89cb-109bc9bb15a0"}
{"parentUuid":"7d130527-75d0-4b25-9c12-00b0d1614689","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nq9kmws295PvSKvw1Ekned","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/image_mode_widget.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/generation_logic.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/parameter_logic.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/mode_widget_impl.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py","is_error":false}]},"uuid":"31d21f58-3d01-4a53-a4f0-e8a27b9cd3af","timestamp":"2026-01-08T08:39:47.249Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/image_mode_widget.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/generation_logic.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/parameter_logic.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/mode_widget_impl.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"7d130527-75d0-4b25-9c12-00b0d1614689"}
{"parentUuid":"31d21f58-3d01-4a53-a4f0-e8a27b9cd3af","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01W5nt7UhiuTTfQyiq5Dwu6W","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check how references are collected from the UI:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1141,"cache_read_input_tokens":82330,"cache_creation":{"ephemeral_5m_input_tokens":1141,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"0bf18fa3-c4f5-440c-acc6-d6cfbf8a213f","timestamp":"2026-01-08T08:39:54.477Z"}
{"parentUuid":"0bf18fa3-c4f5-440c-acc6-d6cfbf8a213f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01W5nt7UhiuTTfQyiq5Dwu6W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0196d98qL6inKWDe8C5451vX","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1141,"cache_read_input_tokens":82330,"cache_creation":{"ephemeral_5m_input_tokens":1141,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"d4bef30d-b4f6-43f5-b32a-2878b81fb6b8","timestamp":"2026-01-08T08:39:54.923Z"}
{"parentUuid":"d4bef30d-b4f6-43f5-b32a-2878b81fb6b8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01W5nt7UhiuTTfQyiq5Dwu6W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fd8WE1pAfZqyPr31j9cJze","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py","limit":120}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1141,"cache_read_input_tokens":82330,"cache_creation":{"ephemeral_5m_input_tokens":1141,"ephemeral_1h_input_tokens":0},"output_tokens":183,"service_tier":"standard"}},"type":"assistant","uuid":"ef4124e0-0cd1-47d5-a24d-7476bb4179f9","timestamp":"2026-01-08T08:39:55.192Z"}
{"parentUuid":"d4bef30d-b4f6-43f5-b32a-2878b81fb6b8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0196d98qL6inKWDe8C5451vX","type":"tool_result","content":"     1→\"\"\"Image mode: generation orchestration logic (Phase 4.3.b).\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import os\n     6→from datetime import datetime\n     7→from typing import Any, Dict, List, Optional\n     8→\n     9→from PySide6.QtCore import QTimer\n    10→from loguru import logger\n    11→\n    12→from config.sources.generation_config import IMAGE_GENERATION_DEFAULTS\n    13→from utils.reference_display import _mask_reference_ids\n    14→\n    15→\n    16→def generate_image(self) -> None:\n    17→    \"\"\"生成图片\"\"\"\n    18→    prompt = self.prompt_input.toPlainText().strip()\n    19→    if not prompt:\n    20→        self.show_styled_message(\"警告\", \"请输入提示词\", \"warning\")\n    21→        return\n    22→\n    23→    form_values = self._collect_image_form_values()\n    24→    if form_values is None:\n    25→        self.generate_button.setEnabled(True)\n    26→        return\n    27→\n    28→    guidance_scale = float(IMAGE_GENERATION_DEFAULTS.get(\"guidance_scale\", 2.5))\n    29→\n    30→    seed_value = form_values.get(\"seed\", -1)\n    31→    try:\n    32→        seed_value = int(seed_value)\n    33→    except Exception:\n    34→        seed_value = -1\n    35→\n    36→    count_value = form_values.get(\"count\", 1)\n    37→    try:\n    38→        count_value = max(1, int(count_value))\n    39→    except Exception:\n    40→        count_value = 1\n    41→\n    42→    schema_values = dict(form_values)\n    43→    schema_values[\"guidance_scale\"] = guidance_scale\n    44→\n    45→    params = {\n    46→        \"size\": form_values.get(\"size\"),\n    47→        \"guidance_scale\": guidance_scale,\n    48→        \"seed\": seed_value,\n    49→        \"count\": count_value,\n    50→        \"model_variant\": form_values.get(\"model_variant\") or self._image_schema_variant,\n    51→        \"auto_compress_references\": form_values.get(\"auto_compress_references\", True),\n    52→        \"sequential_mode\": bool(form_values.get(\"sequential_mode\", False)),\n    53→        \"schema_values\": schema_values,\n    54→    }\n    55→    if not params[\"size\"]:\n    56→        params[\"size\"] = IMAGE_GENERATION_DEFAULTS.get(\"size\", \"1024x1024\")\n    57→\n    58→    expected_outputs = max(1, count_value)\n    59→\n    60→    reference_assets: Optional[List[Dict[str, Any]]]\n    61→    # 移除了参考图数量限制验证 - ImageService._generate_batch() 已正确支持\n    62→    # 参考图 + count > 1 的情况，会自动改为逐张生成模式\n    63→    reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n    64→    if reference_assets is None:\n    65→        self._last_reference_assets = []\n    66→        self.generate_button.setEnabled(True)\n    67→        return\n    68→\n    69→    params[\"reference_images\"] = reference_assets\n    70→    params[\"reference_count\"] = len(reference_assets)\n    71→    self._last_reference_assets = reference_assets or []\n    72→    params[\"prompt\"] = prompt\n    73→    if self.uploaded_image:\n    74→        params[\"image_path\"] = self.uploaded_image\n    75→        params.setdefault(\"input_image_path\", self.uploaded_image)\n    76→\n    77→    self.generate_button.setEnabled(False)\n    78→    try:\n    79→        task_id = self._task_manager.submit_image_task(params)\n    80→        # 占位 ID 必须与最终记录一致：单张用基 ID，批量使用派生 ID\n    81→        derived_ids = params.get(\"derived_ids\")\n    82→        if not derived_ids:\n    83→            if expected_outputs <= 1:\n    84→                derived_ids = [task_id]\n    85→            else:\n    86→                derived_ids = [f\"{task_id}_{i+1}\" for i in range(expected_outputs)]\n    87→        derived_ids = derived_ids[:expected_outputs]\n    88→        self._task_placeholder_index[task_id] = derived_ids\n    89→\n    90→        repo_manager = self.get_repository_manager()\n    91→        if repo_manager:\n    92→            pending_template = {\n    93→                \"prompt\": prompt,\n    94→                \"model\": params.get(\"model\", \"\"),\n    95→                \"status\": \"pending\",\n    96→                \"created_at\": datetime.now().isoformat(),\n    97→                \"parameters\": params,\n    98→            }\n    99→            for pid in derived_ids:\n   100→                repo_manager.add_content(pid, \"images\", dict(pending_template))\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"6521798b-70e7-4997-82ad-5a421ff01688","timestamp":"2026-01-08T08:39:55.265Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py","content":"\"\"\"Image mode: generation orchestration logic (Phase 4.3.b).\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\n\nfrom PySide6.QtCore import QTimer\nfrom loguru import logger\n\nfrom config.sources.generation_config import IMAGE_GENERATION_DEFAULTS\nfrom utils.reference_display import _mask_reference_ids\n\n\ndef generate_image(self) -> None:\n    \"\"\"生成图片\"\"\"\n    prompt = self.prompt_input.toPlainText().strip()\n    if not prompt:\n        self.show_styled_message(\"警告\", \"请输入提示词\", \"warning\")\n        return\n\n    form_values = self._collect_image_form_values()\n    if form_values is None:\n        self.generate_button.setEnabled(True)\n        return\n\n    guidance_scale = float(IMAGE_GENERATION_DEFAULTS.get(\"guidance_scale\", 2.5))\n\n    seed_value = form_values.get(\"seed\", -1)\n    try:\n        seed_value = int(seed_value)\n    except Exception:\n        seed_value = -1\n\n    count_value = form_values.get(\"count\", 1)\n    try:\n        count_value = max(1, int(count_value))\n    except Exception:\n        count_value = 1\n\n    schema_values = dict(form_values)\n    schema_values[\"guidance_scale\"] = guidance_scale\n\n    params = {\n        \"size\": form_values.get(\"size\"),\n        \"guidance_scale\": guidance_scale,\n        \"seed\": seed_value,\n        \"count\": count_value,\n        \"model_variant\": form_values.get(\"model_variant\") or self._image_schema_variant,\n        \"auto_compress_references\": form_values.get(\"auto_compress_references\", True),\n        \"sequential_mode\": bool(form_values.get(\"sequential_mode\", False)),\n        \"schema_values\": schema_values,\n    }\n    if not params[\"size\"]:\n        params[\"size\"] = IMAGE_GENERATION_DEFAULTS.get(\"size\", \"1024x1024\")\n\n    expected_outputs = max(1, count_value)\n\n    reference_assets: Optional[List[Dict[str, Any]]]\n    # 移除了参考图数量限制验证 - ImageService._generate_batch() 已正确支持\n    # 参考图 + count > 1 的情况，会自动改为逐张生成模式\n    reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n    if reference_assets is None:\n        self._last_reference_assets = []\n        self.generate_button.setEnabled(True)\n        return\n\n    params[\"reference_images\"] = reference_assets\n    params[\"reference_count\"] = len(reference_assets)\n    self._last_reference_assets = reference_assets or []\n    params[\"prompt\"] = prompt\n    if self.uploaded_image:\n        params[\"image_path\"] = self.uploaded_image\n        params.setdefault(\"input_image_path\", self.uploaded_image)\n\n    self.generate_button.setEnabled(False)\n    try:\n        task_id = self._task_manager.submit_image_task(params)\n        # 占位 ID 必须与最终记录一致：单张用基 ID，批量使用派生 ID\n        derived_ids = params.get(\"derived_ids\")\n        if not derived_ids:\n            if expected_outputs <= 1:\n                derived_ids = [task_id]\n            else:\n                derived_ids = [f\"{task_id}_{i+1}\" for i in range(expected_outputs)]\n        derived_ids = derived_ids[:expected_outputs]\n        self._task_placeholder_index[task_id] = derived_ids\n\n        repo_manager = self.get_repository_manager()\n        if repo_manager:\n            pending_template = {\n                \"prompt\": prompt,\n                \"model\": params.get(\"model\", \"\"),\n                \"status\": \"pending\",\n                \"created_at\": datetime.now().isoformat(),\n                \"parameters\": params,\n            }\n            for pid in derived_ids:\n                repo_manager.add_content(pid, \"images\", dict(pending_template))","numLines":100,"startLine":1,"totalLines":438}},"sourceToolAssistantUUID":"d4bef30d-b4f6-43f5-b32a-2878b81fb6b8"}
{"parentUuid":"ef4124e0-0cd1-47d5-a24d-7476bb4179f9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fd8WE1pAfZqyPr31j9cJze","type":"tool_result","content":"     1→\"\"\"Seedream image generation service layer.\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import uuid\n     6→from typing import Any, Callable, Dict, List, Optional\n     7→\n     8→from config.unified_config import get_unified_config\n     9→from modules.repository.manager import RepositoryManager\n    10→from modules.seedream.manager import SeedreamManager\n    11→from modules.storage import get_v2_storage_manager\n    12→from utils.logger import logger\n    13→\n    14→ProgressCallback = Optional[Callable[[Optional[float], str], None]]\n    15→CancelCallback = Optional[Callable[[], bool]]\n    16→\n    17→\n    18→class ImageService:\n    19→    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n    20→\n    21→    def __init__(\n    22→        self,\n    23→        storage_manager=None,\n    24→        repository_manager: Optional[RepositoryManager] = None,\n    25→        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    26→    ) -> None:\n    27→        # Use unified config for storage path and API validation\n    28→        self.unified_config = get_unified_config()\n    29→\n    30→        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n    31→        self.repository_manager = repository_manager\n    32→        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n    33→\n    34→    # ------------------------------------------------------------------\n    35→    # Public API\n    36→    # ------------------------------------------------------------------\n    37→    def generate_image(\n    38→        self,\n    39→        params: Dict[str, Any],\n    40→        progress_callback: ProgressCallback = None,\n    41→        should_cancel: CancelCallback = None,\n    42→    ) -> Dict[str, Any]:\n    43→        prompt = (params.get(\"prompt\") or \"\").strip()\n    44→        if not prompt:\n    45→            return self._failure(\"Prompt cannot be empty\")\n    46→\n    47→        if self._is_cancelled(should_cancel):\n    48→            return self._cancelled()\n    49→\n    50→        self._emit_progress(progress_callback, \"Preparing...\")\n    51→\n    52→        try:\n    53→            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n    54→            if not is_valid:\n    55→                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n    56→                detail = message or \"API key not configured\"\n    57→                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n    58→        except Exception as cfg_err:\n    59→            return self._failure(f\"Config validation failed: {cfg_err}\")\n    60→\n    61→        try:\n    62→            api_key = self.unified_config.get_api_key(\"volcengine\")\n    63→        except Exception as key_err:\n    64→            return self._failure(f\"Failed to load API key: {key_err}\")\n    65→\n    66→        if self._is_cancelled(should_cancel):\n    67→            return self._cancelled()\n    68→\n    69→        try:\n    70→            seedream_manager = self._seedream_manager_factory(api_key)\n    71→            self._emit_progress(progress_callback, \"Seedream manager ready\")\n    72→        except Exception as init_err:\n    73→            logger.error(f\"Seedream manager init failed: {init_err}\")\n    74→            return self._failure(f\"Seedream manager init failed: {init_err}\")\n    75→\n    76→        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n    77→        reference_images = params.get(\"reference_images\") or []\n    78→        input_image_path = (\n    79→            params.get(\"input_image_path\")\n    80→            or params.get(\"input_image\")\n    81→            or params.get(\"image_path\")\n    82→            or params.get(\"image\")\n    83→        )\n    84→        base_size = params.get(\"size\", \"1024x1024\")\n    85→        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n    86→        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n    87→        model_variant = params.get(\"model_variant\")\n    88→        generation_id = params.get(\"generation_id\")\n    89→        derived_ids: List[str] = params.get(\"derived_ids\") or []\n    90→        sequential_mode = bool(params.get(\"sequential_mode\", False))\n    91→\n    92→        try:\n    93→            if generation_count == 1:\n    94→                result = self._generate_single(\n    95→                    seedream_manager=seedream_manager,\n    96→                    prompt=prompt,\n    97→                    size=base_size,\n    98→                    guidance_scale=guidance_scale,\n    99→                    seed=seed,\n   100→                    model_variant=model_variant,\n   101→                    input_image_path=input_image_path,\n   102→                    reference_images=reference_images,\n   103→                    generation_id=generation_id,\n   104→                    sequential_mode=sequential_mode,\n   105→                    progress_callback=progress_callback,\n   106→                    should_cancel=should_cancel,\n   107→                )\n   108→            else:\n   109→                result = self._generate_batch(\n   110→                    seedream_manager=seedream_manager,\n   111→                    prompt=prompt,\n   112→                    count=generation_count,\n   113→                    size=base_size,\n   114→                    guidance_scale=guidance_scale,\n   115→                    seed=seed,\n   116→                    input_image_path=input_image_path,\n   117→                    reference_images=reference_images,\n   118→                    model_variant=model_variant,\n   119→                    generation_id=generation_id,\n   120→                    derived_ids=derived_ids,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"79df73c0-5231-4e09-98d5-48dac2cd25db","timestamp":"2026-01-08T08:39:55.265Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py","content":"\"\"\"Seedream image generation service layer.\"\"\"\n\nfrom __future__ import annotations\n\nimport uuid\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom config.unified_config import get_unified_config\nfrom modules.repository.manager import RepositoryManager\nfrom modules.seedream.manager import SeedreamManager\nfrom modules.storage import get_v2_storage_manager\nfrom utils.logger import logger\n\nProgressCallback = Optional[Callable[[Optional[float], str], None]]\nCancelCallback = Optional[Callable[[], bool]]\n\n\nclass ImageService:\n    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n\n    def __init__(\n        self,\n        storage_manager=None,\n        repository_manager: Optional[RepositoryManager] = None,\n        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    ) -> None:\n        # Use unified config for storage path and API validation\n        self.unified_config = get_unified_config()\n\n        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n        self.repository_manager = repository_manager\n        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n    def generate_image(\n        self,\n        params: Dict[str, Any],\n        progress_callback: ProgressCallback = None,\n        should_cancel: CancelCallback = None,\n    ) -> Dict[str, Any]:\n        prompt = (params.get(\"prompt\") or \"\").strip()\n        if not prompt:\n            return self._failure(\"Prompt cannot be empty\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        self._emit_progress(progress_callback, \"Preparing...\")\n\n        try:\n            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n            if not is_valid:\n                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n                detail = message or \"API key not configured\"\n                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n        except Exception as cfg_err:\n            return self._failure(f\"Config validation failed: {cfg_err}\")\n\n        try:\n            api_key = self.unified_config.get_api_key(\"volcengine\")\n        except Exception as key_err:\n            return self._failure(f\"Failed to load API key: {key_err}\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        try:\n            seedream_manager = self._seedream_manager_factory(api_key)\n            self._emit_progress(progress_callback, \"Seedream manager ready\")\n        except Exception as init_err:\n            logger.error(f\"Seedream manager init failed: {init_err}\")\n            return self._failure(f\"Seedream manager init failed: {init_err}\")\n\n        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n        reference_images = params.get(\"reference_images\") or []\n        input_image_path = (\n            params.get(\"input_image_path\")\n            or params.get(\"input_image\")\n            or params.get(\"image_path\")\n            or params.get(\"image\")\n        )\n        base_size = params.get(\"size\", \"1024x1024\")\n        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n        model_variant = params.get(\"model_variant\")\n        generation_id = params.get(\"generation_id\")\n        derived_ids: List[str] = params.get(\"derived_ids\") or []\n        sequential_mode = bool(params.get(\"sequential_mode\", False))\n\n        try:\n            if generation_count == 1:\n                result = self._generate_single(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    model_variant=model_variant,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    generation_id=generation_id,\n                    sequential_mode=sequential_mode,\n                    progress_callback=progress_callback,\n                    should_cancel=should_cancel,\n                )\n            else:\n                result = self._generate_batch(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    count=generation_count,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    model_variant=model_variant,\n                    generation_id=generation_id,\n                    derived_ids=derived_ids,","numLines":120,"startLine":1,"totalLines":398}},"sourceToolAssistantUUID":"ef4124e0-0cd1-47d5-a24d-7476bb4179f9"}
{"parentUuid":"79df73c0-5231-4e09-98d5-48dac2cd25db","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NpwD1X2T2C9UrZK6nerUmD","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! Now I have a comprehensive understanding. Let me search for how references are passed from UI to the service layer:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3672,"cache_read_input_tokens":83471,"cache_creation":{"ephemeral_5m_input_tokens":3672,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"95a9358e-8e51-444c-9fcb-eb1b906930da","timestamp":"2026-01-08T08:40:00.898Z"}
{"parentUuid":"95a9358e-8e51-444c-9fcb-eb1b906930da","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NpwD1X2T2C9UrZK6nerUmD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011PJEfkbZymvaAYYYyFRqt3","name":"Bash","input":{"command":"grep -r \"_collect_reference_assets_for_image\\|collect_assets\" /Users/yunchang/Documents/GitHub/gemeng2/components --include=\"*.py\" | head -15","description":"Find reference asset collection methods"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3672,"cache_read_input_tokens":83471,"cache_creation":{"ephemeral_5m_input_tokens":3672,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"75d0818d-025f-4d09-9ba9-6be771aba322","timestamp":"2026-01-08T08:40:01.618Z"}
{"parentUuid":"75d0818d-025f-4d09-9ba9-6be771aba322","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NpwD1X2T2C9UrZK6nerUmD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K9bseQLKQoNTWe9emdSXU2","name":"Grep","input":{"head_limit":30,"output_mode":"content","path":"/Users/yunchang/Documents/GitHub/gemeng2","pattern":"_collect_reference.*|collect_assets|reference_panel","type":"py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3672,"cache_read_input_tokens":83471,"cache_creation":{"ephemeral_5m_input_tokens":3672,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"b084d65f-5bfe-43c8-8a20-772d87244c30","timestamp":"2026-01-08T08:40:02.205Z"}
{"parentUuid":"b084d65f-5bfe-43c8-8a20-772d87244c30","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K9bseQLKQoNTWe9emdSXU2","type":"tool_result","content":".style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py:167:    def collect_assets(self) -> List[Dict[str, Any]]:\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py:189:        assets = self.collect_assets()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4999:        self.reference_panel: Optional[ReferenceAssetsPanel] = None\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5321:        self.reference_panel = ReferenceAssetsPanel(self.input_widget)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5322:        self.reference_panel.setVisible(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5323:        self.reference_panel.set_panel_enabled(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5324:        self.reference_panel.filesChanged.connect(self._on_reference_files_changed)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5325:        self.reference_panel.warningEmitted.connect(self._on_reference_warning)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5326:        input_layout.addWidget(self.reference_panel)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5393:        self._refresh_image_reference_panel_state(preserved)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5401:        panel = self.reference_panel\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5427:        self._refresh_image_reference_panel_state()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5439:    def _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5440:        panel = self.reference_panel\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5462:        if not self.reference_panel:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5464:        count = self.reference_panel.current_count()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5476:    def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5477:        panel = self.reference_panel\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5517:        return panel.collect_assets()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6347:        if self.reference_panel and self.reference_panel.current_count() > 0 and count_value > 1:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6357:        reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6510:        self.video_reference_panel: Optional[ReferenceAssetsPanel] = None\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6910:        self.video_reference_panel = ReferenceAssetsPanel(self.input_widget)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6911:        self.video_reference_panel.setVisible(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6912:        self.video_reference_panel.set_panel_enabled(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6913:        self.video_reference_panel.filesChanged.connect(self._on_video_reference_files_changed)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6914:        self.video_reference_panel.warningEmitted.connect(self._on_video_reference_warning)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6915:        input_layout.addWidget(self.video_reference_panel)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6981:        self._refresh_video_reference_panel_state(preserved)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6989:        panel = self.video_reference_panel\n\n[Showing results with pagination = limit: 30, offset: 0]"}]},"uuid":"e710a189-ea8a-42f7-90bd-55c2a4106101","timestamp":"2026-01-08T08:40:02.299Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":".style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py:167:    def collect_assets(self) -> List[Dict[str, Any]]:\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py:189:        assets = self.collect_assets()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4999:        self.reference_panel: Optional[ReferenceAssetsPanel] = None\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5321:        self.reference_panel = ReferenceAssetsPanel(self.input_widget)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5322:        self.reference_panel.setVisible(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5323:        self.reference_panel.set_panel_enabled(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5324:        self.reference_panel.filesChanged.connect(self._on_reference_files_changed)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5325:        self.reference_panel.warningEmitted.connect(self._on_reference_warning)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5326:        input_layout.addWidget(self.reference_panel)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5393:        self._refresh_image_reference_panel_state(preserved)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5401:        panel = self.reference_panel\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5427:        self._refresh_image_reference_panel_state()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5439:    def _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5440:        panel = self.reference_panel\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5462:        if not self.reference_panel:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5464:        count = self.reference_panel.current_count()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5476:    def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5477:        panel = self.reference_panel\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:5517:        return panel.collect_assets()\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6347:        if self.reference_panel and self.reference_panel.current_count() > 0 and count_value > 1:\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6357:        reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6510:        self.video_reference_panel: Optional[ReferenceAssetsPanel] = None\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6910:        self.video_reference_panel = ReferenceAssetsPanel(self.input_widget)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6911:        self.video_reference_panel.setVisible(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6912:        self.video_reference_panel.set_panel_enabled(False)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6913:        self.video_reference_panel.filesChanged.connect(self._on_video_reference_files_changed)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6914:        self.video_reference_panel.warningEmitted.connect(self._on_video_reference_warning)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6915:        input_layout.addWidget(self.video_reference_panel)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6981:        self._refresh_video_reference_panel_state(preserved)\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6989:        panel = self.video_reference_panel","numLines":30,"appliedLimit":30},"sourceToolAssistantUUID":"b084d65f-5bfe-43c8-8a20-772d87244c30"}
{"parentUuid":"75d0818d-025f-4d09-9ba9-6be771aba322","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011PJEfkbZymvaAYYYyFRqt3","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/parameter_logic.py:    return panel.collect_assets()\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py:    reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py:def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py:        panel_assets = panel.collect_assets()\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/mode_widget_impl.py:    def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/controllers/parameter_controller.py:        return _image._collect_reference_assets_for_image(self._w, expected_outputs)\n/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/reference_assets_panel.py:    def collect_assets(self) -> List[Dict[str, Any]]:\n/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/reference_assets_panel.py:        assets = self.collect_assets()\n/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/integrated_reference_panel.py:    def collect_assets(self) -> List[Dict[str, Any]]:","is_error":false}]},"uuid":"2adf7e95-81e8-43f0-a8c5-c01e38fc3e5e","timestamp":"2026-01-08T08:40:02.363Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/video/parameter_logic.py:    return panel.collect_assets()\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py:    reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py:def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py:        panel_assets = panel.collect_assets()\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/mode_widget_impl.py:    def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/controllers/parameter_controller.py:        return _image._collect_reference_assets_for_image(self._w, expected_outputs)\n/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/reference_assets_panel.py:    def collect_assets(self) -> List[Dict[str, Any]]:\n/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/reference_assets_panel.py:        assets = self.collect_assets()\n/Users/yunchang/Documents/GitHub/gemeng2/components/widgets/integrated_reference_panel.py:    def collect_assets(self) -> List[Dict[str, Any]]:","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"75d0818d-025f-4d09-9ba9-6be771aba322"}
{"parentUuid":"2adf7e95-81e8-43f0-a8c5-c01e38fc3e5e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QNhKDnJhUSpu3vn33nr1oo","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me get the complete picture by checking the parameter_logic file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1620,"cache_creation_input_tokens":888,"cache_read_input_tokens":87143,"cache_creation":{"ephemeral_5m_input_tokens":888,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"64f67cfb-1bdd-44fb-9137-04c6284438b3","timestamp":"2026-01-08T08:40:08.043Z"}
{"parentUuid":"64f67cfb-1bdd-44fb-9137-04c6284438b3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QNhKDnJhUSpu3vn33nr1oo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hgqb4bQQe2B4NxiQXdwSMk","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1620,"cache_creation_input_tokens":888,"cache_read_input_tokens":87143,"cache_creation":{"ephemeral_5m_input_tokens":888,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"201202d8-a2e6-4ef7-b017-fd3002df8bc8","timestamp":"2026-01-08T08:40:08.627Z"}
{"parentUuid":"201202d8-a2e6-4ef7-b017-fd3002df8bc8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Hgqb4bQQe2B4NxiQXdwSMk","type":"tool_result","content":"     1→\"\"\"Image mode: parameter/schema related logic (Phase 4.3.a).\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import os\n     6→import re\n     7→import json\n     8→from datetime import datetime\n     9→from pathlib import Path\n    10→from typing import Any, Dict, List, Optional\n    11→\n    12→from PySide6.QtWidgets import QMessageBox\n    13→from loguru import logger\n    14→\n    15→from modules.provider import get_ui_schema\n    16→from utils.reference_display import _evaluate_dependency_rules\n    17→\n    18→\n    19→def _load_image_schema(\n    20→    self,\n    21→    variant: Optional[str] = None,\n    22→    *,\n    23→    keep_values: bool = True,\n    24→    initial_values: Optional[Dict[str, Any]] = None,\n    25→) -> None:\n    26→    if not self.image_schema_form:\n    27→        return\n    28→\n    29→    preserved: Dict[str, Any] = {}\n    30→    if keep_values and self.image_schema_form.schema():\n    31→        try:\n    32→            current_values, _errors = self.image_schema_form.collect_values()\n    33→            preserved.update(current_values)\n    34→        except Exception as exc:  # pragma: no cover - best effort cache\n    35→            logger.debug(f\"采集旧参数失败: {exc}\")\n    36→    if self._image_form_cache:\n    37→        preserved.update(self._image_form_cache)\n    38→    if initial_values:\n    39→        preserved.update(initial_values)\n    40→\n    41→    try:\n    42→        schema = get_ui_schema(\"seedream\", \"image\", variant)\n    43→    except Exception as exc:\n    44→        logger.error(f\"加载图片 Schema 失败: {exc}\")\n    45→        return\n    46→\n    47→    self._image_schema = schema\n    48→    self._image_schema_variant = schema.variant\n    49→    self.image_schema_form.set_schema(schema, initial_values=preserved)\n    50→    self._image_form_cache = preserved\n    51→    self._handle_image_schema_extras(schema, preserved)\n    52→    self._handle_image_schema_extras(schema, preserved)\n    53→    self._refresh_image_reference_panel_state(preserved)\n    54→\n    55→    # Debug logs for schema loading\n    56→    logger.debug(f\"加载图片 Schema 成功: variant={schema.variant}\")\n    57→    logger.debug(f\"Schema Fields: {[f.name for f in schema.fields]}\")\n    58→\n    59→    # 根据当前模型变体设置上传按钮的初始可见性\n    60→    current_variant = preserved.get(\"model_variant\") or schema.variant\n    61→    self._update_upload_button_visibility(current_variant)\n    62→\n    63→    # 初始化组图模式联动逻辑（仅 Seedream 4.5）\n    64→    self._on_sequential_mode_changed()\n    65→\n    66→\n    67→def _handle_image_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n    68→    config = getattr(schema, \"reference_assets\", {}) or {}\n    69→    self._image_reference_config = config\n    70→    self._image_reference_visibility_rules = config.get(\"visible_if\") or []\n    71→    self._image_reference_auto_field = config.get(\"auto_compress_field\")\n    72→\n    73→    panel = self.reference_panel\n    74→    if not panel:\n    75→        return\n    76→\n    77→    if not config.get(\"enabled\"):\n    78→        panel.clear()\n    79→        panel.set_panel_enabled(False)\n    80→        self._image_reference_visibility_rules = []\n    81→        self._image_reference_auto_field = None\n    82→        return\n    83→\n    84→    panel.set_panel_enabled(True)\n    85→    panel.set_limits(\n    86→        max_count=config.get(\"max_count\"),\n    87→        bundle_limit=config.get(\"bundle_limit\"),\n    88→    )\n    89→    if config.get(\"accept\"):\n    90→        panel.set_accept_mime_types(config.get(\"accept\"))\n    91→    panel.set_hint_text(config.get(\"help_text\"))\n    92→\n    93→\n    94→def _on_image_schema_reload(self, variant: str) -> None:\n    95→    logger.info(f\"Schema 切换请求: {variant}\")\n    96→    self._load_image_schema(variant=variant, keep_values=False)\n    97→\n    98→    # Plan P: 切换模型时强制重置布局状态\n    99→    self._reset_input_layout()\n   100→\n   101→\n   102→def _on_image_field_changed(self, field_name: str, value: Any) -> None:\n   103→    self._image_form_cache[field_name] = value\n   104→    self._refresh_image_reference_panel_state()\n   105→\n   106→    # 当模型变体改变时，控制上传按钮的显示\n   107→    if field_name == \"model_variant\":\n   108→        self._update_upload_button_visibility(value)\n   109→\n   110→    # 组图模式联动逻辑（仅 Seedream 4.5）\n   111→    if field_name in {\"sequential_mode\", \"count\", \"model_variant\"}:\n   112→        self._on_sequential_mode_changed()\n   113→\n   114→\n   115→def _collect_image_form_values(self) -> Optional[Dict[str, Any]]:\n   116→    if not self.image_schema_form:\n   117→        return {}\n   118→    values, errors = self.image_schema_form.collect_values()\n   119→    if errors:\n   120→        QMessageBox.warning(self, \"参数校验失败\", \"\\n\".join(errors))\n   121→        return None\n   122→    self._image_form_cache = dict(values)\n   123→    return values\n   124→\n   125→\n   126→def _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n   127→    panel = self.reference_panel\n   128→    if not panel:\n   129→        return\n   130→\n   131→    config = self._image_reference_config or {}\n   132→    if not config.get(\"enabled\"):\n   133→        panel.set_panel_enabled(False)\n   134→        return\n   135→\n   136→    panel.set_panel_enabled(True)\n   137→\n   138→    data = dict(self._image_form_cache)\n   139→    if values:\n   140→        data.update(values)\n   141→\n   142→    visible = _evaluate_dependency_rules(self._image_reference_visibility_rules, data)\n   143→    panel.setVisible(visible)\n   144→\n   145→    if self._image_reference_auto_field:\n   146→        panel.set_auto_compress_enabled(bool(data.get(self._image_reference_auto_field, True)))\n   147→\n   148→\n   149→def _on_reference_files_changed(self) -> None:\n   150→    if not self.reference_panel:\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a960b4d7-6996-4886-9d6f-627f56767755","timestamp":"2026-01-08T08:40:08.681Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py","content":"\"\"\"Image mode: parameter/schema related logic (Phase 4.3.a).\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom PySide6.QtWidgets import QMessageBox\nfrom loguru import logger\n\nfrom modules.provider import get_ui_schema\nfrom utils.reference_display import _evaluate_dependency_rules\n\n\ndef _load_image_schema(\n    self,\n    variant: Optional[str] = None,\n    *,\n    keep_values: bool = True,\n    initial_values: Optional[Dict[str, Any]] = None,\n) -> None:\n    if not self.image_schema_form:\n        return\n\n    preserved: Dict[str, Any] = {}\n    if keep_values and self.image_schema_form.schema():\n        try:\n            current_values, _errors = self.image_schema_form.collect_values()\n            preserved.update(current_values)\n        except Exception as exc:  # pragma: no cover - best effort cache\n            logger.debug(f\"采集旧参数失败: {exc}\")\n    if self._image_form_cache:\n        preserved.update(self._image_form_cache)\n    if initial_values:\n        preserved.update(initial_values)\n\n    try:\n        schema = get_ui_schema(\"seedream\", \"image\", variant)\n    except Exception as exc:\n        logger.error(f\"加载图片 Schema 失败: {exc}\")\n        return\n\n    self._image_schema = schema\n    self._image_schema_variant = schema.variant\n    self.image_schema_form.set_schema(schema, initial_values=preserved)\n    self._image_form_cache = preserved\n    self._handle_image_schema_extras(schema, preserved)\n    self._handle_image_schema_extras(schema, preserved)\n    self._refresh_image_reference_panel_state(preserved)\n\n    # Debug logs for schema loading\n    logger.debug(f\"加载图片 Schema 成功: variant={schema.variant}\")\n    logger.debug(f\"Schema Fields: {[f.name for f in schema.fields]}\")\n\n    # 根据当前模型变体设置上传按钮的初始可见性\n    current_variant = preserved.get(\"model_variant\") or schema.variant\n    self._update_upload_button_visibility(current_variant)\n\n    # 初始化组图模式联动逻辑（仅 Seedream 4.5）\n    self._on_sequential_mode_changed()\n\n\ndef _handle_image_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n    config = getattr(schema, \"reference_assets\", {}) or {}\n    self._image_reference_config = config\n    self._image_reference_visibility_rules = config.get(\"visible_if\") or []\n    self._image_reference_auto_field = config.get(\"auto_compress_field\")\n\n    panel = self.reference_panel\n    if not panel:\n        return\n\n    if not config.get(\"enabled\"):\n        panel.clear()\n        panel.set_panel_enabled(False)\n        self._image_reference_visibility_rules = []\n        self._image_reference_auto_field = None\n        return\n\n    panel.set_panel_enabled(True)\n    panel.set_limits(\n        max_count=config.get(\"max_count\"),\n        bundle_limit=config.get(\"bundle_limit\"),\n    )\n    if config.get(\"accept\"):\n        panel.set_accept_mime_types(config.get(\"accept\"))\n    panel.set_hint_text(config.get(\"help_text\"))\n\n\ndef _on_image_schema_reload(self, variant: str) -> None:\n    logger.info(f\"Schema 切换请求: {variant}\")\n    self._load_image_schema(variant=variant, keep_values=False)\n\n    # Plan P: 切换模型时强制重置布局状态\n    self._reset_input_layout()\n\n\ndef _on_image_field_changed(self, field_name: str, value: Any) -> None:\n    self._image_form_cache[field_name] = value\n    self._refresh_image_reference_panel_state()\n\n    # 当模型变体改变时，控制上传按钮的显示\n    if field_name == \"model_variant\":\n        self._update_upload_button_visibility(value)\n\n    # 组图模式联动逻辑（仅 Seedream 4.5）\n    if field_name in {\"sequential_mode\", \"count\", \"model_variant\"}:\n        self._on_sequential_mode_changed()\n\n\ndef _collect_image_form_values(self) -> Optional[Dict[str, Any]]:\n    if not self.image_schema_form:\n        return {}\n    values, errors = self.image_schema_form.collect_values()\n    if errors:\n        QMessageBox.warning(self, \"参数校验失败\", \"\\n\".join(errors))\n        return None\n    self._image_form_cache = dict(values)\n    return values\n\n\ndef _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n    panel = self.reference_panel\n    if not panel:\n        return\n\n    config = self._image_reference_config or {}\n    if not config.get(\"enabled\"):\n        panel.set_panel_enabled(False)\n        return\n\n    panel.set_panel_enabled(True)\n\n    data = dict(self._image_form_cache)\n    if values:\n        data.update(values)\n\n    visible = _evaluate_dependency_rules(self._image_reference_visibility_rules, data)\n    panel.setVisible(visible)\n\n    if self._image_reference_auto_field:\n        panel.set_auto_compress_enabled(bool(data.get(self._image_reference_auto_field, True)))\n\n\ndef _on_reference_files_changed(self) -> None:\n    if not self.reference_panel:","numLines":150,"startLine":1,"totalLines":388}},"sourceToolAssistantUUID":"201202d8-a2e6-4ef7-b017-fd3002df8bc8"}
{"parentUuid":"a960b4d7-6996-4886-9d6f-627f56767755","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"4a4ac58f-7c34-4652-87ba-1720c0f0cff1","version":"2.1.1","gitBranch":"main","agentId":"aaa49f1","slug":"zany-wobbling-curry","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016LsK8PkUHXAWDCUkg9gmQg","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now I have a comprehensive view of the entire reference image handling flow. Let me compile a detailed exploration report:\n\n## 参考图处理流程探索 - 完整分析报告\n\n### 一、整体流程架构\n\n参考图在项目中的处理分为三个主要阶段：\n\n#### **1. UI 层（选择和上传）**\n**入口文件**: `/components/widgets/reference_assets_panel.py` (ReferenceAssetsPanel)\n\n**流程**:\n- 用户通过拖拽或\"添加参考图\"按钮选择图片\n- `ReferenceAssetsPanel.collect_assets()` 方法收集所有参考图，返回：\n```python\n{\n    \"path\": str(file_path),          # 本地文件路径\n    \"order\": int,                     # 排序序号\n    \"source\": str(file_path.name),   # 文件名\n    \"auto_compress\": bool,            # 是否自动压缩\n    \"size\": int                       # 文件大小（字节）\n}\n```\n\n**关键配置**:\n- MAX_REFERENCE_IMAGES = 14 （火山引擎 Seedream 4.5 默认支持）\n- MAX_REFERENCE_BUNDLE = 15 （参考图数 + 生成图数 ≤ 15）\n- 支持的格式：`.png`, `.jpg`, `.jpeg`, `.webp`, `.bmp`\n\n---\n\n#### **2. 业务逻辑层（参数收集和转换）**\n**关键文件链路**:\n1. `components/modes/shared/image/generation_logic.py` → `_collect_reference_assets_for_image()`\n2. `components/modes/shared/image/parameter_logic.py` \n3. `components/modes/shared/controllers/parameter_controller.py`\n\n**参考图的转换过程**:\n\n```\nUI collect_assets() \n  ↓\n(list of dict with 'path')\n  ↓\n_collect_reference_assets_for_image() \n  ↓\nparams[\"reference_images\"] = reference_assets\n  ↓\nImageService.generate_image()\n```\n\n**参数验证**:\n```python\n# 在 parameter_logic.py:_collect_reference_assets_for_image()\ncheck_limits_result = panel.check_limits(expected_outputs=expected_outputs)\n# 检查是否超过单个参考图限制或与生成数总和超过 15\n```\n\n---\n\n#### **3. API 层（处理和发送）**\n**两条路径**:\n\n##### **路径 A: Seedream 文生图/图生图** \n`modules/seedream/manager.py`:\n\n```python\ndef generate_text_to_image(\n    reference_images: Optional[List[Any]] = None,  # 参考图列表\n    ...\n)\n```\n\n**关键处理步骤**:\n1. **加载参考图源** (`_load_reference_source()`)\n   - 支持多种输入格式：\n     - 本地文件路径：`Path(raw)` → 读取 bytes\n     - URL：`requests.get()` → 下载 bytes\n     - Base64 data URL：`data:image/xxx;base64,...` → 解码 bytes\n     - Dict 对象：提取 `_payload_b64` 或 `data` 字段\n\n2. **复制到参考图目录** (`_process_reference_assets()`)\n   ```python\n   record = self.storage_manager.save_reference_asset(\n       'images',\n       file_data,\n       asset_id=asset_id,  # SHA1 校验和\n       extension=extension,\n       metadata=meta\n   )\n   ```\n   - 每个参考图生成唯一 ID：`ref_20240115120530000001_a1b2c3d4`\n   - 存储在 `~/.pigeon_dream/data/references/images/` 下\n\n3. **构建 API 载荷** (`_build_reference_payloads()`)\n   ```python\n   # 从 asset 中提取 _payload_b64（base64 编码的二进制）\n   payload = asset.get('_payload_b64')\n   # 包装成 data URL\n   payloads.append(f\"data:{mime};base64,{payload}\")\n   ```\n   - MIME 类型自动推断：`.jpg` → `image/jpeg`, `.png` → `image/png` 等\n   - 最终传递给 API\n\n4. **API 调用**\n   ```python\n   api_result = self.client.text_to_image(\n       ...\n       reference_images=ref_payloads or None,  # list of \"data:image/...;base64,...\"\n   )\n   ```\n\n**客户端层** (`modules/seedream/client.py`):\n```python\ndef text_to_image(\n    reference_images: Optional[List[Any]] = None\n):\n    # 构建 API 请求数据\n    data = {\n        \"model\": \"doubao-seedream-3-0-t2i-250415\",\n        \"prompt\": prompt,\n        \"image\": reference_images,  # 如果 > 1 张，则是列表；= 1 张，则是单个 str\n        \"sequential_image_generation\": \"disabled\",  # 禁用对多参考图的处理\n        ...\n    }\n    # 通过 POST 请求发送 JSON 格式数据\n```\n\n##### **路径 B: Seedance 视频生成**\n`modules/seedance/manager.py`:\n\n类似逻辑，但有区别：\n- **Seedance 1.5 Pro 明确不支持** reference_image 模式（行 126-128）\n- 对于支持参考图的版本，处理流程同 Seedream\n\n---\n\n### 二、现有图片处理能力\n\n#### **1. 格式验证和转换**\n**文件**: `utils/image_format_validator.py`\n\n**支持的格式**: \n- JPEG/JPG, PNG, WEBP, BMP\n- 不支持：GIF, TIFF 等\n\n**大小限制**: \n- **单个文件**: 10MB (`MAX_FILE_SIZE = 10 * 1024 * 1024`)\n- **无自动压缩机制** - 只有格式转换\n\n**关键方法**:\n```python\nclass ImageFormatValidator:\n    def validate_image(image_path: str) → Dict[str, Any]\n        # 返回：valid, error, format, size, dimensions, needs_conversion\n    \n    def convert_image_format(\n        image_path: str, \n        target_format: str = 'JPEG',\n        quality: int = 95,  # JPEG/WEBP 质量，1-100\n        output_dir: str = None\n    ) → Optional[str]\n        # 转换图片格式，返回新文件路径\n    \n    def prepare_image_for_api(\n        image_path: str,\n        auto_convert: bool = True\n    ) → Dict[str, Any]\n        # 一站式处理：验证 → 转换 → 编码为 data URL\n```\n\n**不足之处**:\n- ❌ **无自动缩放/压缩** - 只做格式转换，不会压缩像素尺寸或文件大小\n- ❌ **API 限制未知** - 没有找到火山引擎参考图的具体尺寸/大小限制文档\n- ❌ **参考图处理中未使用** - `ImageFormatValidator` 被 Seedance Client 使用，但 Seedream 参考图处理没有调用它\n\n---\n\n#### **2. 参考图的限制**\n从代码推断：\n\n| 维度 | 限制值 | 来源 |\n|------|--------|------|\n| **最多参考图数** | 14 张 | `MAX_REFERENCE_IMAGES` (schema.py:17) |\n| **参考图 + 生成数** | ≤ 15 | `MAX_REFERENCE_BUNDLE` (schema.py:18) |\n| **单个参考图大小** | 未定义 | 推断：10MB（formatter 限制） |\n| **支持格式** | JPEG, PNG, WEBP | 从 client 推断 |\n| **自动压缩** | ❌ 无 | 只有手动格式转换 |\n\n---\n\n### 三、参考图处理的代码路径总结\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ UI 层：ReferenceAssetsPanel                                      │\n│ - collect_assets()：收集本地文件路径                            │\n│ - 支持拖拽、粘贴、文件对话框                                   │\n└──────────────────────┬──────────────────────────────────────────┘\n                       ↓\n┌─────────────────────────────────────────────────────────────────┐\n│ 业务逻辑层                                                       │\n│ - _collect_reference_assets_for_image()                         │\n│ - check_limits()：验证数量是否超限                             │\n│ - params[\"reference_images\"] = asset list                       │\n└──────────────────────┬──────────────────────────────────────────┘\n                       ↓\n┌─────────────────────────────────────────────────────────────────┐\n│ 服务层：ImageService                                            │\n│ - params[\"reference_images\"] 传入 _generate_single/batch       │\n└──────────────────────┬──────────────────────────────────────────┘\n                       ↓\n┌─────────────────────────────────────────────────────────────────┐\n│ 管理层：SeedreamManager                                          │\n│ 1. _load_reference_source(item)                                 │\n│    ├─ 本地文件：Path.read_bytes()                              │\n│    ├─ URL：requests.get()                                      │\n│    ├─ Data URL：base64.b64decode()                             │\n│    └─ 返回：(bytes, extension, metadata)                       │\n│                                                                  │\n│ 2. _process_reference_assets()                                  │\n│    └─ storage_manager.save_reference_asset()                   │\n│       ├─ 生成 asset_id（SHA1 + 时间戳）                        │\n│       └─ 存储到 references/images/                             │\n│                                                                  │\n│ 3. _build_reference_payloads()                                  │\n│    └─ 包装成 base64 data URL：                                  │\n│       \"data:image/png;base64,iVBORw0KGgo...\"                   │\n└──────────────────────┬──────────────────────────────────────────┘\n                       ↓\n┌─────────────────────────────────────────────────────────────────┐\n│ API 客户端：SeedreamClient                                      │\n│ - text_to_image(reference_images=[...])                        │\n│ - 请求数据：{\"image\": [...], \"sequential_image_generation\": ...}\n└──────────────────────┬──────────────────────────────────────────┘\n                       ↓\n┌─────────────────────────────────────────────────────────────────┐\n│ 火山引擎 API                                                     │\n│ POST /images/generations                                        │\n│ Body: {\"image\": [\"data:image/png;base64,...\", ...]}            │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n### 四、关键代码片段详解\n\n#### **1. 参考图加载** (manager.py:1099-1170)\n```python\ndef _load_reference_source(self, ref: Any) → Optional[Tuple[bytes, str, Dict]]:\n    \"\"\"支持的输入格式\"\"\"\n    # ✓ 字节流：bytes\n    # ✓ 本地文件：\"/path/to/image.png\"\n    # ✓ URL：\"https://example.com/image.png\"\n    # ✓ Data URL：\"data:image/png;base64,iVBORw0...\"\n    # ✓ 字典：{\"data\": bytes, \"path\": \"...\", \"_payload_b64\": \"...\"}\n```\n\n#### **2. 参考图存储** (manager.py:1209-1228)\n```python\n# 核心逻辑\nasset_id = self._generate_reference_asset_id(file_data)  # SHA1\nrecord = self.storage_manager.save_reference_asset(\n    'images',\n    file_data,\n    asset_id=asset_id,\n    extension=extension,  # .png, .jpg, 等\n    metadata=meta\n)\n# 返回值包含：\n# - 'id', 'path', 'relative_path', 'absolute_path'\n# - 'asset_id', 'checksum', 'file_size'\n# - 'width', 'height'（如果是图片）\n```\n\n#### **3. Base64 编码** (manager.py:1246-1268)\n```python\ndef _build_reference_payloads(self, assets: List[Dict]) → List[str]:\n    payloads = []\n    for asset in assets:\n        payload = asset.get('_payload_b64')  # 已编码的 base64\n        mime = 'image/png'  # 默认，根据扩展名调整\n        payloads.append(f\"data:{mime};base64,{payload}\")\n    return payloads\n    # 最终格式：\"data:image/png;base64,iVBORw0KGgo...\"\n```\n\n---\n\n### 五、发现的潜在问题和优化点\n\n#### **问题 1：无自动图片压缩**\n- 现在仅有格式转换（JPEG 质量 95），没有缩放或尺寸限制\n- 如果用户上传很大的高分辨率图片，可能导致：\n  - API 请求体过大（JSON 中 base64 数据很大）\n  - API 服务端可能有隐藏的大小限制导致请求失败\n\n**建议**:\n```python\n# 增加到 image_format_validator.py 中\ndef compress_image(\n    image_path: str,\n    max_width: int = 2048,\n    max_height: int = 2048,\n    quality: int = 90,\n    max_file_size: int = 5 * 1024 * 1024  # 5MB\n) → str\n```\n\n#### **问题 2：API 限制信息缺失**\n- 项目代码中没有找到火山引擎对参考图的具体要求文档\n- 参考了 CSDN 博客链接（line 22 in image_format_validator.py），但该链接在读取时不可验证\n\n**建议**:\n```\n在官方文档或配置中明确记录：\n- 单个参考图的最大尺寸（像素）\n- 单个参考图的最大文件大小\n- 参考图总数据量限制\n```\n\n#### **问题 3：Seedream 参考图处理未使用 ImageFormatValidator**\n- `ImageFormatValidator` 存在但仅在 Seedance Client 中使用（line 1267, 1301）\n- Seedream Manager 的 `_load_reference_source()` 直接处理，没有调用格式验证\n\n**建议**:\n```python\n# 在 SeedreamManager._load_reference_source() 中增加\nvalidation = image_validator.validate_image(file_path)\nif validation['needs_conversion']:\n    file_data = convert_to_supported_format(file_path)\n```\n\n#### **问题 4：参考图大小未记录**\n- 虽然 `save_reference_asset()` 返回 `file_size`，但未在参考图元数据中持久化或校验\n- 无法追踪参考图的总大小\n\n#### **问题 5：Base64 编码效率**\n- 参考图被编码成 base64 字符串并嵌入 JSON POST 请求体\n- Base64 编码会增加 ~33% 的数据量\n- 如果火山引擎支持，应考虑直接上传二进制数据或分离的文件上传\n\n---\n\n### 六、各模块中的参考图支持情况\n\n| 模块 | 支持参考图 | 备注 |\n|------|-----------|------|\n| Seedream 3.0 文生图 | ✓ | API 端点：`/images/generations`, 字段：`image: [...]` |\n| Seedream 3.0 图生图 | ✓ | 仅主图，无额外参考图 |\n| Seedream 4.0 文生图 | ✓ | 通过 provider 路由 `volc_v4` |\n| Seedream 4.0 图生图 | ✓ | 通过 provider 路由 `volc_v4` |\n| Seedream 4.5 文生图 | ✓ | 组图模式（sequential），参考图 + 生成数 ≤ 15 |\n| Seedream 4.5 图生图 | ✓ | 通过 provider 路由 `volc_v4_5` |\n| Seedance 1.5 Pro | ❌ | 明确不支持参考图（line 126-128 in manager.py） |\n| Seedance 1.5 Lite | ✓? | 代码中支持，但 Lite 模式要求必须有 image_path（line 676） |\n\n---\n\n这个探索总结了参考图的完整处理流程、现有能力、限制和改进建议。重点是理解数据如何从 UI 流向 API，以及在这个过程中的转换和存储方式。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":4078,"cache_read_input_tokens":88031,"cache_creation":{"ephemeral_5m_input_tokens":4078,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"98f651aa-dded-4da4-99dd-29505809c5d7","timestamp":"2026-01-08T08:40:55.131Z"}
