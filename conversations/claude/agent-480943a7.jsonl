{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxRmXEUjNXQkGauvaJJaFD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011q7ZFrNkQ7hzwFqeCU1sXb","name":"Grep","input":{"pattern":"seedream|seedance","-i":true,"output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14840,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14840,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"3ffc7c5a-0164-4f12-918b-a579128bad7d","timestamp":"2025-12-09T03:56:16.969Z"}
{"parentUuid":"3ffc7c5a-0164-4f12-918b-a579128bad7d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxRmXEUjNXQkGauvaJJaFD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AT34FsYZPw9hgYS3bsNHsM","name":"Glob","input":{"pattern":"**/*seedream*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14840,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14840,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"be4eb2db-b9fe-4fa5-a241-b99e4e37a318","timestamp":"2025-12-09T03:56:17.224Z"}
{"parentUuid":"be4eb2db-b9fe-4fa5-a241-b99e4e37a318","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxRmXEUjNXQkGauvaJJaFD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W19m55HJBj7Yq3YjFAD2hR","name":"Glob","input":{"pattern":"**/*seedance*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14840,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14840,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"20c26cbf-0819-4c3b-b7a5-96908ad53349","timestamp":"2025-12-09T03:56:17.532Z"}
{"parentUuid":"20c26cbf-0819-4c3b-b7a5-96908ad53349","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxRmXEUjNXQkGauvaJJaFD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012NzQ6WH157LbL9RdaEHR4A","name":"Glob","input":{"pattern":"**/*model*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14840,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14840,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"8a7e10e1-90f2-43c2-8764-5f8d0cf70fd9","timestamp":"2025-12-09T03:56:17.795Z"}
{"parentUuid":"8a7e10e1-90f2-43c2-8764-5f8d0cf70fd9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxRmXEUjNXQkGauvaJJaFD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012Jbkzi8yBnPmK6rqzCuaBP","name":"Glob","input":{"pattern":"**/*api*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14840,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14840,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"8113620a-cb64-4ebe-af67-d6c017868797","timestamp":"2025-12-09T03:56:18.175Z"}
{"parentUuid":"8113620a-cb64-4ebe-af67-d6c017868797","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011q7ZFrNkQ7hzwFqeCU1sXb","type":"tool_result","content":"Found 20 files limit: 20, offset: 0\n.claude/PACKAGING_NOTES.md\nconfig_api.py\nGoDream_macOS_Official.spec\nGoDream_macOS_Trial.spec\nmodules/seedance/manager.py\npackaging/windows/gemeng_windows_trial.spec\npackaging/zero_config_launcher.py\npackaging/windows/gemeng_windows.spec\ncomponents/modes/video_mode_widget.py\ncomponents/modes/image_mode_widget.py\ndocs/release_notes/CHANGELOG.md\ndocs/macos/TROUBLESHOOTING.md\ndocs/macos/README.md\nservices/image_service.py\nmodules/seedream/manager.py\nmodules/seedance/client.py\nmodules/seedream/client.py\n问题排查与修复方案_20251113.md\n火山引擎 API 调用文档/视频生成-火山方舟大模型服务平台-火山引擎.md\n火山引擎 API 调用文档/流式响应-火山方舟大模型服务平台-火山引擎.md"}]},"uuid":"00a6b22c-6b8d-4984-9a48-878dad736362","timestamp":"2025-12-09T03:56:18.300Z","toolUseResult":{"mode":"files_with_matches","filenames":[".claude/PACKAGING_NOTES.md","config_api.py","GoDream_macOS_Official.spec","GoDream_macOS_Trial.spec","modules/seedance/manager.py","packaging/windows/gemeng_windows_trial.spec","packaging/zero_config_launcher.py","packaging/windows/gemeng_windows.spec","components/modes/video_mode_widget.py","components/modes/image_mode_widget.py","docs/release_notes/CHANGELOG.md","docs/macos/TROUBLESHOOTING.md","docs/macos/README.md","services/image_service.py","modules/seedream/manager.py","modules/seedance/client.py","modules/seedream/client.py","问题排查与修复方案_20251113.md","火山引擎 API 调用文档/视频生成-火山方舟大模型服务平台-火山引擎.md","火山引擎 API 调用文档/流式响应-火山方舟大模型服务平台-火山引擎.md"],"numFiles":20,"appliedLimit":20}}
{"parentUuid":"00a6b22c-6b8d-4984-9a48-878dad736362","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012Jbkzi8yBnPmK6rqzCuaBP","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/config_api.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/config_api_example.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/config_api.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/config_api_example.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/sources/api_config.py\n/Users/yunchang/Documents/GitHub/gemeng2/config_api_example.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_api_header_issue.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_api_key_issue.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_api_header_issue.py\n/Users/yunchang/Documents/GitHub/gemeng2/config_api_production.py\n/Users/yunchang/Documents/GitHub/gemeng2/config_api.py 2.backup_for_macos_packaging\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/hook-config_api.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/__pycache__/hook-config_api.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/config/sources/__pycache__/api_config.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/hook-config_api_trial.py\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/config_api_production.py\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_体验版/_internal/config_api_trial.py\n/Users/yunchang/Documents/GitHub/gemeng2/config_api_trial.py\n/Users/yunchang/Documents/GitHub/gemeng2/config_api.py\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_v1.3.0_正式版.app/Contents/Resources/config_api_production.py\n/Users/yunchang/Documents/GitHub/gemeng2/__pycache__/config_api.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_v1.3.0_体验版.app/Contents/Resources/config_api_trial.py"}]},"uuid":"50cc6819-808f-4e45-8a4f-b055c7092ad4","timestamp":"2025-12-09T03:56:18.319Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/config_api.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/config_api_example.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/config_api.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/config_api_example.py","/Users/yunchang/Documents/GitHub/gemeng2/config/sources/api_config.py","/Users/yunchang/Documents/GitHub/gemeng2/config_api_example.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_api_header_issue.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_api_key_issue.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_api_header_issue.py","/Users/yunchang/Documents/GitHub/gemeng2/config_api_production.py","/Users/yunchang/Documents/GitHub/gemeng2/config_api.py 2.backup_for_macos_packaging","/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/hook-config_api.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/__pycache__/hook-config_api.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/config/sources/__pycache__/api_config.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/hook-config_api_trial.py","/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/config_api_production.py","/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_体验版/_internal/config_api_trial.py","/Users/yunchang/Documents/GitHub/gemeng2/config_api_trial.py","/Users/yunchang/Documents/GitHub/gemeng2/config_api.py","/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_v1.3.0_正式版.app/Contents/Resources/config_api_production.py","/Users/yunchang/Documents/GitHub/gemeng2/__pycache__/config_api.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_v1.3.0_体验版.app/Contents/Resources/config_api_trial.py"],"durationMs":65,"numFiles":22,"truncated":false}}
{"parentUuid":"50cc6819-808f-4e45-8a4f-b055c7092ad4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012NzQ6WH157LbL9RdaEHR4A","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/components/models/image_history_model.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/components/models/video_history_model.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/components/models/image_history_model.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/components/models/video_history_model.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_history_model_optimized_20250928/history_model_optimized.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/models/image_history_model.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/models/__pycache__/image_history_model.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/components/models/video_history_model.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/models/__pycache__/video_history_model.cpython-313.pyc"}]},"uuid":"00d324e5-a3a0-4c07-b3dd-350b045dcd45","timestamp":"2025-12-09T03:56:18.320Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/components/models/image_history_model.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/components/models/video_history_model.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/components/models/image_history_model.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/components/models/video_history_model.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_history_model_optimized_20250928/history_model_optimized.py","/Users/yunchang/Documents/GitHub/gemeng2/components/models/image_history_model.py","/Users/yunchang/Documents/GitHub/gemeng2/components/models/__pycache__/image_history_model.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/components/models/video_history_model.py","/Users/yunchang/Documents/GitHub/gemeng2/components/models/__pycache__/video_history_model.cpython-313.pyc"],"durationMs":66,"numFiles":9,"truncated":false}}
{"parentUuid":"00d324e5-a3a0-4c07-b3dd-350b045dcd45","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AT34FsYZPw9hgYS3bsNHsM","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/火山引擎 API 调用文档/doubao-seedream-4.0教程-火山方舟大模型服务平台-火山引擎.md"}]},"uuid":"e30f07e5-d2e1-4dec-b8f8-9105bbbfe88b","timestamp":"2025-12-09T03:56:18.322Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/火山引擎 API 调用文档/doubao-seedream-4.0教程-火山方舟大模型服务平台-火山引擎.md"],"durationMs":68,"numFiles":1,"truncated":false}}
{"parentUuid":"e30f07e5-d2e1-4dec-b8f8-9105bbbfe88b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W19m55HJBj7Yq3YjFAD2hR","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_direct.py\n/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test.py\n/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test2.py"}]},"uuid":"d1c6820b-3625-4ad0-8772-a7e46fd428b3","timestamp":"2025-12-09T03:56:18.321Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_direct.py","/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test.py","/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test2.py"],"durationMs":67,"numFiles":3,"truncated":false}}
{"parentUuid":"d1c6820b-3625-4ad0-8772-a7e46fd428b3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VacPm8J5xvdyjMT6386UKY","type":"message","role":"assistant","content":[{"type":"text","text":"Let me explore the key files to understand the Seedream and Seedance module structure:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1083,"cache_creation_input_tokens":1041,"cache_read_input_tokens":14840,"cache_creation":{"ephemeral_5m_input_tokens":1041,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"cece6bab-1e1b-4398-8237-b44eda08917d","timestamp":"2025-12-09T03:56:23.258Z"}
{"parentUuid":"cece6bab-1e1b-4398-8237-b44eda08917d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VacPm8J5xvdyjMT6386UKY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P8npQDaPCphPcB4jgauB86","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1083,"cache_creation_input_tokens":1041,"cache_read_input_tokens":14840,"cache_creation":{"ephemeral_5m_input_tokens":1041,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a2096e4e-2e32-43d2-ac21-78c5dd6548cb","timestamp":"2025-12-09T03:56:23.695Z"}
{"parentUuid":"a2096e4e-2e32-43d2-ac21-78c5dd6548cb","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VacPm8J5xvdyjMT6386UKY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013zaNgWePSCFAVpqkbcdgyx","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1083,"cache_creation_input_tokens":1041,"cache_read_input_tokens":14840,"cache_creation":{"ephemeral_5m_input_tokens":1041,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9191d478-174c-49f3-82ce-069f08f3c096","timestamp":"2025-12-09T03:56:24.098Z"}
{"parentUuid":"9191d478-174c-49f3-82ce-069f08f3c096","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VacPm8J5xvdyjMT6386UKY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JBNj1RVMSBviZ1ETdJJTNP","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1083,"cache_creation_input_tokens":1041,"cache_read_input_tokens":14840,"cache_creation":{"ephemeral_5m_input_tokens":1041,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"76aff4f3-892f-4f2c-8f4f-22adefa9448e","timestamp":"2025-12-09T03:56:24.613Z"}
{"parentUuid":"76aff4f3-892f-4f2c-8f4f-22adefa9448e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VacPm8J5xvdyjMT6386UKY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018rkHnMAbuAk6FRrNUJwuL8","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1083,"cache_creation_input_tokens":1041,"cache_read_input_tokens":14840,"cache_creation":{"ephemeral_5m_input_tokens":1041,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2d02ff73-77f7-4875-a7b8-e6a685abc204","timestamp":"2025-12-09T03:56:25.027Z"}
{"parentUuid":"2d02ff73-77f7-4875-a7b8-e6a685abc204","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VacPm8J5xvdyjMT6386UKY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Wjrz39cYE7p23ekKK16Dxb","name":"Glob","input":{"pattern":"modules/seedream/**/*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1083,"cache_creation_input_tokens":1041,"cache_read_input_tokens":14840,"cache_creation":{"ephemeral_5m_input_tokens":1041,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2ce46135-2d5c-45a6-9e0b-00f8e6ce2864","timestamp":"2025-12-09T03:56:25.337Z"}
{"parentUuid":"2ce46135-2d5c-45a6-9e0b-00f8e6ce2864","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VacPm8J5xvdyjMT6386UKY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Vv1EPw3d6ALG89By8yozY8","name":"Glob","input":{"pattern":"modules/seedance/**/*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1083,"cache_creation_input_tokens":1041,"cache_read_input_tokens":14840,"cache_creation":{"ephemeral_5m_input_tokens":1041,"ephemeral_1h_input_tokens":0},"output_tokens":349,"service_tier":"standard"}},"type":"assistant","uuid":"47b6b424-7774-4ca9-810f-693b16f248c2","timestamp":"2025-12-09T03:56:25.609Z"}
{"parentUuid":"47b6b424-7774-4ca9-810f-693b16f248c2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Wjrz39cYE7p23ekKK16Dxb","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__pycache__/__init__.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__pycache__/client.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__pycache__/manager.cpython-313.pyc"}]},"uuid":"754d80c0-715a-4814-a08f-4fc92f50dcaf","timestamp":"2025-12-09T03:56:25.696Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__pycache__/__init__.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__pycache__/client.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__pycache__/manager.cpython-313.pyc"],"durationMs":29,"numFiles":6,"truncated":false}}
{"parentUuid":"754d80c0-715a-4814-a08f-4fc92f50dcaf","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vv1EPw3d6ALG89By8yozY8","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/__init__.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/config.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/client.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/manager.cpython-313.pyc"}]},"uuid":"b4c1f7d3-5852-471a-adaf-61ef1a566225","timestamp":"2025-12-09T03:56:25.716Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/__init__.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/config.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/client.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__pycache__/manager.cpython-313.pyc"],"durationMs":49,"numFiles":8,"truncated":false}}
{"parentUuid":"b4c1f7d3-5852-471a-adaf-61ef1a566225","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013zaNgWePSCFAVpqkbcdgyx","type":"tool_result","content":"     1→# Seedream图像生成客户端\n     2→# 封装火山引擎Seedream3.0 API调用\n     3→\n     4→import json\n     5→import os\n     6→import requests\n     7→import time\n     8→import random\n     9→from typing import Dict, Any, Optional, List\n    10→from pathlib import Path\n    11→from loguru import logger\n    12→from urllib3.util.retry import Retry\n    13→from requests.adapters import HTTPAdapter\n    14→\n    15→# 导入配置管理器和错误处理\n    16→from config.unified_config import get_unified_config\n    17→from modules.utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n    18→\n    19→\n    20→class SeedreamClient:\n    21→    \"\"\"火山引擎Seedream图片生成客户端\n    22→\n    23→    提供文生图和图生图功能\n    24→    \"\"\"\n    25→\n    26→    def __init__(\n    27→        self,\n    28→        api_key: Optional[str] = None,\n    29→        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n    30→        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n    31→        timeout: int = 60,\n    32→        max_retries: int = 3,\n    33→    ):\n    34→        \"\"\"初始化Seedream客户端\n    35→\n    36→        Args:\n    37→            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n    38→            base_url: API基础URL\n    39→            timeout: 请求超时时间（秒）\n    40→            max_retries: 最大重试次数\n    41→        \"\"\"\n    42→        # 获取API密钥\n    43→        if api_key is None:\n    44→            try:\n    45→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    46→            except Exception as exc:\n    47→                raise AppError(str(exc), ErrorHandler.ErrorType.AUTH_ERROR) from exc\n    48→\n    49→        self.api_key = api_key\n    50→        self.base_url = base_url.rstrip(\"/\")\n    51→        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n    52→        self.timeout = timeout\n    53→        self.max_retries = max_retries\n    54→\n    55→        # 配置会话\n    56→        self.session = requests.Session()\n    57→\n    58→        # 配置重试策略\n    59→        retry_strategy = Retry(\n    60→            total=max_retries,\n    61→            status_forcelist=[429, 500, 502, 503, 504],\n    62→            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n    63→            backoff_factor=1\n    64→        )\n    65→\n    66→        adapter = HTTPAdapter(max_retries=retry_strategy)\n    67→        self.session.mount(\"http://\", adapter)\n    68→        self.session.mount(\"https://\", adapter)\n    69→\n    70→        logger.info(\"Seedream客户端初始化完成\")\n    71→\n    72→        # 初始化性能监控与错误缓存（统一结构）\n    73→        self._performance_stats = {\n    74→            \"total_requests\": 0,\n    75→            \"successful_requests\": 0,\n    76→            \"failed_requests\": 0,\n    77→            \"total_response_time\": 0.0,\n    78→            \"last_request_time\": None,\n    79→        }\n    80→        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n    81→        self._last_provider: Optional[str] = None\n    82→        self._last_endpoint: Optional[str] = None\n    83→\n    84→    def _encode_image(self, image_path: str) -> str:\n    85→        \"\"\"将图像文件编码为base64字符串\n    86→        \n    87→        Args:\n    88→            image_path: 图像文件路径\n    89→            \n    90→        Returns:\n    91→            base64编码的图像字符串\n    92→        \"\"\"\n    93→        import base64\n    94→        \n    95→        try:\n    96→            with open(image_path, 'rb') as image_file:\n    97→                image_data = image_file.read()\n    98→                base64_string = base64.b64encode(image_data).decode('utf-8')\n    99→                return base64_string\n   100→        except Exception as e:\n   101→            # 避免在日志中显示可能包含base64数据的异常信息\n   102→            error_msg = str(e)\n   103→            if len(error_msg) > 200:\n   104→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   105→            logger.error(f\"图像编码失败: {error_msg}\")\n   106→            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorHandler.ErrorType.FILE_ERROR)\n   107→\n   108→    def _get_headers(self) -> Dict[str, str]:\n   109→        \"\"\"获取请求头\"\"\"\n   110→        # 验证API密钥，防止尺寸配置被错误使用\n   111→        api_key = str(self.api_key).strip()\n   112→\n   113→        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n   114→        try:\n   115→            api_key.encode('ascii')\n   116→        except UnicodeEncodeError:\n   117→            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n   118→\n   119→        # 检查是否包含尺寸信息或换行符\n   120→        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n   121→            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n   122→\n   123→        # 检查API密钥长度\n   124→        if len(api_key) < 10 or len(api_key) > 200:\n   125→            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n   126→        \n   127→        return {\n   128→            \"Authorization\": f\"Bearer {api_key}\",\n   129→            \"Content-Type\": \"application/json; charset=utf-8\",\n   130→            \"User-Agent\": \"Seedream-Client/1.0.0\",\n   131→        }\n   132→\n   133→    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n   134→        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n   135→        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   136→        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n   137→\n   138→    def _provider_enabled(self) -> bool:\n   139→        try:\n   140→            import os\n   141→            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n   142→            return v not in {\"0\", \"false\", \"no\"}\n   143→        except Exception:\n   144→            return True\n   145→\n   146→    def _get_seedream_provider_order(self) -> List[str]:\n   147→        order: List[str] = []\n   148→        try:\n   149→            env_value = os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n   150→        except Exception:\n   151→            env_value = \"volc_v3\"\n   152→        candidates = [env_value]\n   153→        for candidate in candidates:\n   154→            if not candidate:\n   155→                continue\n   156→            name = candidate.strip().lower()\n   157→            if not name:\n   158→                continue\n   159→            if name not in order:\n   160→                order.append(name)\n   161→        if \"volc_v3\" not in order:\n   162→            order.append(\"volc_v3\")\n   163→        return order\n   164→\n   165→    def _call_seedream_provider(self, headers: Dict[str, str], mapper, operation: str):\n   166→        from modules.provider.factory import get_default_provider\n   167→        default_endpoint = \"/images/generations\"\n   168→        base_url = self.base_url.rstrip(\"/\")\n   169→        first_choice = None\n   170→        last_error: Optional[BaseException] = None\n   171→        order = self._get_seedream_provider_order()\n   172→        if order:\n   173→            first_choice = order[0]\n   174→        for idx, name in enumerate(order):\n   175→            try:\n   176→                provider = get_default_provider(name)\n   177→            except Exception as e:\n   178→                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n   179→                last_error = e\n   180→                continue\n   181→            try:\n   182→                mapped = mapper(provider)\n   183→                if not isinstance(mapped, tuple):\n   184→                    raise ValueError(\"provider mapper 返回值异常\")\n   185→                if len(mapped) == 4:\n   186→                    payload, fb, reason, endpoint = mapped\n   187→                elif len(mapped) == 3:\n   188→                    payload, fb, reason = mapped\n   189→                    endpoint = default_endpoint\n   190→                else:\n   191→                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n   192→            except Exception as e:\n   193→                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n   194→                last_error = e\n   195→                continue\n   196→            start_time = time.time()\n   197→            try:\n   198→                endpoint_path = endpoint or default_endpoint\n   199→                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n   200→                    request_url = endpoint_path\n   201→                else:\n   202→                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   203→                    if not normalized.startswith(\"/\"):\n   204→                        normalized = f\"/{normalized}\"\n   205→                    request_url = f\"{base_url}{normalized}\"\n   206→                response = self._safe_json_post(request_url, headers, payload, timeout=60)\n   207→                result = self._handle_response(response)\n   208→                elapsed = time.time() - start_time\n   209→                if idx > 0 and first_choice:\n   210→                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n   211→                if fb and reason:\n   212→                    logger.warning(f\"参数回退: {reason}\")\n   213→                logger.info(\n   214→                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n   215→                )\n   216→                self._last_provider = name\n   217→                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   218→                return result, payload, endpoint_path, name, fb, reason, elapsed\n   219→            except AppError as e:\n   220→                last_error = e\n   221→                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n   222→                continue\n   223→            except Exception as e:\n   224→                last_error = e\n   225→                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n   226→                continue\n   227→        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n   228→\n   229→    def _log_seedream_event(\n   230→        self,\n   231→        operation: str,\n   232→        status: str,\n   233→        provider: Optional[str],\n   234→        endpoint: Optional[str],\n   235→        elapsed: float,\n   236→        fallback_applied: bool,\n   237→        fallback_reason: Optional[str] = None,\n   238→        extra: Optional[Dict[str, Any]] = None,\n   239→    ) -> None:\n   240→        try:\n   241→            provider_name = provider or \"unknown\"\n   242→            endpoint_text = endpoint or \"/images/generations\"\n   243→            parts = [\n   244→                f\"operation={operation}\",\n   245→                f\"status={status}\",\n   246→                f\"provider={provider_name}\",\n   247→                f\"endpoint={endpoint_text}\",\n   248→                f\"elapsed={elapsed:.2f}s\",\n   249→                f\"fallback={'yes' if fallback_applied else 'no'}\",\n   250→            ]\n   251→            if fallback_applied and fallback_reason:\n   252→                safe_reason = str(fallback_reason)\n   253→                if len(safe_reason) > 120:\n   254→                    safe_reason = safe_reason[:120] + \"...\"\n   255→                parts.append(f\"fallback_reason={safe_reason}\")\n   256→            if extra:\n   257→                for key, value in extra.items():\n   258→                    if value is None:\n   259→                        continue\n   260→                    parts.append(f\"{key}={value}\")\n   261→            logger.info(\"摘要|\" + \" \".join(parts))\n   262→        except Exception:\n   263→            # 保证日志逻辑不会影响主流程\n   264→            pass\n   265→\n   266→    @staticmethod\n   267→    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n   268→        mime = \"image/png\"\n   269→        try:\n   270→            if path_hint:\n   271→                suffix = Path(path_hint).suffix.lower()\n   272→                if suffix in {\".jpg\", \".jpeg\"}:\n   273→                    mime = \"image/jpeg\"\n   274→                elif suffix == \".webp\":\n   275→                    mime = \"image/webp\"\n   276→                elif suffix == \".bmp\":\n   277→                    mime = \"image/bmp\"\n   278→                elif suffix == \".gif\":\n   279→                    mime = \"image/gif\"\n   280→        except Exception:\n   281→            pass\n   282→        return f\"data:{mime};base64,{b64_data}\"\n   283→\n   284→    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n   285→        \"\"\"处理API响应\n   286→\n   287→        Args:\n   288→            response: HTTP响应对象\n   289→\n   290→        Returns:\n   291→            解析后的响应数据\n   292→\n   293→        Raises:\n   294→            AppError: 当API返回错误时\n   295→        \"\"\"\n   296→        try:\n   297→            if not response.ok:\n   298→                try:\n   299→                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n   300→                except Exception:\n   301→                    error_text = str(response.content[:500])\n   302→                # 避免在日志中显示可能包含base64数据的完整响应\n   303→                if len(error_text) > 500:\n   304→                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n   305→                else:\n   306→                    error_summary = error_text\n   307→                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n   308→                raise AppError(\n   309→                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n   310→                    ErrorType.API_ERROR,\n   311→                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n   312→                )\n   313→\n   314→            # 解析响应（增强容错：包括编码问题回退）\n   315→            try:\n   316→                result = response.json()\n   317→            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n   318→                raw = response.content or b\"\"\n   319→                tried = set()\n   320→                result = None\n   321→                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n   322→                    if not enc or enc in tried:\n   323→                        continue\n   324→                    tried.add(enc)\n   325→                    try:\n   326→                        text = raw.decode(enc, errors=\"strict\")\n   327→                        result = json.loads(text)\n   328→                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n   329→                        break\n   330→                    except Exception:\n   331→                        continue\n   332→                if result is None:\n   333→                    try:\n   334→                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n   335→                    except Exception:\n   336→                        preview = str(raw[:200])\n   337→                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n   338→                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n   339→\n   340→            # OpenAI格式的响应检查\n   341→            if \"data\" not in result:\n   342→                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n   343→                logger.error(f\"Seedream API错误: {error_msg}\")\n   344→                raise AppError(\n   345→                    f\"API错误: {error_msg}\",\n   346→                    ErrorHandler.ErrorType.API_ERROR,\n   347→                    {\"response_data\": result},\n   348→                )\n   349→\n   350→            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n   351→            images = []\n   352→            for item in result[\"data\"]:\n   353→                if \"url\" in item:\n   354→                    images.append({\n   355→                        \"url\": item[\"url\"]\n   356→                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n   357→                    })\n   358→\n   359→            return {\n   360→                \"code\": 200,\n   361→                \"message\": \"success\",\n   362→                \"data\": {\n   363→                    \"images\": images\n   364→                },\n   365→                \"created\": result.get(\"created\"),\n   366→                \"usage\": result.get(\"usage\", {})\n   367→            }\n   368→\n   369→        except requests.exceptions.RequestException as e:\n   370→            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n   371→        except json.JSONDecodeError as e:\n   372→            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n   373→\n   374→    def _record_request_stats(\n   375→        self,\n   376→        operation: str,\n   377→        success: bool,\n   378→        response_time: float,\n   379→        error_code: Optional[str] = None,\n   380→        error_message: Optional[str] = None,\n   381→    ) -> None:\n   382→        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n   383→        try:\n   384→            self._performance_stats[\"total_requests\"] += 1\n   385→            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n   386→            self._performance_stats[\"last_request_time\"] = time.time()\n   387→            if success:\n   388→                self._performance_stats[\"successful_requests\"] += 1\n   389→            else:\n   390→                self._performance_stats[\"failed_requests\"] += 1\n   391→                if error_code or error_message:\n   392→                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n   393→\n   394→            # 调试日志（安全版）\n   395→            total = max(1, self._performance_stats[\"total_requests\"])\n   396→            avg = self._performance_stats[\"total_response_time\"] / total\n   397→            succ = self._performance_stats[\"successful_requests\"]\n   398→            success_rate = (succ / total) * 100.0\n   399→            logger.debug(\n   400→                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n   401→            )\n   402→        except Exception:\n   403→            # 统计不应影响业务流程\n   404→            pass\n   405→\n   406→    def get_performance_stats(self) -> Dict[str, Any]:\n   407→        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n   408→        stats = dict(self._performance_stats)\n   409→        total = stats.get(\"total_requests\", 0) or 0\n   410→        if total > 0:\n   411→            avg = stats.get(\"total_response_time\", 0.0) / total\n   412→            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n   413→        else:\n   414→            avg = 0.0\n   415→            success_rate = 0.0\n   416→        return {\n   417→            \"total_requests\": total,\n   418→            \"successful_requests\": stats.get(\"successful_requests\", 0),\n   419→            \"failed_requests\": stats.get(\"failed_requests\", 0),\n   420→            \"avg_response_time\": avg,\n   421→            \"success_rate\": success_rate,\n   422→            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n   423→        }\n   424→\n   425→    def dump_metrics(self) -> Dict[str, Any]:\n   426→        \"\"\"导出诊断可读的统一指标。\"\"\"\n   427→        m = self.get_performance_stats()\n   428→        m.update({\n   429→            \"client\": \"Seedream\",\n   430→            \"model\": self.model_id,\n   431→            \"base_url\": self.base_url,\n   432→        })\n   433→        return m\n   434→\n   435→    def last_provider(self) -> Optional[str]:\n   436→        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n   437→        return self._last_provider\n   438→\n   439→    def last_endpoint(self) -> Optional[str]:\n   440→        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n   441→        return self._last_endpoint\n   442→\n   443→    @error_handler(\"Seedream文生图\")\n   444→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   445→    def text_to_image(\n   446→        self,\n   447→        prompt: str,\n   448→        size: str = \"1024x1024\",\n   449→        guidance_scale: float = 2.5,\n   450→        seed: Optional[int] = None,\n   451→        reference_images: Optional[List[Any]] = None,\n   452→    ) -> Dict[str, Any]:\n   453→        \"\"\"\n   454→        文生图API调用\n   455→\n   456→        Args:\n   457→            prompt: 图片描述提示词\n   458→            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n   459→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   460→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   461→            reference_images: 参考图列表（路径或URL），最多10张\n   462→            response_format: 返回格式，\"url\"或\"b64_json\"\n   463→\n   464→        Returns:\n   465→            API响应结果\n   466→\n   467→        Raises:\n   468→            AppError: 当API调用失败时\n   469→        \"\"\"\n   470→        headers = self._get_headers()\n   471→\n   472→        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n   473→\n   474→        if self._provider_enabled():\n   475→            try:\n   476→                from modules.provider.schema import TextToImageParams\n   477→\n   478→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   479→                    headers,\n   480→                    lambda provider: provider.map_t2i(TextToImageParams(\n   481→                        prompt=prompt,\n   482→                        size=size,\n   483→                        guidance_scale=guidance_scale,\n   484→                        seed=(None if (seed is None or seed == -1) else seed),\n   485→                        reference_images=reference_images or []\n   486→                    )),\n   487→                    \"text_to_image\"\n   488→                )\n   489→                self._log_seedream_event(\n   490→                    \"text_to_image\",\n   491→                    \"success\",\n   492→                    provider_used,\n   493→                    endpoint_used,\n   494→                    response_time,\n   495→                    fallback_applied,\n   496→                    fallback_reason,\n   497→                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   498→                )\n   499→                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n   500→                return result\n   501→            except Exception as provider_exc:\n   502→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   503→\n   504→        success = False\n   505→        err_code: Optional[str] = None\n   506→        err_msg: Optional[str] = None\n   507→        start_time = time.time()\n   508→        try:\n   509→            if not self.validate_image_size(size):\n   510→                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n   511→            if not (1.0 <= guidance_scale <= 10.0):\n   512→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   513→            if seed is not None and not (-1 <= seed <= 2147483647):\n   514→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   515→\n   516→            data = {\n   517→                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n   518→                \"prompt\": prompt,\n   519→                \"size\": size,\n   520→                \"response_format\": \"url\",\n   521→                \"watermark\": False,  # 正式版固定禁用水印\n   522→                \"guidance_scale\": guidance_scale,\n   523→            }\n   524→            if seed is not None:\n   525→                data[\"seed\"] = seed\n   526→\n   527→            if reference_images:\n   528→                images_payload = []\n   529→                for item in reference_images:\n   530→                    try:\n   531→                        if isinstance(item, str):\n   532→                            if item.startswith(\"data:image/\"):\n   533→                                images_payload.append(item)\n   534→                                continue\n   535→                            p = Path(item)\n   536→                            if p.exists():\n   537→                                encoded = self._encode_image(str(p))\n   538→                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   539→                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n   540→                                images_payload.append(item)\n   541→                        elif isinstance(item, dict):\n   542→                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n   543→                            path_hint = item.get('path') or item.get('source')\n   544→                            if payload:\n   545→                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n   546→                            else:\n   547→                                path_val = item.get('path')\n   548→                                if path_val:\n   549→                                    p = Path(path_val)\n   550→                                    if p.exists():\n   551→                                        encoded = self._encode_image(str(p))\n   552→                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   553→                    except Exception as exc:\n   554→                        logger.warning(f\"参考图处理失败: {exc}\")\n   555→                if images_payload:\n   556→                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n   557→                    data[\"sequential_image_generation\"] = \"disabled\"\n   558→\n   559→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   560→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   561→            result = self._handle_response(response)\n   562→            success = True\n   563→            elapsed = time.time() - start_time\n   564→            self._last_provider = \"legacy_v3\"\n   565→            self._last_endpoint = \"/images/generations\"\n   566→            self._log_seedream_event(\n   567→                \"text_to_image\",\n   568→                \"success\",\n   569→                \"legacy_v3\",\n   570→                \"/images/generations\",\n   571→                elapsed,\n   572→                False,\n   573→                None,\n   574→                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   575→            )\n   576→            return result\n   577→        except AppError as e:\n   578→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   579→            err_msg = e.message\n   580→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   581→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   582→            raise\n   583→        except Exception as e:\n   584→            err_code = \"UNKNOWN_ERROR\"\n   585→            err_msg = str(e)\n   586→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   587→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   588→            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n   589→        finally:\n   590→            elapsed = time.time() - start_time\n   591→            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n   592→\n   593→    @error_handler(\"Seedream图生图\")\n   594→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   595→    def image_to_image(\n   596→        self,\n   597→        prompt: str,\n   598→        image: str,\n   599→        guidance_scale: float = 5.5,\n   600→        seed: Optional[int] = None,\n   601→        reference_images: Optional[List[str]] = None,\n   602→    ) -> Dict[str, Any]:\n   603→        \"\"\"\n   604→        图生图API调用\n   605→\n   606→        Args:\n   607→            prompt: 图片编辑提示词\n   608→            image: 输入图像URL或Base64编码\n   609→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   610→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   611→            reference_images: 参考图列表（路径或URL），最多10张\n   612→            response_format: 返回格式，\"url\"或\"b64_json\"\n   613→            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n   614→\n   615→        Returns:\n   616→            API响应结果\n   617→\n   618→        Raises:\n   619→            AppError: 当API调用失败时\n   620→        \"\"\"\n   621→        headers = self._get_headers()\n   622→\n   623→        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n   624→\n   625→        if self._provider_enabled():\n   626→            try:\n   627→                from modules.provider.schema import ImageToImageParams\n   628→\n   629→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   630→                    headers,\n   631→                    lambda provider: provider.map_i2i(ImageToImageParams(\n   632→                        prompt=prompt,\n   633→                        image=image,\n   634→                        guidance_scale=guidance_scale,\n   635→                        seed=(None if (seed is None or seed == -1) else seed),\n   636→                        reference_images=(reference_images or []),\n   637→                    )),\n   638→                    \"image_to_image\"\n   639→                )\n   640→                self._log_seedream_event(\n   641→                    \"image_to_image\",\n   642→                    \"success\",\n   643→                    provider_used,\n   644→                    endpoint_used,\n   645→                    response_time,\n   646→                    fallback_applied,\n   647→                    fallback_reason,\n   648→                    {\"seed\": data.get(\"seed\")},\n   649→                )\n   650→                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n   651→                return result\n   652→            except Exception as provider_exc:\n   653→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   654→\n   655→        success = False\n   656→        err_code: Optional[str] = None\n   657→        err_msg: Optional[str] = None\n   658→        start_time = time.time()\n   659→        try:\n   660→            if not (1.0 <= guidance_scale <= 10.0):\n   661→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   662→            if seed is not None and not (-1 <= seed <= 2147483647):\n   663→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   664→\n   665→            data = {\n   666→                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n   667→                \"prompt\": prompt,\n   668→                \"image\": image,\n   669→                \"size\": \"adaptive\",\n   670→                \"response_format\": \"url\",\n   671→                \"watermark\": False,  # 正式版固定禁用水印\n   672→                \"guidance_scale\": guidance_scale,\n   673→            }\n   674→            if seed is not None:\n   675→                data[\"seed\"] = seed\n   676→            if reference_images:\n   677→                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n   678→\n   679→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   680→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   681→            result = self._handle_response(response)\n   682→            success = True\n   683→            elapsed = time.time() - start_time\n   684→            self._last_provider = \"legacy_v3\"\n   685→            self._last_endpoint = \"/images/generations\"\n   686→            self._log_seedream_event(\n   687→                \"image_to_image\",\n   688→                \"success\",\n   689→                \"legacy_v3\",\n   690→                \"/images/generations\",\n   691→                elapsed,\n   692→                False,\n   693→                None,\n   694→                {\"seed\": data.get(\"seed\")},\n   695→            )\n   696→            return result\n   697→        except AppError as e:\n   698→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   699→            err_msg = e.message\n   700→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   701→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   702→            raise\n   703→        except Exception as e:\n   704→            err_code = \"UNKNOWN_ERROR\"\n   705→            err_msg = str(e)\n   706→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   707→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   708→            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n   709→        finally:\n   710→            elapsed = time.time() - start_time\n   711→            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n   712→\n   713→    def batch_text_to_image(\n   714→        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n   715→    ) -> List[Dict[str, Any]]:\n   716→        \"\"\"\n   717→        批量文生图：同时生成多张图片\n   718→\n   719→        Args:\n   720→            prompts: 提示词列表\n   721→            width: 图像宽度\n   722→            height: 图像高度\n   723→            guidance_scale: 提示词一致性\n   724→\n   725→        Returns:\n   726→            List[Dict]: 生成结果列表\n   727→        \"\"\"\n   728→        results = []\n   729→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   730→\n   731→        for i, prompt in enumerate(prompts, 1):\n   732→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   733→\n   734→            try:\n   735→                # 为每个任务生成不同的随机种子\n   736→                seed = random.randint(1, 2147483647)\n   737→\n   738→                result = self.text_to_image(\n   739→                    prompt=prompt, \n   740→                    width=width, \n   741→                    height=height, \n   742→                    guidance_scale=guidance_scale, \n   743→                    seed=seed\n   744→                )\n   745→\n   746→                results.append({\n   747→                    \"success\": True,\n   748→                    \"result\": result,\n   749→                    \"prompt\": prompt\n   750→                })\n   751→\n   752→            except Exception as e:\n   753→                # 避免在日志中显示过长的异常信息\n   754→                error_msg = str(e)\n   755→                if len(error_msg) > 200:\n   756→                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   757→                logger.error(f\"第{i}个任务失败: {error_msg}\")\n   758→                results.append({\n   759→                    \"success\": False,\n   760→                    \"error\": error_msg,\n   761→                    \"prompt\": prompt\n   762→                })\n   763→\n   764→            # 避免请求过于频繁\n   765→            if i < len(prompts):\n   766→                time.sleep(0.5)\n   767→\n   768→        success_count = sum(1 for r in results if r[\"success\"])\n   769→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   770→        return results\n   771→\n   772→    def validate_image_size(self, size: str) -> bool:\n   773→        \"\"\"\n   774→        验证图像尺寸是否支持\n   775→\n   776→        Args:\n   777→            size: 图像尺寸字符串，如 \"1024x1024\"\n   778→\n   779→        Returns:\n   780→            bool: 是否支持该尺寸\n   781→        \"\"\"\n   782→        try:\n   783→            # 解析尺寸字符串\n   784→            if 'x' not in size:\n   785→                return False\n   786→                \n   787→            width_str, height_str = size.split('x', 1)\n   788→            width = int(width_str)\n   789→            height = int(height_str)\n   790→            \n   791→            # 验证范围：Seedream 4.0 支持 512-4096像素\n   792→            return (512 <= width <= 4096) and (512 <= height <= 4096)\n   793→            \n   794→        except (ValueError, AttributeError):\n   795→            return False\n   796→\n   797→    def get_supported_sizes(self) -> List[str]:\n   798→        \"\"\"\n   799→        获取常用的图像尺寸列表\n   800→        \n   801→        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n   802→\n   803→        Returns:\n   804→            List[str]: 常用尺寸列表，包含官方推荐尺寸\n   805→        \"\"\"\n   806→        return [\n   807→            # 官方推荐尺寸 (Seedream 4.0)\n   808→            \"2048x2048\",   # 1:1 官方推荐\n   809→            \"2304x1728\",   # 4:3 官方推荐\n   810→            \"1728x2304\",   # 3:4 官方推荐\n   811→            \"2560x1440\",   # 16:9 官方推荐\n   812→            \"1440x2560\",   # 9:16 官方推荐\n   813→            \"2496x1664\",   # 3:2 官方推荐\n   814→            \"1664x2496\",   # 2:3 官方推荐\n   815→            \"3024x1296\",   # 21:9 官方推荐\n   816→            \n   817→            # 兼容性尺寸\n   818→            \"1920x1080\",   # 16:9 兼容\n   819→            \"1080x1920\",   # 9:16 兼容\n   820→            \"1536x1024\",   # 3:2 兼容\n   821→            \"1024x1536\",   # 2:3 兼容\n   822→            \"1512x648\",    # 21:9 兼容\n   823→            \"1280x720\",    # 16:9 小尺寸\n   824→            \"720x1280\",    # 9:16 小尺寸\n   825→            \"1024x1024\",   # 1:1 兼容\n   826→            \"768x768\",     # 1:1 小尺寸\n   827→            \"512x512\",     # 1:1 最小尺寸\n   828→        ]\n   829→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"19346720-f6f4-41f2-8e7d-b1c744515d22","timestamp":"2025-12-09T03:56:29.320Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py","content":"# Seedream图像生成客户端\n# 封装火山引擎Seedream3.0 API调用\n\nimport json\nimport os\nimport requests\nimport time\nimport random\nfrom typing import Dict, Any, Optional, List\nfrom pathlib import Path\nfrom loguru import logger\nfrom urllib3.util.retry import Retry\nfrom requests.adapters import HTTPAdapter\n\n# 导入配置管理器和错误处理\nfrom config.unified_config import get_unified_config\nfrom modules.utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n\n\nclass SeedreamClient:\n    \"\"\"火山引擎Seedream图片生成客户端\n\n    提供文生图和图生图功能\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n        timeout: int = 60,\n        max_retries: int = 3,\n    ):\n        \"\"\"初始化Seedream客户端\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n            base_url: API基础URL\n            timeout: 请求超时时间（秒）\n            max_retries: 最大重试次数\n        \"\"\"\n        # 获取API密钥\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise AppError(str(exc), ErrorHandler.ErrorType.AUTH_ERROR) from exc\n\n        self.api_key = api_key\n        self.base_url = base_url.rstrip(\"/\")\n        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n        # 配置会话\n        self.session = requests.Session()\n\n        # 配置重试策略\n        retry_strategy = Retry(\n            total=max_retries,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n            backoff_factor=1\n        )\n\n        adapter = HTTPAdapter(max_retries=retry_strategy)\n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        logger.info(\"Seedream客户端初始化完成\")\n\n        # 初始化性能监控与错误缓存（统一结构）\n        self._performance_stats = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"total_response_time\": 0.0,\n            \"last_request_time\": None,\n        }\n        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n        self._last_provider: Optional[str] = None\n        self._last_endpoint: Optional[str] = None\n\n    def _encode_image(self, image_path: str) -> str:\n        \"\"\"将图像文件编码为base64字符串\n        \n        Args:\n            image_path: 图像文件路径\n            \n        Returns:\n            base64编码的图像字符串\n        \"\"\"\n        import base64\n        \n        try:\n            with open(image_path, 'rb') as image_file:\n                image_data = image_file.read()\n                base64_string = base64.b64encode(image_data).decode('utf-8')\n                return base64_string\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图像编码失败: {error_msg}\")\n            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorHandler.ErrorType.FILE_ERROR)\n\n    def _get_headers(self) -> Dict[str, str]:\n        \"\"\"获取请求头\"\"\"\n        # 验证API密钥，防止尺寸配置被错误使用\n        api_key = str(self.api_key).strip()\n\n        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n        try:\n            api_key.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n\n        # 检查是否包含尺寸信息或换行符\n        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n\n        # 检查API密钥长度\n        if len(api_key) < 10 or len(api_key) > 200:\n            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n        \n        return {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"User-Agent\": \"Seedream-Client/1.0.0\",\n        }\n\n    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n\n    def _provider_enabled(self) -> bool:\n        try:\n            import os\n            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n            return v not in {\"0\", \"false\", \"no\"}\n        except Exception:\n            return True\n\n    def _get_seedream_provider_order(self) -> List[str]:\n        order: List[str] = []\n        try:\n            env_value = os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            env_value = \"volc_v3\"\n        candidates = [env_value]\n        for candidate in candidates:\n            if not candidate:\n                continue\n            name = candidate.strip().lower()\n            if not name:\n                continue\n            if name not in order:\n                order.append(name)\n        if \"volc_v3\" not in order:\n            order.append(\"volc_v3\")\n        return order\n\n    def _call_seedream_provider(self, headers: Dict[str, str], mapper, operation: str):\n        from modules.provider.factory import get_default_provider\n        default_endpoint = \"/images/generations\"\n        base_url = self.base_url.rstrip(\"/\")\n        first_choice = None\n        last_error: Optional[BaseException] = None\n        order = self._get_seedream_provider_order()\n        if order:\n            first_choice = order[0]\n        for idx, name in enumerate(order):\n            try:\n                provider = get_default_provider(name)\n            except Exception as e:\n                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n                last_error = e\n                continue\n            try:\n                mapped = mapper(provider)\n                if not isinstance(mapped, tuple):\n                    raise ValueError(\"provider mapper 返回值异常\")\n                if len(mapped) == 4:\n                    payload, fb, reason, endpoint = mapped\n                elif len(mapped) == 3:\n                    payload, fb, reason = mapped\n                    endpoint = default_endpoint\n                else:\n                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n            except Exception as e:\n                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n                last_error = e\n                continue\n            start_time = time.time()\n            try:\n                endpoint_path = endpoint or default_endpoint\n                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n                    request_url = endpoint_path\n                else:\n                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                    if not normalized.startswith(\"/\"):\n                        normalized = f\"/{normalized}\"\n                    request_url = f\"{base_url}{normalized}\"\n                response = self._safe_json_post(request_url, headers, payload, timeout=60)\n                result = self._handle_response(response)\n                elapsed = time.time() - start_time\n                if idx > 0 and first_choice:\n                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n                if fb and reason:\n                    logger.warning(f\"参数回退: {reason}\")\n                logger.info(\n                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n                )\n                self._last_provider = name\n                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                return result, payload, endpoint_path, name, fb, reason, elapsed\n            except AppError as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n                continue\n            except Exception as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n                continue\n        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n\n    def _log_seedream_event(\n        self,\n        operation: str,\n        status: str,\n        provider: Optional[str],\n        endpoint: Optional[str],\n        elapsed: float,\n        fallback_applied: bool,\n        fallback_reason: Optional[str] = None,\n        extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        try:\n            provider_name = provider or \"unknown\"\n            endpoint_text = endpoint or \"/images/generations\"\n            parts = [\n                f\"operation={operation}\",\n                f\"status={status}\",\n                f\"provider={provider_name}\",\n                f\"endpoint={endpoint_text}\",\n                f\"elapsed={elapsed:.2f}s\",\n                f\"fallback={'yes' if fallback_applied else 'no'}\",\n            ]\n            if fallback_applied and fallback_reason:\n                safe_reason = str(fallback_reason)\n                if len(safe_reason) > 120:\n                    safe_reason = safe_reason[:120] + \"...\"\n                parts.append(f\"fallback_reason={safe_reason}\")\n            if extra:\n                for key, value in extra.items():\n                    if value is None:\n                        continue\n                    parts.append(f\"{key}={value}\")\n            logger.info(\"摘要|\" + \" \".join(parts))\n        except Exception:\n            # 保证日志逻辑不会影响主流程\n            pass\n\n    @staticmethod\n    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n        mime = \"image/png\"\n        try:\n            if path_hint:\n                suffix = Path(path_hint).suffix.lower()\n                if suffix in {\".jpg\", \".jpeg\"}:\n                    mime = \"image/jpeg\"\n                elif suffix == \".webp\":\n                    mime = \"image/webp\"\n                elif suffix == \".bmp\":\n                    mime = \"image/bmp\"\n                elif suffix == \".gif\":\n                    mime = \"image/gif\"\n        except Exception:\n            pass\n        return f\"data:{mime};base64,{b64_data}\"\n\n    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n        \"\"\"处理API响应\n\n        Args:\n            response: HTTP响应对象\n\n        Returns:\n            解析后的响应数据\n\n        Raises:\n            AppError: 当API返回错误时\n        \"\"\"\n        try:\n            if not response.ok:\n                try:\n                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n                except Exception:\n                    error_text = str(response.content[:500])\n                # 避免在日志中显示可能包含base64数据的完整响应\n                if len(error_text) > 500:\n                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n                else:\n                    error_summary = error_text\n                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n                raise AppError(\n                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n                    ErrorType.API_ERROR,\n                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n                )\n\n            # 解析响应（增强容错：包括编码问题回退）\n            try:\n                result = response.json()\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                raw = response.content or b\"\"\n                tried = set()\n                result = None\n                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                    if not enc or enc in tried:\n                        continue\n                    tried.add(enc)\n                    try:\n                        text = raw.decode(enc, errors=\"strict\")\n                        result = json.loads(text)\n                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n                        break\n                    except Exception:\n                        continue\n                if result is None:\n                    try:\n                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                    except Exception:\n                        preview = str(raw[:200])\n                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n\n            # OpenAI格式的响应检查\n            if \"data\" not in result:\n                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n                logger.error(f\"Seedream API错误: {error_msg}\")\n                raise AppError(\n                    f\"API错误: {error_msg}\",\n                    ErrorHandler.ErrorType.API_ERROR,\n                    {\"response_data\": result},\n                )\n\n            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n            images = []\n            for item in result[\"data\"]:\n                if \"url\" in item:\n                    images.append({\n                        \"url\": item[\"url\"]\n                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n                    })\n\n            return {\n                \"code\": 200,\n                \"message\": \"success\",\n                \"data\": {\n                    \"images\": images\n                },\n                \"created\": result.get(\"created\"),\n                \"usage\": result.get(\"usage\", {})\n            }\n\n        except requests.exceptions.RequestException as e:\n            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n        except json.JSONDecodeError as e:\n            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n\n    def _record_request_stats(\n        self,\n        operation: str,\n        success: bool,\n        response_time: float,\n        error_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n    ) -> None:\n        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n        try:\n            self._performance_stats[\"total_requests\"] += 1\n            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n            self._performance_stats[\"last_request_time\"] = time.time()\n            if success:\n                self._performance_stats[\"successful_requests\"] += 1\n            else:\n                self._performance_stats[\"failed_requests\"] += 1\n                if error_code or error_message:\n                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n\n            # 调试日志（安全版）\n            total = max(1, self._performance_stats[\"total_requests\"])\n            avg = self._performance_stats[\"total_response_time\"] / total\n            succ = self._performance_stats[\"successful_requests\"]\n            success_rate = (succ / total) * 100.0\n            logger.debug(\n                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n            )\n        except Exception:\n            # 统计不应影响业务流程\n            pass\n\n    def get_performance_stats(self) -> Dict[str, Any]:\n        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n        stats = dict(self._performance_stats)\n        total = stats.get(\"total_requests\", 0) or 0\n        if total > 0:\n            avg = stats.get(\"total_response_time\", 0.0) / total\n            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n        else:\n            avg = 0.0\n            success_rate = 0.0\n        return {\n            \"total_requests\": total,\n            \"successful_requests\": stats.get(\"successful_requests\", 0),\n            \"failed_requests\": stats.get(\"failed_requests\", 0),\n            \"avg_response_time\": avg,\n            \"success_rate\": success_rate,\n            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n        }\n\n    def dump_metrics(self) -> Dict[str, Any]:\n        \"\"\"导出诊断可读的统一指标。\"\"\"\n        m = self.get_performance_stats()\n        m.update({\n            \"client\": \"Seedream\",\n            \"model\": self.model_id,\n            \"base_url\": self.base_url,\n        })\n        return m\n\n    def last_provider(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n        return self._last_provider\n\n    def last_endpoint(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n        return self._last_endpoint\n\n    @error_handler(\"Seedream文生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[Any]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        文生图API调用\n\n        Args:\n            prompt: 图片描述提示词\n            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            response_format: 返回格式，\"url\"或\"b64_json\"\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import TextToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_t2i(TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=reference_images or []\n                    )),\n                    \"text_to_image\"\n                )\n                self._log_seedream_event(\n                    \"text_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not self.validate_image_size(size):\n                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n                \"prompt\": prompt,\n                \"size\": size,\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n\n            if reference_images:\n                images_payload = []\n                for item in reference_images:\n                    try:\n                        if isinstance(item, str):\n                            if item.startswith(\"data:image/\"):\n                                images_payload.append(item)\n                                continue\n                            p = Path(item)\n                            if p.exists():\n                                encoded = self._encode_image(str(p))\n                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n                                images_payload.append(item)\n                        elif isinstance(item, dict):\n                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n                            path_hint = item.get('path') or item.get('source')\n                            if payload:\n                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n                            else:\n                                path_val = item.get('path')\n                                if path_val:\n                                    p = Path(path_val)\n                                    if p.exists():\n                                        encoded = self._encode_image(str(p))\n                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                    except Exception as exc:\n                        logger.warning(f\"参考图处理失败: {exc}\")\n                if images_payload:\n                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n                    data[\"sequential_image_generation\"] = \"disabled\"\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"text_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n\n    @error_handler(\"Seedream图生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        图生图API调用\n\n        Args:\n            prompt: 图片编辑提示词\n            image: 输入图像URL或Base64编码\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import ImageToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_i2i(ImageToImageParams(\n                        prompt=prompt,\n                        image=image,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=(reference_images or []),\n                    )),\n                    \"image_to_image\"\n                )\n                self._log_seedream_event(\n                    \"image_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n                \"prompt\": prompt,\n                \"image\": image,\n                \"size\": \"adaptive\",\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n            if reference_images:\n                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"image_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n\n    def batch_text_to_image(\n        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量文生图：同时生成多张图片\n\n        Args:\n            prompts: 提示词列表\n            width: 图像宽度\n            height: 图像高度\n            guidance_scale: 提示词一致性\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        results = []\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            try:\n                # 为每个任务生成不同的随机种子\n                seed = random.randint(1, 2147483647)\n\n                result = self.text_to_image(\n                    prompt=prompt, \n                    width=width, \n                    height=height, \n                    guidance_scale=guidance_scale, \n                    seed=seed\n                )\n\n                results.append({\n                    \"success\": True,\n                    \"result\": result,\n                    \"prompt\": prompt\n                })\n\n            except Exception as e:\n                # 避免在日志中显示过长的异常信息\n                error_msg = str(e)\n                if len(error_msg) > 200:\n                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                logger.error(f\"第{i}个任务失败: {error_msg}\")\n                results.append({\n                    \"success\": False,\n                    \"error\": error_msg,\n                    \"prompt\": prompt\n                })\n\n            # 避免请求过于频繁\n            if i < len(prompts):\n                time.sleep(0.5)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n        return results\n\n    def validate_image_size(self, size: str) -> bool:\n        \"\"\"\n        验证图像尺寸是否支持\n\n        Args:\n            size: 图像尺寸字符串，如 \"1024x1024\"\n\n        Returns:\n            bool: 是否支持该尺寸\n        \"\"\"\n        try:\n            # 解析尺寸字符串\n            if 'x' not in size:\n                return False\n                \n            width_str, height_str = size.split('x', 1)\n            width = int(width_str)\n            height = int(height_str)\n            \n            # 验证范围：Seedream 4.0 支持 512-4096像素\n            return (512 <= width <= 4096) and (512 <= height <= 4096)\n            \n        except (ValueError, AttributeError):\n            return False\n\n    def get_supported_sizes(self) -> List[str]:\n        \"\"\"\n        获取常用的图像尺寸列表\n        \n        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n\n        Returns:\n            List[str]: 常用尺寸列表，包含官方推荐尺寸\n        \"\"\"\n        return [\n            # 官方推荐尺寸 (Seedream 4.0)\n            \"2048x2048\",   # 1:1 官方推荐\n            \"2304x1728\",   # 4:3 官方推荐\n            \"1728x2304\",   # 3:4 官方推荐\n            \"2560x1440\",   # 16:9 官方推荐\n            \"1440x2560\",   # 9:16 官方推荐\n            \"2496x1664\",   # 3:2 官方推荐\n            \"1664x2496\",   # 2:3 官方推荐\n            \"3024x1296\",   # 21:9 官方推荐\n            \n            # 兼容性尺寸\n            \"1920x1080\",   # 16:9 兼容\n            \"1080x1920\",   # 9:16 兼容\n            \"1536x1024\",   # 3:2 兼容\n            \"1024x1536\",   # 2:3 兼容\n            \"1512x648\",    # 21:9 兼容\n            \"1280x720\",    # 16:9 小尺寸\n            \"720x1280\",    # 9:16 小尺寸\n            \"1024x1024\",   # 1:1 兼容\n            \"768x768\",     # 1:1 小尺寸\n            \"512x512\",     # 1:1 最小尺寸\n        ]\n","numLines":829,"startLine":1,"totalLines":829}}}
{"parentUuid":"19346720-f6f4-41f2-8e7d-b1c744515d22","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JBNj1RVMSBviZ1ETdJJTNP","type":"tool_result","content":"     1→# Seedance视频生成管理器\n     2→# 负责视频生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→import base64\n    13→import pandas as pd\n    14→from datetime import datetime\n    15→from pathlib import Path\n    16→from typing import Dict, Any, List, Optional, Tuple\n    17→from urllib.parse import urlparse\n    18→from loguru import logger\n    19→from PIL import Image\n    20→\n    21→from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n    22→\n    23→from .client import SeedanceClient\n    24→from ..storage import get_v2_storage_manager\n    25→from ..provider.schema import (\n    26→    VideoParams,\n    27→    validate_and_normalize_video,\n    28→)\n    29→from config.unified_config import get_unified_config\n    30→from config_api import get_storage_dir\n    31→# 使用统一水印服务（edition/watermark_service.py）\n    32→from edition.watermark_service import (\n    33→    should_add_watermark,\n    34→    get_watermark_text,\n    35→    get_watermark_opacity,\n    36→)\n    37→\n    38→# API水印配置保持不变（用于服务端水印）\n    39→try:  # pragma: no cover\n    40→    from config_api import API_WATERMARK_CONFIG  # type: ignore\n    41→except Exception:  # pragma: no cover\n    42→    API_WATERMARK_CONFIG = {\n    43→        \"image_watermark\": False,\n    44→        \"video_watermark\": False,\n    45→    }\n    46→try:  # pragma: no cover\n    47→    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\n    48→except Exception:  # pragma: no cover\n    49→    LOCAL_WATERMARK_CONFIG = {\n    50→        \"enabled\": False,\n    51→        \"text\": \"\",\n    52→        \"opacity\": 0.0,\n    53→        \"position\": \"bottom_right\",\n    54→        \"font_size\": 0,\n    55→    }\n    56→\n    57→\n    58→class SeedanceManager:\n    59→    \"\"\"Seedance视频生成管理器\"\"\"\n    60→\n    61→    def __init__(self, api_key: str = None):\n    62→        \"\"\"\n    63→        初始化Seedance管理器\n    64→\n    65→        Args:\n    66→            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n    67→        \"\"\"\n    68→        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n    69→        if api_key is None:\n    70→            try:\n    71→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    72→            except Exception as exc:\n    73→                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n    74→        \n    75→        self.client = SeedanceClient(api_key)\n    76→        \n    77→        # 使用V2统一存储管理器（与单一真源对齐）\n    78→        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n    79→        \n    80→        # 保持兼容性别名\n    81→        self.file_manager = self.storage_manager\n    82→        self.metadata_manager = self.storage_manager\n    83→        self.video_storage_manager = self.storage_manager\n    84→        \n    85→        # 保留原有的目录属性以保持兼容性\n    86→        self.data_dir = Path(self.storage_manager.root_path)\n    87→        self.videos_dir = self.data_dir / \"videos\"\n    88→        self.metadata_dir = self.data_dir / \"metadata\"\n    89→\n    90→        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    91→\n    92→    def generate_video(\n    93→        self,\n    94→        prompt: str,\n    95→        image_path: Optional[str] = None,\n    96→        first_frame_path: Optional[str] = None,\n    97→        last_frame_path: Optional[str] = None,\n    98→        duration: float = 4.0,\n    99→        seed: int = -1,\n   100→        watermark: bool = False,\n   101→        save_local: bool = True,\n   102→        wait_for_completion: bool = True,\n   103→        # 新增参数（P0b）\n   104→        resolution_grade: Optional[str] = None,\n   105→        ratio: Optional[str] = None,\n   106→        fps: int = 24,\n   107→        camera_fixed: bool = True,\n   108→        use_pro_model: bool = True,\n   109→        reference_images: Optional[List[Any]] = None,\n   110→        generation_id: Optional[str] = None,\n   111→    ) -> Dict[str, Any]:\n   112→        \"\"\"\n   113→        生成视频并保存到本地\n   114→\n   115→        Args:\n   116→            image_path: 输入图像路径\n   117→            duration: 视频时长（秒）\n   118→            motion_strength: 运动强度 (0.1-1.0)\n   119→            seed: 随机种子\n   120→            watermark: 保留参数（服务端水印由配置决定）\n   121→            save_local: 是否保存到本地\n   122→            wait_for_completion: 是否等待任务完成\n   123→\n   124→        Returns:\n   125→            Dict: 生成结果\n   126→        \"\"\"\n   127→        logger.info(\"开始视频生成任务(Manager)\")\n   128→\n   129→        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n   130→        task_id = generation_id or str(uuid.uuid4())\n   131→\n   132→        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n   133→        # 构建待处理的图片列表\n   134→        all_input_images = []\n   135→\n   136→        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n   137→        frame_inputs = []\n   138→        if first_frame_path:\n   139→            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n   140→        if last_frame_path:\n   141→            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n   142→        elif image_path and not first_frame_path:\n   143→            frame_inputs.append({'path': image_path, 'type': 'image'})\n   144→\n   145→        all_input_images.extend(frame_inputs)\n   146→\n   147→        # 2. 添加参考图\n   148→        if reference_images:\n   149→            for ref in reference_images:\n   150→                if isinstance(ref, dict):\n   151→                    ref_copy = dict(ref)\n   152→                    ref_copy['type'] = ref_copy.get('type', 'reference')\n   153→                    all_input_images.append(ref_copy)\n   154→                else:\n   155→                    all_input_images.append({'path': ref, 'type': 'reference'})\n   156→\n   157→        # 3. 统一处理（复制到 references 目录）\n   158→        ref_summary = self._process_reference_assets(\n   159→            all_input_images if all_input_images else None,\n   160→            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n   161→            expected_outputs=1,\n   162→        )\n   163→        ref_assets = ref_summary.get('assets', [])\n   164→        ref_paths: List[str] = list(ref_summary.get('paths', []))\n   165→\n   166→        # 4. 分离帧图片和参考图\n   167→        frame_assets = {}\n   168→        pure_ref_assets = []\n   169→        for asset in ref_assets:\n   170→            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n   171→            if asset_type in ('first_frame', 'last_frame', 'image'):\n   172→                frame_assets[asset_type] = asset\n   173→            else:\n   174→                pure_ref_assets.append(asset)\n   175→\n   176→        # 5. 提取帧图片的相对路径（用于存储）\n   177→        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n   178→        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n   179→        stored_image_path = frame_assets.get('image', {}).get('path')\n   180→\n   181→        # 6. 提取参考图的 payload（用于 API 调用）\n   182→        ref_payloads: List[str] = []\n   183→        for asset in pure_ref_assets:\n   184→            payload = asset.get('_payload_b64')\n   185→            if payload:\n   186→                ref_payloads.append(payload)\n   187→\n   188→        if ref_summary.get('errors'):\n   189→            logger.warning(\n   190→                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   191→            )\n   192→        if ref_summary.get('warnings'):\n   193→            for warn in ref_summary['warnings']:\n   194→                logger.warning(f\"图片处理提示: {warn}\")\n   195→\n   196→        watermark_enabled = bool(\n   197→            LOCAL_WATERMARK_CONFIG.get(\"enabled\", API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n   198→        )\n   199→\n   200→        create_kwargs = dict(\n   201→            prompt=prompt,\n   202→            duration=int(duration),\n   203→            seed=None if seed == -1 else seed,\n   204→            fps=fps,\n   205→            resolution_grade=resolution_grade,\n   206→            ratio=ratio,\n   207→            watermark=watermark_enabled,\n   208→            camera_fixed=bool(camera_fixed),\n   209→            use_pro_model=use_pro_model,\n   210→        )\n   211→        if ref_payloads:\n   212→            create_kwargs['reference_images'] = ref_payloads\n   213→        if first_frame_path and last_frame_path:\n   214→            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n   215→        elif image_path:\n   216→            create_kwargs.update(dict(image_path=image_path))\n   217→        # 文生视频：不追加图片参数\n   218→\n   219→        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n   220→        precheck_fb = False\n   221→        precheck_reason = \"\"\n   222→        try:\n   223→            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n   224→                VideoParams(\n   225→                    prompt=prompt,\n   226→                    image_path=None,  # 校验不依赖图像数据\n   227→                    first_frame_path=None,\n   228→                    last_frame_path=None,\n   229→                    duration=int(duration),\n   230→                    fps=int(fps),\n   231→                    seed=(None if seed == -1 else seed),\n   232→                    camera_fixed=bool(camera_fixed),\n   233→                    watermark=bool(watermark),\n   234→                    resolution_grade=resolution_grade,\n   235→                    ratio=ratio,\n   236→                    use_pro_model=bool(use_pro_model),\n   237→                )\n   238→            )\n   239→            logger.info(\n   240→                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   241→            )\n   242→            if fb:\n   243→                logger.warning(f\"前置参数回退建议: {reason}\")\n   244→            precheck_fb = fb\n   245→            precheck_reason = reason\n   246→        except Exception as _e:\n   247→            logger.debug(f\"前置参数校验跳过: {_e}\")\n   248→\n   249→        create_result = self.client.create_video_task(**create_kwargs)\n   250→\n   251→        if not create_result[\"success\"]:\n   252→            self._cleanup_reference_paths(ref_paths)\n   253→            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n   254→            return create_result\n   255→\n   256→        api_task_id = create_result[\"task_id\"]\n   257→\n   258→        result = {\n   259→            \"task_id\": task_id,\n   260→            \"api_task_id\": api_task_id,\n   261→            \"success\": True,\n   262→            \"type\": \"image_to_video\",\n   263→            \"input_image\": image_path,\n   264→            \"status\": \"pending\",\n   265→            \"parameters\": {\n   266→                \"prompt\": prompt,\n   267→                \"duration\": duration,\n   268→                \"seed\": (None if seed == -1 else seed),\n   269→                \"watermark\": watermark_enabled,\n   270→                \"resolution_grade\": resolution_grade,\n   271→                \"ratio\": ratio,\n   272→                \"fps\": fps,\n   273→                \"camera_fixed\": bool(camera_fixed),\n   274→                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n   275→                \"first_frame\": stored_first_frame,\n   276→                \"last_frame\": stored_last_frame,\n   277→                \"image_path\": stored_image_path,\n   278→            },\n   279→            \"created_at\": datetime.now().isoformat(),\n   280→        }\n   281→\n   282→        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   283→        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n   284→        result['reference_assets'] = sanitized_refs\n   285→        if ref_summary.get('errors'):\n   286→            result['reference_asset_errors'] = ref_summary['errors']\n   287→        if ref_summary.get('warnings'):\n   288→            result['reference_asset_warnings'] = ref_summary['warnings']\n   289→        if precheck_fb and precheck_reason:\n   290→            result.setdefault('fallback_applied', True)\n   291→            if result.get('fallback_reason'):\n   292→                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n   293→            else:\n   294→                result['fallback_reason'] = precheck_reason\n   295→\n   296→        masked_ids = self._summarize_reference_ids(sanitized_refs)\n   297→        logger.info(\n   298→            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n   299→            len(sanitized_refs),\n   300→            masked_ids or \"-\",\n   301→            self._provider_hint(),\n   302→        )\n   303→\n   304→        # 透传回退信息\n   305→        if create_result.get(\"fallback_applied\"):\n   306→            result[\"fallback_applied\"] = True\n   307→            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n   308→\n   309→        # 如果等待完成，轮询任务状态\n   310→        if wait_for_completion:\n   311→            completion_result = self.client.wait_for_completion(api_task_id)\n   312→\n   313→            if completion_result[\"success\"]:\n   314→                if completion_result[\"status\"] == \"success\":\n   315→                    result[\"status\"] = \"success\"\n   316→                    result[\"video_url\"] = completion_result[\"video_url\"]\n   317→                    result[\"duration\"] = completion_result.get(\"duration\")\n   318→                    result[\"file_size\"] = completion_result.get(\"file_size\")\n   319→                    result[\"completed_at\"] = datetime.now().isoformat()\n   320→\n   321→                    # 保存到本地\n   322→                    if save_local:\n   323→                        local_result = self._save_video_locally(result)\n   324→                        result.update(local_result)\n   325→                        if local_result.get('local_save_error'):\n   326→                            self._cleanup_reference_paths(ref_paths)\n   327→                            result['parameters'][\"reference_assets\"] = []\n   328→                            result['reference_assets'] = []\n   329→                            warnings = result.setdefault('reference_asset_warnings', [])\n   330→                            warnings.append(\"视频保存失败，参考图已回滚\")\n   331→                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   332→\n   333→                    logger.success(f\"视频生成任务完成: {task_id}\")\n   334→                else:\n   335→                    result[\"status\"] = completion_result[\"status\"]\n   336→                    result[\"error\"] = completion_result.get(\"error\")\n   337→                    result[\"error_code\"] = completion_result.get(\"error_code\")\n   338→                    logger.error(f\"视频生成任务失败: {result['error']}\")\n   339→            else:\n   340→                result[\"status\"] = \"failed\"\n   341→                result[\"error\"] = completion_result[\"error\"]\n   342→                result[\"error_code\"] = completion_result[\"error_code\"]\n   343→                logger.error(f\"等待任务完成失败: {result['error']}\")\n   344→\n   345→        # 记录元数据\n   346→        self._save_task_metadata(result)\n   347→\n   348→        return result\n   349→\n   350→    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n   351→        \"\"\"\n   352→        检查任务状态\n   353→\n   354→        Args:\n   355→            task_id: 本地任务ID\n   356→\n   357→        Returns:\n   358→            Dict: 任务状态信息\n   359→        \"\"\"\n   360→        logger.info(f\"检查任务状态: {task_id}\")\n   361→\n   362→        # 从元数据中获取任务信息\n   363→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   364→\n   365→        if not task_record:\n   366→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   367→\n   368→        api_task_id = task_record.get(\"api_task_id\")\n   369→        if not api_task_id:\n   370→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   371→\n   372→        # 查询API任务状态\n   373→        status_result = self.client.get_task_status(api_task_id)\n   374→\n   375→        if status_result[\"success\"]:\n   376→            # 更新本地记录\n   377→            updates = {\n   378→                \"status\": status_result[\"status\"],\n   379→                \"progress\": status_result.get(\"progress\", 0),\n   380→                \"updated_at\": datetime.now().isoformat(),\n   381→            }\n   382→\n   383→            # 如果任务完成，添加结果信息\n   384→            if status_result[\"status\"] == \"success\":\n   385→                updates[\"video_url\"] = status_result[\"video_url\"]\n   386→                updates[\"duration\"] = status_result.get(\"duration\")\n   387→                updates[\"file_size\"] = status_result.get(\"file_size\")\n   388→                updates[\"completed_at\"] = datetime.now().isoformat()\n   389→\n   390→            # 如果任务失败，添加错误信息\n   391→            elif status_result[\"status\"] == \"failed\":\n   392→                updates[\"error\"] = status_result.get(\"error\")\n   393→                updates[\"error_code\"] = status_result.get(\"error_code\")\n   394→\n   395→            # 更新元数据\n   396→            self.metadata_manager.update_record(task_id, updates)\n   397→\n   398→            # 合并任务信息\n   399→            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n   400→\n   401→            return result\n   402→        else:\n   403→            return status_result\n   404→\n   405→    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n   406→        \"\"\"\n   407→        下载已完成的视频\n   408→\n   409→        Args:\n   410→            task_id: 本地任务ID\n   411→\n   412→        Returns:\n   413→            Dict: 下载结果\n   414→        \"\"\"\n   415→        logger.info(f\"下载视频: {task_id}\")\n   416→\n   417→        # 获取任务信息\n   418→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   419→\n   420→        if not task_record:\n   421→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   422→\n   423→        # 检查任务状态\n   424→        if task_record.get(\"status\") != \"success\":\n   425→            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n   426→\n   427→        video_url = task_record.get(\"video_url\")\n   428→        if not video_url:\n   429→            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n   430→\n   431→        # 检查是否已下载\n   432→        local_path = task_record.get(\"local_path\")\n   433→        if local_path and Path(local_path).exists():\n   434→            logger.info(\n   435→                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n   436→            )\n   437→            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n   438→\n   439→        # 下载视频\n   440→        try:\n   441→            response = safe_requests_get(video_url, timeout=300)\n   442→\n   443→            # 生成本地文件名\n   444→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n   445→            task_id_short = task_id[:8]\n   446→            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n   447→\n   448→            # 保存文件\n   449→            local_path = self.file_manager.save_file(filename, response.content)\n   450→\n   451→            # 获取视频信息\n   452→            video_info = self._get_video_info(local_path)\n   453→\n   454→            # 更新元数据\n   455→            updates = {\n   456→                \"filename\": filename,\n   457→                \"local_path\": str(local_path),\n   458→                \"local_file_size\": local_path.stat().st_size,\n   459→                \"downloaded_at\": datetime.now().isoformat(),\n   460→            }\n   461→\n   462→            if video_info:\n   463→                updates.update(video_info)\n   464→\n   465→            self.metadata_manager.update_record(task_id, updates)\n   466→\n   467→            logger.success(f\"视频下载成功: {filename}\")\n   468→\n   469→            summary = {\n   470→                \"success\": True,\n   471→                \"local_path\": str(local_path),\n   472→                \"filename\": filename,\n   473→                \"file_size\": local_path.stat().st_size,\n   474→                \"video_info\": video_info,\n   475→            }\n   476→            try:\n   477→                logger.info(\n   478→                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n   479→                )\n   480→            except Exception:\n   481→                pass\n   482→            return summary\n   483→\n   484→        except Exception as e:\n   485→            logger.error(f\"下载视频失败: {e}\")\n   486→            try:\n   487→                logger.info(\n   488→                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n   489→                )\n   490→            except Exception:\n   491→                pass\n   492→            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n   493→\n   494→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n   495→        \"\"\"\n   496→        取消任务\n   497→\n   498→        Args:\n   499→            task_id: 本地任务ID\n   500→\n   501→        Returns:\n   502→            Dict: 取消结果\n   503→        \"\"\"\n   504→        logger.info(f\"取消任务: {task_id}\")\n   505→\n   506→        # 获取任务信息\n   507→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   508→\n   509→        if not task_record:\n   510→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   511→\n   512→        api_task_id = task_record.get(\"api_task_id\")\n   513→        if not api_task_id:\n   514→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   515→\n   516→        # 调用API取消任务\n   517→        cancel_result = self.client.cancel_task(api_task_id)\n   518→\n   519→        if cancel_result[\"success\"]:\n   520→            # 更新本地记录\n   521→            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n   522→\n   523→            self.metadata_manager.update_record(task_id, updates)\n   524→\n   525→            logger.success(f\"任务取消成功: {task_id}\")\n   526→\n   527→        return cancel_result\n   528→\n   529→    def batch_generate_videos(\n   530→        self,\n   531→        image_paths: List[str],\n   532→        duration: float = 4.0,\n   533→        motion_strength: float = 0.8,\n   534→        watermark: bool = True,\n   535→        save_local: bool = True,\n   536→        wait_for_completion: bool = False,\n   537→    ) -> List[Dict[str, Any]]:\n   538→        \"\"\"\n   539→        批量生成视频\n   540→\n   541→        Args:\n   542→            image_paths: 图像路径列表\n   543→            duration: 视频时长\n   544→            motion_strength: 运动强度\n   545→            watermark: 保留参数（服务端水印由配置决定）\n   546→            save_local: 是否保存到本地\n   547→            wait_for_completion: 是否等待任务完成\n   548→\n   549→        Returns:\n   550→            List[Dict]: 生成结果列表\n   551→        \"\"\"\n   552→        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n   553→\n   554→        results = []\n   555→        for i, image_path in enumerate(image_paths, 1):\n   556→            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n   557→\n   558→            result = self.generate_video(\n   559→                image_path=image_path,\n   560→                duration=duration,\n   561→                motion_strength=motion_strength,\n   562→                watermark=watermark,\n   563→                save_local=save_local,\n   564→                wait_for_completion=wait_for_completion,\n   565→            )\n   566→\n   567→            results.append(result)\n   568→\n   569→        success_count = sum(1 for r in results if r[\"success\"])\n   570→        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n   571→\n   572→        return results\n   573→\n   574→    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   575→        \"\"\"\n   576→        保存视频到本地\n   577→\n   578→        Args:\n   579→            result: API生成结果\n   580→\n   581→        Returns:\n   582→            Dict: 包含本地文件信息的字典\n   583→        \"\"\"\n   584→        try:\n   585→            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n   586→            \n   587→            # Validate inputs\n   588→            task_id = result.get(\"task_id\")\n   589→            video_url = result.get(\"video_url\")\n   590→            if not task_id:\n   591→                raise ValueError(\"Task ID is required\")\n   592→            if not video_url:\n   593→                raise ValueError(\"Video URL is required\")\n   594→            \n   595→            # 下载视频\n   596→            logger.info(f\"Downloading video from {video_url}\")\n   597→            try:\n   598→                response = safe_requests_get(video_url, stream=True, timeout=300)\n   599→                \n   600→                # Check content type\n   601→                content_type = response.headers.get('content-type', '')\n   602→                if 'video' not in content_type:\n   603→                    logger.warning(f\"Unexpected content type: {content_type}\")\n   604→                \n   605→                # Get file size for progress tracking\n   606→                total_size = int(response.headers.get('content-length', 0))\n   607→                video_data = response.content\n   608→                \n   609→                logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n   610→                \n   611→            except requests.exceptions.RequestException as e:\n   612→                logger.error(f\"Network error downloading video: {e}\")\n   613→                raise Exception(f\"Failed to download video: {str(e)}\")\n   614→            \n   615→            # 在保存前获取真实视频信息（写临时文件以便读取）\n   616→            actual_width = None\n   617→            actual_height = None\n   618→            actual_fps = None\n   619→            actual_duration = None\n   620→            try:\n   621→                import tempfile\n   622→                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   623→                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n   624→                    tf.write(video_data)\n   625→                    temp_path = Path(tf.name)\n   626→                # 使用缩略图工具的get_video_info\n   627→                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   628→                gen = VideoThumbnailGenerator(str(thumbs_dir))\n   629→                info = gen.get_video_info(str(temp_path))\n   630→                try:\n   631→                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n   632→                except Exception:\n   633→                    pass\n   634→                if info:\n   635→                    actual_width = info.get('width')\n   636→                    actual_height = info.get('height')\n   637→                    actual_fps = info.get('fps')\n   638→                    actual_duration = info.get('duration')\n   639→            except Exception as e:\n   640→                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n   641→\n   642→            # 准备元数据（适配UnifiedStorageManager的格式）\n   643→            metadata = {\n   644→                'generation_id': task_id,\n   645→                'task_id': task_id,\n   646→                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n   647→                'parameters': {\n   648→                    **result.get('parameters', {}),\n   649→                    # 回填真实视频信息\n   650→                    **({} if actual_width is None else {'width': actual_width}),\n   651→                    **({} if actual_height is None else {'height': actual_height}),\n   652→                    **({} if actual_fps is None else {'fps': actual_fps}),\n   653→                    **({} if actual_duration is None else {'duration': actual_duration}),\n   654→                    # 透传fallback信息\n   655→                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n   656→                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n   657→                },\n   658→                'model': self._get_display_model_name(result),\n   659→                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n   660→                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n   661→                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n   662→                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n   663→                'generation_time': result.get('generation_time', 0),\n   664→                'status': result.get('status', 'completed'),\n   665→                'batch_id': result.get('batch_id', '')\n   666→            }\n   667→            \n   668→            # 使用统一存储管理器保存文件\n   669→            save_result = self.storage_manager.save_content_file(\n   670→                content_type='videos',\n   671→                file_data=video_data,\n   672→                url=video_url,\n   673→                metadata=metadata\n   674→            )\n   675→\n   676→            # 缩略图生成（已由UnifiedStorageManager处理）\n   677→            thumbnail_local_path = save_result.get('thumbnail_path')\n   678→            thumbnail_filename = None\n   679→            if thumbnail_local_path:\n   680→                thumbnail_filename = Path(thumbnail_local_path).name\n   681→                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n   682→            else:\n   683→                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n   684→\n   685→            # 下载并保存API返回的缩略图（如果有）作为备用\n   686→            api_thumbnail_local_path = None\n   687→            api_thumbnail_filename = None\n   688→            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n   689→                try:\n   690→                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n   691→                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n   692→                    \n   693→                    # 使用统一存储管理器保存备用缩略图\n   694→                    backup_metadata = {\n   695→                        'generation_id': task_id,\n   696→                        'prompt': 'API backup thumbnail for video',\n   697→                        'model': 'seedance',\n   698→                        'width': 320,\n   699→                        'height': 180,\n   700→                        'status': 'completed'\n   701→                    }\n   702→                    \n   703→                    backup_result = self.storage_manager.save_content_file(\n   704→                        content_type='images',  # 缩略图保存为图片\n   705→                        file_data=thumbnail_response.content,\n   706→                        url=result[\"thumbnail_url\"],\n   707→                        metadata=backup_metadata\n   708→                    )\n   709→                    \n   710→                    api_thumbnail_local_path = backup_result['local_path']\n   711→                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n   712→                    \n   713→                    # 如果本地缩略图生成失败，使用API缩略图\n   714→                    if not thumbnail_local_path:\n   715→                        thumbnail_local_path = api_thumbnail_local_path\n   716→                        thumbnail_filename = api_thumbnail_filename\n   717→                    \n   718→                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n   719→                        \n   720→                except Exception as e:\n   721→                    logger.warning(f\"下载API缩略图失败: {e}\")\n   722→                    api_thumbnail_local_path = None\n   723→                    api_thumbnail_filename = None\n   724→\n   725→            # 获取视频信息\n   726→            local_path = Path(save_result['local_path'])\n   727→            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n   728→            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n   729→                try:\n   730→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   731→                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   732→                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n   733→                    video_info = gen.get_video_info(str(local_path))\n   734→                except Exception:\n   735→                    video_info = {}\n   736→            else:\n   737→                video_info = {\n   738→                    'width': actual_width,\n   739→                    'height': actual_height,\n   740→                    'fps': actual_fps,\n   741→                    'duration': actual_duration,\n   742→                }\n   743→            file_size = local_path.stat().st_size if local_path.exists() else 0\n   744→            \n   745→            logger.success(f\"视频已保存到本地: {local_path.name}\")\n   746→            \n   747→            # 本地视频水印（使用统一水印服务控制）\n   748→            if should_add_watermark():\n   749→                try:\n   750→                    from edition.watermark_service import WatermarkService\n   751→\n   752→                    watermark_text = get_watermark_text() or \"PIGEON\"\n   753→                    try:\n   754→                        opacity = get_watermark_opacity()\n   755→                    except Exception:\n   756→                        opacity = 0.3\n   757→                    opacity = max(0.0, min(opacity, 1.0))\n   758→\n   759→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n   760→                    watermark_applied = watermark_service.apply_to_video(local_path)\n   761→                    if watermark_applied:\n   762→                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n   763→                    else:\n   764→                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n   765→                except Exception as e:\n   766→                    logger.warning(f\"添加视频水印时出错: {e}\")\n   767→\n   768→            result_obj = {\n   769→                \"local_path\": save_result['local_path'],\n   770→                \"filename\": local_path.name,\n   771→                \"file_path\": save_result['local_path'],  # 保持兼容性\n   772→                \"local_file_size\": file_size,\n   773→                \"video_info\": video_info,\n   774→                # 同步回填至顶层，便于上游使用\n   775→                **({} if not video_info else {\n   776→                    'width': video_info.get('width'),\n   777→                    'height': video_info.get('height'),\n   778→                    'fps': video_info.get('fps'),\n   779→                    'duration': video_info.get('duration'),\n   780→                }),\n   781→                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n   782→                \"thumbnail_filename\": thumbnail_filename,\n   783→                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n   784→                \"api_thumbnail_filename\": api_thumbnail_filename,\n   785→                \"task_id\": task_id,  # 添加task_id以供后续使用\n   786→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n   787→                \"file_id\": save_result.get('file_id'),\n   788→                \"relative_path\": save_result.get('relative_path'),\n   789→            }\n   790→            try:\n   791→                logger.info(\n   792→                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n   793→                )\n   794→            except Exception:\n   795→                pass\n   796→            return result_obj\n   797→\n   798→        except Exception as e:\n   799→            logger.error(f\"保存视频到本地失败: {e}\")\n   800→            logger.exception(\"Full traceback for video save error:\")\n   801→            try:\n   802→                logger.info(\n   803→                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n   804→                )\n   805→            except Exception:\n   806→                pass\n   807→            return {\"local_save_error\": str(e)}\n   808→\n   809→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n   810→        checksum = hashlib.sha1(file_data).hexdigest()\n   811→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n   812→        return f\"ref_{ts}_{checksum[:8]}\"\n   813→\n   814→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n   815→        source_meta: Dict[str, Any] = {}\n   816→        raw = ref\n   817→        if isinstance(ref, dict):\n   818→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n   819→                if ref.get(key) is not None:\n   820→                    source_meta[key] = ref.get(key)\n   821→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n   822→        if raw is None:\n   823→            return None\n   824→\n   825→        extension = source_meta.get('extension')\n   826→        data = None\n   827→        source_repr = source_meta.get('source')\n   828→\n   829→        try:\n   830→            if isinstance(raw, bytes):\n   831→                data = raw\n   832→            elif isinstance(raw, str):\n   833→                stripped = raw.strip()\n   834→                if stripped.startswith('data:') and ';base64,' in stripped:\n   835→                    header, payload = stripped.split(';base64,', 1)\n   836→                    mime_part = header[5:]\n   837→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n   838→                    data = base64.b64decode(payload)\n   839→                    source_repr = source_repr or mime_part\n   840→                    source_meta.setdefault('type', 'image')\n   841→                elif stripped.startswith(('http://', 'https://')):\n   842→                    resp = safe_requests_get(stripped, timeout=15)\n   843→                    data = resp.content\n   844→                    parsed = urlparse(stripped)\n   845→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n   846→                    source_repr = source_repr or stripped\n   847→                    source_meta.setdefault('source_url', stripped)\n   848→                else:\n   849→                    path = Path(stripped)\n   850→                    if not path.exists():\n   851→                        logger.warning(f\"参考图像不存在: {stripped}\")\n   852→                        return None\n   853→                    data = path.read_bytes()\n   854→                    extension = extension or path.suffix or '.png'\n   855→                    source_repr = source_repr or path.name\n   856→                    source_meta.setdefault('source_path', str(path))\n   857→            else:\n   858→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n   859→                return None\n   860→        except Exception as exc:\n   861→            logger.warning(f\"加载参考图失败: {exc}\")\n   862→            return None\n   863→\n   864→        if data is None:\n   865→            return None\n   866→\n   867→        width = source_meta.get('width')\n   868→        height = source_meta.get('height')\n   869→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n   870→            try:\n   871→                from io import BytesIO\n   872→\n   873→                with Image.open(BytesIO(data)) as img:\n   874→                    width = img.width\n   875→                    height = img.height\n   876→            except Exception:\n   877→                pass\n   878→\n   879→        source_meta['width'] = width\n   880→        source_meta['height'] = height\n   881→        source_meta.setdefault('type', 'image')\n   882→        source_meta['source'] = source_repr or source_meta.get('source')\n   883→\n   884→        return data, extension, source_meta\n   885→\n   886→    def _process_reference_assets(\n   887→        self,\n   888→        references: Optional[List[Any]],\n   889→        *,\n   890→        max_refs: int = MAX_REFERENCE_IMAGES,\n   891→        expected_outputs: int = 1,\n   892→    ) -> Dict[str, Any]:\n   893→        stored: List[Dict[str, Any]] = []\n   894→        absolute_paths: List[str] = []\n   895→        errors: List[str] = []\n   896→        warnings: List[str] = []\n   897→\n   898→        if not references:\n   899→            return {\n   900→                'assets': stored,\n   901→                'paths': absolute_paths,\n   902→                'errors': errors,\n   903→                'warnings': warnings,\n   904→            }\n   905→\n   906→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n   907→            warnings.append(\n   908→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n   909→            )\n   910→            references = references[:max_refs]\n   911→\n   912→        for order, item in enumerate(references):\n   913→            load_result = self._load_reference_source(item)\n   914→            if not load_result:\n   915→                errors.append(f\"ref[{order}] 加载失败\")\n   916→                continue\n   917→\n   918→            file_data, extension, meta = load_result\n   919→            meta.setdefault('order', order)\n   920→            meta.setdefault('kind', meta.get('type', 'image'))\n   921→\n   922→            try:\n   923→                asset_id = self._generate_reference_asset_id(file_data)\n   924→                record = self.storage_manager.save_reference_asset(\n   925→                    'images',\n   926→                    file_data,\n   927→                    asset_id=asset_id,\n   928→                    extension=extension,\n   929→                    metadata=meta,\n   930→                )\n   931→                try:\n   932→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n   933→                except Exception:\n   934→                    record['_payload_b64'] = None\n   935→                record['_source_meta'] = meta\n   936→                stored.append(record)\n   937→                if record.get('absolute_path'):\n   938→                    absolute_paths.append(record['absolute_path'])\n   939→            except Exception as exc:\n   940→                logger.warning(f\"保存参考图失败: {exc}\")\n   941→                errors.append(f\"ref[{order}] 保存失败\")\n   942→\n   943→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n   944→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n   945→            if len(stored) > allowed:\n   946→                warnings.append(\n   947→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n   948→                )\n   949→                stored = stored[:allowed]\n   950→                absolute_paths = absolute_paths[:allowed]\n   951→\n   952→        return {\n   953→            'assets': stored,\n   954→            'paths': absolute_paths,\n   955→            'errors': errors,\n   956→            'warnings': warnings,\n   957→        }\n   958→\n   959→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   960→        cleaned: List[Dict[str, Any]] = []\n   961→        for rec in assets or []:\n   962→            rec.pop('_payload_b64', None)\n   963→            rec.pop('_source_meta', None)\n   964→            rec.pop('absolute_path', None)\n   965→            cleaned.append({\n   966→                'id': rec.get('id') or rec.get('reference_id'),\n   967→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n   968→                'type': rec.get('type'),\n   969→                'kind': rec.get('kind'),\n   970→                'source': rec.get('source'),\n   971→                'order': rec.get('order'),\n   972→                'checksum': rec.get('checksum'),\n   973→                'size': rec.get('size'),\n   974→                'width': rec.get('width'),\n   975→                'height': rec.get('height'),\n   976→                'created_at': rec.get('created_at'),\n   977→            })\n   978→        return cleaned\n   979→\n   980→    @staticmethod\n   981→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n   982→        masked: List[str] = []\n   983→        for rec in assets or []:\n   984→            rid = rec.get('id') or ''\n   985→            if not rid:\n   986→                continue\n   987→            masked.append(f\"{rid[:6]}***\")\n   988→        return \",\".join(masked)\n   989→\n   990→    @staticmethod\n   991→    def _provider_hint() -> str:\n   992→        try:\n   993→            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n   994→        except Exception:\n   995→            return \"seedance\"\n   996→\n   997→    @staticmethod\n   998→    def _cleanup_reference_paths(paths: List[str]):\n   999→        for path in paths or []:\n  1000→            try:\n  1001→                if path and Path(path).exists():\n  1002→                    Path(path).unlink(missing_ok=True)\n  1003→            except Exception as exc:\n  1004→                logger.debug(f\"参考图清理失败: {exc}\")\n  1005→\n  1006→    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n  1007→        \"\"\"\n  1008→        将绝对路径转换为相对路径（相对于存储根目录）\n  1009→\n  1010→        如果路径已经是相对路径或无法转换，返回原路径。\n  1011→        这确保数据库中存储的是相对路径，支持跨平台迁移。\n  1012→\n  1013→        Args:\n  1014→            abs_path: 绝对路径或相对路径\n  1015→\n  1016→        Returns:\n  1017→            相对路径字符串，如 \"images/xxx.png\"\n  1018→        \"\"\"\n  1019→        if not abs_path:\n  1020→            return None\n  1021→\n  1022→        try:\n  1023→            path = Path(abs_path)\n  1024→\n  1025→            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n  1026→            if not path.is_absolute():\n  1027→                return str(path).replace('\\\\', '/')\n  1028→\n  1029→            # 尝试转换为相对于存储根目录的路径\n  1030→            storage_root = Path(self.storage_manager.root_path)\n  1031→            try:\n  1032→                relative = path.relative_to(storage_root)\n  1033→                return str(relative).replace('\\\\', '/')\n  1034→            except ValueError:\n  1035→                # 路径不在存储根目录下，尝试提取文件名部分\n  1036→                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n  1037→                parts = path.parts\n  1038→                for i, part in enumerate(parts):\n  1039→                    if part in ('images', 'videos', 'thumbnails', 'references'):\n  1040→                        relative = Path(*parts[i:])\n  1041→                        return str(relative).replace('\\\\', '/')\n  1042→\n  1043→                # 无法提取，返回原路径（记录警告）\n  1044→                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n  1045→                return str(path).replace('\\\\', '/')\n  1046→\n  1047→        except Exception as e:\n  1048→            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n  1049→            return abs_path\n  1050→\n  1051→    def _extract_width_from_resolution(self, resolution: str) -> int:\n  1052→        \"\"\"\n  1053→        从分辨率字符串中提取宽度\n  1054→        \n  1055→        Args:\n  1056→            resolution: 分辨率字符串，如 \"1280x720\"\n  1057→            \n  1058→        Returns:\n  1059→            int: 宽度值\n  1060→        \"\"\"\n  1061→        try:\n  1062→            return int(resolution.split('x')[0])\n  1063→        except (ValueError, IndexError):\n  1064→            return 1280  # 默认值\n  1065→    \n  1066→    def _extract_height_from_resolution(self, resolution: str) -> int:\n  1067→        \"\"\"\n  1068→        从分辨率字符串中提取高度\n  1069→        \n  1070→        Args:\n  1071→            resolution: 分辨率字符串，如 \"1280x720\"\n  1072→            \n  1073→        Returns:\n  1074→            int: 高度值\n  1075→        \"\"\"\n  1076→        try:\n  1077→            return int(resolution.split('x')[1])\n  1078→        except (ValueError, IndexError):\n  1079→            return 720  # 默认值\n  1080→\n  1081→    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n  1082→        \"\"\"\n  1083→        获取视频信息\n  1084→\n  1085→        Args:\n  1086→            video_path: 视频文件路径\n  1087→\n  1088→        Returns:\n  1089→            Dict: 视频信息\n  1090→        \"\"\"\n  1091→        try:\n  1092→            # 这里可以使用ffprobe或其他工具获取视频信息\n  1093→            # 暂时返回基本信息\n  1094→            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n  1095→        except Exception as e:\n  1096→            logger.error(f\"获取视频信息失败: {e}\")\n  1097→            return {}\n  1098→\n  1099→    def _save_task_metadata(self, result: Dict[str, Any]):\n  1100→        \"\"\"\n  1101→        保存任务元数据\n  1102→\n  1103→        Args:\n  1104→            result: 任务结果\n  1105→        \"\"\"\n  1106→        try:\n  1107→            # 构建视频元数据\n  1108→            metadata = {\n  1109→                \"generation_id\": result[\"task_id\"],\n  1110→                \"file_id\": result[\"task_id\"],\n  1111→                \"filename\": result.get(\"filename\", \"\"),\n  1112→                \"file_path\": result.get(\"local_path\", \"\"),\n  1113→                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n  1114→                \"parameters\": result.get(\"parameters\", {}),\n  1115→                \"created_at\": result[\"created_at\"],\n  1116→                \"file_size\": result.get(\"local_file_size\", 0),\n  1117→                \"source_url\": result.get(\"video_url\", \"\"),\n  1118→                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n  1119→                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n  1120→            }\n  1121→\n  1122→            # 调用视频元数据保存方法\n  1123→            self.metadata_manager.save_video_metadata(metadata)\n  1124→            \n  1125→            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n  1126→\n  1127→        except Exception as e:\n  1128→            logger.error(f\"保存任务元数据失败: {e}\")\n  1129→\n  1130→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1131→        \"\"\"\n  1132→        获取视频生成历史记录\n  1133→\n  1134→        Args:\n  1135→            limit: 返回记录数量限制\n  1136→\n  1137→        Returns:\n  1138→            List[Dict]: 历史记录列表\n  1139→        \"\"\"\n  1140→        return self.storage_manager.load_history('videos', limit=limit)\n  1141→\n  1142→    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n  1143→        \"\"\"\n  1144→        根据输入图像路径搜索历史记录\n  1145→\n  1146→        Args:\n  1147→            keyword: 搜索关键字\n  1148→\n  1149→        Returns:\n  1150→            List[Dict]: 匹配的记录列表\n  1151→        \"\"\"\n  1152→        return self.metadata_manager.search_records(\"input_image\", keyword)\n  1153→\n  1154→    def get_statistics(self) -> Dict[str, Any]:\n  1155→        \"\"\"\n  1156→        获取生成统计信息\n  1157→\n  1158→        Returns:\n  1159→            Dict: 统计信息\n  1160→        \"\"\"\n  1161→        try:\n  1162→            df = self.metadata_manager.get_dataframe()\n  1163→\n  1164→            if df.empty:\n  1165→                return {\n  1166→                    \"total_videos\": 0,\n  1167→                    \"success_count\": 0,\n  1168→                    \"failed_count\": 0,\n  1169→                    \"pending_count\": 0,\n  1170→                    \"total_file_size\": 0,\n  1171→                    \"average_file_size\": 0,\n  1172→                    \"total_duration\": 0,\n  1173→                    \"average_duration\": 0,\n  1174→                }\n  1175→\n  1176→            stats = {\n  1177→                \"total_videos\": len(df),\n  1178→                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n  1179→                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n  1180→                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n  1181→                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n  1182→                \"total_file_size\": df[\"local_file_size\"].sum(),\n  1183→                \"average_file_size\": df[\"local_file_size\"].mean(),\n  1184→                \"total_duration\": df[\"duration\"].sum(),\n  1185→                \"average_duration\": df[\"duration\"].mean(),\n  1186→                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n  1187→            }\n  1188→\n  1189→            return stats\n  1190→\n  1191→        except Exception as e:\n  1192→            logger.error(f\"获取统计信息失败: {e}\")\n  1193→            return {}\n  1194→\n  1195→    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n  1196→        \"\"\"获取用于显示的模型名称\"\"\"\n  1197→        # 从参数中获取模型变体信息\n  1198→        params = result.get('parameters', {})\n  1199→        model_variant = params.get('model_variant', '')\n  1200→        use_pro_model = params.get('use_pro_model', True)\n  1201→        \n  1202→        # 根据模型变体返回友好的显示名称\n  1203→        if 'seedance_pro' in model_variant or (use_pro_model and not model_variant):\n  1204→            return 'seedance 1.0 pro'\n  1205→        elif 'seedance_lite' in model_variant or (not use_pro_model and not model_variant):\n  1206→            return 'seedance 1.0 lite'\n  1207→        else:\n  1208→            # 回退到原始模型名称或默认值\n  1209→            return result.get('model', 'seedance')\n  1210→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"453cd94c-264a-4a49-af1f-e0efba54f12b","timestamp":"2025-12-09T03:56:29.611Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"# Seedance视频生成管理器\n# 负责视频生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nimport base64\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom urllib.parse import urlparse\nfrom loguru import logger\nfrom PIL import Image\n\nfrom ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n\nfrom .client import SeedanceClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    VideoParams,\n    validate_and_normalize_video,\n)\nfrom config.unified_config import get_unified_config\nfrom config_api import get_storage_dir\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n# API水印配置保持不变（用于服务端水印）\ntry:  # pragma: no cover\n    from config_api import API_WATERMARK_CONFIG  # type: ignore\nexcept Exception:  # pragma: no cover\n    API_WATERMARK_CONFIG = {\n        \"image_watermark\": False,\n        \"video_watermark\": False,\n    }\ntry:  # pragma: no cover\n    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\nexcept Exception:  # pragma: no cover\n    LOCAL_WATERMARK_CONFIG = {\n        \"enabled\": False,\n        \"text\": \"\",\n        \"opacity\": 0.0,\n        \"position\": \"bottom_right\",\n        \"font_size\": 0,\n    }\n\n\nclass SeedanceManager:\n    \"\"\"Seedance视频生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedance管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n        \"\"\"\n        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n        \n        self.client = SeedanceClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.video_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.videos_dir = self.data_dir / \"videos\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_video(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: float = 4.0,\n        seed: int = -1,\n        watermark: bool = False,\n        save_local: bool = True,\n        wait_for_completion: bool = True,\n        # 新增参数（P0b）\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        fps: int = 24,\n        camera_fixed: bool = True,\n        use_pro_model: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成视频并保存到本地\n\n        Args:\n            image_path: 输入图像路径\n            duration: 视频时长（秒）\n            motion_strength: 运动强度 (0.1-1.0)\n            seed: 随机种子\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            Dict: 生成结果\n        \"\"\"\n        logger.info(\"开始视频生成任务(Manager)\")\n\n        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n        # 构建待处理的图片列表\n        all_input_images = []\n\n        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n        frame_inputs = []\n        if first_frame_path:\n            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n        if last_frame_path:\n            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n        elif image_path and not first_frame_path:\n            frame_inputs.append({'path': image_path, 'type': 'image'})\n\n        all_input_images.extend(frame_inputs)\n\n        # 2. 添加参考图\n        if reference_images:\n            for ref in reference_images:\n                if isinstance(ref, dict):\n                    ref_copy = dict(ref)\n                    ref_copy['type'] = ref_copy.get('type', 'reference')\n                    all_input_images.append(ref_copy)\n                else:\n                    all_input_images.append({'path': ref, 'type': 'reference'})\n\n        # 3. 统一处理（复制到 references 目录）\n        ref_summary = self._process_reference_assets(\n            all_input_images if all_input_images else None,\n            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n            expected_outputs=1,\n        )\n        ref_assets = ref_summary.get('assets', [])\n        ref_paths: List[str] = list(ref_summary.get('paths', []))\n\n        # 4. 分离帧图片和参考图\n        frame_assets = {}\n        pure_ref_assets = []\n        for asset in ref_assets:\n            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n            if asset_type in ('first_frame', 'last_frame', 'image'):\n                frame_assets[asset_type] = asset\n            else:\n                pure_ref_assets.append(asset)\n\n        # 5. 提取帧图片的相对路径（用于存储）\n        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n        stored_image_path = frame_assets.get('image', {}).get('path')\n\n        # 6. 提取参考图的 payload（用于 API 调用）\n        ref_payloads: List[str] = []\n        for asset in pure_ref_assets:\n            payload = asset.get('_payload_b64')\n            if payload:\n                ref_payloads.append(payload)\n\n        if ref_summary.get('errors'):\n            logger.warning(\n                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n            )\n        if ref_summary.get('warnings'):\n            for warn in ref_summary['warnings']:\n                logger.warning(f\"图片处理提示: {warn}\")\n\n        watermark_enabled = bool(\n            LOCAL_WATERMARK_CONFIG.get(\"enabled\", API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n        )\n\n        create_kwargs = dict(\n            prompt=prompt,\n            duration=int(duration),\n            seed=None if seed == -1 else seed,\n            fps=fps,\n            resolution_grade=resolution_grade,\n            ratio=ratio,\n            watermark=watermark_enabled,\n            camera_fixed=bool(camera_fixed),\n            use_pro_model=use_pro_model,\n        )\n        if ref_payloads:\n            create_kwargs['reference_images'] = ref_payloads\n        if first_frame_path and last_frame_path:\n            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n        elif image_path:\n            create_kwargs.update(dict(image_path=image_path))\n        # 文生视频：不追加图片参数\n\n        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n        precheck_fb = False\n        precheck_reason = \"\"\n        try:\n            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n                VideoParams(\n                    prompt=prompt,\n                    image_path=None,  # 校验不依赖图像数据\n                    first_frame_path=None,\n                    last_frame_path=None,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if seed == -1 else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=bool(watermark),\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                )\n            )\n            logger.info(\n                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n            )\n            if fb:\n                logger.warning(f\"前置参数回退建议: {reason}\")\n            precheck_fb = fb\n            precheck_reason = reason\n        except Exception as _e:\n            logger.debug(f\"前置参数校验跳过: {_e}\")\n\n        create_result = self.client.create_video_task(**create_kwargs)\n\n        if not create_result[\"success\"]:\n            self._cleanup_reference_paths(ref_paths)\n            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n            return create_result\n\n        api_task_id = create_result[\"task_id\"]\n\n        result = {\n            \"task_id\": task_id,\n            \"api_task_id\": api_task_id,\n            \"success\": True,\n            \"type\": \"image_to_video\",\n            \"input_image\": image_path,\n            \"status\": \"pending\",\n            \"parameters\": {\n                \"prompt\": prompt,\n                \"duration\": duration,\n                \"seed\": (None if seed == -1 else seed),\n                \"watermark\": watermark_enabled,\n                \"resolution_grade\": resolution_grade,\n                \"ratio\": ratio,\n                \"fps\": fps,\n                \"camera_fixed\": bool(camera_fixed),\n                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n                \"first_frame\": stored_first_frame,\n                \"last_frame\": stored_last_frame,\n                \"image_path\": stored_image_path,\n            },\n            \"created_at\": datetime.now().isoformat(),\n        }\n\n        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n        result['reference_assets'] = sanitized_refs\n        if ref_summary.get('errors'):\n            result['reference_asset_errors'] = ref_summary['errors']\n        if ref_summary.get('warnings'):\n            result['reference_asset_warnings'] = ref_summary['warnings']\n        if precheck_fb and precheck_reason:\n            result.setdefault('fallback_applied', True)\n            if result.get('fallback_reason'):\n                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n            else:\n                result['fallback_reason'] = precheck_reason\n\n        masked_ids = self._summarize_reference_ids(sanitized_refs)\n        logger.info(\n            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n            len(sanitized_refs),\n            masked_ids or \"-\",\n            self._provider_hint(),\n        )\n\n        # 透传回退信息\n        if create_result.get(\"fallback_applied\"):\n            result[\"fallback_applied\"] = True\n            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n\n        # 如果等待完成，轮询任务状态\n        if wait_for_completion:\n            completion_result = self.client.wait_for_completion(api_task_id)\n\n            if completion_result[\"success\"]:\n                if completion_result[\"status\"] == \"success\":\n                    result[\"status\"] = \"success\"\n                    result[\"video_url\"] = completion_result[\"video_url\"]\n                    result[\"duration\"] = completion_result.get(\"duration\")\n                    result[\"file_size\"] = completion_result.get(\"file_size\")\n                    result[\"completed_at\"] = datetime.now().isoformat()\n\n                    # 保存到本地\n                    if save_local:\n                        local_result = self._save_video_locally(result)\n                        result.update(local_result)\n                        if local_result.get('local_save_error'):\n                            self._cleanup_reference_paths(ref_paths)\n                            result['parameters'][\"reference_assets\"] = []\n                            result['reference_assets'] = []\n                            warnings = result.setdefault('reference_asset_warnings', [])\n                            warnings.append(\"视频保存失败，参考图已回滚\")\n                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n                    logger.success(f\"视频生成任务完成: {task_id}\")\n                else:\n                    result[\"status\"] = completion_result[\"status\"]\n                    result[\"error\"] = completion_result.get(\"error\")\n                    result[\"error_code\"] = completion_result.get(\"error_code\")\n                    logger.error(f\"视频生成任务失败: {result['error']}\")\n            else:\n                result[\"status\"] = \"failed\"\n                result[\"error\"] = completion_result[\"error\"]\n                result[\"error_code\"] = completion_result[\"error_code\"]\n                logger.error(f\"等待任务完成失败: {result['error']}\")\n\n        # 记录元数据\n        self._save_task_metadata(result)\n\n        return result\n\n    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        检查任务状态\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        logger.info(f\"检查任务状态: {task_id}\")\n\n        # 从元数据中获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 查询API任务状态\n        status_result = self.client.get_task_status(api_task_id)\n\n        if status_result[\"success\"]:\n            # 更新本地记录\n            updates = {\n                \"status\": status_result[\"status\"],\n                \"progress\": status_result.get(\"progress\", 0),\n                \"updated_at\": datetime.now().isoformat(),\n            }\n\n            # 如果任务完成，添加结果信息\n            if status_result[\"status\"] == \"success\":\n                updates[\"video_url\"] = status_result[\"video_url\"]\n                updates[\"duration\"] = status_result.get(\"duration\")\n                updates[\"file_size\"] = status_result.get(\"file_size\")\n                updates[\"completed_at\"] = datetime.now().isoformat()\n\n            # 如果任务失败，添加错误信息\n            elif status_result[\"status\"] == \"failed\":\n                updates[\"error\"] = status_result.get(\"error\")\n                updates[\"error_code\"] = status_result.get(\"error_code\")\n\n            # 更新元数据\n            self.metadata_manager.update_record(task_id, updates)\n\n            # 合并任务信息\n            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n\n            return result\n        else:\n            return status_result\n\n    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        下载已完成的视频\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 下载结果\n        \"\"\"\n        logger.info(f\"下载视频: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        # 检查任务状态\n        if task_record.get(\"status\") != \"success\":\n            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n\n        video_url = task_record.get(\"video_url\")\n        if not video_url:\n            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n\n        # 检查是否已下载\n        local_path = task_record.get(\"local_path\")\n        if local_path and Path(local_path).exists():\n            logger.info(\n                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n            )\n            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n\n        # 下载视频\n        try:\n            response = safe_requests_get(video_url, timeout=300)\n\n            # 生成本地文件名\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            task_id_short = task_id[:8]\n            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n\n            # 保存文件\n            local_path = self.file_manager.save_file(filename, response.content)\n\n            # 获取视频信息\n            video_info = self._get_video_info(local_path)\n\n            # 更新元数据\n            updates = {\n                \"filename\": filename,\n                \"local_path\": str(local_path),\n                \"local_file_size\": local_path.stat().st_size,\n                \"downloaded_at\": datetime.now().isoformat(),\n            }\n\n            if video_info:\n                updates.update(video_info)\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"视频下载成功: {filename}\")\n\n            summary = {\n                \"success\": True,\n                \"local_path\": str(local_path),\n                \"filename\": filename,\n                \"file_size\": local_path.stat().st_size,\n                \"video_info\": video_info,\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n                )\n            except Exception:\n                pass\n            return summary\n\n        except Exception as e:\n            logger.error(f\"下载视频失败: {e}\")\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n                )\n            except Exception:\n                pass\n            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消任务\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 取消结果\n        \"\"\"\n        logger.info(f\"取消任务: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 调用API取消任务\n        cancel_result = self.client.cancel_task(api_task_id)\n\n        if cancel_result[\"success\"]:\n            # 更新本地记录\n            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"任务取消成功: {task_id}\")\n\n        return cancel_result\n\n    def batch_generate_videos(\n        self,\n        image_paths: List[str],\n        duration: float = 4.0,\n        motion_strength: float = 0.8,\n        watermark: bool = True,\n        save_local: bool = True,\n        wait_for_completion: bool = False,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成视频\n\n        Args:\n            image_paths: 图像路径列表\n            duration: 视频时长\n            motion_strength: 运动强度\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n\n        results = []\n        for i, image_path in enumerate(image_paths, 1):\n            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n\n            result = self.generate_video(\n                image_path=image_path,\n                duration=duration,\n                motion_strength=motion_strength,\n                watermark=watermark,\n                save_local=save_local,\n                wait_for_completion=wait_for_completion,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n\n        return results\n\n    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存视频到本地\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n            \n            # Validate inputs\n            task_id = result.get(\"task_id\")\n            video_url = result.get(\"video_url\")\n            if not task_id:\n                raise ValueError(\"Task ID is required\")\n            if not video_url:\n                raise ValueError(\"Video URL is required\")\n            \n            # 下载视频\n            logger.info(f\"Downloading video from {video_url}\")\n            try:\n                response = safe_requests_get(video_url, stream=True, timeout=300)\n                \n                # Check content type\n                content_type = response.headers.get('content-type', '')\n                if 'video' not in content_type:\n                    logger.warning(f\"Unexpected content type: {content_type}\")\n                \n                # Get file size for progress tracking\n                total_size = int(response.headers.get('content-length', 0))\n                video_data = response.content\n                \n                logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n                \n            except requests.exceptions.RequestException as e:\n                logger.error(f\"Network error downloading video: {e}\")\n                raise Exception(f\"Failed to download video: {str(e)}\")\n            \n            # 在保存前获取真实视频信息（写临时文件以便读取）\n            actual_width = None\n            actual_height = None\n            actual_fps = None\n            actual_duration = None\n            try:\n                import tempfile\n                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n                    tf.write(video_data)\n                    temp_path = Path(tf.name)\n                # 使用缩略图工具的get_video_info\n                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                gen = VideoThumbnailGenerator(str(thumbs_dir))\n                info = gen.get_video_info(str(temp_path))\n                try:\n                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n                except Exception:\n                    pass\n                if info:\n                    actual_width = info.get('width')\n                    actual_height = info.get('height')\n                    actual_fps = info.get('fps')\n                    actual_duration = info.get('duration')\n            except Exception as e:\n                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n\n            # 准备元数据（适配UnifiedStorageManager的格式）\n            metadata = {\n                'generation_id': task_id,\n                'task_id': task_id,\n                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n                'parameters': {\n                    **result.get('parameters', {}),\n                    # 回填真实视频信息\n                    **({} if actual_width is None else {'width': actual_width}),\n                    **({} if actual_height is None else {'height': actual_height}),\n                    **({} if actual_fps is None else {'fps': actual_fps}),\n                    **({} if actual_duration is None else {'duration': actual_duration}),\n                    # 透传fallback信息\n                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n                },\n                'model': self._get_display_model_name(result),\n                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n                'generation_time': result.get('generation_time', 0),\n                'status': result.get('status', 'completed'),\n                'batch_id': result.get('batch_id', '')\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='videos',\n                file_data=video_data,\n                url=video_url,\n                metadata=metadata\n            )\n\n            # 缩略图生成（已由UnifiedStorageManager处理）\n            thumbnail_local_path = save_result.get('thumbnail_path')\n            thumbnail_filename = None\n            if thumbnail_local_path:\n                thumbnail_filename = Path(thumbnail_local_path).name\n                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n            else:\n                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n\n            # 下载并保存API返回的缩略图（如果有）作为备用\n            api_thumbnail_local_path = None\n            api_thumbnail_filename = None\n            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n                try:\n                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n                    \n                    # 使用统一存储管理器保存备用缩略图\n                    backup_metadata = {\n                        'generation_id': task_id,\n                        'prompt': 'API backup thumbnail for video',\n                        'model': 'seedance',\n                        'width': 320,\n                        'height': 180,\n                        'status': 'completed'\n                    }\n                    \n                    backup_result = self.storage_manager.save_content_file(\n                        content_type='images',  # 缩略图保存为图片\n                        file_data=thumbnail_response.content,\n                        url=result[\"thumbnail_url\"],\n                        metadata=backup_metadata\n                    )\n                    \n                    api_thumbnail_local_path = backup_result['local_path']\n                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n                    \n                    # 如果本地缩略图生成失败，使用API缩略图\n                    if not thumbnail_local_path:\n                        thumbnail_local_path = api_thumbnail_local_path\n                        thumbnail_filename = api_thumbnail_filename\n                    \n                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n                        \n                except Exception as e:\n                    logger.warning(f\"下载API缩略图失败: {e}\")\n                    api_thumbnail_local_path = None\n                    api_thumbnail_filename = None\n\n            # 获取视频信息\n            local_path = Path(save_result['local_path'])\n            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n                try:\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n                    video_info = gen.get_video_info(str(local_path))\n                except Exception:\n                    video_info = {}\n            else:\n                video_info = {\n                    'width': actual_width,\n                    'height': actual_height,\n                    'fps': actual_fps,\n                    'duration': actual_duration,\n                }\n            file_size = local_path.stat().st_size if local_path.exists() else 0\n            \n            logger.success(f\"视频已保存到本地: {local_path.name}\")\n            \n            # 本地视频水印（使用统一水印服务控制）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_video(local_path)\n                    if watermark_applied:\n                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n                    else:\n                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n                except Exception as e:\n                    logger.warning(f\"添加视频水印时出错: {e}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": local_path.name,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"local_file_size\": file_size,\n                \"video_info\": video_info,\n                # 同步回填至顶层，便于上游使用\n                **({} if not video_info else {\n                    'width': video_info.get('width'),\n                    'height': video_info.get('height'),\n                    'fps': video_info.get('fps'),\n                    'duration': video_info.get('duration'),\n                }),\n                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n                \"thumbnail_filename\": thumbnail_filename,\n                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n                \"api_thumbnail_filename\": api_thumbnail_filename,\n                \"task_id\": task_id,  # 添加task_id以供后续使用\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n                )\n            except Exception:\n                pass\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存视频到本地失败: {e}\")\n            logger.exception(\"Full traceback for video save error:\")\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n                )\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"参考图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('reference_id'),\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum'),\n                'size': rec.get('size'),\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n        except Exception:\n            return \"seedance\"\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n        \"\"\"\n        将绝对路径转换为相对路径（相对于存储根目录）\n\n        如果路径已经是相对路径或无法转换，返回原路径。\n        这确保数据库中存储的是相对路径，支持跨平台迁移。\n\n        Args:\n            abs_path: 绝对路径或相对路径\n\n        Returns:\n            相对路径字符串，如 \"images/xxx.png\"\n        \"\"\"\n        if not abs_path:\n            return None\n\n        try:\n            path = Path(abs_path)\n\n            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n            if not path.is_absolute():\n                return str(path).replace('\\\\', '/')\n\n            # 尝试转换为相对于存储根目录的路径\n            storage_root = Path(self.storage_manager.root_path)\n            try:\n                relative = path.relative_to(storage_root)\n                return str(relative).replace('\\\\', '/')\n            except ValueError:\n                # 路径不在存储根目录下，尝试提取文件名部分\n                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n                parts = path.parts\n                for i, part in enumerate(parts):\n                    if part in ('images', 'videos', 'thumbnails', 'references'):\n                        relative = Path(*parts[i:])\n                        return str(relative).replace('\\\\', '/')\n\n                # 无法提取，返回原路径（记录警告）\n                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n                return str(path).replace('\\\\', '/')\n\n        except Exception as e:\n            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n            return abs_path\n\n    def _extract_width_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取宽度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[0])\n        except (ValueError, IndexError):\n            return 1280  # 默认值\n    \n    def _extract_height_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取高度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[1])\n        except (ValueError, IndexError):\n            return 720  # 默认值\n\n    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取视频信息\n\n        Args:\n            video_path: 视频文件路径\n\n        Returns:\n            Dict: 视频信息\n        \"\"\"\n        try:\n            # 这里可以使用ffprobe或其他工具获取视频信息\n            # 暂时返回基本信息\n            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n        except Exception as e:\n            logger.error(f\"获取视频信息失败: {e}\")\n            return {}\n\n    def _save_task_metadata(self, result: Dict[str, Any]):\n        \"\"\"\n        保存任务元数据\n\n        Args:\n            result: 任务结果\n        \"\"\"\n        try:\n            # 构建视频元数据\n            metadata = {\n                \"generation_id\": result[\"task_id\"],\n                \"file_id\": result[\"task_id\"],\n                \"filename\": result.get(\"filename\", \"\"),\n                \"file_path\": result.get(\"local_path\", \"\"),\n                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n                \"parameters\": result.get(\"parameters\", {}),\n                \"created_at\": result[\"created_at\"],\n                \"file_size\": result.get(\"local_file_size\", 0),\n                \"source_url\": result.get(\"video_url\", \"\"),\n                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n            }\n\n            # 调用视频元数据保存方法\n            self.metadata_manager.save_video_metadata(metadata)\n            \n            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n\n        except Exception as e:\n            logger.error(f\"保存任务元数据失败: {e}\")\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取视频生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('videos', limit=limit)\n\n    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据输入图像路径搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        return self.metadata_manager.search_records(\"input_image\", keyword)\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            df = self.metadata_manager.get_dataframe()\n\n            if df.empty:\n                return {\n                    \"total_videos\": 0,\n                    \"success_count\": 0,\n                    \"failed_count\": 0,\n                    \"pending_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"total_duration\": 0,\n                    \"average_duration\": 0,\n                }\n\n            stats = {\n                \"total_videos\": len(df),\n                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n                \"total_file_size\": df[\"local_file_size\"].sum(),\n                \"average_file_size\": df[\"local_file_size\"].mean(),\n                \"total_duration\": df[\"duration\"].sum(),\n                \"average_duration\": df[\"duration\"].mean(),\n                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n            }\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {}\n\n    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n        \"\"\"获取用于显示的模型名称\"\"\"\n        # 从参数中获取模型变体信息\n        params = result.get('parameters', {})\n        model_variant = params.get('model_variant', '')\n        use_pro_model = params.get('use_pro_model', True)\n        \n        # 根据模型变体返回友好的显示名称\n        if 'seedance_pro' in model_variant or (use_pro_model and not model_variant):\n            return 'seedance 1.0 pro'\n        elif 'seedance_lite' in model_variant or (not use_pro_model and not model_variant):\n            return 'seedance 1.0 lite'\n        else:\n            # 回退到原始模型名称或默认值\n            return result.get('model', 'seedance')\n","numLines":1210,"startLine":1,"totalLines":1210}}}
{"parentUuid":"453cd94c-264a-4a49-af1f-e0efba54f12b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018rkHnMAbuAk6FRrNUJwuL8","type":"tool_result","content":"     1→# Seedance视频生成客户端\n     2→# 封装火山引擎Seedance1.0pro的API调用\n     3→\n     4→import os\n     5→import time\n     6→import json\n     7→import base64\n     8→import requests\n     9→import logging\n    10→import asyncio\n    11→from typing import Dict, Any, Optional, List, Tuple\n    12→from pathlib import Path\n    13→from loguru import logger\n    14→# volcenginesdkarkruntime import removed - not used in current implementation\n    15→from requests.adapters import HTTPAdapter\n    16→from urllib3.util.retry import Retry\n    17→\n    18→# 导入配置管理器和错误处理\n    19→from config.unified_config import get_unified_config\n    20→from modules.utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler\n    21→from .config import SeedanceModels, TaskStatus, SeedanceConfig\n    22→\n    23→\"\"\"\n    24→常量与辅助方法（视频参数 P0b）\n    25→- 仅保留“分辨率档位 + 比例”的新路径；不再支持旧 width/height → --rs 映射\n    26→\"\"\"\n    27→\n    28→# 白名单常量\n    29→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    30→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\"}\n    31→\n    32→def _validate_and_build_flags(\n    33→    resolution_grade: Optional[str],\n    34→    ratio: Optional[str],\n    35→    duration: int,\n    36→    fps: int,\n    37→    watermark: bool,\n    38→    camera_fixed: bool,\n    39→    seed: Optional[int],\n    40→) -> Tuple[str, bool, str, str, str]:\n    41→    \"\"\"生成安全版文本命令片段；返回 (flags_text, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n    42→    used_rs = resolution_grade or \"\"\n    43→    used_rt = ratio or \"\"\n    44→    fallback_applied = False\n    45→    fallback_reasons: List[str] = []\n    46→\n    47→    # 校验白名单\n    48→    if not used_rs or used_rs not in RES_GRADES:\n    49→        fallback_applied = True\n    50→        fallback_reasons.append(f\"无效分辨率: {used_rs or '缺失'}\")\n    51→        used_rs = \"1080p\"\n    52→    if not used_rt or used_rt not in RATIOS:\n    53→        fallback_applied = True\n    54→        fallback_reasons.append(f\"无效比例: {used_rt or '缺失'}\")\n    55→        used_rt = \"16:9\"\n    56→\n    57→    # 组装顺序: --rs --rt --dur --fps --wm --seed --cf\n    58→    parts: List[str] = []\n    59→    parts += [\"--rs\", used_rs, \"--rt\", used_rt, \"--dur\", str(int(duration)), \"--fps\", str(int(fps))]\n    60→    parts += [\"--wm\", str(bool(watermark)).lower()]\n    61→    if seed is not None and seed != -1:\n    62→        try:\n    63→            parts += [\"--seed\", str(int(seed))]\n    64→        except Exception:\n    65→            # 种子解析异常时忽略，不触发全局fallback\n    66→            logger.warning(\"种子参数无效，已忽略 --seed\")\n    67→    parts += [\"--cf\", str(bool(camera_fixed)).lower()]\n    68→\n    69→    flags_text = \" \".join(parts)\n    70→    fallback_reason = \", \".join(fallback_reasons) if fallback_applied else \"\"\n    71→    return flags_text, fallback_applied, fallback_reason, used_rs, used_rt\n    72→\n    73→\n    74→class SeedanceClient:\n    75→    \"\"\"火山引擎Seedance视频生成客户端\n    76→\n    77→    提供文生视频、图生视频和首尾帧视频生成功能\n    78→    \"\"\"\n    79→\n    80→    def __init__(\n    81→        self,\n    82→        api_key: Optional[str] = None,\n    83→        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n    84→        timeout: int = 60,\n    85→        max_retries: int = 3,\n    86→    ):\n    87→        \"\"\"初始化Seedance客户端\n    88→\n    89→        Args:\n    90→            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n    91→            base_url: API基础URL\n    92→            timeout: 请求超时时间（秒）\n    93→            max_retries: 最大重试次数\n    94→        \"\"\"\n    95→        # 获取API密钥\n    96→        if api_key is None:\n    97→            try:\n    98→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    99→            except Exception as exc:\n   100→                raise AppError(str(exc), ErrorHandler.ErrorType.AUTH_ERROR) from exc\n   101→\n   102→        self.api_key = api_key\n   103→        self.base_url = base_url.rstrip(\"/\")\n   104→        self.timeout = timeout\n   105→        self.max_retries = max_retries\n   106→        self.retry_delay = 2\n   107→        self.config = SeedanceConfig()\n   108→        self._active_tasks = set()  # 跟踪活跃任务\n   109→\n   110→        # 配置会话\n   111→        self.session = requests.Session()\n   112→        \n   113→        # 配置SSL和连接参数\n   114→        import ssl\n   115→        from requests.adapters import HTTPAdapter\n   116→        from urllib3.util.retry import Retry\n   117→        from urllib3.util.ssl_ import create_urllib3_context\n   118→        \n   119→        # 创建自定义SSL上下文\n   120→        ssl_context = create_urllib3_context()\n   121→        ssl_context.check_hostname = False\n   122→        ssl_context.verify_mode = ssl.CERT_NONE\n   123→        ssl_context.set_ciphers('DEFAULT@SECLEVEL=1')\n   124→        \n   125→        # 配置更强的重试策略\n   126→        retry_strategy = Retry(\n   127→            total=max_retries * 2,  # 增加重试次数\n   128→            status_forcelist=[429, 500, 502, 503, 504],\n   129→            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n   130→            backoff_factor=2,  # 增加退避因子\n   131→            raise_on_status=False\n   132→        )\n   133→        \n   134→        # 创建自定义适配器\n   135→        class SSLAdapter(HTTPAdapter):\n   136→            def init_poolmanager(self, *args, **kwargs):\n   137→                kwargs['ssl_context'] = ssl_context\n   138→                kwargs['socket_options'] = [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]\n   139→                return super().init_poolmanager(*args, **kwargs)\n   140→        \n   141→        import socket\n   142→        adapter = SSLAdapter(\n   143→            max_retries=retry_strategy,\n   144→            pool_connections=10,\n   145→            pool_maxsize=20,\n   146→            pool_block=False\n   147→        )\n   148→        \n   149→        self.session.mount(\"http://\", adapter)\n   150→        self.session.mount(\"https://\", adapter)\n   151→\n   152→        # 设置会话级别的超时和连接参数\n   153→        self.session.timeout = (30, 120)  # (连接超时, 读取超时)\n   154→        self.session.verify = False  # 直接禁用SSL验证，避免证书问题\n   155→\n   156→        # 禁用SSL警告\n   157→        import urllib3\n   158→        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   159→\n   160→        self.session.headers.update({\n   161→            'Connection': 'keep-alive',\n   162→            'Keep-Alive': 'timeout=30, max=100'\n   163→        })\n   164→\n   165→        # 初始化性能监控\n   166→        self._performance_stats = {\n   167→            \"total_requests\": 0,\n   168→            \"successful_requests\": 0,\n   169→            \"failed_requests\": 0,\n   170→            \"total_response_time\": 0,\n   171→            \"last_request_time\": None\n   172→        }\n   173→        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n   174→        \n   175→        logger.info(\"Seedance客户端初始化完成\")\n   176→        logger.info(f\"使用配置: 基础URL={self.base_url}, 超时={timeout}秒, 最大重试={max_retries}次\")\n   177→\n   178→    def _provider_enabled(self) -> bool:\n   179→        try:\n   180→            import os\n   181→            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n   182→            return v not in {\"0\", \"false\", \"no\"}\n   183→        except Exception:\n   184→            return True\n   185→\n   186→    def _get_headers(self) -> Dict[str, str]:\n   187→        \"\"\"获取请求头\"\"\"\n   188→        api_key = str(self.api_key).strip()\n   189→\n   190→        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n   191→        try:\n   192→            api_key.encode('ascii')\n   193→        except UnicodeEncodeError:\n   194→            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n   195→\n   196→        return {\n   197→            \"Authorization\": f\"Bearer {api_key}\",\n   198→            \"Content-Type\": \"application/json; charset=utf-8\",\n   199→            \"User-Agent\": \"Seedance-Client/1.0.0\",\n   200→        }\n   201→\n   202→    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout=60):\n   203→        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n   204→        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   205→        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n   206→\n   207→    def _handle_response(self, response: requests.Response, operation: str = \"API调用\") -> Dict[str, Any]:\n   208→        \"\"\"处理API响应\n   209→\n   210→        Args:\n   211→            response: HTTP响应对象\n   212→            operation: 操作描述，用于日志记录\n   213→\n   214→        Returns:\n   215→            解析后的响应数据\n   216→\n   217→        Raises:\n   218→            Exception: 当API返回错误时\n   219→        \"\"\"\n   220→        try:\n   221→            # 记录响应基本信息\n   222→            logger.info(f\"{operation} - 响应状态码: {response.status_code}\")\n   223→            \n   224→            # 处理HTTP错误状态码\n   225→            if not response.ok:\n   226→                error_details = {\n   227→                    \"status_code\": response.status_code,\n   228→                    \"url\": response.url,\n   229→                    \"headers\": dict(response.headers),\n   230→                    \"operation\": operation\n   231→                }\n   232→                \n   233→                try:\n   234→                    error_body = response.json()\n   235→                    error_details[\"response_body\"] = error_body\n   236→                except Exception:\n   237→                    try:\n   238→                        error_details[\"response_text\"] = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   239→                    except Exception:\n   240→                        error_details[\"response_text\"] = str(response.content[:500])\n   241→                \n   242→                # 根据状态码分类错误\n   243→                if response.status_code == 400:\n   244→                    logger.error(f\"{operation} - 请求参数错误: {error_details}\")\n   245→                    try:\n   246→                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   247→                    except Exception:\n   248→                        preview = str(response.content[:500])\n   249→                    raise Exception(f\"请求参数错误: {preview}\")\n   250→                elif response.status_code == 401:\n   251→                    logger.error(f\"{operation} - 认证失败: API密钥无效\")\n   252→                    raise Exception(\"认证失败: 请检查API密钥是否正确\")\n   253→                elif response.status_code == 403:\n   254→                    logger.error(f\"{operation} - 权限不足: {error_details}\")\n   255→                    raise Exception(\"权限不足: 请检查API密钥权限\")\n   256→                elif response.status_code == 404:\n   257→                    logger.error(f\"{operation} - 资源不存在: {error_details}\")\n   258→                    raise Exception(\"资源不存在: 请检查API端点或任务ID\")\n   259→                elif response.status_code == 429:\n   260→                    logger.error(f\"{operation} - 请求频率限制: {error_details}\")\n   261→                    raise Exception(\"请求频率过高: 请稍后重试\")\n   262→                elif response.status_code >= 500:\n   263→                    logger.error(f\"{operation} - 服务器错误: {error_details}\")\n   264→                    raise Exception(f\"服务器错误: {response.status_code}\")\n   265→                else:\n   266→                    logger.error(f\"{operation} - HTTP错误: {error_details}\")\n   267→                    try:\n   268→                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   269→                    except Exception:\n   270→                        preview = str(response.content[:500])\n   271→                    raise Exception(f\"HTTP错误: {response.status_code} - {preview}\")\n   272→\n   273→            # 解析JSON响应（增强容错：包括编码问题回退）\n   274→            try:\n   275→                result = response.json()\n   276→            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n   277→                raw = response.content or b\"\"\n   278→                tried = set()\n   279→                result = None\n   280→                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n   281→                    if not enc or enc in tried:\n   282→                        continue\n   283→                    tried.add(enc)\n   284→                    try:\n   285→                        text = raw.decode(enc, errors=\"strict\")\n   286→                        result = json.loads(text)\n   287→                        logger.debug(f\"{operation} - 通过备用编码解析成功: {enc}\")\n   288→                        break\n   289→                    except Exception:\n   290→                        continue\n   291→                if result is None:\n   292→                    # 最后尝试宽松日志预览，抛出统一错误\n   293→                    try:\n   294→                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n   295→                    except Exception:\n   296→                        preview = str(raw[:200])\n   297→                    logger.error(f\"{operation} - JSON解析失败(编码问题): {preview}\")\n   298→                    raise Exception(f\"响���格式错误: 无法解析JSON - {str(e)}\")\n   299→\n   300→            # 检查业务错误\n   301→            if \"error\" in result:\n   302→                error_info = result[\"error\"]\n   303→                error_msg = error_info.get(\"message\", \"未知错误\")\n   304→                error_code = error_info.get(\"code\", \"UNKNOWN_ERROR\")\n   305→                \n   306→                logger.error(f\"{operation} - API业务错误: {error_msg} (代码: {error_code})\")\n   307→                logger.error(f\"完整错误信息: {result}\")\n   308→                \n   309→                # 根据错误代码提供更友好的错误信息\n   310→                friendly_msg = self._get_friendly_error_message(error_code, error_msg)\n   311→                raise Exception(f\"API业务错误: {friendly_msg}\")\n   312→\n   313→            # 记录成功响应的关键信息\n   314→            if \"id\" in result:\n   315→                logger.info(f\"{operation} - 成功，任务ID: {result['id']}\")\n   316→            elif \"status\" in result:\n   317→                logger.info(f\"{operation} - 成功，状态: {result['status']}\")\n   318→            else:\n   319→                logger.info(f\"{operation} - 成功\")\n   320→\n   321→            return result\n   322→\n   323→        except requests.exceptions.Timeout as e:\n   324→            logger.error(f\"{operation} - 请求超时: {str(e)}\")\n   325→            raise Exception(f\"请求超时: 请检查网络连接或稍后重试\")\n   326→        except requests.exceptions.ConnectionError as e:\n   327→            logger.error(f\"{operation} - 连接错误: {str(e)}\")\n   328→            raise Exception(f\"网络连接错误: 请检查网络连接\")\n   329→        except requests.exceptions.RequestException as e:\n   330→            logger.error(f\"{operation} - 网络请求错误: {str(e)}\")\n   331→            raise Exception(f\"网络请求失败: {str(e)}\")\n   332→        except Exception as e:\n   333→            if \"API业务错误\" in str(e) or \"请求参数错误\" in str(e) or \"认证失败\" in str(e):\n   334→                # 重新抛出已处理的业务错误\n   335→                raise\n   336→            else:\n   337→                logger.error(f\"{operation} - 未知错误: {str(e)}\")\n   338→                raise Exception(f\"处理响应时发生未知错误: {str(e)}\")\n   339→    \n   340→    def _get_friendly_error_message(self, error_code: str, error_msg: str) -> str:\n   341→        \"\"\"获取友好的错误信息\n   342→        \n   343→        Args:\n   344→            error_code: 错误代码\n   345→            error_msg: 原始错误信息\n   346→            \n   347→        Returns:\n   348→            友好的错误信息\n   349→        \"\"\"\n   350→        error_mapping = {\n   351→            \"INVALID_PARAMETER\": \"参数无效，请检查输入参数\",\n   352→            \"INSUFFICIENT_QUOTA\": \"配额不足，请检查账户余额\",\n   353→            \"MODEL_NOT_FOUND\": \"模型不存在，请检查模型名称\",\n   354→            \"TASK_NOT_FOUND\": \"任务不存在，请检查任务ID\",\n   355→            \"TASK_ALREADY_CANCELLED\": \"任务已被取消\",\n   356→            \"TASK_ALREADY_COMPLETED\": \"任务已完成，无法取消\",\n   357→            \"RATE_LIMIT_EXCEEDED\": \"请求频率过高，请稍后重试\",\n   358→            \"INTERNAL_ERROR\": \"服务内部错误，请稍后重试\",\n   359→            \"UNAUTHORIZED\": \"未授权访问，请检查API密钥\",\n   360→            \"FORBIDDEN\": \"禁止访问，请检查权限设置\"\n   361→        }\n   362→        \n   363→        return error_mapping.get(error_code, f\"{error_msg} (错误代码: {error_code})\")\n   364→    \n   365→    def _record_request_stats(\n   366→        self,\n   367→        operation: str,\n   368→        success: bool,\n   369→        response_time: float,\n   370→        error_code: Optional[str] = None,\n   371→        error_message: Optional[str] = None,\n   372→    ):\n   373→        \"\"\"记录请求统计信息（统一结构 + 最近错误）。\"\"\"\n   374→        try:\n   375→            self._performance_stats[\"total_requests\"] += 1\n   376→            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n   377→            self._performance_stats[\"last_request_time\"] = time.time()\n   378→            \n   379→            if success:\n   380→                self._performance_stats[\"successful_requests\"] += 1\n   381→            else:\n   382→                self._performance_stats[\"failed_requests\"] += 1\n   383→                if error_code or error_message:\n   384→                    self._last_error = {\"code\": error_code, \"message\": (str(error_message)[:200] if error_message else None)}\n   385→            \n   386→            # 记录性能日志（安全摘要）\n   387→            total = max(1, self._performance_stats[\"total_requests\"])\n   388→            avg = self._performance_stats[\"total_response_time\"] / total\n   389→            success_rate = (self._performance_stats[\"successful_requests\"] / total) * 100\n   390→            logger.debug(f\"{operation} - 响应时间: {response_time:.2f}s, 平均: {avg:.2f}s, 成功率: {success_rate:.1f}%\")\n   391→        except Exception:\n   392→            pass\n   393→    \n   394→    def get_performance_stats(self) -> Dict[str, Any]:\n   395→        \"\"\"获取性能统计信息（统一字段命名）。\"\"\"\n   396→        stats = dict(self._performance_stats)\n   397→        total = stats.get(\"total_requests\", 0) or 0\n   398→        if total > 0:\n   399→            avg = stats.get(\"total_response_time\", 0.0) / total\n   400→            suc_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n   401→        else:\n   402→            avg = 0.0\n   403→            suc_rate = 0.0\n   404→        return {\n   405→            \"total_requests\": total,\n   406→            \"successful_requests\": stats.get(\"successful_requests\", 0),\n   407→            \"failed_requests\": stats.get(\"failed_requests\", 0),\n   408→            \"avg_response_time\": avg,\n   409→            \"success_rate\": suc_rate,\n   410→            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n   411→        }\n   412→\n   413→    def dump_metrics(self) -> Dict[str, Any]:\n   414→        \"\"\"导出统一指标，便于诊断脚本读取。\"\"\"\n   415→        m = self.get_performance_stats()\n   416→        m.update({\n   417→            \"client\": \"Seedance\",\n   418→            \"base_url\": self.base_url,\n   419→        })\n   420→        return m\n   421→\n   422→    def create_video_task(\n   423→        self,\n   424→        prompt: str,\n   425→        image_path: Optional[str] = None,\n   426→        first_frame_path: Optional[str] = None,\n   427→        last_frame_path: Optional[str] = None,\n   428→        duration: int = 8,\n   429→        fps: int = 24,\n   430→        width: Optional[int] = None,\n   431→        height: Optional[int] = None,\n   432→        seed: Optional[int] = None,\n   433→        use_pro_model: bool = True,\n   434→        camera_fixed: bool = True,\n   435→        resolution_grade: Optional[str] = None,\n   436→        ratio: Optional[str] = None,\n   437→        watermark: bool = False,\n   438→        reference_images: Optional[List[str]] = None,\n   439→    ) -> Dict[str, Any]:\n   440→        \"\"\"\n   441→        创建视频生成任务（新路径：分辨率档位 + 比例）\n   442→\n   443→        Args:\n   444→            prompt: 视频描述提示词\n   445→            image_path: 输入图片路径（图生视频）\n   446→            first_frame_path: 首帧图片路径（首尾帧模式）\n   447→            last_frame_path: 尾帧图片路径（首尾帧模式）\n   448→            duration: 视频时长（秒），默认8秒\n   449→            fps: 帧率，默认24fps\n   450→            width/height: 旧路径兼容（关闭灰度时使用）\n   451→            seed: 随机种子\n   452→            use_pro_model: 是否使用Pro模型\n   453→            camera_fixed: 是否固定摄像头视角\n   454→            resolution_grade: 分辨率档位\n   455→            ratio: 画面比例\n   456→            watermark: 是否添加水印\n   457→            reference_images: 额外参考图（base64/url），Seedream 4.0 视频扩展预留\n   458→\n   459→        Returns:\n   460→            包含任务ID的响应结果\n   461→        \"\"\"\n   462→        url = f\"{self.base_url}/contents/generations/tasks\"\n   463→\n   464→        # 通过 Provider Schema 映射（默认启用；关闭时回退旧逻辑）\n   465→        data = None\n   466→        mode = \"\"\n   467→        fallback_applied = False\n   468→        fallback_reason = \"\"\n   469→        used_rs = \"\"\n   470→        used_rt = \"\"\n   471→        if self._provider_enabled():\n   472→            try:\n   473→                # 预编码图片为 data URL（与旧实现一致），再交由 Provider 组装 content\n   474→                enc_first = self._encode_image(first_frame_path) if first_frame_path else None\n   475→                enc_last = self._encode_image(last_frame_path) if last_frame_path else None\n   476→                enc_img = self._encode_image(image_path) if image_path else None\n   477→\n   478→                from modules.provider.factory import get_default_provider\n   479→                from modules.provider.schema import VideoParams\n   480→                provider = get_default_provider()\n   481→                mapped, fb, reason, used_rs, used_rt = provider.map_video(VideoParams(\n   482→                    prompt=prompt,\n   483→                    image_path=enc_img,\n   484→                    first_frame_path=enc_first,\n   485→                    last_frame_path=enc_last,\n   486→                    duration=int(duration),\n   487→                    fps=int(fps),\n   488→                    seed=(None if (seed is None or seed == -1) else seed),\n   489→                    camera_fixed=bool(camera_fixed),\n   490→                    watermark=False,\n   491→                    resolution_grade=resolution_grade,\n   492→                    ratio=ratio,\n   493→                    use_pro_model=bool(use_pro_model),\n   494→                    reference_images=(reference_images or []),\n   495→                ))\n   496→                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\n   497→                mode = mapped.get(\"mode\", \"视频\")\n   498→                model = data[\"model\"]\n   499→                fallback_applied, fallback_reason = fb, reason\n   500→                if fb:\n   501→                    logger.warning(f\"参数回退: {reason}\")\n   502→                logger.info(f\"安全版参数: {mapped.get('flags_text', '')}\")\n   503→            except Exception as _e:\n   504→                logger.warning(f\"Provider 映射失败，回退旧路径: {_e}\")\n   505→\n   506→        if data is None:\n   507→            # 旧内容组装路径（保持不变）\n   508→            content: List[Dict[str, Any]] = []\n   509→            # 模型选择\n   510→            if first_frame_path and last_frame_path:\n   511→                model = SeedanceModels.LITE_I2V.value\n   512→                mode = \"首尾帧视频(Lite)\"\n   513→                if use_pro_model:\n   514→                    logger.warning(\"Pro模型不支持首尾帧模式，自动切换到Lite I2V模型\")\n   515→            elif use_pro_model:\n   516→                model = SeedanceModels.PRO.value\n   517→                mode = \"图生视频(Pro)\" if image_path else \"文生视频(Pro)\"\n   518→            else:\n   519→                if image_path:\n   520→                    model = SeedanceModels.LITE_I2V.value\n   521→                    mode = \"图生视频(Lite)\"\n   522→                else:\n   523→                    model = SeedanceModels.LITE_T2V.value\n   524→                    mode = \"文生视频(Lite)\"\n   525→\n   526→            if first_frame_path and last_frame_path:\n   527→                content.append({\n   528→                    \"type\": \"image_url\",\n   529→                    \"image_url\": {\"url\": self._encode_image(first_frame_path)},\n   530→                    \"role\": \"first_frame\"\n   531→                })\n   532→                content.append({\n   533→                    \"type\": \"image_url\",\n   534→                    \"image_url\": {\"url\": self._encode_image(last_frame_path)},\n   535→                    \"role\": \"last_frame\"\n   536→                })\n   537→            elif image_path:\n   538→                content.append({\n   539→                    \"type\": \"image_url\",\n   540→                    \"image_url\": {\"url\": self._encode_image(image_path)},\n   541→                    \"role\": \"first_frame\"\n   542→                })\n   543→            if reference_images:\n   544→                logger.warning(\"Seedance 旧路径暂不支持多参考图，已忽略 reference_images\")\n   545→\n   546→            # 文本命令\n   547→            # Force server-side watermark off for Plan B (local watermark only)\n   548→            flags_text, fallback_applied, fallback_reason, used_rs, used_rt = _validate_and_build_flags(\n   549→                resolution_grade=resolution_grade,\n   550→                ratio=ratio,\n   551→                duration=duration,\n   552→                fps=fps,\n   553→                watermark=False,\n   554→                camera_fixed=camera_fixed,\n   555→                seed=seed,\n   556→            )\n   557→            text_prompt = f\"{prompt} {flags_text}\".strip()\n   558→            if fallback_applied:\n   559→                logger.warning(f\"参数回退: {fallback_reason}\")\n   560→            logger.info(f\"安全版参数: {flags_text}\")\n   561→            content.append({\"type\": \"text\", \"text\": text_prompt})\n   562→            data = {\"model\": model, \"content\": content}\n   563→        headers = self._get_headers()\n   564→        logger.info(f\"创建{mode}任务: {prompt[:50]}...\")\n   565→        logger.info(f\"使用模型: {model}\")\n   566→        logger.info(f\"参数: {used_rs or resolution_grade}+{used_rt or ratio}, dur={duration}s, fps={fps}\")\n   567→\n   568→        start_time = time.time()\n   569→        success = False\n   570→        err_code: Optional[str] = None\n   571→        err_msg: Optional[str] = None\n   572→        try:\n   573→            logger.info(f\"发送请求到: {url}\")\n   574→            # 安全日志对象，避免 content 结构异常导致索引错误\n   575→            text_items = [item for item in data.get(\"content\", []) if item.get(\"type\") == \"text\"]\n   576→            text_len = 0\n   577→            if text_items:\n   578→                try:\n   579→                    text_len = len(text_items[0].get(\"text\", \"\"))\n   580→                except Exception:\n   581→                    text_len = 0\n   582→            safe_data = {\n   583→                \"model\": data.get(\"model\"),\n   584→                \"content_types\": [item.get(\"type\") for item in data.get(\"content\", [])],\n   585→                \"text_prompt_length\": text_len,\n   586→                \"image_count\": len([item for item in data.get(\"content\", []) if item.get(\"type\") == \"image_url\"]) \n   587→            }\n   588→            logger.info(f\"请求参数: {json.dumps(safe_data, indent=2, ensure_ascii=False)}\")\n   589→\n   590→            response = self._safe_json_post(url, headers, data, timeout=60)\n   591→            response_time = time.time() - start_time\n   592→            logger.info(f\"响应状态码: {response.status_code}, 响应时间: {response_time:.2f}s\")\n   593→\n   594→            result = self._handle_response(response, \"创建视频任务\")\n   595→            success = True\n   596→            task_id = result.get(\"id\")\n   597→            if task_id:\n   598→                self._active_tasks.add(task_id)\n   599→                logger.info(f\"{mode}任务创建成功，任务ID: {task_id}\")\n   600→                result_obj = {\n   601→                    \"success\": True,\n   602→                    \"task_id\": task_id,\n   603→                    \"status\": result.get(\"status\", \"processing\"),\n   604→                    \"model\": model,\n   605→                    \"mode\": mode,\n   606→                    \"estimated_cost\": self._calculate_cost(model, duration),\n   607→                    \"created_at\": time.time(),\n   608→                    \"fallback_applied\": fallback_applied,\n   609→                    \"fallback_reason\": fallback_reason,\n   610→                    \"used_rs\": used_rs,\n   611→                    \"used_rt\": used_rt,\n   612→                }\n   613→                # 安全摘要日志\n   614→                logger.info(\n   615→                    f\"摘要|operation=create_task status=success elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id}\"\n   616→                )\n   617→                return result_obj\n   618→            else:\n   619→                logger.error(f\"{mode}任务创建失败，未获取到任务ID\")\n   620→                return {\"success\": False, \"error\": \"未获取到任务ID\", \"response\": result}\n   621→\n   622→        except requests.exceptions.SSLError as e:\n   623→            logger.error(f\"{mode}任务创建失败 - SSL错误: {str(e)}\")\n   624→            logger.info(\"尝试使用备用SSL配置重新连接...\")\n   625→            try:\n   626→                backup_session = requests.Session()\n   627→                backup_session.verify = False\n   628→                import urllib3\n   629→                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   630→                # 手动编码避免 PyInstaller latin-1 问题\n   631→                body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   632→                response = backup_session.post(url, headers=headers, data=body, timeout=(30, 120))\n   633→                result = self._handle_response(response, \"创建视频任务(备用连接)\")\n   634→                success = True\n   635→                task_id = result.get(\"id\")\n   636→                if task_id:\n   637→                    self._active_tasks.add(task_id)\n   638→                    logger.info(f\"{mode}任务创建成功(备用连接)，任务ID: {task_id}\")\n   639→                    result_obj = {\n   640→                        \"success\": True,\n   641→                        \"task_id\": task_id,\n   642→                        \"status\": result.get(\"status\", \"processing\"),\n   643→                        \"model\": model,\n   644→                        \"mode\": mode,\n   645→                        \"estimated_cost\": self._calculate_cost(model, duration),\n   646→                        \"created_at\": time.time(),\n   647→                        \"fallback_applied\": fallback_applied,\n   648→                        \"fallback_reason\": fallback_reason,\n   649→                        \"used_rs\": used_rs,\n   650→                        \"used_rt\": used_rt,\n   651→                    }\n   652→                    logger.info(\n   653→                        f\"摘要|operation=create_task status=success elapsed={time.time() - start_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id} (backup)\"\n   654→                    )\n   655→                    return result_obj\n   656→                else:\n   657→                    raise Exception(\"备用连接也未获取到任务ID\")\n   658→            except Exception as backup_e:\n   659→                logger.error(f\"备用连接也失败: {str(backup_e)}\")\n   660→                err_code, err_msg = \"SSL_ERROR\", f\"SSL连接失败: {str(e)}; 备用: {str(backup_e)}\"\n   661→                raise Exception(f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}\")\n   662→        except requests.exceptions.ConnectionError as e:\n   663→            logger.error(f\"{mode}任务创建失败 - 连接错误: {str(e)}\")\n   664→            err_code, err_msg = \"NETWORK_ERROR\", str(e)\n   665→            raise Exception(f\"网络连接失败，请检查网络连接: {str(e)}\")\n   666→        except requests.exceptions.Timeout as e:\n   667→            logger.error(f\"{mode}任务创建失败 - 超时: {str(e)}\")\n   668→            err_code, err_msg = \"TIMEOUT_ERROR\", str(e)\n   669→            raise Exception(f\"请求超时，请稍后重试: {str(e)}\")\n   670→        except Exception as e:\n   671→            logger.error(f\"{mode}任务创建失败: {str(e)}\")\n   672→            err_code, err_msg = \"UNKNOWN_ERROR\", str(e)\n   673→            raise Exception(f\"视频生成任务创建失败: {str(e)}\")\n   674→        finally:\n   675→            response_time = time.time() - start_time\n   676→            # 失败时记录摘要\n   677→            if not success:\n   678→                logger.info(\n   679→                    f\"摘要|operation=create_task status=failed elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s error={err_code}\"\n   680→                )\n   681→            self._record_request_stats(\"创建视频任务\", success, response_time, err_code, err_msg)\n   682→\n   683→    \n   684→    def _calculate_cost(self, model: str, duration: int) -> float:\n   685→        \"\"\"计算预估成本\"\"\"\n   686→        base_cost = self.config.MODEL_PRICING.get(model, 15)\n   687→        # 简单的成本估算：基础价格 * 时长系数\n   688→        return base_cost * (duration / 5.0)  # 以5秒为基准\n   689→\n   690→    def query_video_task(self, task_id: str) -> Dict[str, Any]:\n   691→        \"\"\"查询视频生成任务状态\n   692→\n   693→        Args:\n   694→            task_id: 任务ID\n   695→\n   696→        Returns:\n   697→            任务状态信息\n   698→\n   699→        Raises:\n   700→            AppError: 当API调用失败时\n   701→        \"\"\"\n   702→        # 使用正确的查询API端点\n   703→        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n   704→        headers = self._get_headers()\n   705→\n   706→        logger.info(f\"查询视频任务状态: {task_id}\")\n   707→\n   708→        try:\n   709→            try:\n   710→                response = self.session.get(url, headers=headers, timeout=30)\n   711→            except requests.exceptions.SSLError as e:\n   712→                logger.error(f\"查询视频任务状态失败 - SSL错误: {str(e)}\")\n   713→                logger.info(\"尝试使用备用SSL配置重新查询任务状态...\")\n   714→                try:\n   715→                    backup_session = requests.Session()\n   716→                    backup_session.verify = False\n   717→                    import urllib3\n   718→                    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   719→                    response = backup_session.get(url, headers=headers, timeout=30)\n   720→                except Exception as backup_e:\n   721→                    logger.error(f\"备用SSL配置查询失败: {str(backup_e)}\")\n   722→                    raise Exception(\n   723→                        f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}; 备用: {str(backup_e)}\"\n   724→                    ) from e\n   725→\n   726→            result = self._handle_response(response, \"查询视频任务\")\n   727→\n   728→            # 根据官方API返回格式解析状态\n   729→            status = result.get(\"status\", \"unknown\")\n   730→            video_url = result.get(\"content\", {}).get(\"video_url\")\n   731→            \n   732→            logger.info(f\"任务 {task_id} 状态: {status}\")\n   733→            \n   734→            if status == \"succeeded\" and video_url:\n   735→                logger.info(f\"视频生成完成: {video_url}\")\n   736→\n   737→            # 获取缩略图URL\n   738→            thumbnail_url = result.get(\"content\", {}).get(\"thumbnail_url\") or result.get(\"thumbnail_url\")\n   739→            preview_url = result.get(\"content\", {}).get(\"preview_url\") or result.get(\"preview_url\")\n   740→            \n   741→            result_obj = {\n   742→                \"success\": True,\n   743→                \"task_id\": task_id,\n   744→                \"status\": status,\n   745→                \"video_url\": video_url,\n   746→                \"thumbnail_url\": thumbnail_url,\n   747→                \"preview_url\": preview_url,\n   748→                \"model\": result.get(\"model\"),\n   749→                \"resolution\": result.get(\"resolution\"),\n   750→                \"duration\": result.get(\"duration\"),\n   751→                \"fps\": result.get(\"framespersecond\"),\n   752→                \"usage\": result.get(\"usage\"),\n   753→                \"created_at\": result.get(\"created_at\"),\n   754→                \"updated_at\": result.get(\"updated_at\")\n   755→            }\n   756→            # 安全摘要日志\n   757→            logger.info(\n   758→                f\"摘要|operation=query_task status={status} task_id={task_id} video_ready={'yes' if bool(video_url) else 'no'}\"\n   759→            )\n   760→            return result_obj\n   761→\n   762→        except Exception as e:\n   763→            logger.error(f\"查询视频任务状态失败: {str(e)}\")\n   764→            raise Exception(f\"查询任务状态失败: {str(e)}\")\n   765→\n   766→    def get_task_status(self, task_id: str) -> Dict[str, Any]:\n   767→        \"\"\"\n   768→        查询任务状态（兼容旧接口）\n   769→\n   770→        Args:\n   771→            task_id: 任务ID\n   772→\n   773→        Returns:\n   774→            Dict: 任务状态信息\n   775→        \"\"\"\n   776→        return self.query_video_task(task_id)\n   777→\n   778→    def wait_for_completion(self, task_id: str, max_wait_time: Optional[int] = None) -> Dict[str, Any]:\n   779→        \"\"\"\n   780→        等待任务完成（智能轮询）\n   781→\n   782→        Args:\n   783→            task_id: 任务ID\n   784→            max_wait_time: 最大等待时间（秒），默认使用配置值\n   785→\n   786→        Returns:\n   787→            Dict: 最终任务结果\n   788→        \"\"\"\n   789→        max_wait_time = max_wait_time or self.config.POLLING[\"max_wait_time\"]\n   790→        intervals = self.config.POLLING[\"intervals\"]\n   791→        \n   792→        logger.info(f\"开始智能轮询任务: {task_id}\")\n   793→        \n   794→        start_time = time.time()\n   795→        attempt = 0\n   796→\n   797→        while time.time() - start_time < max_wait_time:\n   798→            try:\n   799→                # 查询任务状态\n   800→                status_result = self.get_task_status(task_id)\n   801→\n   802→                if not status_result[\"success\"]:\n   803→                    return status_result\n   804→\n   805→                status = status_result[\"status\"]\n   806→                progress = status_result.get(\"progress\", 0)\n   807→\n   808→                logger.info(f\"任务 {task_id} 状态: {status}, 进度: {progress}%\")\n   809→\n   810→                # 检查是否为终态\n   811→                if TaskStatus.is_terminal(status):\n   812→                    if status == TaskStatus.SUCCEEDED.value:\n   813→                        logger.success(f\"任务完成: {task_id}\")\n   814→                    elif status == TaskStatus.FAILED.value:\n   815→                        logger.error(f\"任务失败: {task_id}\")\n   816→                    elif status == TaskStatus.CANCELLED.value:\n   817→                        logger.warning(f\"任务被取消: {task_id}\")\n   818→                    \n   819→                    # 从活跃任务中移除\n   820→                    self._active_tasks.discard(task_id)\n   821→                    return status_result\n   822→\n   823→                # 动态调整轮询间隔\n   824→                interval = intervals[min(attempt, len(intervals) - 1)]\n   825→                logger.debug(f\"等待 {interval} 秒后继续轮询\")\n   826→                time.sleep(interval)\n   827→                attempt += 1\n   828→                \n   829→            except Exception as e:\n   830→                logger.error(f\"轮询异常: {e}\")\n   831→                time.sleep(5)  # 异常时等待5秒\n   832→\n   833→        # 超时处理\n   834→        logger.error(f\"轮询超时: {task_id}\")\n   835→        self._active_tasks.discard(task_id)\n   836→        return {\n   837→            \"success\": False, \n   838→            \"error\": \"等待任务完成超时\", \n   839→            \"error_code\": \"TIMEOUT_ERROR\", \n   840→            \"task_id\": task_id,\n   841→            \"elapsed_time\": time.time() - start_time\n   842→        }\n   843→\n   844→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n   845→        \"\"\"\n   846→        取消视频生成任务（仅在queued状态有效）\n   847→\n   848→        Args:\n   849→            task_id: 任务ID\n   850→\n   851→        Returns:\n   852→            成功: {\"success\": True, \"status\": \"cancelled\"}\n   853→            失败: {\"success\": False, \"error\": \"错误信息\"}\n   854→        \"\"\"\n   855→        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n   856→        headers = {\n   857→            \"Content-Type\": \"application/json\",\n   858→            \"Authorization\": f\"Bearer {self.api_key}\"\n   859→        }\n   860→\n   861→        try:\n   862→            response = requests.delete(url, headers=headers, timeout=10)\n   863→\n   864→            if response.status_code == 200:\n   865→                # DELETE请求成功，等待0.5秒后查询实际状态\n   866→                time.sleep(0.5)\n   867→\n   868→                # 查询任务状态以确认是否真的变成cancelled\n   869→                try:\n   870→                    status_result = self.query_video_task(task_id)\n   871→                    current_status = status_result.get(\"status\", \"unknown\")\n   872→\n   873→                    if current_status == \"cancelled\":\n   874→                        # 真正成功取消\n   875→                        self._active_tasks.discard(task_id)\n   876→                        logger.info(f\"任务已成功取消: {task_id}，状态已变更为 cancelled\")\n   877→                        return {\"success\": True, \"status\": \"cancelled\"}\n   878→                    else:\n   879→                        # DELETE成功但状态不是cancelled（任务可能已在执行中）\n   880→                        logger.warning(f\"DELETE请求成功，但任务状态为 {current_status}（任务可能已在执行中，无法取消）\")\n   881→                        return {\"success\": False, \"status\": current_status, \"error\": f\"任务状态为 {current_status}，无法取消\"}\n   882→                except Exception as query_e:\n   883→                    # 状态查询失败，但DELETE请求成功\n   884→                    logger.warning(f\"DELETE请求成功，但状态查询失败: {query_e}\")\n   885→                    self._active_tasks.discard(task_id)\n   886→                    return {\"success\": True, \"status\": \"cancelled\", \"warning\": \"状态确认失败\"}\n   887→\n   888→            if response.status_code == 400:\n   889→                error_msg = response.json().get(\"error\", {}).get(\"message\", \"任务无法取消（可能已在执行中）\")\n   890→                logger.warning(f\"取消任务失败: {task_id} - {error_msg}\")\n   891→                return {\"success\": False, \"error\": error_msg}\n   892→\n   893→            error_msg = f\"HTTP {response.status_code}: {response.text}\"\n   894→            logger.error(f\"取消任务请求失败: {error_msg}\")\n   895→            return {\"success\": False, \"error\": error_msg}\n   896→\n   897→        except Exception as e:  # pylint: disable=broad-except\n   898→            logger.error(f\"取消任务异常: {task_id} - {e}\")\n   899→            return {\"success\": False, \"error\": str(e)}\n   900→\n   901→    def list_tasks(self, limit: int = 20, offset: int = 0, status_filter: Optional[str] = None) -> Dict[str, Any]:\n   902→        \"\"\"\n   903→        获取任务列表（改进版）\n   904→\n   905→        Args:\n   906→            limit: 返回数量限制\n   907→            offset: 偏移量\n   908→            status_filter: 状态过滤器\n   909→\n   910→        Returns:\n   911→            Dict: 任务列表\n   912→        \"\"\"\n   913→        url = f\"{self.base_url}{self.config.ENDPOINTS['list_tasks']}\"\n   914→        headers = self._get_headers()\n   915→        \n   916→        params = {\n   917→            \"limit\": limit,\n   918→            \"offset\": offset\n   919→        }\n   920→        \n   921→        if status_filter:\n   922→            params[\"status\"] = status_filter\n   923→        \n   924→        logger.info(f\"获取任务列表: limit={limit}, offset={offset}, status_filter={status_filter}\")\n   925→        \n   926→        # 记录开始时间\n   927→        start_time = time.time()\n   928→        success = False\n   929→\n   930→        try:\n   931→            response = self.session.get(url, headers=headers, params=params, timeout=30)\n   932→            result = self._handle_response(response, \"获取任务列表\")\n   933→            \n   934→            tasks = result.get(\"data\", [])\n   935→            total = result.get(\"total\", len(tasks))\n   936→            \n   937→            logger.success(f\"获取任务列表成功，共{len(tasks)}个任务\")\n   938→            success = True\n   939→            \n   940→            return {\n   941→                \"success\": True,\n   942→                \"tasks\": tasks,\n   943→                \"total\": total,\n   944→                \"limit\": limit,\n   945→                \"offset\": offset,\n   946→                \"has_more\": offset + len(tasks) < total\n   947→            }\n   948→            \n   949→        except Exception as e:\n   950→            logger.error(f\"获取任务列表失败: {e}\")\n   951→            return {\n   952→                 \"success\": False,\n   953→                 \"error\": str(e)\n   954→             }\n   955→        finally:\n   956→            # 记录性能统计\n   957→            response_time = time.time() - start_time\n   958→            self._record_request_stats(\"获取任务列表\", success, response_time)\n   959→    \n   960→    def batch_query_tasks(self, task_ids: List[str]) -> Dict[str, Any]:\n   961→        \"\"\"\n   962→        批量查询任务状态\n   963→        \n   964→        Args:\n   965→            task_ids: 任务ID列表\n   966→        \n   967→        Returns:\n   968→            批量查询结果\n   969→        \"\"\"\n   970→        results = {}\n   971→        success_count = 0\n   972→        \n   973→        logger.info(f\"批量查询{len(task_ids)}个任务\")\n   974→        \n   975→        for task_id in task_ids:\n   976→            try:\n   977→                result = self.query_video_task(task_id)\n   978→                if result.get(\"success\", True):  # 兼容不同的返回格式\n   979→                    success_count += 1\n   980→                results[task_id] = result\n   981→            except Exception as e:\n   982→                results[task_id] = {\n   983→                    \"success\": False,\n   984→                    \"error\": str(e)\n   985→                }\n   986→        \n   987→        return {\n   988→            \"success\": True,\n   989→            \"results\": results,\n   990→            \"total\": len(task_ids),\n   991→            \"success_count\": success_count,\n   992→            \"failed_count\": len(task_ids) - success_count\n   993→        }\n   994→    \n   995→    def cancel_all_active_tasks(self) -> Dict[str, Any]:\n   996→        \"\"\"\n   997→        取消所有活跃任务\n   998→        \n   999→        Returns:\n  1000→            取消结果统计\n  1001→        \"\"\"\n  1002→        active_tasks = list(self._active_tasks)\n  1003→        \n  1004→        if not active_tasks:\n  1005→            return {\n  1006→                \"success\": True,\n  1007→                \"message\": \"没有活跃任务需要取消\",\n  1008→                \"cancelled\": 0\n  1009→            }\n  1010→        \n  1011→        cancelled_count = 0\n  1012→        failed_count = 0\n  1013→        \n  1014→        logger.info(f\"取消{len(active_tasks)}个活跃任务\")\n  1015→        \n  1016→        for task_id in active_tasks:\n  1017→            result = self.cancel_task(task_id)\n  1018→            if result.get(\"success\"):\n  1019→                cancelled_count += 1\n  1020→            else:\n  1021→                failed_count += 1\n  1022→        \n  1023→        return {\n  1024→            \"success\": True,\n  1025→            \"cancelled\": cancelled_count,\n  1026→            \"failed\": failed_count,\n  1027→            \"total_active\": len(active_tasks)\n  1028→        }\n  1029→    \n  1030→    def get_task_statistics(self) -> Dict[str, Any]:\n  1031→        \"\"\"\n  1032→        获取任务统计信息\n  1033→        \n  1034→        Returns:\n  1035→            统计信息\n  1036→        \"\"\"\n  1037→        try:\n  1038→            # 获取最近的任务列表\n  1039→            tasks_result = self.list_tasks(limit=100)\n  1040→            \n  1041→            if not tasks_result.get(\"success\"):\n  1042→                return tasks_result\n  1043→            \n  1044→            tasks = tasks_result.get(\"tasks\", [])\n  1045→            \n  1046→            # 统计各状态任务数量\n  1047→            status_counts = {}\n  1048→            total_cost = 0\n  1049→            \n  1050→            for task in tasks:\n  1051→                status = task.get(\"status\", \"unknown\")\n  1052→                status_counts[status] = status_counts.get(status, 0) + 1\n  1053→                \n  1054→                # 估算成本\n  1055→                model = task.get(\"model\", \"\")\n  1056→                if model in self.config.MODEL_PRICING:\n  1057→                    total_cost += self.config.MODEL_PRICING[model]\n  1058→            \n  1059→            return {\n  1060→                \"success\": True,\n  1061→                \"total_tasks\": len(tasks),\n  1062→                \"active_tasks\": len(self._active_tasks),\n  1063→                \"status_counts\": status_counts,\n  1064→                \"estimated_total_cost\": total_cost,\n  1065→                \"timestamp\": time.time()\n  1066→            }\n  1067→            \n  1068→        except Exception as e:\n  1069→            logger.error(f\"获取统计信息失败: {e}\")\n  1070→            return {\n  1071→                \"success\": False,\n  1072→                \"error\": str(e)\n  1073→            }\n  1074→\n  1075→    def _prepare_image(self, image_path: str) -> str:\n  1076→        \"\"\"准备图片数据，返回data URL格式\"\"\"\n  1077→        try:\n  1078→            # 使用新的图片格式验证器\n  1079→            from utils.image_format_validator import validate_and_prepare_image\n  1080→            \n  1081→            result = validate_and_prepare_image(image_path, auto_convert=True)\n  1082→            \n  1083→            if result['success']:\n  1084→                if result['is_converted']:\n  1085→                    logger.info(f\"图片已自动转换: {result['original_format']} -> {result['final_format']}\")\n  1086→                return result['data_url']\n  1087→            else:\n  1088→                raise Exception(result['error'])\n  1089→                \n  1090→        except Exception as e:\n  1091→            logger.error(f\"图片处理失败: {str(e)}\")\n  1092→            raise Exception(f\"图片处理失败: {str(e)}\")\n  1093→\n  1094→    def _encode_image(self, image_path: str) -> str:\n  1095→        \"\"\"将图像文件编码为data URL格式\n  1096→        集成图片格式验证和自动转换功能\n  1097→        \n  1098→        Args:\n  1099→            image_path: 图像文件路径\n  1100→            \n  1101→        Returns:\n  1102→            data URL格式的图像字符串\n  1103→            \n  1104→        Raises:\n  1105→            AppError: 当图像文件不存在或编码失败时\n  1106→        \"\"\"\n  1107→        try:\n  1108→            image_path = Path(image_path)\n  1109→            if not image_path.exists():\n  1110→                raise AppError(f\"图像文件不存在: {image_path}\", ErrorHandler.ErrorType.FILE_ERROR)\n  1111→            \n  1112→            # 使用图片格式验证器处理\n  1113→            from utils.image_format_validator import validate_and_prepare_image\n  1114→            \n  1115→            result = validate_and_prepare_image(str(image_path), auto_convert=True)\n  1116→            \n  1117→            if result['success']:\n  1118→                if result['is_converted']:\n  1119→                    logger.info(f\"图片格式已自动转换: {result['original_format']} -> {result['final_format']}\")\n  1120→                return result['data_url']\n  1121→            else:\n  1122→                logger.error(f\"图片处理失败: {result['error']}\")\n  1123→                raise AppError(f\"图片处理失败: {result['error']}\", ErrorHandler.ErrorType.FILE_ERROR)\n  1124→                \n  1125→        except AppError:\n  1126→            raise\n  1127→        except Exception as e:\n  1128→            # 避免在日志中显示可能包含base64数据的异常信息\n  1129→            error_msg = str(e)\n  1130→            if len(error_msg) > 200:\n  1131→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n  1132→            logger.error(f\"图像编码失败: {error_msg}\")\n  1133→            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorHandler.ErrorType.FILE_ERROR)\n  1134→\n  1135→    def _get_mime_type(self, extension: str) -> str:\n  1136→        \"\"\"\n  1137→        根据文件扩展名获取MIME类型\n  1138→\n  1139→        Args:\n  1140→            extension: 文件扩展名\n  1141→\n  1142→        Returns:\n  1143→            str: MIME类型\n  1144→        \"\"\"\n  1145→        mime_types = {\".jpg\": \"image/jpeg\", \".jpeg\": \"image/jpeg\", \".png\": \"image/png\", \".webp\": \"image/webp\"}\n  1146→        return mime_types.get(extension, \"image/jpeg\")\n  1147→\n  1148→    def _make_request(\n  1149→        self,\n  1150→        endpoint: str,\n  1151→        data: Optional[Dict[str, Any]] = None,\n  1152→        params: Optional[Dict[str, Any]] = None,\n  1153→        method: str = \"POST\",\n  1154→    ) -> Dict[str, Any]:\n  1155→        \"\"\"\n  1156→        发送HTTP请求\n  1157→\n  1158→        Args:\n  1159→            endpoint: API端点\n  1160→            data: 请求数据\n  1161→            params: 查询参数\n  1162→            method: HTTP方法\n  1163→\n  1164→        Returns:\n  1165→            Dict: 响应结果\n  1166→        \"\"\"\n  1167→        url = f\"{self.base_url}{endpoint}\"\n  1168→\n  1169→        headers = {\"Authorization\": f\"Bearer {self.api_key}\", \"Content-Type\": \"application/json\"}\n  1170→\n  1171→        for attempt in range(self.max_retries):\n  1172→            try:\n  1173→                if method.upper() == \"GET\":\n  1174→                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)\n  1175→                else:\n  1176→                    response = requests.post(url, headers=headers, json=data, params=params, timeout=self.timeout)\n  1177→\n  1178→                response.raise_for_status()\n  1179→\n  1180→                # 解析响应（增强容错：包括编码问题回退）\n  1181→                try:\n  1182→                    result = response.json()\n  1183→                except (json.JSONDecodeError, UnicodeDecodeError) as e:\n  1184→                    raw = response.content or b\"\"\n  1185→                    tried = set()\n  1186→                    result = None\n  1187→                    for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n  1188→                        if not enc or enc in tried:\n  1189→                            continue\n  1190→                        tried.add(enc)\n  1191→                        try:\n  1192→                            text = raw.decode(enc, errors=\"strict\")\n  1193→                            result = json.loads(text)\n  1194→                            logger.debug(f\"_make_request - 通过备用编码解析成功: {enc}\")\n  1195→                            break\n  1196→                        except Exception:\n  1197→                            continue\n  1198→                    if result is None:\n  1199→                        try:\n  1200→                            preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n  1201→                        except Exception:\n  1202→                            preview = str(raw[:200])\n  1203→                        logger.error(f\"_make_request - JSON解析失败(编码问题): {preview}\")\n  1204→                        raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n  1205→\n  1206→                return {\"success\": True, \"data\": result}\n  1207→\n  1208→            except requests.exceptions.Timeout:\n  1209→                logger.warning(f\"请求超时，第{attempt + 1}次重试\")\n  1210→                if attempt < self.max_retries - 1:\n  1211→                    time.sleep(self.retry_delay)\n  1212→                    continue\n  1213→                else:\n  1214→                    return {\"success\": False, \"error\": \"请求超时\", \"error_code\": \"TIMEOUT_ERROR\"}\n  1215→\n  1216→            except requests.exceptions.HTTPError as e:\n  1217→                if response.status_code == 429:\n  1218→                    logger.warning(f\"API配额限制，第{attempt + 1}次重试\")\n  1219→                    if attempt < self.max_retries - 1:\n  1220→                        time.sleep(self.retry_delay * 2)  # 配额限制时等待更长时间\n  1221→                        continue\n  1222→                    else:\n  1223→                        return {\"success\": False, \"error\": \"API配额已用完\", \"error_code\": \"QUOTA_EXCEEDED\"}\n  1224→                else:\n  1225→                    try:\n  1226→                        # 安全解析错误响应\n  1227→                        try:\n  1228→                            error_data = response.json()\n  1229→                        except (json.JSONDecodeError, UnicodeDecodeError):\n  1230→                            # 编码问题时使用安全解码\n  1231→                            try:\n  1232→                                safe_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n  1233→                                error_data = json.loads(safe_text)\n  1234→                            except Exception:\n  1235→                                error_data = {\"error\": {\"message\": \"响应解析失败\"}}\n  1236→                        error_message = error_data.get(\"error\", {}).get(\"message\", str(e))\n  1237→                    except:\n  1238→                        error_message = str(e)\n  1239→\n  1240→                    return {\n  1241→                        \"success\": False,\n  1242→                        \"error\": error_message,\n  1243→                        \"error_code\": \"API_ERROR\",\n  1244→                        \"status_code\": response.status_code,\n  1245→                    }\n  1246→\n  1247→            except requests.exceptions.RequestException as e:\n  1248→                logger.warning(f\"网络错误，第{attempt + 1}次重试: {e}\")\n  1249→                if attempt < self.max_retries - 1:\n  1250→                    time.sleep(self.retry_delay)\n  1251→                    continue\n  1252→                else:\n  1253→                    return {\"success\": False, \"error\": f\"网络连接错误: {e}\", \"error_code\": \"NETWORK_ERROR\"}\n  1254→\n  1255→            except Exception as e:\n  1256→                logger.error(f\"未知错误: {e}\")\n  1257→                return {\"success\": False, \"error\": str(e), \"error_code\": \"UNKNOWN_ERROR\"}\n  1258→\n  1259→        return {\"success\": False, \"error\": \"达到最大重试次数\", \"error_code\": \"MAX_RETRIES_EXCEEDED\"}\n  1260→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"dbcfdb38-f59a-4dd0-9c05-97d802180c2e","timestamp":"2025-12-09T03:56:29.964Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py","content":"# Seedance视频生成客户端\n# 封装火山引擎Seedance1.0pro的API调用\n\nimport os\nimport time\nimport json\nimport base64\nimport requests\nimport logging\nimport asyncio\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom pathlib import Path\nfrom loguru import logger\n# volcenginesdkarkruntime import removed - not used in current implementation\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\n# 导入配置管理器和错误处理\nfrom config.unified_config import get_unified_config\nfrom modules.utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler\nfrom .config import SeedanceModels, TaskStatus, SeedanceConfig\n\n\"\"\"\n常量与辅助方法（视频参数 P0b）\n- 仅保留“分辨率档位 + 比例”的新路径；不再支持旧 width/height → --rs 映射\n\"\"\"\n\n# 白名单常量\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\"}\n\ndef _validate_and_build_flags(\n    resolution_grade: Optional[str],\n    ratio: Optional[str],\n    duration: int,\n    fps: int,\n    watermark: bool,\n    camera_fixed: bool,\n    seed: Optional[int],\n) -> Tuple[str, bool, str, str, str]:\n    \"\"\"生成安全版文本命令片段；返回 (flags_text, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n    used_rs = resolution_grade or \"\"\n    used_rt = ratio or \"\"\n    fallback_applied = False\n    fallback_reasons: List[str] = []\n\n    # 校验白名单\n    if not used_rs or used_rs not in RES_GRADES:\n        fallback_applied = True\n        fallback_reasons.append(f\"无效分辨率: {used_rs or '缺失'}\")\n        used_rs = \"1080p\"\n    if not used_rt or used_rt not in RATIOS:\n        fallback_applied = True\n        fallback_reasons.append(f\"无效比例: {used_rt or '缺失'}\")\n        used_rt = \"16:9\"\n\n    # 组装顺序: --rs --rt --dur --fps --wm --seed --cf\n    parts: List[str] = []\n    parts += [\"--rs\", used_rs, \"--rt\", used_rt, \"--dur\", str(int(duration)), \"--fps\", str(int(fps))]\n    parts += [\"--wm\", str(bool(watermark)).lower()]\n    if seed is not None and seed != -1:\n        try:\n            parts += [\"--seed\", str(int(seed))]\n        except Exception:\n            # 种子解析异常时忽略，不触发全局fallback\n            logger.warning(\"种子参数无效，已忽略 --seed\")\n    parts += [\"--cf\", str(bool(camera_fixed)).lower()]\n\n    flags_text = \" \".join(parts)\n    fallback_reason = \", \".join(fallback_reasons) if fallback_applied else \"\"\n    return flags_text, fallback_applied, fallback_reason, used_rs, used_rt\n\n\nclass SeedanceClient:\n    \"\"\"火山引擎Seedance视频生成客户端\n\n    提供文生视频、图生视频和首尾帧视频生成功能\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n        timeout: int = 60,\n        max_retries: int = 3,\n    ):\n        \"\"\"初始化Seedance客户端\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n            base_url: API基础URL\n            timeout: 请求超时时间（秒）\n            max_retries: 最大重试次数\n        \"\"\"\n        # 获取API密钥\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise AppError(str(exc), ErrorHandler.ErrorType.AUTH_ERROR) from exc\n\n        self.api_key = api_key\n        self.base_url = base_url.rstrip(\"/\")\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self.retry_delay = 2\n        self.config = SeedanceConfig()\n        self._active_tasks = set()  # 跟踪活跃任务\n\n        # 配置会话\n        self.session = requests.Session()\n        \n        # 配置SSL和连接参数\n        import ssl\n        from requests.adapters import HTTPAdapter\n        from urllib3.util.retry import Retry\n        from urllib3.util.ssl_ import create_urllib3_context\n        \n        # 创建自定义SSL上下文\n        ssl_context = create_urllib3_context()\n        ssl_context.check_hostname = False\n        ssl_context.verify_mode = ssl.CERT_NONE\n        ssl_context.set_ciphers('DEFAULT@SECLEVEL=1')\n        \n        # 配置更强的重试策略\n        retry_strategy = Retry(\n            total=max_retries * 2,  # 增加重试次数\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n            backoff_factor=2,  # 增加退避因子\n            raise_on_status=False\n        )\n        \n        # 创建自定义适配器\n        class SSLAdapter(HTTPAdapter):\n            def init_poolmanager(self, *args, **kwargs):\n                kwargs['ssl_context'] = ssl_context\n                kwargs['socket_options'] = [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]\n                return super().init_poolmanager(*args, **kwargs)\n        \n        import socket\n        adapter = SSLAdapter(\n            max_retries=retry_strategy,\n            pool_connections=10,\n            pool_maxsize=20,\n            pool_block=False\n        )\n        \n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        # 设置会话级别的超时和连接参数\n        self.session.timeout = (30, 120)  # (连接超时, 读取超时)\n        self.session.verify = False  # 直接禁用SSL验证，避免证书问题\n\n        # 禁用SSL警告\n        import urllib3\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n        self.session.headers.update({\n            'Connection': 'keep-alive',\n            'Keep-Alive': 'timeout=30, max=100'\n        })\n\n        # 初始化性能监控\n        self._performance_stats = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"total_response_time\": 0,\n            \"last_request_time\": None\n        }\n        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n        \n        logger.info(\"Seedance客户端初始化完成\")\n        logger.info(f\"使用配置: 基础URL={self.base_url}, 超时={timeout}秒, 最大重试={max_retries}次\")\n\n    def _provider_enabled(self) -> bool:\n        try:\n            import os\n            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n            return v not in {\"0\", \"false\", \"no\"}\n        except Exception:\n            return True\n\n    def _get_headers(self) -> Dict[str, str]:\n        \"\"\"获取请求头\"\"\"\n        api_key = str(self.api_key).strip()\n\n        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n        try:\n            api_key.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n\n        return {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"User-Agent\": \"Seedance-Client/1.0.0\",\n        }\n\n    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout=60):\n        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n\n    def _handle_response(self, response: requests.Response, operation: str = \"API调用\") -> Dict[str, Any]:\n        \"\"\"处理API响应\n\n        Args:\n            response: HTTP响应对象\n            operation: 操作描述，用于日志记录\n\n        Returns:\n            解析后的响应数据\n\n        Raises:\n            Exception: 当API返回错误时\n        \"\"\"\n        try:\n            # 记录响应基本信息\n            logger.info(f\"{operation} - 响应状态码: {response.status_code}\")\n            \n            # 处理HTTP错误状态码\n            if not response.ok:\n                error_details = {\n                    \"status_code\": response.status_code,\n                    \"url\": response.url,\n                    \"headers\": dict(response.headers),\n                    \"operation\": operation\n                }\n                \n                try:\n                    error_body = response.json()\n                    error_details[\"response_body\"] = error_body\n                except Exception:\n                    try:\n                        error_details[\"response_text\"] = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        error_details[\"response_text\"] = str(response.content[:500])\n                \n                # 根据状态码分类错误\n                if response.status_code == 400:\n                    logger.error(f\"{operation} - 请求参数错误: {error_details}\")\n                    try:\n                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        preview = str(response.content[:500])\n                    raise Exception(f\"请求参数错误: {preview}\")\n                elif response.status_code == 401:\n                    logger.error(f\"{operation} - 认证失败: API密钥无效\")\n                    raise Exception(\"认证失败: 请检查API密钥是否正确\")\n                elif response.status_code == 403:\n                    logger.error(f\"{operation} - 权限不足: {error_details}\")\n                    raise Exception(\"权限不足: 请检查API密钥权限\")\n                elif response.status_code == 404:\n                    logger.error(f\"{operation} - 资源不存在: {error_details}\")\n                    raise Exception(\"资源不存在: 请检查API端点或任务ID\")\n                elif response.status_code == 429:\n                    logger.error(f\"{operation} - 请求频率限制: {error_details}\")\n                    raise Exception(\"请求频率过高: 请稍后重试\")\n                elif response.status_code >= 500:\n                    logger.error(f\"{operation} - 服务器错误: {error_details}\")\n                    raise Exception(f\"服务器错误: {response.status_code}\")\n                else:\n                    logger.error(f\"{operation} - HTTP错误: {error_details}\")\n                    try:\n                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        preview = str(response.content[:500])\n                    raise Exception(f\"HTTP错误: {response.status_code} - {preview}\")\n\n            # 解析JSON响应（增强容错：包括编码问题回退）\n            try:\n                result = response.json()\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                raw = response.content or b\"\"\n                tried = set()\n                result = None\n                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                    if not enc or enc in tried:\n                        continue\n                    tried.add(enc)\n                    try:\n                        text = raw.decode(enc, errors=\"strict\")\n                        result = json.loads(text)\n                        logger.debug(f\"{operation} - 通过备用编码解析成功: {enc}\")\n                        break\n                    except Exception:\n                        continue\n                if result is None:\n                    # 最后尝试宽松日志预览，抛出统一错误\n                    try:\n                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                    except Exception:\n                        preview = str(raw[:200])\n                    logger.error(f\"{operation} - JSON解析失败(编码问题): {preview}\")\n                    raise Exception(f\"响���格式错误: 无法解析JSON - {str(e)}\")\n\n            # 检查业务错误\n            if \"error\" in result:\n                error_info = result[\"error\"]\n                error_msg = error_info.get(\"message\", \"未知错误\")\n                error_code = error_info.get(\"code\", \"UNKNOWN_ERROR\")\n                \n                logger.error(f\"{operation} - API业务错误: {error_msg} (代码: {error_code})\")\n                logger.error(f\"完整错误信息: {result}\")\n                \n                # 根据错误代码提供更友好的错误信息\n                friendly_msg = self._get_friendly_error_message(error_code, error_msg)\n                raise Exception(f\"API业务错误: {friendly_msg}\")\n\n            # 记录成功响应的关键信息\n            if \"id\" in result:\n                logger.info(f\"{operation} - 成功，任务ID: {result['id']}\")\n            elif \"status\" in result:\n                logger.info(f\"{operation} - 成功，状态: {result['status']}\")\n            else:\n                logger.info(f\"{operation} - 成功\")\n\n            return result\n\n        except requests.exceptions.Timeout as e:\n            logger.error(f\"{operation} - 请求超时: {str(e)}\")\n            raise Exception(f\"请求超时: 请检查网络连接或稍后重试\")\n        except requests.exceptions.ConnectionError as e:\n            logger.error(f\"{operation} - 连接错误: {str(e)}\")\n            raise Exception(f\"网络连接错误: 请检查网络连接\")\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"{operation} - 网络请求错误: {str(e)}\")\n            raise Exception(f\"网络请求失败: {str(e)}\")\n        except Exception as e:\n            if \"API业务错误\" in str(e) or \"请求参数错误\" in str(e) or \"认证失败\" in str(e):\n                # 重新抛出已处理的业务错误\n                raise\n            else:\n                logger.error(f\"{operation} - 未知错误: {str(e)}\")\n                raise Exception(f\"处理响应时发生未知错误: {str(e)}\")\n    \n    def _get_friendly_error_message(self, error_code: str, error_msg: str) -> str:\n        \"\"\"获取友好的错误信息\n        \n        Args:\n            error_code: 错误代码\n            error_msg: 原始错误信息\n            \n        Returns:\n            友好的错误信息\n        \"\"\"\n        error_mapping = {\n            \"INVALID_PARAMETER\": \"参数无效，请检查输入参数\",\n            \"INSUFFICIENT_QUOTA\": \"配额不足，请检查账户余额\",\n            \"MODEL_NOT_FOUND\": \"模型不存在，请检查模型名称\",\n            \"TASK_NOT_FOUND\": \"任务不存在，请检查任务ID\",\n            \"TASK_ALREADY_CANCELLED\": \"任务已被取消\",\n            \"TASK_ALREADY_COMPLETED\": \"任务已完成，无法取消\",\n            \"RATE_LIMIT_EXCEEDED\": \"请求频率过高，请稍后重试\",\n            \"INTERNAL_ERROR\": \"服务内部错误，请稍后重试\",\n            \"UNAUTHORIZED\": \"未授权访问，请检查API密钥\",\n            \"FORBIDDEN\": \"禁止访问，请检查权限设置\"\n        }\n        \n        return error_mapping.get(error_code, f\"{error_msg} (错误代码: {error_code})\")\n    \n    def _record_request_stats(\n        self,\n        operation: str,\n        success: bool,\n        response_time: float,\n        error_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n    ):\n        \"\"\"记录请求统计信息（统一结构 + 最近错误）。\"\"\"\n        try:\n            self._performance_stats[\"total_requests\"] += 1\n            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n            self._performance_stats[\"last_request_time\"] = time.time()\n            \n            if success:\n                self._performance_stats[\"successful_requests\"] += 1\n            else:\n                self._performance_stats[\"failed_requests\"] += 1\n                if error_code or error_message:\n                    self._last_error = {\"code\": error_code, \"message\": (str(error_message)[:200] if error_message else None)}\n            \n            # 记录性能日志（安全摘要）\n            total = max(1, self._performance_stats[\"total_requests\"])\n            avg = self._performance_stats[\"total_response_time\"] / total\n            success_rate = (self._performance_stats[\"successful_requests\"] / total) * 100\n            logger.debug(f\"{operation} - 响应时间: {response_time:.2f}s, 平均: {avg:.2f}s, 成功率: {success_rate:.1f}%\")\n        except Exception:\n            pass\n    \n    def get_performance_stats(self) -> Dict[str, Any]:\n        \"\"\"获取性能统计信息（统一字段命名）。\"\"\"\n        stats = dict(self._performance_stats)\n        total = stats.get(\"total_requests\", 0) or 0\n        if total > 0:\n            avg = stats.get(\"total_response_time\", 0.0) / total\n            suc_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n        else:\n            avg = 0.0\n            suc_rate = 0.0\n        return {\n            \"total_requests\": total,\n            \"successful_requests\": stats.get(\"successful_requests\", 0),\n            \"failed_requests\": stats.get(\"failed_requests\", 0),\n            \"avg_response_time\": avg,\n            \"success_rate\": suc_rate,\n            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n        }\n\n    def dump_metrics(self) -> Dict[str, Any]:\n        \"\"\"导出统一指标，便于诊断脚本读取。\"\"\"\n        m = self.get_performance_stats()\n        m.update({\n            \"client\": \"Seedance\",\n            \"base_url\": self.base_url,\n        })\n        return m\n\n    def create_video_task(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: int = 8,\n        fps: int = 24,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        seed: Optional[int] = None,\n        use_pro_model: bool = True,\n        camera_fixed: bool = True,\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        watermark: bool = False,\n        reference_images: Optional[List[str]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        创建视频生成任务（新路径：分辨率档位 + 比例）\n\n        Args:\n            prompt: 视频描述提示词\n            image_path: 输入图片路径（图生视频）\n            first_frame_path: 首帧图片路径（首尾帧模式）\n            last_frame_path: 尾帧图片路径（首尾帧模式）\n            duration: 视频时长（秒），默认8秒\n            fps: 帧率，默认24fps\n            width/height: 旧路径兼容（关闭灰度时使用）\n            seed: 随机种子\n            use_pro_model: 是否使用Pro模型\n            camera_fixed: 是否固定摄像头视角\n            resolution_grade: 分辨率档位\n            ratio: 画面比例\n            watermark: 是否添加水印\n            reference_images: 额外参考图（base64/url），Seedream 4.0 视频扩展预留\n\n        Returns:\n            包含任务ID的响应结果\n        \"\"\"\n        url = f\"{self.base_url}/contents/generations/tasks\"\n\n        # 通过 Provider Schema 映射（默认启用；关闭时回退旧逻辑）\n        data = None\n        mode = \"\"\n        fallback_applied = False\n        fallback_reason = \"\"\n        used_rs = \"\"\n        used_rt = \"\"\n        if self._provider_enabled():\n            try:\n                # 预编码图片为 data URL（与旧实现一致），再交由 Provider 组装 content\n                enc_first = self._encode_image(first_frame_path) if first_frame_path else None\n                enc_last = self._encode_image(last_frame_path) if last_frame_path else None\n                enc_img = self._encode_image(image_path) if image_path else None\n\n                from modules.provider.factory import get_default_provider\n                from modules.provider.schema import VideoParams\n                provider = get_default_provider()\n                mapped, fb, reason, used_rs, used_rt = provider.map_video(VideoParams(\n                    prompt=prompt,\n                    image_path=enc_img,\n                    first_frame_path=enc_first,\n                    last_frame_path=enc_last,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if (seed is None or seed == -1) else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=False,\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                    reference_images=(reference_images or []),\n                ))\n                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\n                mode = mapped.get(\"mode\", \"视频\")\n                model = data[\"model\"]\n                fallback_applied, fallback_reason = fb, reason\n                if fb:\n                    logger.warning(f\"参数回退: {reason}\")\n                logger.info(f\"安全版参数: {mapped.get('flags_text', '')}\")\n            except Exception as _e:\n                logger.warning(f\"Provider 映射失败，回退旧路径: {_e}\")\n\n        if data is None:\n            # 旧内容组装路径（保持不变）\n            content: List[Dict[str, Any]] = []\n            # 模型选择\n            if first_frame_path and last_frame_path:\n                model = SeedanceModels.LITE_I2V.value\n                mode = \"首尾帧视频(Lite)\"\n                if use_pro_model:\n                    logger.warning(\"Pro模型不支持首尾帧模式，自动切换到Lite I2V模型\")\n            elif use_pro_model:\n                model = SeedanceModels.PRO.value\n                mode = \"图生视频(Pro)\" if image_path else \"文生视频(Pro)\"\n            else:\n                if image_path:\n                    model = SeedanceModels.LITE_I2V.value\n                    mode = \"图生视频(Lite)\"\n                else:\n                    model = SeedanceModels.LITE_T2V.value\n                    mode = \"文生视频(Lite)\"\n\n            if first_frame_path and last_frame_path:\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(first_frame_path)},\n                    \"role\": \"first_frame\"\n                })\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(last_frame_path)},\n                    \"role\": \"last_frame\"\n                })\n            elif image_path:\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(image_path)},\n                    \"role\": \"first_frame\"\n                })\n            if reference_images:\n                logger.warning(\"Seedance 旧路径暂不支持多参考图，已忽略 reference_images\")\n\n            # 文本命令\n            # Force server-side watermark off for Plan B (local watermark only)\n            flags_text, fallback_applied, fallback_reason, used_rs, used_rt = _validate_and_build_flags(\n                resolution_grade=resolution_grade,\n                ratio=ratio,\n                duration=duration,\n                fps=fps,\n                watermark=False,\n                camera_fixed=camera_fixed,\n                seed=seed,\n            )\n            text_prompt = f\"{prompt} {flags_text}\".strip()\n            if fallback_applied:\n                logger.warning(f\"参数回退: {fallback_reason}\")\n            logger.info(f\"安全版参数: {flags_text}\")\n            content.append({\"type\": \"text\", \"text\": text_prompt})\n            data = {\"model\": model, \"content\": content}\n        headers = self._get_headers()\n        logger.info(f\"创建{mode}任务: {prompt[:50]}...\")\n        logger.info(f\"使用模型: {model}\")\n        logger.info(f\"参数: {used_rs or resolution_grade}+{used_rt or ratio}, dur={duration}s, fps={fps}\")\n\n        start_time = time.time()\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        try:\n            logger.info(f\"发送请求到: {url}\")\n            # 安全日志对象，避免 content 结构异常导致索引错误\n            text_items = [item for item in data.get(\"content\", []) if item.get(\"type\") == \"text\"]\n            text_len = 0\n            if text_items:\n                try:\n                    text_len = len(text_items[0].get(\"text\", \"\"))\n                except Exception:\n                    text_len = 0\n            safe_data = {\n                \"model\": data.get(\"model\"),\n                \"content_types\": [item.get(\"type\") for item in data.get(\"content\", [])],\n                \"text_prompt_length\": text_len,\n                \"image_count\": len([item for item in data.get(\"content\", []) if item.get(\"type\") == \"image_url\"]) \n            }\n            logger.info(f\"请求参数: {json.dumps(safe_data, indent=2, ensure_ascii=False)}\")\n\n            response = self._safe_json_post(url, headers, data, timeout=60)\n            response_time = time.time() - start_time\n            logger.info(f\"响应状态码: {response.status_code}, 响应时间: {response_time:.2f}s\")\n\n            result = self._handle_response(response, \"创建视频任务\")\n            success = True\n            task_id = result.get(\"id\")\n            if task_id:\n                self._active_tasks.add(task_id)\n                logger.info(f\"{mode}任务创建成功，任务ID: {task_id}\")\n                result_obj = {\n                    \"success\": True,\n                    \"task_id\": task_id,\n                    \"status\": result.get(\"status\", \"processing\"),\n                    \"model\": model,\n                    \"mode\": mode,\n                    \"estimated_cost\": self._calculate_cost(model, duration),\n                    \"created_at\": time.time(),\n                    \"fallback_applied\": fallback_applied,\n                    \"fallback_reason\": fallback_reason,\n                    \"used_rs\": used_rs,\n                    \"used_rt\": used_rt,\n                }\n                # 安全摘要日志\n                logger.info(\n                    f\"摘要|operation=create_task status=success elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id}\"\n                )\n                return result_obj\n            else:\n                logger.error(f\"{mode}任务创建失败，未获取到任务ID\")\n                return {\"success\": False, \"error\": \"未获取到任务ID\", \"response\": result}\n\n        except requests.exceptions.SSLError as e:\n            logger.error(f\"{mode}任务创建失败 - SSL错误: {str(e)}\")\n            logger.info(\"尝试使用备用SSL配置重新连接...\")\n            try:\n                backup_session = requests.Session()\n                backup_session.verify = False\n                import urllib3\n                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n                # 手动编码避免 PyInstaller latin-1 问题\n                body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n                response = backup_session.post(url, headers=headers, data=body, timeout=(30, 120))\n                result = self._handle_response(response, \"创建视频任务(备用连接)\")\n                success = True\n                task_id = result.get(\"id\")\n                if task_id:\n                    self._active_tasks.add(task_id)\n                    logger.info(f\"{mode}任务创建成功(备用连接)，任务ID: {task_id}\")\n                    result_obj = {\n                        \"success\": True,\n                        \"task_id\": task_id,\n                        \"status\": result.get(\"status\", \"processing\"),\n                        \"model\": model,\n                        \"mode\": mode,\n                        \"estimated_cost\": self._calculate_cost(model, duration),\n                        \"created_at\": time.time(),\n                        \"fallback_applied\": fallback_applied,\n                        \"fallback_reason\": fallback_reason,\n                        \"used_rs\": used_rs,\n                        \"used_rt\": used_rt,\n                    }\n                    logger.info(\n                        f\"摘要|operation=create_task status=success elapsed={time.time() - start_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id} (backup)\"\n                    )\n                    return result_obj\n                else:\n                    raise Exception(\"备用连接也未获取到任务ID\")\n            except Exception as backup_e:\n                logger.error(f\"备用连接也失败: {str(backup_e)}\")\n                err_code, err_msg = \"SSL_ERROR\", f\"SSL连接失败: {str(e)}; 备用: {str(backup_e)}\"\n                raise Exception(f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}\")\n        except requests.exceptions.ConnectionError as e:\n            logger.error(f\"{mode}任务创建失败 - 连接错误: {str(e)}\")\n            err_code, err_msg = \"NETWORK_ERROR\", str(e)\n            raise Exception(f\"网络连接失败，请检查网络连接: {str(e)}\")\n        except requests.exceptions.Timeout as e:\n            logger.error(f\"{mode}任务创建失败 - 超时: {str(e)}\")\n            err_code, err_msg = \"TIMEOUT_ERROR\", str(e)\n            raise Exception(f\"请求超时，请稍后重试: {str(e)}\")\n        except Exception as e:\n            logger.error(f\"{mode}任务创建失败: {str(e)}\")\n            err_code, err_msg = \"UNKNOWN_ERROR\", str(e)\n            raise Exception(f\"视频生成任务创建失败: {str(e)}\")\n        finally:\n            response_time = time.time() - start_time\n            # 失败时记录摘要\n            if not success:\n                logger.info(\n                    f\"摘要|operation=create_task status=failed elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s error={err_code}\"\n                )\n            self._record_request_stats(\"创建视频任务\", success, response_time, err_code, err_msg)\n\n    \n    def _calculate_cost(self, model: str, duration: int) -> float:\n        \"\"\"计算预估成本\"\"\"\n        base_cost = self.config.MODEL_PRICING.get(model, 15)\n        # 简单的成本估算：基础价格 * 时长系数\n        return base_cost * (duration / 5.0)  # 以5秒为基准\n\n    def query_video_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"查询视频生成任务状态\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            任务状态信息\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        # 使用正确的查询API端点\n        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n        headers = self._get_headers()\n\n        logger.info(f\"查询视频任务状态: {task_id}\")\n\n        try:\n            try:\n                response = self.session.get(url, headers=headers, timeout=30)\n            except requests.exceptions.SSLError as e:\n                logger.error(f\"查询视频任务状态失败 - SSL错误: {str(e)}\")\n                logger.info(\"尝试使用备用SSL配置重新查询任务状态...\")\n                try:\n                    backup_session = requests.Session()\n                    backup_session.verify = False\n                    import urllib3\n                    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n                    response = backup_session.get(url, headers=headers, timeout=30)\n                except Exception as backup_e:\n                    logger.error(f\"备用SSL配置查询失败: {str(backup_e)}\")\n                    raise Exception(\n                        f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}; 备用: {str(backup_e)}\"\n                    ) from e\n\n            result = self._handle_response(response, \"查询视频任务\")\n\n            # 根据官方API返回格式解析状态\n            status = result.get(\"status\", \"unknown\")\n            video_url = result.get(\"content\", {}).get(\"video_url\")\n            \n            logger.info(f\"任务 {task_id} 状态: {status}\")\n            \n            if status == \"succeeded\" and video_url:\n                logger.info(f\"视频生成完成: {video_url}\")\n\n            # 获取缩略图URL\n            thumbnail_url = result.get(\"content\", {}).get(\"thumbnail_url\") or result.get(\"thumbnail_url\")\n            preview_url = result.get(\"content\", {}).get(\"preview_url\") or result.get(\"preview_url\")\n            \n            result_obj = {\n                \"success\": True,\n                \"task_id\": task_id,\n                \"status\": status,\n                \"video_url\": video_url,\n                \"thumbnail_url\": thumbnail_url,\n                \"preview_url\": preview_url,\n                \"model\": result.get(\"model\"),\n                \"resolution\": result.get(\"resolution\"),\n                \"duration\": result.get(\"duration\"),\n                \"fps\": result.get(\"framespersecond\"),\n                \"usage\": result.get(\"usage\"),\n                \"created_at\": result.get(\"created_at\"),\n                \"updated_at\": result.get(\"updated_at\")\n            }\n            # 安全摘要日志\n            logger.info(\n                f\"摘要|operation=query_task status={status} task_id={task_id} video_ready={'yes' if bool(video_url) else 'no'}\"\n            )\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"查询视频任务状态失败: {str(e)}\")\n            raise Exception(f\"查询任务状态失败: {str(e)}\")\n\n    def get_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        查询任务状态（兼容旧接口）\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        return self.query_video_task(task_id)\n\n    def wait_for_completion(self, task_id: str, max_wait_time: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"\n        等待任务完成（智能轮询）\n\n        Args:\n            task_id: 任务ID\n            max_wait_time: 最大等待时间（秒），默认使用配置值\n\n        Returns:\n            Dict: 最终任务结果\n        \"\"\"\n        max_wait_time = max_wait_time or self.config.POLLING[\"max_wait_time\"]\n        intervals = self.config.POLLING[\"intervals\"]\n        \n        logger.info(f\"开始智能轮询任务: {task_id}\")\n        \n        start_time = time.time()\n        attempt = 0\n\n        while time.time() - start_time < max_wait_time:\n            try:\n                # 查询任务状态\n                status_result = self.get_task_status(task_id)\n\n                if not status_result[\"success\"]:\n                    return status_result\n\n                status = status_result[\"status\"]\n                progress = status_result.get(\"progress\", 0)\n\n                logger.info(f\"任务 {task_id} 状态: {status}, 进度: {progress}%\")\n\n                # 检查是否为终态\n                if TaskStatus.is_terminal(status):\n                    if status == TaskStatus.SUCCEEDED.value:\n                        logger.success(f\"任务完成: {task_id}\")\n                    elif status == TaskStatus.FAILED.value:\n                        logger.error(f\"任务失败: {task_id}\")\n                    elif status == TaskStatus.CANCELLED.value:\n                        logger.warning(f\"任务被取消: {task_id}\")\n                    \n                    # 从活跃任务中移除\n                    self._active_tasks.discard(task_id)\n                    return status_result\n\n                # 动态调整轮询间隔\n                interval = intervals[min(attempt, len(intervals) - 1)]\n                logger.debug(f\"等待 {interval} 秒后继续轮询\")\n                time.sleep(interval)\n                attempt += 1\n                \n            except Exception as e:\n                logger.error(f\"轮询异常: {e}\")\n                time.sleep(5)  # 异常时等待5秒\n\n        # 超时处理\n        logger.error(f\"轮询超时: {task_id}\")\n        self._active_tasks.discard(task_id)\n        return {\n            \"success\": False, \n            \"error\": \"等待任务完成超时\", \n            \"error_code\": \"TIMEOUT_ERROR\", \n            \"task_id\": task_id,\n            \"elapsed_time\": time.time() - start_time\n        }\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消视频生成任务（仅在queued状态有效）\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            成功: {\"success\": True, \"status\": \"cancelled\"}\n            失败: {\"success\": False, \"error\": \"错误信息\"}\n        \"\"\"\n        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.api_key}\"\n        }\n\n        try:\n            response = requests.delete(url, headers=headers, timeout=10)\n\n            if response.status_code == 200:\n                # DELETE请求成功，等待0.5秒后查询实际状态\n                time.sleep(0.5)\n\n                # 查询任务状态以确认是否真的变成cancelled\n                try:\n                    status_result = self.query_video_task(task_id)\n                    current_status = status_result.get(\"status\", \"unknown\")\n\n                    if current_status == \"cancelled\":\n                        # 真正成功取消\n                        self._active_tasks.discard(task_id)\n                        logger.info(f\"任务已成功取消: {task_id}，状态已变更为 cancelled\")\n                        return {\"success\": True, \"status\": \"cancelled\"}\n                    else:\n                        # DELETE成功但状态不是cancelled（任务可能已在执行中）\n                        logger.warning(f\"DELETE请求成功，但任务状态为 {current_status}（任务可能已在执行中，无法取消）\")\n                        return {\"success\": False, \"status\": current_status, \"error\": f\"任务状态为 {current_status}，无法取消\"}\n                except Exception as query_e:\n                    # 状态查询失败，但DELETE请求成功\n                    logger.warning(f\"DELETE请求成功，但状态查询失败: {query_e}\")\n                    self._active_tasks.discard(task_id)\n                    return {\"success\": True, \"status\": \"cancelled\", \"warning\": \"状态确认失败\"}\n\n            if response.status_code == 400:\n                error_msg = response.json().get(\"error\", {}).get(\"message\", \"任务无法取消（可能已在执行中）\")\n                logger.warning(f\"取消任务失败: {task_id} - {error_msg}\")\n                return {\"success\": False, \"error\": error_msg}\n\n            error_msg = f\"HTTP {response.status_code}: {response.text}\"\n            logger.error(f\"取消任务请求失败: {error_msg}\")\n            return {\"success\": False, \"error\": error_msg}\n\n        except Exception as e:  # pylint: disable=broad-except\n            logger.error(f\"取消任务异常: {task_id} - {e}\")\n            return {\"success\": False, \"error\": str(e)}\n\n    def list_tasks(self, limit: int = 20, offset: int = 0, status_filter: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        获取任务列表（改进版）\n\n        Args:\n            limit: 返回数量限制\n            offset: 偏移量\n            status_filter: 状态过滤器\n\n        Returns:\n            Dict: 任务列表\n        \"\"\"\n        url = f\"{self.base_url}{self.config.ENDPOINTS['list_tasks']}\"\n        headers = self._get_headers()\n        \n        params = {\n            \"limit\": limit,\n            \"offset\": offset\n        }\n        \n        if status_filter:\n            params[\"status\"] = status_filter\n        \n        logger.info(f\"获取任务列表: limit={limit}, offset={offset}, status_filter={status_filter}\")\n        \n        # 记录开始时间\n        start_time = time.time()\n        success = False\n\n        try:\n            response = self.session.get(url, headers=headers, params=params, timeout=30)\n            result = self._handle_response(response, \"获取任务列表\")\n            \n            tasks = result.get(\"data\", [])\n            total = result.get(\"total\", len(tasks))\n            \n            logger.success(f\"获取任务列表成功，共{len(tasks)}个任务\")\n            success = True\n            \n            return {\n                \"success\": True,\n                \"tasks\": tasks,\n                \"total\": total,\n                \"limit\": limit,\n                \"offset\": offset,\n                \"has_more\": offset + len(tasks) < total\n            }\n            \n        except Exception as e:\n            logger.error(f\"获取任务列表失败: {e}\")\n            return {\n                 \"success\": False,\n                 \"error\": str(e)\n             }\n        finally:\n            # 记录性能统计\n            response_time = time.time() - start_time\n            self._record_request_stats(\"获取任务列表\", success, response_time)\n    \n    def batch_query_tasks(self, task_ids: List[str]) -> Dict[str, Any]:\n        \"\"\"\n        批量查询任务状态\n        \n        Args:\n            task_ids: 任务ID列表\n        \n        Returns:\n            批量查询结果\n        \"\"\"\n        results = {}\n        success_count = 0\n        \n        logger.info(f\"批量查询{len(task_ids)}个任务\")\n        \n        for task_id in task_ids:\n            try:\n                result = self.query_video_task(task_id)\n                if result.get(\"success\", True):  # 兼容不同的返回格式\n                    success_count += 1\n                results[task_id] = result\n            except Exception as e:\n                results[task_id] = {\n                    \"success\": False,\n                    \"error\": str(e)\n                }\n        \n        return {\n            \"success\": True,\n            \"results\": results,\n            \"total\": len(task_ids),\n            \"success_count\": success_count,\n            \"failed_count\": len(task_ids) - success_count\n        }\n    \n    def cancel_all_active_tasks(self) -> Dict[str, Any]:\n        \"\"\"\n        取消所有活跃任务\n        \n        Returns:\n            取消结果统计\n        \"\"\"\n        active_tasks = list(self._active_tasks)\n        \n        if not active_tasks:\n            return {\n                \"success\": True,\n                \"message\": \"没有活跃任务需要取消\",\n                \"cancelled\": 0\n            }\n        \n        cancelled_count = 0\n        failed_count = 0\n        \n        logger.info(f\"取消{len(active_tasks)}个活跃任务\")\n        \n        for task_id in active_tasks:\n            result = self.cancel_task(task_id)\n            if result.get(\"success\"):\n                cancelled_count += 1\n            else:\n                failed_count += 1\n        \n        return {\n            \"success\": True,\n            \"cancelled\": cancelled_count,\n            \"failed\": failed_count,\n            \"total_active\": len(active_tasks)\n        }\n    \n    def get_task_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取任务统计信息\n        \n        Returns:\n            统计信息\n        \"\"\"\n        try:\n            # 获取最近的任务列表\n            tasks_result = self.list_tasks(limit=100)\n            \n            if not tasks_result.get(\"success\"):\n                return tasks_result\n            \n            tasks = tasks_result.get(\"tasks\", [])\n            \n            # 统计各状态任务数量\n            status_counts = {}\n            total_cost = 0\n            \n            for task in tasks:\n                status = task.get(\"status\", \"unknown\")\n                status_counts[status] = status_counts.get(status, 0) + 1\n                \n                # 估算成本\n                model = task.get(\"model\", \"\")\n                if model in self.config.MODEL_PRICING:\n                    total_cost += self.config.MODEL_PRICING[model]\n            \n            return {\n                \"success\": True,\n                \"total_tasks\": len(tasks),\n                \"active_tasks\": len(self._active_tasks),\n                \"status_counts\": status_counts,\n                \"estimated_total_cost\": total_cost,\n                \"timestamp\": time.time()\n            }\n            \n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\n    def _prepare_image(self, image_path: str) -> str:\n        \"\"\"准备图片数据，返回data URL格式\"\"\"\n        try:\n            # 使用新的图片格式验证器\n            from utils.image_format_validator import validate_and_prepare_image\n            \n            result = validate_and_prepare_image(image_path, auto_convert=True)\n            \n            if result['success']:\n                if result['is_converted']:\n                    logger.info(f\"图片已自动转换: {result['original_format']} -> {result['final_format']}\")\n                return result['data_url']\n            else:\n                raise Exception(result['error'])\n                \n        except Exception as e:\n            logger.error(f\"图片处理失败: {str(e)}\")\n            raise Exception(f\"图片处理失败: {str(e)}\")\n\n    def _encode_image(self, image_path: str) -> str:\n        \"\"\"将图像文件编码为data URL格式\n        集成图片格式验证和自动转换功能\n        \n        Args:\n            image_path: 图像文件路径\n            \n        Returns:\n            data URL格式的图像字符串\n            \n        Raises:\n            AppError: 当图像文件不存在或编码失败时\n        \"\"\"\n        try:\n            image_path = Path(image_path)\n            if not image_path.exists():\n                raise AppError(f\"图像文件不存在: {image_path}\", ErrorHandler.ErrorType.FILE_ERROR)\n            \n            # 使用图片格式验证器处理\n            from utils.image_format_validator import validate_and_prepare_image\n            \n            result = validate_and_prepare_image(str(image_path), auto_convert=True)\n            \n            if result['success']:\n                if result['is_converted']:\n                    logger.info(f\"图片格式已自动转换: {result['original_format']} -> {result['final_format']}\")\n                return result['data_url']\n            else:\n                logger.error(f\"图片处理失败: {result['error']}\")\n                raise AppError(f\"图片处理失败: {result['error']}\", ErrorHandler.ErrorType.FILE_ERROR)\n                \n        except AppError:\n            raise\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图像编码失败: {error_msg}\")\n            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorHandler.ErrorType.FILE_ERROR)\n\n    def _get_mime_type(self, extension: str) -> str:\n        \"\"\"\n        根据文件扩展名获取MIME类型\n\n        Args:\n            extension: 文件扩展名\n\n        Returns:\n            str: MIME类型\n        \"\"\"\n        mime_types = {\".jpg\": \"image/jpeg\", \".jpeg\": \"image/jpeg\", \".png\": \"image/png\", \".webp\": \"image/webp\"}\n        return mime_types.get(extension, \"image/jpeg\")\n\n    def _make_request(\n        self,\n        endpoint: str,\n        data: Optional[Dict[str, Any]] = None,\n        params: Optional[Dict[str, Any]] = None,\n        method: str = \"POST\",\n    ) -> Dict[str, Any]:\n        \"\"\"\n        发送HTTP请求\n\n        Args:\n            endpoint: API端点\n            data: 请求数据\n            params: 查询参数\n            method: HTTP方法\n\n        Returns:\n            Dict: 响应结果\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n\n        headers = {\"Authorization\": f\"Bearer {self.api_key}\", \"Content-Type\": \"application/json\"}\n\n        for attempt in range(self.max_retries):\n            try:\n                if method.upper() == \"GET\":\n                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)\n                else:\n                    response = requests.post(url, headers=headers, json=data, params=params, timeout=self.timeout)\n\n                response.raise_for_status()\n\n                # 解析响应（增强容错：包括编码问题回退）\n                try:\n                    result = response.json()\n                except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                    raw = response.content or b\"\"\n                    tried = set()\n                    result = None\n                    for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                        if not enc or enc in tried:\n                            continue\n                        tried.add(enc)\n                        try:\n                            text = raw.decode(enc, errors=\"strict\")\n                            result = json.loads(text)\n                            logger.debug(f\"_make_request - 通过备用编码解析成功: {enc}\")\n                            break\n                        except Exception:\n                            continue\n                    if result is None:\n                        try:\n                            preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                        except Exception:\n                            preview = str(raw[:200])\n                        logger.error(f\"_make_request - JSON解析失败(编码问题): {preview}\")\n                        raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n\n                return {\"success\": True, \"data\": result}\n\n            except requests.exceptions.Timeout:\n                logger.warning(f\"请求超时，第{attempt + 1}次重试\")\n                if attempt < self.max_retries - 1:\n                    time.sleep(self.retry_delay)\n                    continue\n                else:\n                    return {\"success\": False, \"error\": \"请求超时\", \"error_code\": \"TIMEOUT_ERROR\"}\n\n            except requests.exceptions.HTTPError as e:\n                if response.status_code == 429:\n                    logger.warning(f\"API配额限制，第{attempt + 1}次重试\")\n                    if attempt < self.max_retries - 1:\n                        time.sleep(self.retry_delay * 2)  # 配额限制时等待更长时间\n                        continue\n                    else:\n                        return {\"success\": False, \"error\": \"API配额已用完\", \"error_code\": \"QUOTA_EXCEEDED\"}\n                else:\n                    try:\n                        # 安全解析错误响应\n                        try:\n                            error_data = response.json()\n                        except (json.JSONDecodeError, UnicodeDecodeError):\n                            # 编码问题时使用安全解码\n                            try:\n                                safe_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n                                error_data = json.loads(safe_text)\n                            except Exception:\n                                error_data = {\"error\": {\"message\": \"响应解析失败\"}}\n                        error_message = error_data.get(\"error\", {}).get(\"message\", str(e))\n                    except:\n                        error_message = str(e)\n\n                    return {\n                        \"success\": False,\n                        \"error\": error_message,\n                        \"error_code\": \"API_ERROR\",\n                        \"status_code\": response.status_code,\n                    }\n\n            except requests.exceptions.RequestException as e:\n                logger.warning(f\"网络错误，第{attempt + 1}次重试: {e}\")\n                if attempt < self.max_retries - 1:\n                    time.sleep(self.retry_delay)\n                    continue\n                else:\n                    return {\"success\": False, \"error\": f\"网络连接错误: {e}\", \"error_code\": \"NETWORK_ERROR\"}\n\n            except Exception as e:\n                logger.error(f\"未知错误: {e}\")\n                return {\"success\": False, \"error\": str(e), \"error_code\": \"UNKNOWN_ERROR\"}\n\n        return {\"success\": False, \"error\": \"达到最大重试次数\", \"error_code\": \"MAX_RETRIES_EXCEEDED\"}\n","numLines":1260,"startLine":1,"totalLines":1260}}}
{"parentUuid":"dbcfdb38-f59a-4dd0-9c05-97d802180c2e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P8npQDaPCphPcB4jgauB86","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config_api import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n    59→        \n    60→        # 保持兼容性别名\n    61→        self.file_manager = self.storage_manager\n    62→        self.metadata_manager = self.storage_manager\n    63→        self.image_storage_manager = self.storage_manager\n    64→        \n    65→        # 保留原有的目录属性以保持兼容性\n    66→        self.data_dir = Path(self.storage_manager.root_path)\n    67→        self.images_dir = self.data_dir / \"images\"\n    68→        self.metadata_dir = self.data_dir / \"metadata\"\n    69→\n    70→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    71→\n    72→    def generate_text_to_image(\n    73→        self,\n    74→        prompt: str,\n    75→        size: str = \"1024x1024\",\n    76→        guidance_scale: float = 2.5,\n    77→        seed: int = -1,\n    78→        save_local: bool = True,\n    79→        reference_images: Optional[List[Any]] = None,\n    80→        model_variant: Optional[str] = None,\n    81→        generation_id: Optional[str] = None,\n    82→    ) -> Dict[str, Any]:\n    83→        \"\"\"\n    84→        生成文生图并保存到本地\n    85→\n    86→        Args:\n    87→            prompt: 图像生成提示词\n    88→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    89→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    90→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    91→            response_format: 返回格式，\"url\"或\"b64_json\"\n    92→            save_local: 是否保存到本地\n    93→            reference_images: 参考图列表\n    94→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n    95→\n    96→        Returns:\n    97→            Dict: 生成结果，包含本地文件路径\n    98→        \n    99→        Note:\n   100→            model和watermark参数已固定，不再需要前端控制\n   101→        \"\"\"\n   102→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   103→        \n   104→        # 根据 model_variant 设置环境变量\n   105→        if model_variant == 'seedream_v4':\n   106→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4\"\n   107→        else:\n   108→            # 默认使用 volc_v3\n   109→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v3\"\n   110→\n   111→        # 生成唯一ID，优先使用外部传入的generation_id\n   112→        task_id = generation_id or str(uuid.uuid4())\n   113→\n   114→        ref_assets: List[Dict[str, Any]] = []\n   115→        ref_paths: List[str] = []\n   116→        ref_summary: Dict[str, Any] = {}\n   117→        ref_payloads: List[str] = []\n   118→\n   119→        try:\n   120→            if reference_images:\n   121→                ref_summary = self._process_reference_assets(\n   122→                    reference_images,\n   123→                    max_refs=MAX_REFERENCE_IMAGES,\n   124→                    expected_outputs=1,\n   125→                )\n   126→                ref_assets = list(ref_summary.get('assets', []))\n   127→                ref_paths = list(ref_summary.get('paths', []))\n   128→                ref_payloads = self._build_reference_payloads(ref_assets)\n   129→\n   130→                if ref_summary.get('errors'):\n   131→                    logger.warning(\n   132→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   133→                    )\n   134→                if ref_summary.get('warnings'):\n   135→                    for warn in ref_summary['warnings']:\n   136→                        logger.warning(f\"参考图提示: {warn}\")\n   137→\n   138→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   139→            try:\n   140→                norm, fb, reason = validate_and_normalize_t2i(\n   141→                    TextToImageParams(\n   142→                        prompt=prompt,\n   143→                        size=size,\n   144→                        guidance_scale=guidance_scale,\n   145→                        seed=(None if seed == -1 else seed),\n   146→                    )\n   147→                )\n   148→                logger.info(\n   149→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   150→                )\n   151→                if fb:\n   152→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   153→            except Exception as _e:\n   154→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   155→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   156→            api_result = self.client.text_to_image(\n   157→                prompt=prompt,\n   158→                size=size,\n   159→                guidance_scale=guidance_scale,\n   160→                seed=seed,\n   161→                reference_images=ref_payloads or None,\n   162→            )\n   163→\n   164→            result = {\n   165→                \"task_id\": task_id,\n   166→                \"success\": True,\n   167→                \"type\": \"text_to_image\",\n   168→                \"prompt\": prompt,\n   169→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   170→                \"parameters\": {\n   171→                    \"size\": size, \n   172→                    \"guidance_scale\": guidance_scale, \n   173→                    \"seed\": seed, \n   174→                    \"response_format\": \"url\",  # 固定值\n   175→                    \"watermark\": False,  # 固定值\n   176→                    \"model\": self._resolve_model_id(\n   177→                        \"doubao-seedream-3-0-t2i-250415\",\n   178→                        \"doubao-seedream-4-0-250828\",\n   179→                    )\n   180→                },\n   181→                \"created_at\": datetime.now().isoformat(),\n   182→                \"usage\": api_result.get(\"usage\", {}),\n   183→            }\n   184→\n   185→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   186→            if sanitized_refs:\n   187→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   188→                result[\"reference_assets\"] = sanitized_refs\n   189→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   190→                logger.info(\n   191→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   192→                    len(sanitized_refs),\n   193→                    masked_ids or \"-\",\n   194→                    self._provider_used(),\n   195→                )\n   196→            else:\n   197→                result[\"parameters\"][\"reference_assets\"] = []\n   198→                result[\"reference_assets\"] = []\n   199→\n   200→            # 保存到本地\n   201→            if save_local and result.get(\"image_url\"):\n   202→                local_result = self._save_image_locally(result)\n   203→                result.update(local_result)\n   204→                if local_result.get('local_save_error') and sanitized_refs:\n   205→                    self._cleanup_reference_paths(ref_paths)\n   206→                    result[\"parameters\"][\"reference_assets\"] = []\n   207→                    result[\"reference_assets\"] = []\n   208→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   209→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   210→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   211→\n   212→            logger.success(f\"文生图任务完成: {task_id}\")\n   213→            return result\n   214→\n   215→        except Exception as e:\n   216→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   217→            self._cleanup_reference_paths(ref_paths)\n   218→            return {\n   219→                \"task_id\": task_id,\n   220→                \"success\": False,\n   221→                \"error\": str(e),\n   222→                \"type\": \"text_to_image\"\n   223→            }\n   224→\n   225→    def generate_image_to_image(\n   226→        self,\n   227→        prompt: str,\n   228→        image: str,\n   229→        guidance_scale: float = 5.5,\n   230→        seed: int = -1,\n   231→        save_local: bool = True,\n   232→        reference_images: Optional[List[Any]] = None,\n   233→        generation_id: Optional[str] = None,\n   234→    ) -> Dict[str, Any]:\n   235→        \"\"\"\n   236→        生成图生图并保存到本地\n   237→\n   238→        Args:\n   239→            prompt: 编辑提示词\n   240→            image_path: 原始图像路径（本地路径或URL）\n   241→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   242→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   243→            response_format: 返回格式，\"url\"或\"b64_json\"\n   244→            save_local: 是否保存到本地\n   245→\n   246→        Returns:\n   247→            Dict: 生成结果\n   248→        \n   249→        Note:\n   250→            model、size、watermark参数已固定，不再需要前端控制\n   251→        \"\"\"\n   252→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   253→\n   254→        # 生成唯一ID，优先使用外部传入的generation_id\n   255→        task_id = generation_id or str(uuid.uuid4())\n   256→\n   257→        ref_paths: List[str] = []\n   258→\n   259→        try:\n   260→            # 处理输入图像\n   261→            image_data = self._prepare_input_image(image)\n   262→            if not image_data:\n   263→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   264→\n   265→            # 处理参考图（复制到 references 并准备 API 载荷）\n   266→            ref_summary = self._process_reference_assets(\n   267→                reference_images,\n   268→                max_refs=MAX_REFERENCE_IMAGES,\n   269→                expected_outputs=1,\n   270→            )\n   271→            ref_assets = ref_summary.get('assets', [])\n   272→            ref_paths = list(ref_summary.get('paths', []))\n   273→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   274→            if ref_summary.get('errors'):\n   275→                logger.warning(\n   276→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   277→                )\n   278→            if ref_summary.get('warnings'):\n   279→                for warn in ref_summary['warnings']:\n   280→                    logger.warning(f\"参考图提示: {warn}\")\n   281→\n   282→            # 前置参数校验（不改变流程，仅记录摘要）\n   283→            fb = False\n   284→            reason = \"\"\n   285→            try:\n   286→                norm, fb, reason = validate_and_normalize_i2i(\n   287→                    ImageToImageParams(\n   288→                        prompt=prompt,\n   289→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   290→                        guidance_scale=guidance_scale,\n   291→                        seed=(None if seed == -1 else seed),\n   292→                        reference_images=ref_payloads,\n   293→                    )\n   294→                )\n   295→                logger.info(\n   296→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   297→                )\n   298→                if fb:\n   299→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   300→            except Exception as _e:\n   301→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   302→\n   303→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   304→            api_result = self.client.image_to_image(\n   305→                prompt=prompt,\n   306→                image=image_data,\n   307→                guidance_scale=guidance_scale,\n   308→                seed=seed,\n   309→                reference_images=(ref_payloads or None),\n   310→            )\n   311→\n   312→            # 处理input_image字段，避免在日志中输出大量base64数据\n   313→            input_image_info = \"[图像数据]\"\n   314→            if image:\n   315→                if image.startswith(\"data:image/\"):\n   316→                    # 如果是base64数据，只保留格式信息\n   317→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   318→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   319→                elif image.startswith((\"http://\", \"https://\")):\n   320→                    # 如果是URL，保留URL\n   321→                    input_image_info = image\n   322→                else:\n   323→                    # 如果是文件路径，只保留文件名\n   324→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   325→            \n   326→            result = {\n   327→                \"task_id\": task_id,\n   328→                \"success\": True,\n   329→                \"type\": \"image_to_image\",\n   330→                \"prompt\": prompt,\n   331→                \"input_image\": input_image_info,\n   332→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   333→                \"parameters\": {\n   334→                    \"guidance_scale\": guidance_scale, \n   335→                    \"seed\": seed, \n   336→                    \"response_format\": \"url\",  # 固定值\n   337→                    \"watermark\": False,  # 固定值\n   338→                    \"size\": \"adaptive\",  # 固定值\n   339→                    \"model\": self._resolve_model_id(\n   340→                        \"doubao-seededit-3-0-i2i-250628\",\n   341→                        \"doubao-seedream-4-0-250828\",\n   342→                    )  # v4 路径统一使用 Seedream 4.0 模型\n   343→                },\n   344→                \"created_at\": datetime.now().isoformat(),\n   345→                \"usage\": api_result.get(\"usage\", {}),\n   346→            }\n   347→\n   348→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   349→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   350→            result[\"reference_assets\"] = sanitized_refs\n   351→            if ref_summary.get('errors'):\n   352→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   353→            if ref_summary.get('warnings'):\n   354→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   355→            if fb and reason:\n   356→                result[\"fallback_applied\"] = True\n   357→                result[\"fallback_reason\"] = reason\n   358→\n   359→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   360→            logger.info(\n   361→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   362→                len(sanitized_refs),\n   363→                masked_ids or \"-\",\n   364→                self._provider_used(),\n   365→            )\n   366→\n   367→            # 保存到本地\n   368→            if save_local and result.get(\"image_url\"):\n   369→                local_result = self._save_image_locally(result)\n   370→                result.update(local_result)\n   371→                if local_result.get('local_save_error'):\n   372→                    self._cleanup_reference_paths(ref_paths)\n   373→                    result[\"parameters\"][\"reference_assets\"] = []\n   374→                    result[\"reference_assets\"] = []\n   375→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   376→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   377→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   378→\n   379→            logger.success(f\"图生图任务完成: {task_id}\")\n   380→            return result\n   381→\n   382→        except Exception as e:\n   383→            # 避免在日志中显示可能包含base64数据的异常信息\n   384→            error_msg = str(e)\n   385→            if len(error_msg) > 200:\n   386→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   387→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   388→            self._cleanup_reference_paths(ref_paths)\n   389→            return {\n   390→                \"task_id\": task_id,\n   391→                \"success\": False,\n   392→                \"error\": error_msg,\n   393→                \"type\": \"image_to_image\"\n   394→            }\n   395→\n   396→    def batch_generate_text_to_image(\n   397→        self,\n   398→        prompts: List[str],\n   399→        size: str = \"1024x1024\",\n   400→        guidance_scale: float = 2.5,\n   401→        save_local: bool = True,\n   402→    ) -> List[Dict[str, Any]]:\n   403→        \"\"\"\n   404→        批量生成文生图（顺序执行，保持向后兼容）\n   405→\n   406→        Args:\n   407→            prompts: 提示词列表\n   408→            size: 图像尺寸\n   409→            guidance_scale: 提示词一致性\n   410→            save_local: 是否保存到本地\n   411→\n   412→        Returns:\n   413→            List[Dict]: 生成结果列表\n   414→        \n   415→        Note:\n   416→            水印参数已固定为False，不再需要前端控制\n   417→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   418→        \"\"\"\n   419→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   420→\n   421→        results = []\n   422→        for i, prompt in enumerate(prompts, 1):\n   423→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   424→\n   425→            result = self.generate_text_to_image(\n   426→                prompt=prompt,\n   427→                size=size,\n   428→                guidance_scale=guidance_scale,\n   429→                save_local=save_local,\n   430→                generation_id=None,\n   431→            )\n   432→\n   433→            results.append(result)\n   434→\n   435→        success_count = sum(1 for r in results if r[\"success\"])\n   436→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   437→\n   438→        return results\n   439→\n   440→    def concurrent_generate_text_to_image(\n   441→        self,\n   442→        prompt: str,\n   443→        count: int = 4,\n   444→        size: str = \"1024x1024\",\n   445→        guidance_scale: float = 2.5,\n   446→        seed: int = -1,\n   447→        save_local: bool = True,\n   448→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   449→        max_workers: int = 5,\n   450→        derived_ids: Optional[List[str]] = None,\n   451→        generation_id: Optional[str] = None,\n   452→        model_variant: Optional[str] = None,\n   453→    ) -> Dict[str, Any]:\n   454→        \"\"\"\n   455→        并发生成多张文生图\n   456→\n   457→        Args:\n   458→            prompt: 图像生成提示词\n   459→            count: 生成图片数量，默认4张，最多10张\n   460→            size: 图像尺寸\n   461→            guidance_scale: 引导强度\n   462→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   463→            save_local: 是否保存到本地\n   464→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   465→            max_workers: 最大并发数\n   466→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   467→\n   468→        Returns:\n   469→            Dict: 包含所有任务结果的字典\n   470→        \"\"\"\n   471→        # 验证参数\n   472→        if count < 1 or count > 10:\n   473→            raise ValueError(\"生成数量必须在1-10之间\")\n   474→        \n   475→        if max_workers > count:\n   476→            max_workers = count\n   477→        \n   478→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   479→        \n   480→        # 生成批次ID\n   481→        batch_id = str(uuid.uuid4())\n   482→        start_time = time.time()\n   483→\n   484→        slots = max(1, count)\n   485→        per_ids: List[str] = list(derived_ids or [])\n   486→        if len(per_ids) < slots:\n   487→            base = generation_id or batch_id\n   488→            for idx in range(len(per_ids), slots):\n   489→                per_ids.append(f\"{base}_{idx + 1}\")\n   490→        \n   491→        # 准备任务参数\n   492→        tasks = []\n   493→        for i in range(count):\n   494→            # 为每个任务生成不同的种子（如果seed为-1）\n   495→            task_seed = seed if seed != -1 else None\n   496→            gen_id = per_ids[i] if i < len(per_ids) else None\n   497→            tasks.append({\n   498→                'prompt': prompt,\n   499→                'size': size,\n   500→                'guidance_scale': guidance_scale,\n   501→                'seed': task_seed,\n   502→                'save_local': save_local,\n   503→                'task_index': i + 1,\n   504→                'generation_id': gen_id,\n   505→                'model_variant': model_variant,\n   506→            })\n   507→        \n   508→        # 使用线程池并发执行\n   509→        results = []\n   510→        completed_count = 0\n   511→        \n   512→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   513→            # 提交所有任务\n   514→            future_to_task = {\n   515→                executor.submit(self._execute_single_text_to_image_task, task): task \n   516→                for task in tasks\n   517→            }\n   518→            \n   519→            # 收集结果\n   520→            for future in as_completed(future_to_task):\n   521→                task = future_to_task[future]\n   522→                try:\n   523→                    result = future.result()\n   524→                    result['task_index'] = task['task_index']\n   525→                    result['batch_id'] = batch_id\n   526→                    results.append(result)\n   527→                    \n   528→                    completed_count += 1\n   529→                    \n   530→                    # 调用进度回调\n   531→                    if progress_callback:\n   532→                        try:\n   533→                            progress_callback(completed_count, count, result)\n   534→                        except Exception as e:\n   535→                            logger.warning(f\"进度回调执行失败: {e}\")\n   536→                    \n   537→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   538→                    \n   539→                except Exception as e:\n   540→                    error_result = {\n   541→                        'task_index': task['task_index'],\n   542→                        'batch_id': batch_id,\n   543→                        'success': False,\n   544→                        'error': str(e),\n   545→                        'type': 'text_to_image'\n   546→                    }\n   547→                    results.append(error_result)\n   548→                    completed_count += 1\n   549→                    \n   550→                    if progress_callback:\n   551→                        try:\n   552→                            progress_callback(completed_count, count, error_result)\n   553→                        except Exception as e:\n   554→                            logger.warning(f\"进度回调执行失败: {e}\")\n   555→                    \n   556→                    # 避免在日志中显示可能包含base64数据的异常信息\n   557→                    error_msg = str(e)\n   558→                    if len(error_msg) > 200:\n   559→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   560→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   561→        \n   562→        # 按task_index排序\n   563→        results.sort(key=lambda x: x.get('task_index', 0))\n   564→        \n   565→        # 统计结果\n   566→        success_count = sum(1 for r in results if r.get('success', False))\n   567→        total_time = time.time() - start_time\n   568→        \n   569→        batch_result = {\n   570→            'batch_id': batch_id,\n   571→            'success': True,\n   572→            'prompt': prompt,\n   573→            'total_count': count,\n   574→            'success_count': success_count,\n   575→            'failed_count': count - success_count,\n   576→            'total_time': round(total_time, 2),\n   577→            'average_time': round(total_time / count, 2),\n   578→            'results': results,\n   579→            'parameters': {\n   580→                'size': size,\n   581→                'guidance_scale': guidance_scale,\n   582→                'seed': seed,\n   583→                'max_workers': max_workers\n   584→            },\n   585→            'derived_ids': per_ids,\n   586→            'created_at': datetime.now().isoformat()\n   587→        }\n   588→        \n   589→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   590→        return batch_result\n   591→\n   592→    def concurrent_generate_image_to_image(\n   593→        self,\n   594→        prompt: str,\n   595→        image: str,\n   596→        count: int = 4,\n   597→        guidance_scale: float = 5.5,\n   598→        seed: int = -1,\n   599→        save_local: bool = True,\n   600→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   601→        max_workers: int = 5,\n   602→        derived_ids: Optional[List[str]] = None,\n   603→        generation_id: Optional[str] = None,\n   604→    ) -> Dict[str, Any]:\n   605→        \"\"\"\n   606→        并发生成多张图生图\n   607→\n   608→        Args:\n   609→            prompt: 编辑提示词\n   610→            image: 输入图像路径或URL\n   611→            count: 生成图片数量，默认4张，最多10张\n   612→            guidance_scale: 引导强度\n   613→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   614→            save_local: 是否保存到本地\n   615→            progress_callback: 进度回调函数\n   616→            max_workers: 最大并发数\n   617→\n   618→        Returns:\n   619→            Dict: 包含所有任务结果的字典\n   620→        \"\"\"\n   621→        # 验证参数\n   622→        if count < 1 or count > 10:\n   623→            raise ValueError(\"生成数量必须在1-10之间\")\n   624→        \n   625→        if max_workers > count:\n   626→            max_workers = count\n   627→        \n   628→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   629→        \n   630→        # 生成批次ID\n   631→        batch_id = str(uuid.uuid4())\n   632→        start_time = time.time()\n   633→        \n   634→        slots = max(1, count)\n   635→        per_ids: List[str] = list(derived_ids or [])\n   636→        if len(per_ids) < slots:\n   637→            base = generation_id or batch_id\n   638→            for idx in range(len(per_ids), slots):\n   639→                per_ids.append(f\"{base}_{idx + 1}\")\n   640→        \n   641→        # 准备输入图像\n   642→        image_data = self._prepare_input_image(image)\n   643→        if not image_data:\n   644→            return {\n   645→                'batch_id': batch_id,\n   646→                'success': False,\n   647→                'error': '无法处理输入图像',\n   648→                'type': 'image_to_image'\n   649→            }\n   650→        \n   651→        # 准备任务参数\n   652→        tasks = []\n   653→        for i in range(count):\n   654→            task_seed = seed if seed != -1 else None\n   655→            gen_id = per_ids[i] if i < len(per_ids) else None\n   656→            tasks.append({\n   657→                'prompt': prompt,\n   658→                'image': image_data,\n   659→                'guidance_scale': guidance_scale,\n   660→                'seed': task_seed,\n   661→                'save_local': save_local,\n   662→                'task_index': i + 1,\n   663→                'generation_id': gen_id\n   664→            })\n   665→        \n   666→        # 使用线程池并发执行\n   667→        results = []\n   668→        completed_count = 0\n   669→        \n   670→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   671→            # 提交所有任务\n   672→            future_to_task = {\n   673→                executor.submit(self._execute_single_image_to_image_task, task): task \n   674→                for task in tasks\n   675→            }\n   676→            \n   677→            # 收集结果\n   678→            for future in as_completed(future_to_task):\n   679→                task = future_to_task[future]\n   680→                try:\n   681→                    result = future.result()\n   682→                    result['task_index'] = task['task_index']\n   683→                    result['batch_id'] = batch_id\n   684→                    results.append(result)\n   685→                    \n   686→                    completed_count += 1\n   687→                    \n   688→                    # 调用进度回调\n   689→                    if progress_callback:\n   690→                        try:\n   691→                            progress_callback(completed_count, count, result)\n   692→                        except Exception as e:\n   693→                            logger.warning(f\"进度回调执行失败: {e}\")\n   694→                    \n   695→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   696→                    \n   697→                except Exception as e:\n   698→                    error_result = {\n   699→                        'task_index': task['task_index'],\n   700→                        'batch_id': batch_id,\n   701→                        'success': False,\n   702→                        'error': str(e),\n   703→                        'type': 'image_to_image'\n   704→                    }\n   705→                    results.append(error_result)\n   706→                    completed_count += 1\n   707→                    \n   708→                    if progress_callback:\n   709→                        try:\n   710→                            progress_callback(completed_count, count, error_result)\n   711→                        except Exception as e:\n   712→                            logger.warning(f\"进度回调执行失败: {e}\")\n   713→                    \n   714→                    # 避免在日志中显示可能包含base64数据的异常信息\n   715→                    error_msg = str(e)\n   716→                    if len(error_msg) > 200:\n   717→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   718→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   719→        \n   720→        # 按task_index排序\n   721→        results.sort(key=lambda x: x.get('task_index', 0))\n   722→        \n   723→        # 统计结果\n   724→        success_count = sum(1 for r in results if r.get('success', False))\n   725→        total_time = time.time() - start_time\n   726→        \n   727→        # 处理input_image字段，避免在日志中输出大量base64数据\n   728→        input_image_info = \"[图像数据]\"\n   729→        if image:\n   730→            if image.startswith(\"data:image/\"):\n   731→                # 如果是base64数据，只保留格式信息\n   732→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   733→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   734→            elif image.startswith((\"http://\", \"https://\")):\n   735→                # 如果是URL，保留URL\n   736→                input_image_info = image\n   737→            else:\n   738→                # 如果是文件路径，只保留文件名\n   739→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   740→        \n   741→        batch_result = {\n   742→            'batch_id': batch_id,\n   743→            'success': True,\n   744→            'prompt': prompt,\n   745→            'input_image': input_image_info,\n   746→            'total_count': count,\n   747→            'success_count': success_count,\n   748→            'failed_count': count - success_count,\n   749→            'total_time': round(total_time, 2),\n   750→            'average_time': round(total_time / count, 2),\n   751→            'results': results,\n   752→            'parameters': {\n   753→                'guidance_scale': guidance_scale,\n   754→                'seed': seed,\n   755→                'max_workers': max_workers\n   756→            },\n   757→            'derived_ids': per_ids,\n   758→            'created_at': datetime.now().isoformat()\n   759→        }\n   760→        \n   761→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   762→        return batch_result\n   763→\n   764→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   765→        \"\"\"\n   766→        执行单个文生图任务\n   767→        \n   768→        Args:\n   769→            task: 任务参数字典\n   770→            \n   771→        Returns:\n   772→            Dict: 任务执行结果\n   773→        \"\"\"\n   774→        return self.generate_text_to_image(\n   775→            prompt=task['prompt'],\n   776→            size=task['size'],\n   777→            guidance_scale=task['guidance_scale'],\n   778→            seed=task['seed'],\n   779→            save_local=task['save_local'],\n   780→            generation_id=task.get('generation_id'),\n   781→            model_variant=task.get('model_variant'),\n   782→        )\n   783→    \n   784→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   785→        \"\"\"\n   786→        执行单个图生图任务\n   787→        \n   788→        Args:\n   789→            task: 任务参数字典\n   790→            \n   791→        Returns:\n   792→            Dict: 任务执行结果\n   793→        \"\"\"\n   794→        # 生成唯一ID，优先使用外部传入的generation_id\n   795→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   796→        \n   797→        try:\n   798→            # 直接使用已经处理好的图片数据，避免重复处理\n   799→            image_data = task['image']\n   800→            \n   801→            # 调用API生成图像\n   802→            api_result = self.client.image_to_image(\n   803→                prompt=task['prompt'], \n   804→                image=image_data, \n   805→                guidance_scale=task['guidance_scale'], \n   806→                seed=task['seed']\n   807→            )\n   808→            \n   809→            result = {\n   810→                \"task_id\": task_id,\n   811→                \"success\": True,\n   812→                \"type\": \"image_to_image\",\n   813→                \"prompt\": task['prompt'],\n   814→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   815→                \"parameters\": {\n   816→                    \"guidance_scale\": task['guidance_scale'], \n   817→                    \"seed\": task['seed'], \n   818→                    \"response_format\": \"url\",\n   819→                    \"watermark\": False,\n   820→                    \"size\": \"adaptive\",\n   821→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   822→                },\n   823→                \"created_at\": datetime.now().isoformat(),\n   824→                \"usage\": api_result.get(\"usage\", {}),\n   825→            }\n   826→            \n   827→            # 保存到本地\n   828→            if task['save_local'] and result.get(\"image_url\"):\n   829→                local_result = self._save_image_locally(result)\n   830→                result.update(local_result)\n   831→            \n   832→            return result\n   833→            \n   834→        except Exception as e:\n   835→            # 避免在日志中显示可能包含base64数据的异常信息\n   836→            error_msg = str(e)\n   837→            if len(error_msg) > 200:\n   838→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   839→            return {\n   840→                \"task_id\": task_id,\n   841→                \"success\": False,\n   842→                \"error\": error_msg,\n   843→                \"type\": \"image_to_image\"\n   844→            }\n   845→\n   846→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   847→        \"\"\"\n   848→        保存图像到本地并记录元数据\n   849→\n   850→        Args:\n   851→            result: API生成结果\n   852→\n   853→        Returns:\n   854→            Dict: 包含本地文件信息的字典\n   855→        \"\"\"\n   856→        try:\n   857→            # 下载图像\n   858→            image_url = result[\"image_url\"]\n   859→            response = safe_requests_get(image_url, timeout=30)\n   860→\n   861→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   862→            from io import BytesIO\n   863→            real_w, real_h = None, None\n   864→            try:\n   865→                with Image.open(BytesIO(response.content)) as img:\n   866→                    real_w, real_h = int(img.width), int(img.height)\n   867→            except Exception as _e:\n   868→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n   869→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   870→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   871→\n   872→            # 组装元数据（适配UnifiedStorageManager的格式）\n   873→            params = result.get(\"parameters\", {}) or {}\n   874→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n   875→            try:\n   876→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n   877→                    from math import gcd\n   878→                    g = gcd(real_w, real_h)\n   879→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n   880→            except Exception:\n   881→                pass\n   882→\n   883→            metadata = {\n   884→                'generation_id': result.get(\"task_id\", \"\"),\n   885→                'prompt': result.get(\"prompt\", \"\"),\n   886→                'parameters': params,\n   887→                'model': params.get(\"model\", \"seedream\"),\n   888→                'width': real_w,\n   889→                'height': real_h,\n   890→                'generation_time': result.get(\"generation_time\", 0),\n   891→                'batch_id': result.get(\"batch_id\", \"\"),\n   892→                'status': 'completed'\n   893→            }\n   894→            \n   895→            # 使用统一存储管理器保存文件\n   896→            save_result = self.storage_manager.save_content_file(\n   897→                content_type='images',\n   898→                file_data=response.content,\n   899→                url=image_url,\n   900→                metadata=metadata\n   901→            )\n   902→\n   903→            # 获取图像信息（再次确认像素尺寸）\n   904→            image_info = self._get_image_info(Path(save_result['local_path']))\n   905→            file_size = Path(save_result['local_path']).stat().st_size\n   906→\n   907→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n   908→\n   909→            result_obj = {\n   910→                \"local_path\": save_result['local_path'],\n   911→                \"filename\": Path(save_result['local_path']).name,\n   912→                \"file_size\": file_size,\n   913→                \"image_info\": image_info,\n   914→                \"file_path\": save_result['local_path'],  # 保持兼容性\n   915→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n   916→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n   917→                \"file_id\": save_result.get('file_id'),\n   918→                \"relative_path\": save_result.get('relative_path'),\n   919→            }\n   920→            try:\n   921→                w = image_info.get('width') if isinstance(image_info, dict) else None\n   922→                h = image_info.get('height') if isinstance(image_info, dict) else None\n   923→                logger.info(\n   924→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n   925→                )\n   926→            except Exception:\n   927→                pass\n   928→\n   929→            # 体验版本地图片水印（使用统一水印服务）\n   930→            if should_add_watermark():\n   931→                try:\n   932→                    from edition.watermark_service import WatermarkService\n   933→\n   934→                    watermark_text = get_watermark_text() or \"PIGEON\"\n   935→                    try:\n   936→                        opacity = get_watermark_opacity()\n   937→                    except Exception:\n   938→                        opacity = 0.3\n   939→                    opacity = max(0.0, min(opacity, 1.0))\n   940→\n   941→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n   942→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n   943→                    if watermark_applied:\n   944→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n   945→                        result_obj[\"watermark_applied\"] = True\n   946→                    else:\n   947→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n   948→                        result_obj[\"watermark_applied\"] = False\n   949→                except Exception as e:\n   950→                    logger.warning(f\"添加图片水印时出错: {e}\")\n   951→                    result_obj[\"watermark_applied\"] = False\n   952→\n   953→            return result_obj\n   954→\n   955→        except Exception as e:\n   956→            logger.error(f\"保存图像到本地失败: {e}\")\n   957→            try:\n   958→                logger.info(\"摘要|operation=save_image status=failed\")\n   959→            except Exception:\n   960→                pass\n   961→            return {\"local_save_error\": str(e)}\n   962→\n   963→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n   964→        checksum = hashlib.sha1(file_data).hexdigest()\n   965→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n   966→        return f\"ref_{ts}_{checksum[:8]}\"\n   967→\n   968→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n   969→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n   970→        source_meta: Dict[str, Any] = {}\n   971→        raw = ref\n   972→        if isinstance(ref, dict):\n   973→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n   974→                if ref.get(key) is not None:\n   975→                    source_meta[key] = ref.get(key)\n   976→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n   977→        if raw is None:\n   978→            return None\n   979→\n   980→        extension = source_meta.get('extension')\n   981→        data = None\n   982→        source_repr = source_meta.get('source')\n   983→\n   984→        try:\n   985→            if isinstance(raw, bytes):\n   986→                data = raw\n   987→            elif isinstance(raw, str):\n   988→                stripped = raw.strip()\n   989→                if stripped.startswith('data:') and ';base64,' in stripped:\n   990→                    header, payload = stripped.split(';base64,', 1)\n   991→                    mime_part = header[5:]\n   992→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n   993→                    data = base64.b64decode(payload)\n   994→                    source_repr = source_repr or mime_part\n   995→                    source_meta.setdefault('type', 'image')\n   996→                elif stripped.startswith(('http://', 'https://')):\n   997→                    resp = safe_requests_get(stripped, timeout=15)\n   998→                    data = resp.content\n   999→                    parsed = urlparse(stripped)\n  1000→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1001→                    source_repr = source_repr or stripped\n  1002→                    source_meta.setdefault('source_url', stripped)\n  1003→                else:\n  1004→                    path = Path(stripped)\n  1005→                    if not path.exists():\n  1006→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1007→                        return None\n  1008→                    data = path.read_bytes()\n  1009→                    extension = extension or path.suffix or '.png'\n  1010→                    source_repr = source_repr or path.name\n  1011→                    source_meta.setdefault('source_path', str(path))\n  1012→            else:\n  1013→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1014→                return None\n  1015→        except Exception as exc:\n  1016→            logger.warning(f\"加载参考图失败: {exc}\")\n  1017→            return None\n  1018→\n  1019→        if data is None:\n  1020→            return None\n  1021→\n  1022→        width = source_meta.get('width')\n  1023→        height = source_meta.get('height')\n  1024→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1025→            try:\n  1026→                from io import BytesIO\n  1027→\n  1028→                with Image.open(BytesIO(data)) as img:\n  1029→                    width = img.width\n  1030→                    height = img.height\n  1031→            except Exception:\n  1032→                pass\n  1033→\n  1034→        source_meta['width'] = width\n  1035→        source_meta['height'] = height\n  1036→        source_meta.setdefault('type', 'image')\n  1037→        source_meta['source'] = source_repr or source_meta.get('source')\n  1038→\n  1039→        return data, extension, source_meta\n  1040→\n  1041→    def _process_reference_assets(\n  1042→        self,\n  1043→        references: Optional[List[Any]],\n  1044→        *,\n  1045→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1046→        expected_outputs: int = 1,\n  1047→    ) -> Dict[str, Any]:\n  1048→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1049→        stored: List[Dict[str, Any]] = []\n  1050→        absolute_paths: List[str] = []\n  1051→        errors: List[str] = []\n  1052→        warnings: List[str] = []\n  1053→\n  1054→        if not references:\n  1055→            return {\n  1056→                'assets': stored,\n  1057→                'paths': absolute_paths,\n  1058→                'errors': errors,\n  1059→                'warnings': warnings,\n  1060→            }\n  1061→\n  1062→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1063→            warnings.append(\n  1064→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1065→            )\n  1066→            references = references[:max_refs]\n  1067→\n  1068→        for order, item in enumerate(references):\n  1069→            load_result = self._load_reference_source(item)\n  1070→            if not load_result:\n  1071→                errors.append(f\"ref[{order}] 加载失败\")\n  1072→                continue\n  1073→\n  1074→            file_data, extension, meta = load_result\n  1075→            meta.setdefault('order', order)\n  1076→            meta.setdefault('kind', meta.get('type', 'image'))\n  1077→\n  1078→            try:\n  1079→                asset_id = self._generate_reference_asset_id(file_data)\n  1080→                record = self.storage_manager.save_reference_asset(\n  1081→                    'images',\n  1082→                    file_data,\n  1083→                    asset_id=asset_id,\n  1084→                    extension=extension,\n  1085→                    metadata=meta,\n  1086→                )\n  1087→                try:\n  1088→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1089→                except Exception:\n  1090→                    record['_payload_b64'] = None\n  1091→                record['_source_meta'] = meta\n  1092→                stored.append(record)\n  1093→                if record.get('absolute_path'):\n  1094→                    absolute_paths.append(record['absolute_path'])\n  1095→            except Exception as exc:\n  1096→                logger.warning(f\"保存参考图失败: {exc}\")\n  1097→                errors.append(f\"ref[{order}] 保存失败\")\n  1098→\n  1099→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1100→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1101→            if len(stored) > allowed:\n  1102→                warnings.append(\n  1103→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1104→                )\n  1105→                stored = stored[:allowed]\n  1106→                absolute_paths = absolute_paths[:allowed]\n  1107→\n  1108→        return {\n  1109→            'assets': stored,\n  1110→            'paths': absolute_paths,\n  1111→            'errors': errors,\n  1112→            'warnings': warnings,\n  1113→        }\n  1114→\n  1115→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1116→        payloads: List[str] = []\n  1117→        for asset in assets or []:\n  1118→            payload = asset.get('_payload_b64')\n  1119→            if not payload:\n  1120→                continue\n  1121→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1122→            mime = 'image/png'\n  1123→            try:\n  1124→                if path_hint:\n  1125→                    suffix = Path(path_hint).suffix.lower()\n  1126→                    if suffix in {'.jpg', '.jpeg'}:\n  1127→                        mime = 'image/jpeg'\n  1128→                    elif suffix == '.webp':\n  1129→                        mime = 'image/webp'\n  1130→                    elif suffix == '.bmp':\n  1131→                        mime = 'image/bmp'\n  1132→                    elif suffix == '.gif':\n  1133→                        mime = 'image/gif'\n  1134→            except Exception:\n  1135→                pass\n  1136→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1137→        return payloads\n  1138→\n  1139→    def _resolve_model_id(self, default_model: str, v4_model: str) -> str:\n  1140→        provider = (self.client.last_provider() or \"\").lower()\n  1141→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1142→            return v4_model\n  1143→        return default_model\n  1144→\n  1145→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1146→        cleaned: List[Dict[str, Any]] = []\n  1147→        for rec in assets or []:\n  1148→            rec.pop('_payload_b64', None)\n  1149→            rec.pop('_source_meta', None)\n  1150→            rec.pop('absolute_path', None)\n  1151→            cleaned.append({\n  1152→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1153→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1154→                'type': rec.get('type'),\n  1155→                'kind': rec.get('kind'),\n  1156→                'source': rec.get('source'),\n  1157→                'order': rec.get('order'),\n  1158→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1159→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1160→                'width': rec.get('width'),\n  1161→                'height': rec.get('height'),\n  1162→                'created_at': rec.get('created_at'),\n  1163→            })\n  1164→        return cleaned\n  1165→\n  1166→    @staticmethod\n  1167→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1168→        masked: List[str] = []\n  1169→        for rec in assets or []:\n  1170→            rid = rec.get('id') or ''\n  1171→            if not rid:\n  1172→                continue\n  1173→            masked.append(f\"{rid[:6]}***\")\n  1174→        return \",\".join(masked)\n  1175→\n  1176→    @staticmethod\n  1177→    def _provider_hint() -> str:\n  1178→        try:\n  1179→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1180→        except Exception:\n  1181→            return \"unknown\"\n  1182→\n  1183→    def _provider_used(self) -> str:\n  1184→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1185→        if provider:\n  1186→            return provider\n  1187→        return self._provider_hint()\n  1188→\n  1189→    @staticmethod\n  1190→    def _cleanup_reference_paths(paths: List[str]):\n  1191→        for path in paths or []:\n  1192→            try:\n  1193→                if path and Path(path).exists():\n  1194→                    Path(path).unlink(missing_ok=True)\n  1195→            except Exception as exc:\n  1196→                logger.debug(f\"参考图清理失败: {exc}\")\n  1197→\n  1198→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1199→        \"\"\"\n  1200→        准备输入图像，支持本地文件和URL\n  1201→        \n  1202→        Args:\n  1203→            image_path: 图像路径（本地路径或URL）\n  1204→            \n  1205→        Returns:\n  1206→            str: 图像URL、base64数据或None\n  1207→        \"\"\"\n  1208→        try:\n  1209→            # 如果是URL，直接返回\n  1210→            if image_path.startswith((\"http://\", \"https://\")):\n  1211→                return image_path\n  1212→\n  1213→            # 如果是本地文件，转换为Base64\n  1214→            local_path = Path(image_path)\n  1215→            if local_path.exists():\n  1216→                with open(local_path, \"rb\") as f:\n  1217→                    image_data = f.read()\n  1218→\n  1219→                # 检测图像格式\n  1220→                image = Image.open(local_path)\n  1221→                format_name = image.format.lower()\n  1222→\n  1223→                # 转换为Base64\n  1224→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1225→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1226→\n  1227→            logger.error(f\"图像文件不存在: {image_path}\")\n  1228→            return None\n  1229→\n  1230→        except Exception as e:\n  1231→            logger.error(f\"处理输入图像失败: {e}\")\n  1232→            return None\n  1233→\n  1234→    def _extract_width_from_size(self, size: str) -> int:\n  1235→        \"\"\"\n  1236→        从尺寸字符串中提取宽度\n  1237→        \n  1238→        Args:\n  1239→            size: 尺寸字符串，如 \"1024x1024\"\n  1240→            \n  1241→        Returns:\n  1242→            int: 宽度值\n  1243→        \"\"\"\n  1244→        try:\n  1245→            return int(size.split('x')[0])\n  1246→        except (ValueError, IndexError):\n  1247→            return 1024  # 默认值\n  1248→    \n  1249→    def _extract_height_from_size(self, size: str) -> int:\n  1250→        \"\"\"\n  1251→        从尺寸字符串中提取高度\n  1252→        \n  1253→        Args:\n  1254→            size: 尺寸字符串，如 \"1024x1024\"\n  1255→            \n  1256→        Returns:\n  1257→            int: 高度值\n  1258→        \"\"\"\n  1259→        try:\n  1260→            return int(size.split('x')[1])\n  1261→        except (ValueError, IndexError):\n  1262→            return 1024  # 默认值\n  1263→\n  1264→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1265→        \"\"\"\n  1266→        获取图像信息\n  1267→\n  1268→        Args:\n  1269→            image_path: 图像文件路径\n  1270→\n  1271→        Returns:\n  1272→            Dict: 图像信息\n  1273→        \"\"\"\n  1274→        try:\n  1275→            with Image.open(image_path) as img:\n  1276→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1277→        except Exception as e:\n  1278→            logger.error(f\"获取图像信息失败: {e}\")\n  1279→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1280→\n  1281→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1282→        \"\"\"\n  1283→        获取图像生成历史记录\n  1284→\n  1285→        Args:\n  1286→            limit: 返回记录数量限制\n  1287→\n  1288→        Returns:\n  1289→            List[Dict]: 历史记录列表\n  1290→        \"\"\"\n  1291→        return self.storage_manager.load_history('images', limit=limit)\n  1292→\n  1293→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1294→        \"\"\"\n  1295→        根据提示词关键字搜索历史记录\n  1296→\n  1297→        Args:\n  1298→            keyword: 搜索关键字\n  1299→\n  1300→        Returns:\n  1301→            List[Dict]: 匹配的记录列表\n  1302→        \"\"\"\n  1303→        # 获取所有历史记录并在内存中过滤\n  1304→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1305→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1306→\n  1307→    def get_statistics(self) -> Dict[str, Any]:\n  1308→        \"\"\"\n  1309→        获取生成统计信息\n  1310→\n  1311→        Returns:\n  1312→            Dict: 统计信息\n  1313→        \"\"\"\n  1314→        try:\n  1315→            # 使用统一存储管理器获取存储统计\n  1316→            storage_stats = self.storage_manager.get_storage_stats()\n  1317→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1318→            \n  1319→            # 获取历史记录进行详细统计\n  1320→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1321→            \n  1322→            if not all_records:\n  1323→                return {\n  1324→                    \"total_images\": 0,\n  1325→                    \"text_to_image_count\": 0,\n  1326→                    \"image_to_image_count\": 0,\n  1327→                    \"total_file_size\": 0,\n  1328→                    \"average_file_size\": 0,\n  1329→                    \"most_common_size\": \"unknown\"\n  1330→                }\n  1331→\n  1332→            # 统计不同类型的图片数量\n  1333→            text_to_image_count = 0\n  1334→            image_to_image_count = 0\n  1335→            total_file_size = 0\n  1336→            sizes = []\n  1337→            \n  1338→            for record in all_records:\n  1339→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1340→                if 'input_image' in record.get('parameters', {}):\n  1341→                    image_to_image_count += 1\n  1342→                else:\n  1343→                    text_to_image_count += 1\n  1344→                \n  1345→                # 计算文件大小\n  1346→                file_size = record.get('file_size', 0)\n  1347→                if isinstance(file_size, str) and file_size.isdigit():\n  1348→                    file_size = int(file_size)\n  1349→                elif not isinstance(file_size, (int, float)):\n  1350→                    file_size = 0\n  1351→                total_file_size += file_size\n  1352→                \n  1353→                # 收集尺寸信息\n  1354→                width = record.get('width', 0)\n  1355→                height = record.get('height', 0)\n  1356→                if width and height:\n  1357→                    sizes.append(f\"{width}x{height}\")\n  1358→\n  1359→            stats = {\n  1360→                \"total_images\": len(all_records),\n  1361→                \"text_to_image_count\": text_to_image_count,\n  1362→                \"image_to_image_count\": image_to_image_count,\n  1363→                \"total_file_size\": total_file_size,\n  1364→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1365→                \"most_common_size\": \"unknown\",\n  1366→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1367→            }\n  1368→\n  1369→            # 最常用的尺寸\n  1370→            if sizes:\n  1371→                from collections import Counter\n  1372→                size_counts = Counter(sizes)\n  1373→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1374→\n  1375→            return stats\n  1376→\n  1377→        except Exception as e:\n  1378→            logger.error(f\"获取统计信息失败: {e}\")\n  1379→            return {\n  1380→                \"total_images\": 0,\n  1381→                \"text_to_image_count\": 0,\n  1382→                \"image_to_image_count\": 0,\n  1383→                \"total_file_size\": 0,\n  1384→                \"average_file_size\": 0,\n  1385→                \"most_common_size\": \"unknown\"\n  1386→            }\n  1387→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"96f2ee17-7827-4870-90fb-5994e0920777","timestamp":"2025-12-09T03:56:32.145Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config_api import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n        \n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n        \n        # 根据 model_variant 设置环境变量\n        if model_variant == 'seedream_v4':\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4\"\n        else:\n            # 默认使用 volc_v3\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v3\"\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n            )\n\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size, \n                    \"guidance_scale\": guidance_scale, \n                    \"seed\": seed, \n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                    )\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale, \n                    \"seed\": seed, \n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                    )  # v4 路径统一使用 Seedream 4.0 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1387,"startLine":1,"totalLines":1387}}}
{"parentUuid":"96f2ee17-7827-4870-90fb-5994e0920777","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_0131bCdrPWXxnZWqXfsSEoF7","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me explore the provider layer and config files for model selection logic (Pro vs Lite routing):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":49654,"cache_creation_input_tokens":21891,"cache_read_input_tokens":15881,"cache_creation":{"ephemeral_5m_input_tokens":21891,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"02839ce3-3c52-4242-8448-c59ac89efa20","timestamp":"2025-12-09T03:56:46.392Z"}
{"parentUuid":"02839ce3-3c52-4242-8448-c59ac89efa20","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_0131bCdrPWXxnZWqXfsSEoF7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WsJsQFRJHDLf9RS2noKTTx","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":49654,"cache_creation_input_tokens":21891,"cache_read_input_tokens":15881,"cache_creation":{"ephemeral_5m_input_tokens":21891,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"52714955-5740-4c34-9922-311bca17c603","timestamp":"2025-12-09T03:56:47.283Z"}
{"parentUuid":"52714955-5740-4c34-9922-311bca17c603","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_0131bCdrPWXxnZWqXfsSEoF7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TknjtCXpMG3LaD5PDU7DLv","name":"Glob","input":{"pattern":"modules/provider/**/*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":49654,"cache_creation_input_tokens":21891,"cache_read_input_tokens":15881,"cache_creation":{"ephemeral_5m_input_tokens":21891,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"type":"assistant","uuid":"c9f293a4-1e60-4ce4-a86a-fb6054599e44","timestamp":"2025-12-09T03:56:47.838Z"}
{"parentUuid":"c9f293a4-1e60-4ce4-a86a-fb6054599e44","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_0131bCdrPWXxnZWqXfsSEoF7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YGisju3Lqz5AMJ8upB1NVj","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/config_api.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":49654,"cache_creation_input_tokens":21891,"cache_read_input_tokens":15881,"cache_creation":{"ephemeral_5m_input_tokens":21891,"ephemeral_1h_input_tokens":0},"output_tokens":191,"service_tier":"standard"}},"type":"assistant","uuid":"941e910f-46dd-4ff3-889b-5b18579c655f","timestamp":"2025-12-09T03:56:48.525Z"}
{"parentUuid":"941e910f-46dd-4ff3-889b-5b18579c655f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WsJsQFRJHDLf9RS2noKTTx","type":"tool_result","content":"     1→# Seedance配置管理\n     2→# 定义模型、状态和配置常量\n     3→\n     4→from enum import Enum\n     5→from typing import Dict, List\n     6→\n     7→\n     8→class SeedanceModels(Enum):\n     9→    \"\"\"Seedance模型枚举\"\"\"\n    10→    PRO = \"doubao-seedance-1-0-pro-250528\"\n    11→    LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    12→    LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n    13→\n    14→\n    15→class TaskStatus(Enum):\n    16→    \"\"\"任务状态枚举\"\"\"\n    17→    PENDING = \"pending\"\n    18→    PROCESSING = \"processing\"\n    19→    RUNNING = \"running\"\n    20→    SUCCEEDED = \"succeeded\"\n    21→    FAILED = \"failed\"\n    22→    CANCELLED = \"cancelled\"\n    23→    \n    24→    @classmethod\n    25→    def is_terminal(cls, status: str) -> bool:\n    26→        \"\"\"判断是否为终态\"\"\"\n    27→        return status in [cls.SUCCEEDED.value, cls.FAILED.value, cls.CANCELLED.value]\n    28→    \n    29→    @classmethod\n    30→    def is_active(cls, status: str) -> bool:\n    31→        \"\"\"判断是否为活跃状态\"\"\"\n    32→        return status in [cls.PENDING.value, cls.PROCESSING.value, cls.RUNNING.value]\n    33→\n    34→\n    35→class SeedanceConfig:\n    36→    \"\"\"Seedance配置管理\"\"\"\n    37→    \n    38→    # API端点\n    39→    ENDPOINTS = {\n    40→        \"create_task\": \"/contents/generations/tasks\",\n    41→        \"query_task\": \"/contents/generations/tasks/{task_id}\",\n    42→        # 根据实测，取消为对任务资源本身执行DELETE，而非 /cancel 动作\n    43→        \"cancel_task\": \"/contents/generations/tasks/{task_id}\",\n    44→        \"list_tasks\": \"/contents/generations/tasks\"\n    45→    }\n    46→    \n    47→    # 轮询配置\n    48→    POLLING = {\n    49→        \"max_wait_time\": 600,  # 10分钟\n    50→        \"intervals\": [2, 3, 5, 8, 10],  # 递增间隔\n    51→        \"max_retries\": 3\n    52→    }\n    53→    \n    54→    # 模型价格（元/百万token）\n    55→    MODEL_PRICING = {\n    56→        SeedanceModels.PRO.value: 15,\n    57→        SeedanceModels.LITE_T2V.value: 10,\n    58→        SeedanceModels.LITE_I2V.value: 10\n    59→    }\n    60→    \n    61→    # 默认参数\n    62→    DEFAULTS = {\n    63→        \"duration\": 8,\n    64→        \"fps\": 24,\n    65→        \"width\": 1920,\n    66→        \"height\": 1080,\n    67→        \"model_type\": \"pro\"\n    68→    }\n    69→    \n    70→    # 支持的分辨率\n    71→    RESOLUTIONS = {\n    72→        \"480p\": {\"width\": 854, \"height\": 480},\n    73→        \"720p\": {\"width\": 1280, \"height\": 720},\n    74→        \"1080p\": {\"width\": 1920, \"height\": 1080}\n    75→    }\n    76→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c3020c52-e619-423f-9469-437f0751a793","timestamp":"2025-12-09T03:56:48.575Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py","content":"# Seedance配置管理\n# 定义模型、状态和配置常量\n\nfrom enum import Enum\nfrom typing import Dict, List\n\n\nclass SeedanceModels(Enum):\n    \"\"\"Seedance模型枚举\"\"\"\n    PRO = \"doubao-seedance-1-0-pro-250528\"\n    LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n\n\nclass TaskStatus(Enum):\n    \"\"\"任务状态枚举\"\"\"\n    PENDING = \"pending\"\n    PROCESSING = \"processing\"\n    RUNNING = \"running\"\n    SUCCEEDED = \"succeeded\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    \n    @classmethod\n    def is_terminal(cls, status: str) -> bool:\n        \"\"\"判断是否为终态\"\"\"\n        return status in [cls.SUCCEEDED.value, cls.FAILED.value, cls.CANCELLED.value]\n    \n    @classmethod\n    def is_active(cls, status: str) -> bool:\n        \"\"\"判断是否为活跃状态\"\"\"\n        return status in [cls.PENDING.value, cls.PROCESSING.value, cls.RUNNING.value]\n\n\nclass SeedanceConfig:\n    \"\"\"Seedance配置管理\"\"\"\n    \n    # API端点\n    ENDPOINTS = {\n        \"create_task\": \"/contents/generations/tasks\",\n        \"query_task\": \"/contents/generations/tasks/{task_id}\",\n        # 根据实测，取消为对任务资源本身执行DELETE，而非 /cancel 动作\n        \"cancel_task\": \"/contents/generations/tasks/{task_id}\",\n        \"list_tasks\": \"/contents/generations/tasks\"\n    }\n    \n    # 轮询配置\n    POLLING = {\n        \"max_wait_time\": 600,  # 10分钟\n        \"intervals\": [2, 3, 5, 8, 10],  # 递增间隔\n        \"max_retries\": 3\n    }\n    \n    # 模型价格（元/百万token）\n    MODEL_PRICING = {\n        SeedanceModels.PRO.value: 15,\n        SeedanceModels.LITE_T2V.value: 10,\n        SeedanceModels.LITE_I2V.value: 10\n    }\n    \n    # 默认参数\n    DEFAULTS = {\n        \"duration\": 8,\n        \"fps\": 24,\n        \"width\": 1920,\n        \"height\": 1080,\n        \"model_type\": \"pro\"\n    }\n    \n    # 支持的分辨率\n    RESOLUTIONS = {\n        \"480p\": {\"width\": 854, \"height\": 480},\n        \"720p\": {\"width\": 1280, \"height\": 720},\n        \"1080p\": {\"width\": 1920, \"height\": 1080}\n    }\n","numLines":76,"startLine":1,"totalLines":76}}}
{"parentUuid":"c3020c52-e619-423f-9469-437f0751a793","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YGisju3Lqz5AMJ8upB1NVj","type":"tool_result","content":"     1→﻿#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Minimal config with placeholders for distribution.\n     5→- Keep API keys empty for end users; they can set in Settings or env.\n     6→- Force storage dir to be configured via env or raises.\n     7→\"\"\"\n     8→\n     9→import os\n    10→from pathlib import Path\n    11→import json\n    12→\n    13→VOLCENGINE_API_KEY = \"\"\n    14→\n    15→# 设置持久化文件（与 SettingsPage/统一配置保持一致）\n    16→_CONFIG_JSON = Path.home() / \".pigeon_dream\" / \"config.json\"\n    17→\n    18→APP_CONFIG = {\n    19→    \"app_name\": \"鸽梦Godream\",\n    20→    \"version\": \"1.3.0\",\n    21→    \"author\": \"AI Assistant\",\n    22→    \"description\": \"PyQt5 local AI content tool\",\n    23→}\n    24→\n    25→IMAGE_GENERATION_DEFAULTS = {\n    26→    \"size\": \"1024x1024\",\n    27→    \"guidance_scale\": 2.5,\n    28→    \"seed\": -1,\n    29→    \"model\": \"doubao-seedream-4-0-250828\",\n    30→    \"watermark\": False,\n    31→}\n    32→\n    33→VIDEO_GENERATION_DEFAULTS = {\n    34→    \"duration\": 4.0,\n    35→    \"motion_strength\": 0.8,\n    36→    \"seed\": -1,\n    37→    \"watermark\": False,\n    38→    \"width\": 1280,\n    39→    \"height\": 720,\n    40→    \"fps\": 24,\n    41→}\n    42→\n    43→LOCAL_WATERMARK_CONFIG = {\n    44→    \"enabled\": False,\n    45→    \"text\": \"\",\n    46→    \"opacity\": 0.0,\n    47→    \"position\": \"bottom_right\",\n    48→    \"font_size\": 0,\n    49→}\n    50→\n    51→API_WATERMARK_CONFIG = {\n    52→    \"image_watermark\": False,\n    53→    \"video_watermark\": False,\n    54→}\n    55→\n    56→\n    57→def validate_api_keys():\n    58→    missing = []\n    59→    if not VOLCENGINE_API_KEY:\n    60→        missing.append(\"VOLCENGINE_API_KEY\")\n    61→    if missing:\n    62→        return False, missing, \"API 密钥未配置\"\n    63→    return True, [], \"API 密钥已配置\"\n    64→\n    65→\n    66→def get_storage_dir():\n    67→    # 优先：环境变量\n    68→    env_path = os.environ.get(\"GEMENG_STORAGE_DIR\")\n    69→    if env_path:\n    70→        p = Path(env_path).expanduser()\n    71→        p.mkdir(parents=True, exist_ok=True)\n    72→        return str(p)\n    73→\n    74→    # 其次：用户配置文件（Settings 保存路径）\n    75→    # 修复：AppConfig 保存到 creation.storage_root_path，需要正确读取嵌套结构\n    76→    try:\n    77→        if _CONFIG_JSON.exists():\n    78→            data = json.loads(_CONFIG_JSON.read_text(encoding=\"utf-8\") or \"{}\")\n    79→            # 优先从 creation 嵌套结构读取（与 AppConfig 保存结构一致）\n    80→            creation = data.get(\"creation\", {})\n    81→            if isinstance(creation, dict):\n    82→                use_custom = creation.get(\"use_custom_storage\", False)\n    83→                custom = creation.get(\"storage_root_path\", \"\")\n    84→                if use_custom and custom:\n    85→                    p = Path(custom).expanduser()\n    86→                    p.mkdir(parents=True, exist_ok=True)\n    87→                    return str(p)\n    88→            # 兼容旧版顶层配置\n    89→            custom = data.get(\"storage_root_path\") or data.get(\"storage_dir\")\n    90→            if custom:\n    91→                p = Path(custom).expanduser()\n    92→                p.mkdir(parents=True, exist_ok=True)\n    93→                return str(p)\n    94→    except Exception:\n    95→        pass\n    96→\n    97→    # 没有配置则报错，引导用户去设置\n    98→    raise ValueError(\"未配置存储路径，请在环境变量 GEMENG_STORAGE_DIR 或应用设置中配置\")\n    99→\n   100→\n   101→def get_api_key(service: str) -> str:\n   102→    s = (service or \"\").lower()\n   103→    key = os.environ.get(\"VOLCENGINE_API_KEY\") or VOLCENGINE_API_KEY\n   104→    if s in {\"volcengine\", \"volc\", \"ark\"}:\n   105→        if not key:\n   106→            raise ValueError(\"火山引擎API密钥未配置，请在设置或环境变量配置\")\n   107→        return key\n   108→    raise ValueError(f\"不支持的服务: {service}\")\n   109→\n   110→\n   111→# Backward compatible aliases\n   112→IS_TRIAL_VERSION = False\n   113→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"221c455b-30ed-413c-83c1-0f6817304ef0","timestamp":"2025-12-09T03:56:48.575Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/config_api.py","content":"﻿#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nMinimal config with placeholders for distribution.\n- Keep API keys empty for end users; they can set in Settings or env.\n- Force storage dir to be configured via env or raises.\n\"\"\"\n\nimport os\nfrom pathlib import Path\nimport json\n\nVOLCENGINE_API_KEY = \"\"\n\n# 设置持久化文件（与 SettingsPage/统一配置保持一致）\n_CONFIG_JSON = Path.home() / \".pigeon_dream\" / \"config.json\"\n\nAPP_CONFIG = {\n    \"app_name\": \"鸽梦Godream\",\n    \"version\": \"1.3.0\",\n    \"author\": \"AI Assistant\",\n    \"description\": \"PyQt5 local AI content tool\",\n}\n\nIMAGE_GENERATION_DEFAULTS = {\n    \"size\": \"1024x1024\",\n    \"guidance_scale\": 2.5,\n    \"seed\": -1,\n    \"model\": \"doubao-seedream-4-0-250828\",\n    \"watermark\": False,\n}\n\nVIDEO_GENERATION_DEFAULTS = {\n    \"duration\": 4.0,\n    \"motion_strength\": 0.8,\n    \"seed\": -1,\n    \"watermark\": False,\n    \"width\": 1280,\n    \"height\": 720,\n    \"fps\": 24,\n}\n\nLOCAL_WATERMARK_CONFIG = {\n    \"enabled\": False,\n    \"text\": \"\",\n    \"opacity\": 0.0,\n    \"position\": \"bottom_right\",\n    \"font_size\": 0,\n}\n\nAPI_WATERMARK_CONFIG = {\n    \"image_watermark\": False,\n    \"video_watermark\": False,\n}\n\n\ndef validate_api_keys():\n    missing = []\n    if not VOLCENGINE_API_KEY:\n        missing.append(\"VOLCENGINE_API_KEY\")\n    if missing:\n        return False, missing, \"API 密钥未配置\"\n    return True, [], \"API 密钥已配置\"\n\n\ndef get_storage_dir():\n    # 优先：环境变量\n    env_path = os.environ.get(\"GEMENG_STORAGE_DIR\")\n    if env_path:\n        p = Path(env_path).expanduser()\n        p.mkdir(parents=True, exist_ok=True)\n        return str(p)\n\n    # 其次：用户配置文件（Settings 保存路径）\n    # 修复：AppConfig 保存到 creation.storage_root_path，需要正确读取嵌套结构\n    try:\n        if _CONFIG_JSON.exists():\n            data = json.loads(_CONFIG_JSON.read_text(encoding=\"utf-8\") or \"{}\")\n            # 优先从 creation 嵌套结构读取（与 AppConfig 保存结构一致）\n            creation = data.get(\"creation\", {})\n            if isinstance(creation, dict):\n                use_custom = creation.get(\"use_custom_storage\", False)\n                custom = creation.get(\"storage_root_path\", \"\")\n                if use_custom and custom:\n                    p = Path(custom).expanduser()\n                    p.mkdir(parents=True, exist_ok=True)\n                    return str(p)\n            # 兼容旧版顶层配置\n            custom = data.get(\"storage_root_path\") or data.get(\"storage_dir\")\n            if custom:\n                p = Path(custom).expanduser()\n                p.mkdir(parents=True, exist_ok=True)\n                return str(p)\n    except Exception:\n        pass\n\n    # 没有配置则报错，引导用户去设置\n    raise ValueError(\"未配置存储路径，请在环境变量 GEMENG_STORAGE_DIR 或应用设置中配置\")\n\n\ndef get_api_key(service: str) -> str:\n    s = (service or \"\").lower()\n    key = os.environ.get(\"VOLCENGINE_API_KEY\") or VOLCENGINE_API_KEY\n    if s in {\"volcengine\", \"volc\", \"ark\"}:\n        if not key:\n            raise ValueError(\"火山引擎API密钥未配置，请在设置或环境变量配置\")\n        return key\n    raise ValueError(f\"不支持的服务: {service}\")\n\n\n# Backward compatible aliases\nIS_TRIAL_VERSION = False\n","numLines":113,"startLine":1,"totalLines":113}}}
{"parentUuid":"221c455b-30ed-413c-83c1-0f6817304ef0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TknjtCXpMG3LaD5PDU7DLv","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/__init__.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/schema.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/factory.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/base.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/volc.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/volc_v4.cpython-313.pyc"}]},"uuid":"85f70f54-0de2-4423-a158-64da5432972a","timestamp":"2025-12-09T03:56:48.614Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/__init__.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/schema.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/factory.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/base.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/volc.cpython-313.pyc","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/volc_v4.cpython-313.pyc"],"durationMs":49,"numFiles":12,"truncated":false}}
{"parentUuid":"85f70f54-0de2-4423-a158-64da5432972a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R3upHMuriNiBaQGdsPxkSa","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the provider layer files to understand the model selection and API parameter mapping:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1575,"cache_creation_input_tokens":51469,"cache_read_input_tokens":37772,"cache_creation":{"ephemeral_5m_input_tokens":51469,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"07f23f16-5afd-44be-aca0-e0748db4e705","timestamp":"2025-12-09T03:56:58.319Z"}
{"parentUuid":"07f23f16-5afd-44be-aca0-e0748db4e705","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R3upHMuriNiBaQGdsPxkSa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015nsHATDrArsisLXmJrGoku","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1575,"cache_creation_input_tokens":51469,"cache_read_input_tokens":37772,"cache_creation":{"ephemeral_5m_input_tokens":51469,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"ce9d5cf5-ae0c-4f31-aa0e-ffba709278c0","timestamp":"2025-12-09T03:56:59.290Z"}
{"parentUuid":"ce9d5cf5-ae0c-4f31-aa0e-ffba709278c0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R3upHMuriNiBaQGdsPxkSa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013cuYZaW7ysdQ2WkVPaBFQv","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1575,"cache_creation_input_tokens":51469,"cache_read_input_tokens":37772,"cache_creation":{"ephemeral_5m_input_tokens":51469,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"aad52af2-7102-4915-87d0-03d72fbc4a4a","timestamp":"2025-12-09T03:56:59.938Z"}
{"parentUuid":"aad52af2-7102-4915-87d0-03d72fbc4a4a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R3upHMuriNiBaQGdsPxkSa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019aDHnvkhP2EUsSe2yScbBr","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1575,"cache_creation_input_tokens":51469,"cache_read_input_tokens":37772,"cache_creation":{"ephemeral_5m_input_tokens":51469,"ephemeral_1h_input_tokens":0},"output_tokens":207,"service_tier":"standard"}},"type":"assistant","uuid":"d54a798a-28a5-49c1-b73e-90eb66b96e85","timestamp":"2025-12-09T03:57:00.523Z"}
{"parentUuid":"d54a798a-28a5-49c1-b73e-90eb66b96e85","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015nsHATDrArsisLXmJrGoku","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 工厂（最小实现）\n     5→\"\"\"\n     6→import os\n     7→from typing import Optional\n     8→from .base import BaseProvider\n     9→from .volc import VolcProvider\n    10→from .volc_v4 import VolcV4Provider\n    11→\n    12→\n    13→def get_default_provider(provider_name: Optional[str] = None) -> BaseProvider:\n    14→    raw_name = provider_name or os.environ.get(\"GEMENG_PROVIDER\", \"volc_v3\")\n    15→    try:\n    16→        name = str(raw_name).strip().lower()\n    17→    except Exception:\n    18→        name = \"volc_v3\"\n    19→\n    20→    if name in {\"volc_v4\", \"volcengine_v4\", \"seedream_v4\", \"seedream4\", \"volc4\"}:\n    21→        return VolcV4Provider()\n    22→    # 默认与历史兼容，返回 v3 实现\n    23→    return VolcProvider()\n    24→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7c7c91d5-5971-463e-8046-50961e6540d3","timestamp":"2025-12-09T03:57:00.570Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 工厂（最小实现）\n\"\"\"\nimport os\nfrom typing import Optional\nfrom .base import BaseProvider\nfrom .volc import VolcProvider\nfrom .volc_v4 import VolcV4Provider\n\n\ndef get_default_provider(provider_name: Optional[str] = None) -> BaseProvider:\n    raw_name = provider_name or os.environ.get(\"GEMENG_PROVIDER\", \"volc_v3\")\n    try:\n        name = str(raw_name).strip().lower()\n    except Exception:\n        name = \"volc_v3\"\n\n    if name in {\"volc_v4\", \"volcengine_v4\", \"seedream_v4\", \"seedream4\", \"volc4\"}:\n        return VolcV4Provider()\n    # 默认与历史兼容，返回 v3 实现\n    return VolcProvider()\n","numLines":24,"startLine":1,"totalLines":24}}}
{"parentUuid":"7c7c91d5-5971-463e-8046-50961e6540d3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013cuYZaW7ysdQ2WkVPaBFQv","type":"tool_result","content":"     1→﻿#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 参数 Schema 与校验（最小落地）\n     5→\n     6→目标：\n     7→- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n     8→- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n     9→- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n    10→\"\"\"\n    11→\n    12→import copy\n    13→from dataclasses import dataclass, field\n    14→from typing import Any, Optional, Tuple, List, Dict\n    15→\n    16→# 参考图限制（见官方文档 lines 203-204）\n    17→MAX_REFERENCE_IMAGES = 10  # doubao-seedream-4.0 最多支持10张参考图\n    18→MAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n    19→\n    20→\n    21→# 白名单与范围\n    22→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    23→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\"}\n    24→\n    25→\n    26→@dataclass\n    27→class TextToImageParams:\n    28→    prompt: str\n    29→    size: str = \"1024x1024\"\n    30→    guidance_scale: float = 2.5\n    31→    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    32→    reference_images: List[str] = field(default_factory=list)\n    33→\n    34→\n    35→@dataclass\n    36→class ImageToImageParams:\n    37→    prompt: str\n    38→    image: str  # URL 或 data URL\n    39→    guidance_scale: float = 5.5\n    40→    seed: Optional[int] = None\n    41→    reference_images: List[str] = field(default_factory=list)\n    42→\n    43→\n    44→@dataclass\n    45→class VideoParams:\n    46→    prompt: str\n    47→    image_path: Optional[str] = None\n    48→    first_frame_path: Optional[str] = None\n    49→    last_frame_path: Optional[str] = None\n    50→    duration: int = 8\n    51→    fps: int = 24\n    52→    seed: Optional[int] = None\n    53→    camera_fixed: bool = True\n    54→    watermark: bool = False\n    55→    resolution_grade: Optional[str] = None\n    56→    ratio: Optional[str] = None\n    57→    use_pro_model: bool = True\n    58→    reference_images: List[str] = field(default_factory=list)\n    59→\n    60→\n    61→@dataclass(frozen=True)\n    62→class UIOption:\n    63→    value: Any\n    64→    label: str\n    65→    description: Optional[str] = None\n    66→    meta: Dict[str, Any] = field(default_factory=dict)\n    67→\n    68→\n    69→@dataclass(frozen=True)\n    70→class UIDependency:\n    71→    field: str\n    72→    equals: Any = None\n    73→    not_equals: Any = None\n    74→    exists: bool = False\n    75→\n    76→\n    77→@dataclass\n    78→class UISchemaField:\n    79→    name: str\n    80→    field_type: str\n    81→    label: str\n    82→    default: Any = None\n    83→    required: bool = False\n    84→    help_text: Optional[str] = None\n    85→    placeholder: Optional[str] = None\n    86→    options: List[UIOption] = field(default_factory=list)\n    87→    min_value: Optional[float] = None\n    88→    max_value: Optional[float] = None\n    89→    step: Optional[float] = None\n    90→    visible_if: List[UIDependency] = field(default_factory=list)\n    91→    enabled_if: List[UIDependency] = field(default_factory=list)\n    92→    extra: Dict[str, Any] = field(default_factory=dict)\n    93→\n    94→    def to_dict(self) -> Dict[str, Any]:\n    95→        return {\n    96→            \"name\": self.name,\n    97→            \"type\": self.field_type,\n    98→            \"label\": self.label,\n    99→            \"default\": self.default,\n   100→            \"required\": self.required,\n   101→            \"help_text\": self.help_text,\n   102→            \"placeholder\": self.placeholder,\n   103→            \"options\": [\n   104→                {\n   105→                    \"value\": opt.value,\n   106→                    \"label\": opt.label,\n   107→                    \"description\": opt.description,\n   108→                    \"meta\": opt.meta,\n   109→                }\n   110→                for opt in self.options\n   111→            ],\n   112→            \"min\": self.min_value,\n   113→            \"max\": self.max_value,\n   114→            \"step\": self.step,\n   115→            \"visible_if\": [\n   116→                {\n   117→                    \"field\": dep.field,\n   118→                    \"equals\": dep.equals,\n   119→                    \"not_equals\": dep.not_equals,\n   120→                    \"exists\": dep.exists,\n   121→                }\n   122→                for dep in self.visible_if\n   123→            ],\n   124→            \"enabled_if\": [\n   125→                {\n   126→                    \"field\": dep.field,\n   127→                    \"equals\": dep.equals,\n   128→                    \"not_equals\": dep.not_equals,\n   129→                    \"exists\": dep.exists,\n   130→                }\n   131→                for dep in self.enabled_if\n   132→            ],\n   133→            \"extra\": self.extra,\n   134→        }\n   135→\n   136→\n   137→@dataclass\n   138→class UISchema:\n   139→    provider: str\n   140→    mode: str\n   141→    variant: str\n   142→    fields: List[UISchemaField] = field(default_factory=list)\n   143→    primary_image: Dict[str, Any] = field(default_factory=dict)\n   144→    reference_assets: Dict[str, Any] = field(default_factory=dict)\n   145→    extra: Dict[str, Any] = field(default_factory=dict)\n   146→\n   147→    def to_dict(self) -> Dict[str, Any]:\n   148→        return {\n   149→            \"provider\": self.provider,\n   150→            \"mode\": self.mode,\n   151→            \"variant\": self.variant,\n   152→            \"fields\": [field.to_dict() for field in self.fields],\n   153→            \"primary_image\": self.primary_image,\n   154→            \"reference_assets\": self.reference_assets,\n   155→            \"extra\": self.extra,\n   156→        }\n   157→\n   158→\n   159→def _clip_seed(seed: Optional[int]) -> Optional[int]:\n   160→    if seed is None:\n   161→        return None\n   162→    try:\n   163→        iv = int(seed)\n   164→    except Exception:\n   165→        return None\n   166→    if iv < 0:\n   167→        return None\n   168→    if iv > 2147483647:\n   169→        iv = 2147483647\n   170→    return iv\n   171→\n   172→\n   173→def validate_and_normalize_t2i(p: TextToImageParams) -> Tuple[TextToImageParams, bool, str]:\n   174→    fb = False\n   175→    reasons: List[str] = []\n   176→    # size: 期望形如 WxH，范围 512..4096（兼容 Seedream 4.0 高分辨率）\n   177→    def _valid_size(s: str) -> bool:\n   178→        try:\n   179→            if 'x' not in s:\n   180→                return False\n   181→            w, h = s.split('x', 1)\n   182→            w, h = int(w), int(h)\n   183→            return 512 <= w <= 4096 and 512 <= h <= 4096\n   184→        except Exception:\n   185→            return False\n   186→\n   187→    size = p.size or \"1024x1024\"\n   188→    if not _valid_size(size):\n   189→        fb = True\n   190→        reasons.append(f\"无效尺寸: {p.size or '缺失'}\")\n   191→        size = \"1024x1024\"\n   192→\n   193→    gs = p.guidance_scale\n   194→    if not (1.0 <= gs <= 10.0):\n   195→        fb = True\n   196→        reasons.append(f\"guidance_scale越界: {gs}\")\n   197→        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 2.5\n   198→\n   199→    seed = _clip_seed(p.seed)\n   200→\n   201→    raw_refs: List[str] = []\n   202→    try:\n   203→        for item in p.reference_images or []:\n   204→            if isinstance(item, str) and item:\n   205→                raw_refs.append(item)\n   206→    except Exception:\n   207→        raw_refs = []\n   208→\n   209→    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n   210→    if ref_fb:\n   211→        fb = True\n   212→        reasons.append(ref_reason)\n   213→\n   214→    norm = TextToImageParams(\n   215→        prompt=p.prompt,\n   216→        size=size,\n   217→        guidance_scale=gs,\n   218→        seed=seed,\n   219→        reference_images=refs,\n   220→    )\n   221→    return norm, fb, \", \".join(reasons) if fb else \"\"\n   222→\n   223→\n   224→def _normalize_reference_images(refs: List[str], expected_outputs: int = 1) -> Tuple[List[str], bool, str]:\n   225→    \"\"\"裁剪/校验参考图数量，返回 (normalized_refs, fallback, reason)。\n   226→\n   227→    约束源于官方文档《doubao-seedream-4.0 教程》（行 203-204）：\n   228→    - Seedream 4.0 最多 10 张参考图；\n   229→    - （组图扩展）参考图数量 + 生成图数量 ≤ 15。\n   230→    \"\"\"\n   231→    fb = False\n   232→    reasons: List[str] = []\n   233→    refs = [r for r in refs if isinstance(r, str) and r]\n   234→    # 限制：≤10 张\n   235→    if len(refs) > MAX_REFERENCE_IMAGES:\n   236→        fb = True\n   237→        reasons.append(\n   238→            f\"参考图数量超过 {MAX_REFERENCE_IMAGES}，已自动截取前 {MAX_REFERENCE_IMAGES} 张\"\n   239→        )\n   240→        refs = refs[:MAX_REFERENCE_IMAGES]\n   241→    # 组图扩展：参考图 + 生成图 ≤ 15（当前生成图默认为 expected_outputs）\n   242→    if expected_outputs >= 0 and len(refs) + expected_outputs > MAX_REFERENCE_BUNDLE:\n   243→        allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n   244→        if len(refs) > allowed:\n   245→            fb = True\n   246→            reasons.append(\n   247→                f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}，已截取前 {allowed} 张\"\n   248→            )\n   249→            refs = refs[:allowed]\n   250→    return refs, fb, \", \".join(reasons) if fb else \"\"\n   251→\n   252→\n   253→def validate_and_normalize_i2i(p: ImageToImageParams) -> Tuple[ImageToImageParams, bool, str]:\n   254→    fb = False\n   255→    reasons: List[str] = []\n   256→    gs = p.guidance_scale\n   257→    if not (1.0 <= gs <= 10.0):\n   258→        fb = True\n   259→        reasons.append(f\"guidance_scale越界: {gs}\")\n   260→        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 5.5\n   261→    seed = _clip_seed(p.seed)\n   262→    raw_refs: List[str] = []\n   263→    try:\n   264→        for item in p.reference_images or []:\n   265→            if isinstance(item, str) and item:\n   266→                raw_refs.append(item)\n   267→    except Exception:\n   268→        raw_refs = []\n   269→\n   270→    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n   271→    if ref_fb:\n   272→        fb = True\n   273→        reasons.append(ref_reason)\n   274→\n   275→    norm = ImageToImageParams(\n   276→        prompt=p.prompt,\n   277→        image=p.image,\n   278→        guidance_scale=gs,\n   279→        seed=seed,\n   280→        reference_images=refs,\n   281→    )\n   282→    return norm, fb, \", \".join(reasons) if fb else \"\"\n   283→\n   284→\n   285→def validate_and_normalize_video(p: VideoParams) -> Tuple[VideoParams, bool, str, str, str]:\n   286→    \"\"\"返回 (normalized, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n   287→    fb = False\n   288→    reasons: List[str] = []\n   289→\n   290→    rs = p.resolution_grade or \"1080p\"\n   291→    rt = p.ratio or \"16:9\"\n   292→    if rs not in RES_GRADES:\n   293→        fb = True\n   294→        reasons.append(f\"无效分辨率: {rs}\")\n   295→        rs = \"1080p\"\n   296→    if rt not in RATIOS:\n   297→        fb = True\n   298→        reasons.append(f\"无效比例: {rt}\")\n   299→        rt = \"16:9\"\n   300→\n   301→    fps = int(p.fps or 24)\n   302→    if fps <= 0:\n   303→        fps = 24\n   304→    dur = int(p.duration or 8)\n   305→    if dur < 3:\n   306→        fb = True\n   307→        reasons.append(\"时长过短(<3s)\")\n   308→        dur = 3\n   309→    if dur > 12:\n   310→        fb = True\n   311→        reasons.append(\"时长过长(>12s)\")\n   312→        dur = 12\n   313→\n   314→    seed = _clip_seed(p.seed)\n   315→    raw_refs: List[str] = []\n   316→    try:\n   317→        for item in p.reference_images or []:\n   318→            if isinstance(item, str) and item:\n   319→                raw_refs.append(item)\n   320→    except Exception:\n   321→        raw_refs = []\n   322→\n   323→    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n   324→    if ref_fb:\n   325→        fb = True\n   326→        reasons.append(ref_reason)\n   327→\n   328→    norm = VideoParams(\n   329→        prompt=p.prompt,\n   330→        image_path=p.image_path,\n   331→        first_frame_path=p.first_frame_path,\n   332→        last_frame_path=p.last_frame_path,\n   333→        duration=dur,\n   334→        fps=fps,\n   335→        seed=seed,\n   336→        camera_fixed=bool(p.camera_fixed),\n   337→        watermark=bool(p.watermark),\n   338→        resolution_grade=rs,\n   339→        ratio=rt,\n   340→        use_pro_model=bool(p.use_pro_model),\n   341→        reference_images=refs,\n   342→    )\n   343→    return norm, fb, \", \".join(reasons) if fb else \"\", rs, rt\n   344→\n   345→\n   346→# ------------------------------\n   347→# UI Schema 定义（供前端驱动参数面板）\n   348→# ------------------------------\n   349→\n   350→\n   351→def _schema_key(provider: str, mode: str, variant: str) -> str:\n   352→    return f\"{provider}:{mode}:{variant}\"\n   353→\n   354→\n   355→def _option(value: Any, label: str, *, description: Optional[str] = None, meta: Optional[Dict[str, Any]] = None) -> UIOption:\n   356→    return UIOption(value=value, label=label, description=description, meta=meta or {})\n   357→\n   358→\n   359→def _dependency(field: str, *, equals: Any = None, not_equals: Any = None, exists: bool = False) -> UIDependency:\n   360→    return UIDependency(field=field, equals=equals, not_equals=not_equals, exists=exists)\n   361→\n   362→\n   363→def _build_seedream_schema(variant: str) -> UISchema:\n   364→    variant = variant or \"seedream_v3\"\n   365→    fields: List[UISchemaField] = []\n   366→\n   367→    model_options = [\n   368→        _option(\n   369→            \"seedream_v3\",\n   370→            \"Seedream 3.x\",\n   371→            description=\"稳定版本，支持单图/文生图\",\n   372→            meta={\n   373→                \"t2i_model\": \"doubao-seedream-3-0-t2i-250415\",\n   374→                \"i2i_model\": \"doubao-seededit-3-0-i2i-250628\",\n   375→                \"ui_variant\": \"seedream_v3\",\n   376→            },\n   377→        ),\n   378→        _option(\n   379→            \"seedream_v4\",\n   380→            \"Seedream 4.0\",\n   381→            description=\"多参考图融合，最大10张参考图\",\n   382→            meta={\n   383→                \"t2i_model\": \"doubao-seedream-4-0-250828\",\n   384→                \"i2i_model\": \"doubao-seedream-4-0-250828\",\n   385→                \"ui_variant\": \"seedream_v4\",\n   386→            },\n   387→        ),\n   388→    ]\n   389→    fields.append(\n   390→        UISchemaField(\n   391→            name=\"model_variant\",\n   392→            field_type=\"select\",\n   393→            label=\"模型版本\",\n   394→            default=variant,\n   395→            help_text=\"切换模型将刷新可选参数与上传限制\",\n   396→            options=model_options,\n   397→            extra={\"reload_on_change\": True, \"schema_family\": \"seedream\"},\n   398→        )\n   399→    )\n   400→\n   401→    if variant == \"seedream_v4\":\n   402→        size_options = [\n   403→            # 4K最大尺寸 (Seedream 4.0)\n   404→            _option(\"4096x4096\", \"4096×4096 (1:1) 🔥\"),\n   405→            _option(\"4096x2304\", \"4096×2304 (16:9) 🔥\"),\n   406→            _option(\"2304x4096\", \"2304×4096 (9:16) 🔥\"),\n   407→            \n   408→            # 标准4K尺寸\n   409→            _option(\"3840x2160\", \"3840×2160 (16:9)\"),\n   410→            _option(\"2160x3840\", \"2160×3840 (9:16)\"),\n   411→            _option(\"4096x3072\", \"4096×3072 (4:3)\"),\n   412→            _option(\"3072x4096\", \"3072×4096 (3:4)\"),\n   413→            _option(\"4096x2731\", \"4096×2731 (3:2)\"),\n   414→            _option(\"2731x4096\", \"2731×4096 (2:3)\"),\n   415→            _option(\"4096x1755\", \"4096×1755 (21:9)\"),\n   416→            \n   417→            # 兼容性尺寸\n   418→            _option(\"3072x2048\", \"3072×2048 (3:2)\"),\n   419→            _option(\"2048x3072\", \"2048×3072 (2:3)\"),\n   420→            _option(\"2048x2048\", \"2048×2048 (1:1)\"),\n   421→            _option(\"1920x1080\", \"1920×1080 (16:9)\"),\n   422→            _option(\"1080x1920\", \"1080×1920 (9:16)\"),\n   423→            _option(\"1024x1024\", \"1024×1024 (1:1)\"),\n   424→        ]\n   425→        default_size = \"4096x4096\"\n   426→        # 过滤：移除边长小于 1024 的尺寸项（例如 1512x648），保证 4.0 仅提供大尺寸\n   427→        try:\n   428→            filtered_opts = []\n   429→            for opt in list(size_options):\n   430→                try:\n   431→                    parts = [int(x.strip()) for x in str(opt.value).lower().split('x')]\n   432→                    if len(parts) == 2 and min(parts[0], parts[1]) < 1024:\n   433→                        continue\n   434→                except Exception:\n   435→                    pass\n   436→                filtered_opts.append(opt)\n   437→            size_options = filtered_opts\n   438→        except Exception:\n   439→            pass\n   440→    else:\n   441→        # Seedream 3.x：按常见比例提供范围内的最大像素组合（宽高在 512–2048）\n   442→        size_options = [\n   443→            _option(\"2048x2048\", \"2048×2048 (1:1)\"),\n   444→            _option(\"2048x1536\", \"2048×1536 (4:3)\"),\n   445→            _option(\"1536x2048\", \"1536×2048 (3:4)\"),\n   446→            _option(\"2048x1152\", \"2048×1152 (16:9)\"),\n   447→            _option(\"1152x2048\", \"1152×2048 (9:16)\"),\n   448→            _option(\"1920x1280\", \"1920×1280 (3:2)\"),\n   449→            _option(\"1280x1920\", \"1280×1920 (2:3)\"),\n   450→            _option(\"1792x768\",  \"1792×768 (21:9)\"),\n   451→        ]\n   452→        default_size = \"2048x2048\"\n   453→\n   454→    fields.append(\n   455→        UISchemaField(\n   456→            name=\"size\",\n   457→            field_type=\"select\",\n   458→            label=\"分辨率\",\n   459→            default=default_size,\n   460→            options=size_options,\n   461→            help_text=\"仅提供官方支持的常用分辨率\",\n   462→        )\n   463→    )\n   464→\n   465→    fields.append(\n   466→        UISchemaField(\n   467→            name=\"seed\",\n   468→            field_type=\"spinbox\",\n   469→            label=\"Seed\",\n   470→            default=-1,\n   471→            min_value=-1,\n   472→            max_value=2147483647,\n   473→            help_text=\"-1 表示随机；指定整数可复现结果\",\n   474→        )\n   475→    )\n   476→\n   477→    fields.append(\n   478→        UISchemaField(\n   479→            name=\"count\",\n   480→            field_type=\"spinbox\",\n   481→            label=\"生成数量\",\n   482→            default=1,\n   483→            min_value=1,\n   484→            max_value=10,\n   485→            help_text=\"一次最多生成 10 张\",\n   486→        )\n   487→    )\n   488→\n   489→    # 隐藏\"自动压缩参考图\"参数，后端自动启用\n   490→    # fields.append(\n   491→    #     UISchemaField(\n   492→    #         name=\"auto_compress_references\",\n   493→    #         field_type=\"toggle\",\n   494→    #         label=\"自动压缩参考图\",\n   495→    #         default=True,\n   496→    #         help_text=\"上传时自动压缩到 2K 内，避免超出 API 限制\",\n   497→    #     )\n   498→    # )\n   499→\n   500→    if variant == \"seedream_v4\":\n   501→        reference_enabled = True\n   502→        ref_max_count = MAX_REFERENCE_IMAGES\n   503→        ref_bundle_limit = MAX_REFERENCE_BUNDLE\n   504→        ref_help = \"最多 10 张参考图，参考图 + 输出数量 ≤ 15\"\n   505→        multi_reference = True\n   506→    else:\n   507→        # seedream_v3: 保留旧体验（单张参考图，面板隐藏）\n   508→        reference_enabled = False\n   509→        ref_max_count = 1\n   510→        ref_bundle_limit = 1\n   511→        ref_help = \"最多 1 张参考图\"\n   512→        multi_reference = False\n   513→\n   514→    reference_assets = {\n   515→        \"enabled\": reference_enabled,\n   516→        \"max_count\": ref_max_count,\n   517→        \"bundle_limit\": ref_bundle_limit,\n   518→        \"accept\": [\"image/png\", \"image/jpeg\"],\n   519→        \"auto_compress_field\": \"auto_compress_references\",\n   520→        \"help_text\": ref_help,\n   521→        \"orderable\": True,\n   522→    }\n   523→\n   524→    primary_image = {\n   525→        \"enabled\": True,\n   526→        \"label\": \"基础图 (可选)\",\n   527→        \"placeholder\": \"拖拽或点击上传一张基础图，留空则进行文生图\",\n   528→        \"accept\": [\"image/png\", \"image/jpeg\"],\n   529→        \"max_size_mb\": 10,\n   530→    }\n   531→\n   532→    capabilities = {\n   533→        \"multi_reference\": multi_reference,\n   534→        \"supports_reference\": True,\n   535→        \"single_reference\": not multi_reference,\n   536→    }\n   537→\n   538→    extra = {\n   539→        \"supports_reference\": True,  # 3.x模式也支持参考图显示，只是UI面板隐藏\n   540→        \"layout\": {\n   541→            \"type\": \"rows\",\n   542→            \"row_spacing\": 6,\n   543→            \"column_spacing\": 12,\n   544→            \"rows\": [\n   545→                [\n   546→                    {\"name\": \"model_variant\", \"stretch\": 3, \"label_width\": 70, \"min_width\": 220},\n   547→                    {\"name\": \"size\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 120},\n   548→                    {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 120},\n   549→                    {\"name\": \"count\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 100},\n   550→                    {\n   551→                        \"name\": \"auto_compress_references\",\n   552→                        \"stretch\": 1,\n   553→                        \"label_width\": 70,\n   554→                    },\n   555→                ],\n   556→            ],\n   557→        },\n   558→        \"capabilities\": capabilities,\n   559→    }\n   560→\n   561→    return UISchema(\n   562→        provider=\"seedream\",\n   563→        mode=\"image\",\n   564→        variant=variant,\n   565→        fields=fields,\n   566→        primary_image=primary_image,\n   567→        reference_assets=reference_assets,\n   568→        extra=extra,\n   569→    )\n   570→\n   571→\n   572→def _build_seedance_schema(variant: str) -> UISchema:\n   573→    variant = variant or \"seedance_pro\"\n   574→    model_options = [\n   575→        _option(\n   576→            \"seedance_pro\",\n   577→            \"Seedance Pro\",\n   578→            description=\"高质量输出，适合正式素材\",\n   579→            meta={\"use_pro_model\": True, \"ui_variant\": \"seedance_pro\"},\n   580→        ),\n   581→        _option(\n   582→            \"seedance_lite\",\n   583→            \"Seedance Lite\",\n   584→            description=\"快速输出，适合草稿\",\n   585→            meta={\"use_pro_model\": False, \"ui_variant\": \"seedance_lite\"},\n   586→        ),\n   587→    ]\n   588→\n   589→    fields: List[UISchemaField] = [\n   590→        UISchemaField(\n   591→            name=\"model_variant\",\n   592→            field_type=\"select\",\n   593→            label=\"模型\",\n   594→            default=variant,\n   595→            help_text=\"Pro 输出质量更高，Lite 更快速\",\n   596→            options=model_options,\n   597→            extra={\"reload_on_change\": True, \"schema_family\": \"seedance\"},\n   598→        ),\n   599→        UISchemaField(\n   600→            name=\"resolution_grade\",\n   601→            field_type=\"select\",\n   602→            label=\"分辨率档位\",\n   603→            default=\"1080p\",\n   604→            options=[\n   605→                _option(\"480p\", \"480p\"),\n   606→                _option(\"720p\", \"720p\"),\n   607→                _option(\"1080p\", \"1080p\"),\n   608→            ],\n   609→            help_text=\"官方推荐 480p/720p/1080p 三档\",\n   610→        ),\n   611→        UISchemaField(\n   612→            name=\"ratio\",\n   613→            field_type=\"select\",\n   614→            label=\"画面比例\",\n   615→            default=\"16:9\",\n   616→            options=[\n   617→                _option(\"16:9\", \"16:9\"),\n   618→                _option(\"9:16\", \"9:16\"),\n   619→                _option(\"4:3\", \"4:3\"),\n   620→                _option(\"1:1\", \"1:1\"),\n   621→                _option(\"3:4\", \"3:4\"),\n   622→                _option(\"21:9\", \"21:9\"),\n   623→            ],\n   624→            help_text=\"生成时自动拼接 --rs/--rt 参数\",\n   625→        ),\n   626→        UISchemaField(\n   627→            name=\"duration\",\n   628→            field_type=\"select\",\n   629→            label=\"时长 (秒)\",\n   630→            default=5,\n   631→            options=[_option(sec, f\"{sec} 秒\") for sec in range(3, 13)],\n   632→            help_text=\"范围 3-12 秒，超过范围将自动回退\",\n   633→        ),\n   634→        UISchemaField(\n   635→            name=\"seed\",\n   636→            field_type=\"spinbox\",\n   637→            label=\"Seed\",\n   638→            default=-1,\n   639→            min_value=-1,\n   640→            max_value=2147483647,\n   641→            help_text=\"-1 表示随机；指定整数可复现\",\n   642→        ),\n   643→        UISchemaField(\n   644→            name=\"camera_fixed\",\n   645→            field_type=\"toggle\",\n   646→            label=\"固定摄像机\",\n   647→            default=True,\n   648→            help_text=\"开启后相机保持固定，适合稳态镜头\",\n   649→        ),\n   650→    ]\n   651→\n   652→    reference_assets = {\n   653→        \"enabled\": False,\n   654→        \"max_count\": 0,\n   655→        \"bundle_limit\": 0,\n   656→        \"accept\": [],\n   657→        \"auto_compress_field\": None,\n   658→        \"help_text\": \"\",\n   659→        \"orderable\": False,\n   660→    }\n   661→\n   662→    primary_frames = {\n   663→        \"enabled\": True,\n   664→        \"slots\": [\n   665→            {\n   666→                \"name\": \"first_frame\",\n   667→                \"label\": \"首帧 (可选)\",\n   668→                \"help_text\": \"提供首帧可提升人物一致性\",\n   669→                \"accept\": [\"image/png\", \"image/jpeg\"],\n   670→            },\n   671→            {\n   672→                \"name\": \"last_frame\",\n   673→                \"label\": \"尾帧 (可选)\",\n   674→                \"help_text\": \"提供尾帧可控制结尾画面\",\n   675→                \"accept\": [\"image/png\", \"image/jpeg\"],\n   676→            },\n   677→        ],\n   678→        \"max_size_mb\": 10,\n   679→    }\n   680→\n   681→    capabilities = {\n   682→        \"multi_reference\": False,\n   683→        \"supports_reference\": False,\n   684→    }\n   685→\n   686→    extra = {\n   687→        \"use_pro_model\": variant == \"seedance_pro\",\n   688→        \"layout\": {\n   689→            \"type\": \"rows\",\n   690→            \"row_spacing\": 6,\n   691→            \"column_spacing\": 10,\n   692→            \"rows\": [\n   693→                [\n   694→                    {\"name\": \"model_variant\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 160},\n   695→                    {\"name\": \"resolution_grade\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 140},\n   696→                    {\"name\": \"ratio\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 110},\n   697→                    {\"name\": \"duration\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 110},\n   698→                    {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 120},\n   699→                    {\"name\": \"camera_fixed\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 110},\n   700→                ],\n   701→            ],\n   702→        },\n   703→        \"capabilities\": capabilities,\n   704→    }\n   705→\n   706→    return UISchema(\n   707→        provider=\"seedance\",\n   708→        mode=\"video\",\n   709→        variant=variant,\n   710→        fields=fields,\n   711→        primary_image=primary_frames,\n   712→        reference_assets=reference_assets,\n   713→        extra=extra,\n   714→    )\n   715→\n   716→\n   717→_UI_SCHEMAS: Dict[str, UISchema] = {\n   718→    _schema_key(\"seedream\", \"image\", \"seedream_v3\"): _build_seedream_schema(\"seedream_v3\"),\n   719→    _schema_key(\"seedream\", \"image\", \"seedream_v4\"): _build_seedream_schema(\"seedream_v4\"),\n   720→    _schema_key(\"seedance\", \"video\", \"seedance_pro\"): _build_seedance_schema(\"seedance_pro\"),\n   721→    _schema_key(\"seedance\", \"video\", \"seedance_lite\"): _build_seedance_schema(\"seedance_lite\"),\n   722→}\n   723→\n   724→\n   725→_DEFAULT_VARIANTS: Dict[Tuple[str, str], str] = {\n   726→    (\"seedream\", \"image\"): \"seedream_v3\",\n   727→    (\"seedance\", \"video\"): \"seedance_pro\",\n   728→}\n   729→\n   730→\n   731→def get_ui_schema(provider: str, mode: str, variant: Optional[str] = None, *, as_dict: bool = False) -> UISchema:\n   732→    \"\"\"返回 UI Schema（深拷贝，避免调用侧修改真源）。\"\"\"\n   733→\n   734→    key_variant = variant or _DEFAULT_VARIANTS.get((provider, mode))\n   735→    if not key_variant:\n   736→        raise ValueError(f\"未定义默认 UI Schema: provider={provider} mode={mode}\")\n   737→\n   738→    key = _schema_key(provider, mode, key_variant)\n   739→    if key not in _UI_SCHEMAS:\n   740→        raise ValueError(f\"未找到 UI Schema: provider={provider} mode={mode} variant={key_variant}\")\n   741→\n   742→    schema = copy.deepcopy(_UI_SCHEMAS[key])\n   743→    if as_dict:\n   744→        return schema.to_dict()  # type: ignore[return-value]\n   745→    return schema\n   746→\n   747→\n   748→def list_ui_schema_variants(provider: str, mode: str) -> List[str]:\n   749→    prefix = f\"{provider}:{mode}:\"\n   750→    return [key.split(\":\", 2)[-1] for key in _UI_SCHEMAS.keys() if key.startswith(prefix)]\n   751→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cc15d3f9-6a35-4d7a-8c37-e86a7a6786d3","timestamp":"2025-12-09T03:57:00.570Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","content":"﻿#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 参数 Schema 与校验（最小落地）\n\n目标：\n- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n\"\"\"\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Any, Optional, Tuple, List, Dict\n\n# 参考图限制（见官方文档 lines 203-204）\nMAX_REFERENCE_IMAGES = 10  # doubao-seedream-4.0 最多支持10张参考图\nMAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n\n\n# 白名单与范围\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\"}\n\n\n@dataclass\nclass TextToImageParams:\n    prompt: str\n    size: str = \"1024x1024\"\n    guidance_scale: float = 2.5\n    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    reference_images: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass ImageToImageParams:\n    prompt: str\n    image: str  # URL 或 data URL\n    guidance_scale: float = 5.5\n    seed: Optional[int] = None\n    reference_images: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass VideoParams:\n    prompt: str\n    image_path: Optional[str] = None\n    first_frame_path: Optional[str] = None\n    last_frame_path: Optional[str] = None\n    duration: int = 8\n    fps: int = 24\n    seed: Optional[int] = None\n    camera_fixed: bool = True\n    watermark: bool = False\n    resolution_grade: Optional[str] = None\n    ratio: Optional[str] = None\n    use_pro_model: bool = True\n    reference_images: List[str] = field(default_factory=list)\n\n\n@dataclass(frozen=True)\nclass UIOption:\n    value: Any\n    label: str\n    description: Optional[str] = None\n    meta: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass(frozen=True)\nclass UIDependency:\n    field: str\n    equals: Any = None\n    not_equals: Any = None\n    exists: bool = False\n\n\n@dataclass\nclass UISchemaField:\n    name: str\n    field_type: str\n    label: str\n    default: Any = None\n    required: bool = False\n    help_text: Optional[str] = None\n    placeholder: Optional[str] = None\n    options: List[UIOption] = field(default_factory=list)\n    min_value: Optional[float] = None\n    max_value: Optional[float] = None\n    step: Optional[float] = None\n    visible_if: List[UIDependency] = field(default_factory=list)\n    enabled_if: List[UIDependency] = field(default_factory=list)\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"type\": self.field_type,\n            \"label\": self.label,\n            \"default\": self.default,\n            \"required\": self.required,\n            \"help_text\": self.help_text,\n            \"placeholder\": self.placeholder,\n            \"options\": [\n                {\n                    \"value\": opt.value,\n                    \"label\": opt.label,\n                    \"description\": opt.description,\n                    \"meta\": opt.meta,\n                }\n                for opt in self.options\n            ],\n            \"min\": self.min_value,\n            \"max\": self.max_value,\n            \"step\": self.step,\n            \"visible_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.visible_if\n            ],\n            \"enabled_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.enabled_if\n            ],\n            \"extra\": self.extra,\n        }\n\n\n@dataclass\nclass UISchema:\n    provider: str\n    mode: str\n    variant: str\n    fields: List[UISchemaField] = field(default_factory=list)\n    primary_image: Dict[str, Any] = field(default_factory=dict)\n    reference_assets: Dict[str, Any] = field(default_factory=dict)\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"provider\": self.provider,\n            \"mode\": self.mode,\n            \"variant\": self.variant,\n            \"fields\": [field.to_dict() for field in self.fields],\n            \"primary_image\": self.primary_image,\n            \"reference_assets\": self.reference_assets,\n            \"extra\": self.extra,\n        }\n\n\ndef _clip_seed(seed: Optional[int]) -> Optional[int]:\n    if seed is None:\n        return None\n    try:\n        iv = int(seed)\n    except Exception:\n        return None\n    if iv < 0:\n        return None\n    if iv > 2147483647:\n        iv = 2147483647\n    return iv\n\n\ndef validate_and_normalize_t2i(p: TextToImageParams) -> Tuple[TextToImageParams, bool, str]:\n    fb = False\n    reasons: List[str] = []\n    # size: 期望形如 WxH，范围 512..4096（兼容 Seedream 4.0 高分辨率）\n    def _valid_size(s: str) -> bool:\n        try:\n            if 'x' not in s:\n                return False\n            w, h = s.split('x', 1)\n            w, h = int(w), int(h)\n            return 512 <= w <= 4096 and 512 <= h <= 4096\n        except Exception:\n            return False\n\n    size = p.size or \"1024x1024\"\n    if not _valid_size(size):\n        fb = True\n        reasons.append(f\"无效尺寸: {p.size or '缺失'}\")\n        size = \"1024x1024\"\n\n    gs = p.guidance_scale\n    if not (1.0 <= gs <= 10.0):\n        fb = True\n        reasons.append(f\"guidance_scale越界: {gs}\")\n        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 2.5\n\n    seed = _clip_seed(p.seed)\n\n    raw_refs: List[str] = []\n    try:\n        for item in p.reference_images or []:\n            if isinstance(item, str) and item:\n                raw_refs.append(item)\n    except Exception:\n        raw_refs = []\n\n    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n    if ref_fb:\n        fb = True\n        reasons.append(ref_reason)\n\n    norm = TextToImageParams(\n        prompt=p.prompt,\n        size=size,\n        guidance_scale=gs,\n        seed=seed,\n        reference_images=refs,\n    )\n    return norm, fb, \", \".join(reasons) if fb else \"\"\n\n\ndef _normalize_reference_images(refs: List[str], expected_outputs: int = 1) -> Tuple[List[str], bool, str]:\n    \"\"\"裁剪/校验参考图数量，返回 (normalized_refs, fallback, reason)。\n\n    约束源于官方文档《doubao-seedream-4.0 教程》（行 203-204）：\n    - Seedream 4.0 最多 10 张参考图；\n    - （组图扩展）参考图数量 + 生成图数量 ≤ 15。\n    \"\"\"\n    fb = False\n    reasons: List[str] = []\n    refs = [r for r in refs if isinstance(r, str) and r]\n    # 限制：≤10 张\n    if len(refs) > MAX_REFERENCE_IMAGES:\n        fb = True\n        reasons.append(\n            f\"参考图数量超过 {MAX_REFERENCE_IMAGES}，已自动截取前 {MAX_REFERENCE_IMAGES} 张\"\n        )\n        refs = refs[:MAX_REFERENCE_IMAGES]\n    # 组图扩展：参考图 + 生成图 ≤ 15（当前生成图默认为 expected_outputs）\n    if expected_outputs >= 0 and len(refs) + expected_outputs > MAX_REFERENCE_BUNDLE:\n        allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n        if len(refs) > allowed:\n            fb = True\n            reasons.append(\n                f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}，已截取前 {allowed} 张\"\n            )\n            refs = refs[:allowed]\n    return refs, fb, \", \".join(reasons) if fb else \"\"\n\n\ndef validate_and_normalize_i2i(p: ImageToImageParams) -> Tuple[ImageToImageParams, bool, str]:\n    fb = False\n    reasons: List[str] = []\n    gs = p.guidance_scale\n    if not (1.0 <= gs <= 10.0):\n        fb = True\n        reasons.append(f\"guidance_scale越界: {gs}\")\n        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 5.5\n    seed = _clip_seed(p.seed)\n    raw_refs: List[str] = []\n    try:\n        for item in p.reference_images or []:\n            if isinstance(item, str) and item:\n                raw_refs.append(item)\n    except Exception:\n        raw_refs = []\n\n    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n    if ref_fb:\n        fb = True\n        reasons.append(ref_reason)\n\n    norm = ImageToImageParams(\n        prompt=p.prompt,\n        image=p.image,\n        guidance_scale=gs,\n        seed=seed,\n        reference_images=refs,\n    )\n    return norm, fb, \", \".join(reasons) if fb else \"\"\n\n\ndef validate_and_normalize_video(p: VideoParams) -> Tuple[VideoParams, bool, str, str, str]:\n    \"\"\"返回 (normalized, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n    fb = False\n    reasons: List[str] = []\n\n    rs = p.resolution_grade or \"1080p\"\n    rt = p.ratio or \"16:9\"\n    if rs not in RES_GRADES:\n        fb = True\n        reasons.append(f\"无效分辨率: {rs}\")\n        rs = \"1080p\"\n    if rt not in RATIOS:\n        fb = True\n        reasons.append(f\"无效比例: {rt}\")\n        rt = \"16:9\"\n\n    fps = int(p.fps or 24)\n    if fps <= 0:\n        fps = 24\n    dur = int(p.duration or 8)\n    if dur < 3:\n        fb = True\n        reasons.append(\"时长过短(<3s)\")\n        dur = 3\n    if dur > 12:\n        fb = True\n        reasons.append(\"时长过长(>12s)\")\n        dur = 12\n\n    seed = _clip_seed(p.seed)\n    raw_refs: List[str] = []\n    try:\n        for item in p.reference_images or []:\n            if isinstance(item, str) and item:\n                raw_refs.append(item)\n    except Exception:\n        raw_refs = []\n\n    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n    if ref_fb:\n        fb = True\n        reasons.append(ref_reason)\n\n    norm = VideoParams(\n        prompt=p.prompt,\n        image_path=p.image_path,\n        first_frame_path=p.first_frame_path,\n        last_frame_path=p.last_frame_path,\n        duration=dur,\n        fps=fps,\n        seed=seed,\n        camera_fixed=bool(p.camera_fixed),\n        watermark=bool(p.watermark),\n        resolution_grade=rs,\n        ratio=rt,\n        use_pro_model=bool(p.use_pro_model),\n        reference_images=refs,\n    )\n    return norm, fb, \", \".join(reasons) if fb else \"\", rs, rt\n\n\n# ------------------------------\n# UI Schema 定义（供前端驱动参数面板）\n# ------------------------------\n\n\ndef _schema_key(provider: str, mode: str, variant: str) -> str:\n    return f\"{provider}:{mode}:{variant}\"\n\n\ndef _option(value: Any, label: str, *, description: Optional[str] = None, meta: Optional[Dict[str, Any]] = None) -> UIOption:\n    return UIOption(value=value, label=label, description=description, meta=meta or {})\n\n\ndef _dependency(field: str, *, equals: Any = None, not_equals: Any = None, exists: bool = False) -> UIDependency:\n    return UIDependency(field=field, equals=equals, not_equals=not_equals, exists=exists)\n\n\ndef _build_seedream_schema(variant: str) -> UISchema:\n    variant = variant or \"seedream_v3\"\n    fields: List[UISchemaField] = []\n\n    model_options = [\n        _option(\n            \"seedream_v3\",\n            \"Seedream 3.x\",\n            description=\"稳定版本，支持单图/文生图\",\n            meta={\n                \"t2i_model\": \"doubao-seedream-3-0-t2i-250415\",\n                \"i2i_model\": \"doubao-seededit-3-0-i2i-250628\",\n                \"ui_variant\": \"seedream_v3\",\n            },\n        ),\n        _option(\n            \"seedream_v4\",\n            \"Seedream 4.0\",\n            description=\"多参考图融合，最大10张参考图\",\n            meta={\n                \"t2i_model\": \"doubao-seedream-4-0-250828\",\n                \"i2i_model\": \"doubao-seedream-4-0-250828\",\n                \"ui_variant\": \"seedream_v4\",\n            },\n        ),\n    ]\n    fields.append(\n        UISchemaField(\n            name=\"model_variant\",\n            field_type=\"select\",\n            label=\"模型版本\",\n            default=variant,\n            help_text=\"切换模型将刷新可选参数与上传限制\",\n            options=model_options,\n            extra={\"reload_on_change\": True, \"schema_family\": \"seedream\"},\n        )\n    )\n\n    if variant == \"seedream_v4\":\n        size_options = [\n            # 4K最大尺寸 (Seedream 4.0)\n            _option(\"4096x4096\", \"4096×4096 (1:1) 🔥\"),\n            _option(\"4096x2304\", \"4096×2304 (16:9) 🔥\"),\n            _option(\"2304x4096\", \"2304×4096 (9:16) 🔥\"),\n            \n            # 标准4K尺寸\n            _option(\"3840x2160\", \"3840×2160 (16:9)\"),\n            _option(\"2160x3840\", \"2160×3840 (9:16)\"),\n            _option(\"4096x3072\", \"4096×3072 (4:3)\"),\n            _option(\"3072x4096\", \"3072×4096 (3:4)\"),\n            _option(\"4096x2731\", \"4096×2731 (3:2)\"),\n            _option(\"2731x4096\", \"2731×4096 (2:3)\"),\n            _option(\"4096x1755\", \"4096×1755 (21:9)\"),\n            \n            # 兼容性尺寸\n            _option(\"3072x2048\", \"3072×2048 (3:2)\"),\n            _option(\"2048x3072\", \"2048×3072 (2:3)\"),\n            _option(\"2048x2048\", \"2048×2048 (1:1)\"),\n            _option(\"1920x1080\", \"1920×1080 (16:9)\"),\n            _option(\"1080x1920\", \"1080×1920 (9:16)\"),\n            _option(\"1024x1024\", \"1024×1024 (1:1)\"),\n        ]\n        default_size = \"4096x4096\"\n        # 过滤：移除边长小于 1024 的尺寸项（例如 1512x648），保证 4.0 仅提供大尺寸\n        try:\n            filtered_opts = []\n            for opt in list(size_options):\n                try:\n                    parts = [int(x.strip()) for x in str(opt.value).lower().split('x')]\n                    if len(parts) == 2 and min(parts[0], parts[1]) < 1024:\n                        continue\n                except Exception:\n                    pass\n                filtered_opts.append(opt)\n            size_options = filtered_opts\n        except Exception:\n            pass\n    else:\n        # Seedream 3.x：按常见比例提供范围内的最大像素组合（宽高在 512–2048）\n        size_options = [\n            _option(\"2048x2048\", \"2048×2048 (1:1)\"),\n            _option(\"2048x1536\", \"2048×1536 (4:3)\"),\n            _option(\"1536x2048\", \"1536×2048 (3:4)\"),\n            _option(\"2048x1152\", \"2048×1152 (16:9)\"),\n            _option(\"1152x2048\", \"1152×2048 (9:16)\"),\n            _option(\"1920x1280\", \"1920×1280 (3:2)\"),\n            _option(\"1280x1920\", \"1280×1920 (2:3)\"),\n            _option(\"1792x768\",  \"1792×768 (21:9)\"),\n        ]\n        default_size = \"2048x2048\"\n\n    fields.append(\n        UISchemaField(\n            name=\"size\",\n            field_type=\"select\",\n            label=\"分辨率\",\n            default=default_size,\n            options=size_options,\n            help_text=\"仅提供官方支持的常用分辨率\",\n        )\n    )\n\n    fields.append(\n        UISchemaField(\n            name=\"seed\",\n            field_type=\"spinbox\",\n            label=\"Seed\",\n            default=-1,\n            min_value=-1,\n            max_value=2147483647,\n            help_text=\"-1 表示随机；指定整数可复现结果\",\n        )\n    )\n\n    fields.append(\n        UISchemaField(\n            name=\"count\",\n            field_type=\"spinbox\",\n            label=\"生成数量\",\n            default=1,\n            min_value=1,\n            max_value=10,\n            help_text=\"一次最多生成 10 张\",\n        )\n    )\n\n    # 隐藏\"自动压缩参考图\"参数，后端自动启用\n    # fields.append(\n    #     UISchemaField(\n    #         name=\"auto_compress_references\",\n    #         field_type=\"toggle\",\n    #         label=\"自动压缩参考图\",\n    #         default=True,\n    #         help_text=\"上传时自动压缩到 2K 内，避免超出 API 限制\",\n    #     )\n    # )\n\n    if variant == \"seedream_v4\":\n        reference_enabled = True\n        ref_max_count = MAX_REFERENCE_IMAGES\n        ref_bundle_limit = MAX_REFERENCE_BUNDLE\n        ref_help = \"最多 10 张参考图，参考图 + 输出数量 ≤ 15\"\n        multi_reference = True\n    else:\n        # seedream_v3: 保留旧体验（单张参考图，面板隐藏）\n        reference_enabled = False\n        ref_max_count = 1\n        ref_bundle_limit = 1\n        ref_help = \"最多 1 张参考图\"\n        multi_reference = False\n\n    reference_assets = {\n        \"enabled\": reference_enabled,\n        \"max_count\": ref_max_count,\n        \"bundle_limit\": ref_bundle_limit,\n        \"accept\": [\"image/png\", \"image/jpeg\"],\n        \"auto_compress_field\": \"auto_compress_references\",\n        \"help_text\": ref_help,\n        \"orderable\": True,\n    }\n\n    primary_image = {\n        \"enabled\": True,\n        \"label\": \"基础图 (可选)\",\n        \"placeholder\": \"拖拽或点击上传一张基础图，留空则进行文生图\",\n        \"accept\": [\"image/png\", \"image/jpeg\"],\n        \"max_size_mb\": 10,\n    }\n\n    capabilities = {\n        \"multi_reference\": multi_reference,\n        \"supports_reference\": True,\n        \"single_reference\": not multi_reference,\n    }\n\n    extra = {\n        \"supports_reference\": True,  # 3.x模式也支持参考图显示，只是UI面板隐藏\n        \"layout\": {\n            \"type\": \"rows\",\n            \"row_spacing\": 6,\n            \"column_spacing\": 12,\n            \"rows\": [\n                [\n                    {\"name\": \"model_variant\", \"stretch\": 3, \"label_width\": 70, \"min_width\": 220},\n                    {\"name\": \"size\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 120},\n                    {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 120},\n                    {\"name\": \"count\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 100},\n                    {\n                        \"name\": \"auto_compress_references\",\n                        \"stretch\": 1,\n                        \"label_width\": 70,\n                    },\n                ],\n            ],\n        },\n        \"capabilities\": capabilities,\n    }\n\n    return UISchema(\n        provider=\"seedream\",\n        mode=\"image\",\n        variant=variant,\n        fields=fields,\n        primary_image=primary_image,\n        reference_assets=reference_assets,\n        extra=extra,\n    )\n\n\ndef _build_seedance_schema(variant: str) -> UISchema:\n    variant = variant or \"seedance_pro\"\n    model_options = [\n        _option(\n            \"seedance_pro\",\n            \"Seedance Pro\",\n            description=\"高质量输出，适合正式素材\",\n            meta={\"use_pro_model\": True, \"ui_variant\": \"seedance_pro\"},\n        ),\n        _option(\n            \"seedance_lite\",\n            \"Seedance Lite\",\n            description=\"快速输出，适合草稿\",\n            meta={\"use_pro_model\": False, \"ui_variant\": \"seedance_lite\"},\n        ),\n    ]\n\n    fields: List[UISchemaField] = [\n        UISchemaField(\n            name=\"model_variant\",\n            field_type=\"select\",\n            label=\"模型\",\n            default=variant,\n            help_text=\"Pro 输出质量更高，Lite 更快速\",\n            options=model_options,\n            extra={\"reload_on_change\": True, \"schema_family\": \"seedance\"},\n        ),\n        UISchemaField(\n            name=\"resolution_grade\",\n            field_type=\"select\",\n            label=\"分辨率档位\",\n            default=\"1080p\",\n            options=[\n                _option(\"480p\", \"480p\"),\n                _option(\"720p\", \"720p\"),\n                _option(\"1080p\", \"1080p\"),\n            ],\n            help_text=\"官方推荐 480p/720p/1080p 三档\",\n        ),\n        UISchemaField(\n            name=\"ratio\",\n            field_type=\"select\",\n            label=\"画面比例\",\n            default=\"16:9\",\n            options=[\n                _option(\"16:9\", \"16:9\"),\n                _option(\"9:16\", \"9:16\"),\n                _option(\"4:3\", \"4:3\"),\n                _option(\"1:1\", \"1:1\"),\n                _option(\"3:4\", \"3:4\"),\n                _option(\"21:9\", \"21:9\"),\n            ],\n            help_text=\"生成时自动拼接 --rs/--rt 参数\",\n        ),\n        UISchemaField(\n            name=\"duration\",\n            field_type=\"select\",\n            label=\"时长 (秒)\",\n            default=5,\n            options=[_option(sec, f\"{sec} 秒\") for sec in range(3, 13)],\n            help_text=\"范围 3-12 秒，超过范围将自动回退\",\n        ),\n        UISchemaField(\n            name=\"seed\",\n            field_type=\"spinbox\",\n            label=\"Seed\",\n            default=-1,\n            min_value=-1,\n            max_value=2147483647,\n            help_text=\"-1 表示随机；指定整数可复现\",\n        ),\n        UISchemaField(\n            name=\"camera_fixed\",\n            field_type=\"toggle\",\n            label=\"固定摄像机\",\n            default=True,\n            help_text=\"开启后相机保持固定，适合稳态镜头\",\n        ),\n    ]\n\n    reference_assets = {\n        \"enabled\": False,\n        \"max_count\": 0,\n        \"bundle_limit\": 0,\n        \"accept\": [],\n        \"auto_compress_field\": None,\n        \"help_text\": \"\",\n        \"orderable\": False,\n    }\n\n    primary_frames = {\n        \"enabled\": True,\n        \"slots\": [\n            {\n                \"name\": \"first_frame\",\n                \"label\": \"首帧 (可选)\",\n                \"help_text\": \"提供首帧可提升人物一致性\",\n                \"accept\": [\"image/png\", \"image/jpeg\"],\n            },\n            {\n                \"name\": \"last_frame\",\n                \"label\": \"尾帧 (可选)\",\n                \"help_text\": \"提供尾帧可控制结尾画面\",\n                \"accept\": [\"image/png\", \"image/jpeg\"],\n            },\n        ],\n        \"max_size_mb\": 10,\n    }\n\n    capabilities = {\n        \"multi_reference\": False,\n        \"supports_reference\": False,\n    }\n\n    extra = {\n        \"use_pro_model\": variant == \"seedance_pro\",\n        \"layout\": {\n            \"type\": \"rows\",\n            \"row_spacing\": 6,\n            \"column_spacing\": 10,\n            \"rows\": [\n                [\n                    {\"name\": \"model_variant\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 160},\n                    {\"name\": \"resolution_grade\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 140},\n                    {\"name\": \"ratio\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 110},\n                    {\"name\": \"duration\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 110},\n                    {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 120},\n                    {\"name\": \"camera_fixed\", \"stretch\": 1, \"label_width\": 70, \"min_width\": 110},\n                ],\n            ],\n        },\n        \"capabilities\": capabilities,\n    }\n\n    return UISchema(\n        provider=\"seedance\",\n        mode=\"video\",\n        variant=variant,\n        fields=fields,\n        primary_image=primary_frames,\n        reference_assets=reference_assets,\n        extra=extra,\n    )\n\n\n_UI_SCHEMAS: Dict[str, UISchema] = {\n    _schema_key(\"seedream\", \"image\", \"seedream_v3\"): _build_seedream_schema(\"seedream_v3\"),\n    _schema_key(\"seedream\", \"image\", \"seedream_v4\"): _build_seedream_schema(\"seedream_v4\"),\n    _schema_key(\"seedance\", \"video\", \"seedance_pro\"): _build_seedance_schema(\"seedance_pro\"),\n    _schema_key(\"seedance\", \"video\", \"seedance_lite\"): _build_seedance_schema(\"seedance_lite\"),\n}\n\n\n_DEFAULT_VARIANTS: Dict[Tuple[str, str], str] = {\n    (\"seedream\", \"image\"): \"seedream_v3\",\n    (\"seedance\", \"video\"): \"seedance_pro\",\n}\n\n\ndef get_ui_schema(provider: str, mode: str, variant: Optional[str] = None, *, as_dict: bool = False) -> UISchema:\n    \"\"\"返回 UI Schema（深拷贝，避免调用侧修改真源）。\"\"\"\n\n    key_variant = variant or _DEFAULT_VARIANTS.get((provider, mode))\n    if not key_variant:\n        raise ValueError(f\"未定义默认 UI Schema: provider={provider} mode={mode}\")\n\n    key = _schema_key(provider, mode, key_variant)\n    if key not in _UI_SCHEMAS:\n        raise ValueError(f\"未找到 UI Schema: provider={provider} mode={mode} variant={key_variant}\")\n\n    schema = copy.deepcopy(_UI_SCHEMAS[key])\n    if as_dict:\n        return schema.to_dict()  # type: ignore[return-value]\n    return schema\n\n\ndef list_ui_schema_variants(provider: str, mode: str) -> List[str]:\n    prefix = f\"{provider}:{mode}:\"\n    return [key.split(\":\", 2)[-1] for key in _UI_SCHEMAS.keys() if key.startswith(prefix)]\n","numLines":751,"startLine":1,"totalLines":751}}}
{"parentUuid":"cc15d3f9-6a35-4d7a-8c37-e86a7a6786d3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019aDHnvkhP2EUsSe2yScbBr","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Volc (Ark) Provider 映射（最小实现）\n     5→\n     6→职责：将统一 Schema 归一化后的参数映射到当前 Ark v3 的请求载荷/文本 flag。\n     7→HTTP 请求仍在各自 Client 内执行。\n     8→\"\"\"\n     9→from typing import Dict, Any, Tuple\n    10→from .base import BaseProvider\n    11→from .schema import TextToImageParams, ImageToImageParams, VideoParams\n    12→try:\n    13→    # 复用现有模型 ID 定义，避免硬编码漂移\n    14→    from modules.seedance.config import SeedanceModels\n    15→except Exception:\n    16→    SeedanceModels = None\n    17→\n    18→\n    19→class VolcProvider(BaseProvider):\n    20→    name = \"volcengine\"\n    21→\n    22→    # Seedream 3.0/3.1 - 文生图\n    23→    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    24→        norm, fb, reason = self.validate_t2i(params)\n    25→        # 与当前实现保持一致：固定 watermark=False，response_format=url\n    26→        data = {\n    27→            \"model\": \"doubao-seedream-3-0-t2i-250415\",\n    28→            \"prompt\": norm.prompt,\n    29→            \"size\": norm.size,\n    30→            \"response_format\": \"url\",\n    31→            \"watermark\": False,\n    32→            \"guidance_scale\": norm.guidance_scale,\n    33→        }\n    34→        if norm.seed is not None:\n    35→            data[\"seed\"] = norm.seed\n    36→        return data, fb, reason, \"/images/generations\"\n    37→\n    38→    # Seedream 3.0/3.1 - 图生图\n    39→    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    40→        norm, fb, reason = self.validate_i2i(params)\n    41→        data = {\n    42→            \"model\": \"doubao-seededit-3-0-i2i-250628\",\n    43→            \"prompt\": norm.prompt,\n    44→            \"image\": norm.image,\n    45→            \"size\": \"adaptive\",\n    46→            \"response_format\": \"url\",\n    47→            \"watermark\": False,\n    48→            \"guidance_scale\": norm.guidance_scale,\n    49→        }\n    50→        if norm.seed is not None:\n    51→            data[\"seed\"] = norm.seed\n    52→        return data, fb, reason, \"/images/generations\"\n    53→\n    54→    # Seedance pro/lite - 视频\n    55→    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n    56→        norm, fb, reason, used_rs, used_rt = self.validate_video(params)\n    57→\n    58→        # 模型选择逻辑保持与现有实现一致\n    59→        if norm.first_frame_path and norm.last_frame_path:\n    60→            model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n    61→            mode = \"首尾帧视频(Lite)\"\n    62→        elif norm.use_pro_model:\n    63→            model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n    64→            mode = \"图生视频(Pro)\" if norm.image_path else \"文生视频(Pro)\"\n    65→        else:\n    66→            if norm.image_path:\n    67→                model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n    68→                mode = \"图生视频(Lite)\"\n    69→            else:\n    70→                model = SeedanceModels.LITE_T2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-t2v-250428\"\n    71→                mode = \"文生视频(Lite)\"\n    72→\n    73→        # 文本 flags（与客户端 _validate_and_build_flags 顺序对齐）\n    74→        parts = [\n    75→            \"--rs\", used_rs,\n    76→            \"--rt\", used_rt,\n    77→            \"--dur\", str(norm.duration),\n    78→            \"--fps\", str(norm.fps),\n    79→            \"--wm\", str(bool(norm.watermark)).lower(),\n    80→        ]\n    81→        if norm.seed is not None:\n    82→            parts += [\"--seed\", str(norm.seed)]\n    83→        parts += [\"--cf\", str(bool(norm.camera_fixed)).lower()]\n    84→        flags_text = \" \".join(parts)\n    85→\n    86→        content = []\n    87→        if norm.first_frame_path and norm.last_frame_path:\n    88→            content.append({\n    89→                \"type\": \"image_url\",\n    90→                \"image_url\": {\"url\": norm.first_frame_path},\n    91→                \"role\": \"first_frame\"\n    92→            })\n    93→            content.append({\n    94→                \"type\": \"image_url\",\n    95→                \"image_url\": {\"url\": norm.last_frame_path},\n    96→                \"role\": \"last_frame\"\n    97→            })\n    98→        elif norm.image_path:\n    99→            content.append({\n   100→                \"type\": \"image_url\",\n   101→                \"image_url\": {\"url\": norm.image_path},\n   102→                \"role\": \"first_frame\"\n   103→            })\n   104→\n   105→        text_prompt = f\"{norm.prompt} {flags_text}\".strip()\n   106→        content.append({\"type\": \"text\", \"text\": text_prompt})\n   107→\n   108→        mapped = {\n   109→            \"model\": model,\n   110→            \"content\": content,\n   111→            \"mode\": mode,\n   112→            \"flags_text\": flags_text,\n   113→        }\n   114→        return mapped, fb, reason, used_rs, used_rt\n   115→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b3ac9af8-154c-40b5-96ea-33f02e1c19db","timestamp":"2025-12-09T03:57:00.570Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVolc (Ark) Provider 映射（最小实现）\n\n职责：将统一 Schema 归一化后的参数映射到当前 Ark v3 的请求载荷/文本 flag。\nHTTP 请求仍在各自 Client 内执行。\n\"\"\"\nfrom typing import Dict, Any, Tuple\nfrom .base import BaseProvider\nfrom .schema import TextToImageParams, ImageToImageParams, VideoParams\ntry:\n    # 复用现有模型 ID 定义，避免硬编码漂移\n    from modules.seedance.config import SeedanceModels\nexcept Exception:\n    SeedanceModels = None\n\n\nclass VolcProvider(BaseProvider):\n    name = \"volcengine\"\n\n    # Seedream 3.0/3.1 - 文生图\n    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_t2i(params)\n        # 与当前实现保持一致：固定 watermark=False，response_format=url\n        data = {\n            \"model\": \"doubao-seedream-3-0-t2i-250415\",\n            \"prompt\": norm.prompt,\n            \"size\": norm.size,\n            \"response_format\": \"url\",\n            \"watermark\": False,\n            \"guidance_scale\": norm.guidance_scale,\n        }\n        if norm.seed is not None:\n            data[\"seed\"] = norm.seed\n        return data, fb, reason, \"/images/generations\"\n\n    # Seedream 3.0/3.1 - 图生图\n    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_i2i(params)\n        data = {\n            \"model\": \"doubao-seededit-3-0-i2i-250628\",\n            \"prompt\": norm.prompt,\n            \"image\": norm.image,\n            \"size\": \"adaptive\",\n            \"response_format\": \"url\",\n            \"watermark\": False,\n            \"guidance_scale\": norm.guidance_scale,\n        }\n        if norm.seed is not None:\n            data[\"seed\"] = norm.seed\n        return data, fb, reason, \"/images/generations\"\n\n    # Seedance pro/lite - 视频\n    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n        norm, fb, reason, used_rs, used_rt = self.validate_video(params)\n\n        # 模型选择逻辑保持与现有实现一致\n        if norm.first_frame_path and norm.last_frame_path:\n            model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n            mode = \"首尾帧视频(Lite)\"\n        elif norm.use_pro_model:\n            model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n            mode = \"图生视频(Pro)\" if norm.image_path else \"文生视频(Pro)\"\n        else:\n            if norm.image_path:\n                model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n                mode = \"图生视频(Lite)\"\n            else:\n                model = SeedanceModels.LITE_T2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-t2v-250428\"\n                mode = \"文生视频(Lite)\"\n\n        # 文本 flags（与客户端 _validate_and_build_flags 顺序对齐）\n        parts = [\n            \"--rs\", used_rs,\n            \"--rt\", used_rt,\n            \"--dur\", str(norm.duration),\n            \"--fps\", str(norm.fps),\n            \"--wm\", str(bool(norm.watermark)).lower(),\n        ]\n        if norm.seed is not None:\n            parts += [\"--seed\", str(norm.seed)]\n        parts += [\"--cf\", str(bool(norm.camera_fixed)).lower()]\n        flags_text = \" \".join(parts)\n\n        content = []\n        if norm.first_frame_path and norm.last_frame_path:\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.first_frame_path},\n                \"role\": \"first_frame\"\n            })\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.last_frame_path},\n                \"role\": \"last_frame\"\n            })\n        elif norm.image_path:\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.image_path},\n                \"role\": \"first_frame\"\n            })\n\n        text_prompt = f\"{norm.prompt} {flags_text}\".strip()\n        content.append({\"type\": \"text\", \"text\": text_prompt})\n\n        mapped = {\n            \"model\": model,\n            \"content\": content,\n            \"mode\": mode,\n            \"flags_text\": flags_text,\n        }\n        return mapped, fb, reason, used_rs, used_rt\n","numLines":115,"startLine":1,"totalLines":115}}}
{"parentUuid":"b3ac9af8-154c-40b5-96ea-33f02e1c19db","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Qb5J74Ursx1XdZodWowuCN","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the volc_v4 provider and the UI mode widgets:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":14849,"cache_read_input_tokens":89241,"cache_creation":{"ephemeral_5m_input_tokens":14849,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"d732ea8a-1a36-4f38-81c5-014701684934","timestamp":"2025-12-09T03:57:20.861Z"}
{"parentUuid":"d732ea8a-1a36-4f38-81c5-014701684934","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Qb5J74Ursx1XdZodWowuCN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Te5fuHgw3ZmbtQWcAWtRJJ","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":14849,"cache_read_input_tokens":89241,"cache_creation":{"ephemeral_5m_input_tokens":14849,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"5cdabe4d-d091-41d7-ac10-6ab0e17b470e","timestamp":"2025-12-09T03:57:21.837Z"}
{"parentUuid":"5cdabe4d-d091-41d7-ac10-6ab0e17b470e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Qb5J74Ursx1XdZodWowuCN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019TNSs9jDyb3hftNHqC2r83","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/image_mode_widget.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":14849,"cache_read_input_tokens":89241,"cache_creation":{"ephemeral_5m_input_tokens":14849,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"2c921f0a-8aec-4114-9eb7-080a3da70958","timestamp":"2025-12-09T03:57:22.569Z"}
{"parentUuid":"2c921f0a-8aec-4114-9eb7-080a3da70958","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Qb5J74Ursx1XdZodWowuCN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0154ZScbcHAsUuRK9E2ag2h2","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":14849,"cache_read_input_tokens":89241,"cache_creation":{"ephemeral_5m_input_tokens":14849,"ephemeral_1h_input_tokens":0},"output_tokens":219,"service_tier":"standard"}},"type":"assistant","uuid":"c1d52c9f-f08c-4287-bace-eacfa94bf535","timestamp":"2025-12-09T03:57:23.190Z"}
{"parentUuid":"c1d52c9f-f08c-4287-bace-eacfa94bf535","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Te5fuHgw3ZmbtQWcAWtRJJ","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Volc (Ark) Seedream 4.0 Provider 映射。\n     5→\n     6→仅调整模型 ID 以及字段，以便在不改 UI 的前提下灰度接入。\n     7→\"\"\"\n     8→from typing import Dict, Any, Tuple, List\n     9→\n    10→def _to_v4_size(size: str) -> str:\n    11→    \"\"\"\n    12→    转换尺寸参数为 Seedream 4.0 支持的格式。\n    13→    支持两种格式：\n    14→    1. 分辨率格式：1K、2K、4K\n    15→    2. 具体像素值：如 2048x2048（保持原样）\n    16→    \"\"\"\n    17→    try:\n    18→        if not size:\n    19→            return \"2048x2048\"  # 默认值\n    20→        \n    21→        normalized = size.strip().lower()\n    22→        \n    23→        # 如果已经是支持的分辨率格式，直接返回\n    24→        if normalized in {\"1k\", \"2k\", \"4k\"}:\n    25→            return normalized\n    26→        \n    27→        # 如果是具体的像素值（如 \"2048x2048\"），验证范围并返回\n    28→        if \"x\" in normalized:\n    29→            width_str, height_str = normalized.split(\"x\", 1)\n    30→            width = int(float(width_str))\n    31→            height = int(float(height_str))\n    32→            \n    33→            # 验证尺寸范围：[1024x1024, 4096x4096]\n    34→            if width < 1024 or height < 1024:\n    35→                # 太小，使用最小尺寸\n    36→                return \"1024x1024\"\n    37→            elif width > 4096 or height > 4096:\n    38→                # 太大，使用最大尺寸\n    39→                return \"4096x4096\"\n    40→            else:\n    41→                # 在有效范围内，返回原始尺寸\n    42→                return f\"{width}x{height}\"\n    43→    except Exception:\n    44→        pass\n    45→    \n    46→    return \"2048x2048\"  # 默认值\n    47→\n    48→from .base import BaseProvider\n    49→from .schema import TextToImageParams, ImageToImageParams\n    50→\n    51→\n    52→class VolcV4Provider(BaseProvider):\n    53→    name = \"volcengine_v4\"\n    54→\n    55→    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    56→        norm, fb, reason = self.validate_t2i(params)\n    57→        size_value = _to_v4_size(norm.size)\n    58→        data = {\n    59→            \"model\": \"doubao-seedream-4-0-250828\",\n    60→            \"prompt\": norm.prompt,\n    61→            \"size\": size_value,\n    62→            \"response_format\": \"url\",\n    63→            \"watermark\": False,\n    64→        }\n    65→        # Seedream 4.0 不支持 seed 参数\n    66→        # 根据官方文档：\"seed 可以传入，但不生效\"\n    67→        # 为避免误导，这里不传递 seed\n    68→\n    69→        images_payload: List[str] = []\n    70→        for ref in norm.reference_images or []:\n    71→            if isinstance(ref, str) and ref:\n    72→                images_payload.append(ref)\n    73→\n    74→        if images_payload:\n    75→            # Ark 文档要求：单图输出场景保持 sequential_image_generation=disabled，\n    76→            # 仅在显式请求组图时才开启 auto。当前桌面端仍是单图出口，因此统一禁用，\n    77→            # 避免超过 4 张参考图时被服务端判定为组图任务并返回参数错误。\n    78→            data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n    79→            data[\"sequential_image_generation\"] = \"disabled\"\n    80→\n    81→        return data, fb, reason, \"/images/generations\"\n    82→\n    83→    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    84→        norm, fb, reason = self.validate_i2i(params)\n    85→        target_size = _to_v4_size(getattr(norm, \"size\", None) or \"1k\")\n    86→        data = {\n    87→            \"model\": \"doubao-seedream-4-0-250828\",\n    88→            \"prompt\": norm.prompt,\n    89→            \"image\": norm.image,\n    90→            \"size\": target_size,\n    91→            \"response_format\": \"url\",\n    92→            \"watermark\": False,\n    93→        }\n    94→        # Seedream 4.0 不支持 seed 参数\n    95→        # 根据官方文档：\"seed 可以传入，但不生效\"\n    96→        # 为避免误导，这里不传递 seed\n    97→\n    98→        images_payload: List[str] = []\n    99→        if norm.image:\n   100→            images_payload.append(norm.image)\n   101→        for ref in norm.reference_images or []:\n   102→            if ref and isinstance(ref, str):\n   103→                images_payload.append(ref)\n   104→\n   105→        if images_payload:\n   106→            # 图生图同样保持单输出模式，避免触发组图分支。\n   107→            data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n   108→            data[\"sequential_image_generation\"] = \"disabled\"\n   109→        return data, fb, reason, \"/images/generations\"\n   110→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d1ace40a-a011-4ac3-b347-711899751460","timestamp":"2025-12-09T03:57:23.248Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVolc (Ark) Seedream 4.0 Provider 映射。\n\n仅调整模型 ID 以及字段，以便在不改 UI 的前提下灰度接入。\n\"\"\"\nfrom typing import Dict, Any, Tuple, List\n\ndef _to_v4_size(size: str) -> str:\n    \"\"\"\n    转换尺寸参数为 Seedream 4.0 支持的格式。\n    支持两种格式：\n    1. 分辨率格式：1K、2K、4K\n    2. 具体像素值：如 2048x2048（保持原样）\n    \"\"\"\n    try:\n        if not size:\n            return \"2048x2048\"  # 默认值\n        \n        normalized = size.strip().lower()\n        \n        # 如果已经是支持的分辨率格式，直接返回\n        if normalized in {\"1k\", \"2k\", \"4k\"}:\n            return normalized\n        \n        # 如果是具体的像素值（如 \"2048x2048\"），验证范围并返回\n        if \"x\" in normalized:\n            width_str, height_str = normalized.split(\"x\", 1)\n            width = int(float(width_str))\n            height = int(float(height_str))\n            \n            # 验证尺寸范围：[1024x1024, 4096x4096]\n            if width < 1024 or height < 1024:\n                # 太小，使用最小尺寸\n                return \"1024x1024\"\n            elif width > 4096 or height > 4096:\n                # 太大，使用最大尺寸\n                return \"4096x4096\"\n            else:\n                # 在有效范围内，返回原始尺寸\n                return f\"{width}x{height}\"\n    except Exception:\n        pass\n    \n    return \"2048x2048\"  # 默认值\n\nfrom .base import BaseProvider\nfrom .schema import TextToImageParams, ImageToImageParams\n\n\nclass VolcV4Provider(BaseProvider):\n    name = \"volcengine_v4\"\n\n    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_t2i(params)\n        size_value = _to_v4_size(norm.size)\n        data = {\n            \"model\": \"doubao-seedream-4-0-250828\",\n            \"prompt\": norm.prompt,\n            \"size\": size_value,\n            \"response_format\": \"url\",\n            \"watermark\": False,\n        }\n        # Seedream 4.0 不支持 seed 参数\n        # 根据官方文档：\"seed 可以传入，但不生效\"\n        # 为避免误导，这里不传递 seed\n\n        images_payload: List[str] = []\n        for ref in norm.reference_images or []:\n            if isinstance(ref, str) and ref:\n                images_payload.append(ref)\n\n        if images_payload:\n            # Ark 文档要求：单图输出场景保持 sequential_image_generation=disabled，\n            # 仅在显式请求组图时才开启 auto。当前桌面端仍是单图出口，因此统一禁用，\n            # 避免超过 4 张参考图时被服务端判定为组图任务并返回参数错误。\n            data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n            data[\"sequential_image_generation\"] = \"disabled\"\n\n        return data, fb, reason, \"/images/generations\"\n\n    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_i2i(params)\n        target_size = _to_v4_size(getattr(norm, \"size\", None) or \"1k\")\n        data = {\n            \"model\": \"doubao-seedream-4-0-250828\",\n            \"prompt\": norm.prompt,\n            \"image\": norm.image,\n            \"size\": target_size,\n            \"response_format\": \"url\",\n            \"watermark\": False,\n        }\n        # Seedream 4.0 不支持 seed 参数\n        # 根据官方文档：\"seed 可以传入，但不生效\"\n        # 为避免误导，这里不传递 seed\n\n        images_payload: List[str] = []\n        if norm.image:\n            images_payload.append(norm.image)\n        for ref in norm.reference_images or []:\n            if ref and isinstance(ref, str):\n                images_payload.append(ref)\n\n        if images_payload:\n            # 图生图同样保持单输出模式，避免触发组图分支。\n            data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n            data[\"sequential_image_generation\"] = \"disabled\"\n        return data, fb, reason, \"/images/generations\"\n","numLines":110,"startLine":1,"totalLines":110}}}
{"parentUuid":"d1ace40a-a011-4ac3-b347-711899751460","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (27617 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_0154ZScbcHAsUuRK9E2ag2h2"}]},"uuid":"3f6ff1e4-b4d6-49f6-bd1a-2c82a91aaf28","timestamp":"2025-12-09T03:57:26.299Z","toolUseResult":"Error: File content (27617 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"3f6ff1e4-b4d6-49f6-bd1a-2c82a91aaf28","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (28131 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_019TNSs9jDyb3hftNHqC2r83"}]},"uuid":"5492f210-1891-4c90-923e-f0e654346622","timestamp":"2025-12-09T03:57:26.584Z","toolUseResult":"Error: File content (28131 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"5492f210-1891-4c90-923e-f0e654346622","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CWU3Lg1HyW65EiYvLWSSTK","type":"message","role":"assistant","content":[{"type":"text","text":"Let me search for the model selection logic in the UI widgets:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":73,"cache_creation_input_tokens":2227,"cache_read_input_tokens":104090,"cache_creation":{"ephemeral_5m_input_tokens":2227,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"9bc1ec4b-5138-40bc-ad95-e7fd0f16c88b","timestamp":"2025-12-09T03:57:43.597Z"}
{"parentUuid":"9bc1ec4b-5138-40bc-ad95-e7fd0f16c88b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CWU3Lg1HyW65EiYvLWSSTK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HZHNPAs8qN7ESEnUGcpZbs","name":"Grep","input":{"pattern":"use_pro_model|seedance_pro|seedance_lite|model_variant","path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes","output_mode":"content","-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":73,"cache_creation_input_tokens":2227,"cache_read_input_tokens":104090,"cache_creation":{"ephemeral_5m_input_tokens":2227,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"89012913-0ef9-40fc-93fa-952fa65e23fe","timestamp":"2025-12-09T03:57:46.032Z"}
{"parentUuid":"89012913-0ef9-40fc-93fa-952fa65e23fe","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CWU3Lg1HyW65EiYvLWSSTK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01R74CR9mVpPhgYXrby2WRUJ","name":"Grep","input":{"pattern":"first_frame|last_frame","path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes","output_mode":"content","-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":73,"cache_creation_input_tokens":2227,"cache_read_input_tokens":104090,"cache_creation":{"ephemeral_5m_input_tokens":2227,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"09f57233-5d4f-4164-bf3f-53e1e58c52b4","timestamp":"2025-12-09T03:57:47.255Z"}
{"parentUuid":"09f57233-5d4f-4164-bf3f-53e1e58c52b4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HZHNPAs8qN7ESEnUGcpZbs","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1890-        server_watermark = bool(API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1891-        camera_fixed = bool(form_values.get('camera_fixed', True))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1892-\ncomponents/modes/video_mode_widget.py:1893:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\ncomponents/modes/video_mode_widget.py:1894:        use_pro_model = True\ncomponents/modes/video_mode_widget.py-1895-        if self._video_schema and getattr(self._video_schema, 'extra', None):\ncomponents/modes/video_mode_widget.py:1896:            use_pro_model = bool(self._video_schema.extra.get('use_pro_model', use_pro_model))\ncomponents/modes/video_mode_widget.py-1897-        else:\ncomponents/modes/video_mode_widget.py:1898:            use_pro_model = str(model_variant).endswith('pro')\ncomponents/modes/video_mode_widget.py:1899:        model_type = 'pro' if use_pro_model else 'lite'\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1900-\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1901-        fps_value = form_values.get('fps', 24)\ncomponents/modes/video_mode_widget.py-1902-        try:\n--\ncomponents/modes/video_mode_widget.py-1924-            \"camera_fixed\": camera_fixed,\ncomponents/modes/video_mode_widget.py-1925-            \"seed\": seed if seed is not None else -1,\ncomponents/modes/video_mode_widget.py-1926-            \"model_type\": model_type,\ncomponents/modes/video_mode_widget.py:1927:            \"model_variant\": model_variant,\ncomponents/modes/video_mode_widget.py-1928-            \"first_frame\": first_frame,\ncomponents/modes/video_mode_widget.py-1929-            \"last_frame\": last_frame,\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"a45c8060-24a3-4ccb-9869-96c1eea4d84a","timestamp":"2025-12-09T03:57:47.377Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1890-        server_watermark = bool(API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1891-        camera_fixed = bool(form_values.get('camera_fixed', True))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1892-\ncomponents/modes/video_mode_widget.py:1893:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\ncomponents/modes/video_mode_widget.py:1894:        use_pro_model = True\ncomponents/modes/video_mode_widget.py-1895-        if self._video_schema and getattr(self._video_schema, 'extra', None):\ncomponents/modes/video_mode_widget.py:1896:            use_pro_model = bool(self._video_schema.extra.get('use_pro_model', use_pro_model))\ncomponents/modes/video_mode_widget.py-1897-        else:\ncomponents/modes/video_mode_widget.py:1898:            use_pro_model = str(model_variant).endswith('pro')\ncomponents/modes/video_mode_widget.py:1899:        model_type = 'pro' if use_pro_model else 'lite'\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1900-\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1901-        fps_value = form_values.get('fps', 24)\ncomponents/modes/video_mode_widget.py-1902-        try:\n--\ncomponents/modes/video_mode_widget.py-1924-            \"camera_fixed\": camera_fixed,\ncomponents/modes/video_mode_widget.py-1925-            \"seed\": seed if seed is not None else -1,\ncomponents/modes/video_mode_widget.py-1926-            \"model_type\": model_type,\ncomponents/modes/video_mode_widget.py:1927:            \"model_variant\": model_variant,\ncomponents/modes/video_mode_widget.py-1928-            \"first_frame\": first_frame,\ncomponents/modes/video_mode_widget.py-1929-            \"last_frame\": last_frame,","numLines":20,"appliedLimit":20}}
{"parentUuid":"a45c8060-24a3-4ccb-9869-96c1eea4d84a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01R74CR9mVpPhgYXrby2WRUJ","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1905-            fps = 24\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1906-        \n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1907-        # 获取上传的图片\ncomponents/modes/video_mode_widget.py:1908:        first_frame = self.uploaded_images[0] if self.uploaded_images[0] else None\ncomponents/modes/video_mode_widget.py:1909:        last_frame = self.uploaded_images[1] if self.uploaded_images[1] else None\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1910-\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1911-        reference_assets = self._collect_reference_assets_for_video()\ncomponents/modes/video_mode_widget.py-1912-        if reference_assets is None:\n--\ncomponents/modes/video_mode_widget.py-1925-            \"seed\": seed if seed is not None else -1,\ncomponents/modes/video_mode_widget.py-1926-            \"model_type\": model_type,\ncomponents/modes/video_mode_widget.py-1927-            \"model_variant\": model_variant,\ncomponents/modes/video_mode_widget.py:1928:            \"first_frame\": first_frame,\ncomponents/modes/video_mode_widget.py:1929:            \"last_frame\": last_frame,\ncomponents/modes/video_mode_widget.py-1930-            \"reference_images\": reference_assets,\ncomponents/modes/video_mode_widget.py-1931-            \"reference_count\": len(reference_assets),\ncomponents/modes/video_mode_widget.py-1932-            \"schema_values\": dict(form_values),\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1933-        }\ncomponents/modes/video_mode_widget.py:1934:        if first_frame and not last_frame:\ncomponents/modes/video_mode_widget.py:1935:            params['image_path'] = first_frame\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"f977b986-89cf-465e-aa3f-94f3ce0471a7","timestamp":"2025-12-09T03:57:47.385Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1905-            fps = 24\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1906-        \n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1907-        # 获取上传的图片\ncomponents/modes/video_mode_widget.py:1908:        first_frame = self.uploaded_images[0] if self.uploaded_images[0] else None\ncomponents/modes/video_mode_widget.py:1909:        last_frame = self.uploaded_images[1] if self.uploaded_images[1] else None\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1910-\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1911-        reference_assets = self._collect_reference_assets_for_video()\ncomponents/modes/video_mode_widget.py-1912-        if reference_assets is None:\n--\ncomponents/modes/video_mode_widget.py-1925-            \"seed\": seed if seed is not None else -1,\ncomponents/modes/video_mode_widget.py-1926-            \"model_type\": model_type,\ncomponents/modes/video_mode_widget.py-1927-            \"model_variant\": model_variant,\ncomponents/modes/video_mode_widget.py:1928:            \"first_frame\": first_frame,\ncomponents/modes/video_mode_widget.py:1929:            \"last_frame\": last_frame,\ncomponents/modes/video_mode_widget.py-1930-            \"reference_images\": reference_assets,\ncomponents/modes/video_mode_widget.py-1931-            \"reference_count\": len(reference_assets),\ncomponents/modes/video_mode_widget.py-1932-            \"schema_values\": dict(form_values),\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1933-        }\ncomponents/modes/video_mode_widget.py:1934:        if first_frame and not last_frame:\ncomponents/modes/video_mode_widget.py:1935:            params['image_path'] = first_frame","numLines":20,"appliedLimit":20}}
{"parentUuid":"f977b986-89cf-465e-aa3f-94f3ce0471a7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Sukx3FW6Cbv1CGQcaNrUNx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01APJx6eaBBrj9kTpXW1fnrf","name":"Grep","input":{"pattern":"seedream_v4|model_variant|GEMENG_SEEDREAM_PROVIDER","path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes","output_mode":"content","-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2056,"cache_read_input_tokens":106317,"cache_creation":{"ephemeral_5m_input_tokens":2056,"ephemeral_1h_input_tokens":0},"output_tokens":23,"service_tier":"standard"}},"type":"assistant","uuid":"91b9c5b4-4f50-4a3e-af83-ac1535417107","timestamp":"2025-12-09T03:58:06.591Z"}
{"parentUuid":"91b9c5b4-4f50-4a3e-af83-ac1535417107","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Sukx3FW6Cbv1CGQcaNrUNx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SBqHZzg99q57p27MFosuSA","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2056,"cache_read_input_tokens":106317,"cache_creation":{"ephemeral_5m_input_tokens":2056,"ephemeral_1h_input_tokens":0},"output_tokens":23,"service_tier":"standard"}},"type":"assistant","uuid":"c2af4335-598e-41b0-92a0-cf12d4d21a73","timestamp":"2025-12-09T03:58:07.434Z"}
{"parentUuid":"c2af4335-598e-41b0-92a0-cf12d4d21a73","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SBqHZzg99q57p27MFosuSA","type":"tool_result","content":"     1→\"\"\"Seedream image generation service layer.\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import uuid\n     6→from typing import Any, Callable, Dict, List, Optional\n     7→\n     8→from config.unified_config import get_unified_config\n     9→from modules.repository.manager import RepositoryManager\n    10→from modules.seedream.manager import SeedreamManager\n    11→from modules.storage import get_v2_storage_manager\n    12→from utils.logger import logger\n    13→\n    14→ProgressCallback = Optional[Callable[[Optional[float], str], None]]\n    15→CancelCallback = Optional[Callable[[], bool]]\n    16→\n    17→\n    18→class ImageService:\n    19→    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n    20→\n    21→    def __init__(\n    22→        self,\n    23→        storage_manager=None,\n    24→        repository_manager: Optional[RepositoryManager] = None,\n    25→        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    26→    ) -> None:\n    27→        # Use unified config for storage path and API validation\n    28→        self.unified_config = get_unified_config()\n    29→\n    30→        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n    31→        self.repository_manager = repository_manager\n    32→        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n    33→\n    34→    # ------------------------------------------------------------------\n    35→    # Public API\n    36→    # ------------------------------------------------------------------\n    37→    def generate_image(\n    38→        self,\n    39→        params: Dict[str, Any],\n    40→        progress_callback: ProgressCallback = None,\n    41→        should_cancel: CancelCallback = None,\n    42→    ) -> Dict[str, Any]:\n    43→        prompt = (params.get(\"prompt\") or \"\").strip()\n    44→        if not prompt:\n    45→            return self._failure(\"Prompt cannot be empty\")\n    46→\n    47→        if self._is_cancelled(should_cancel):\n    48→            return self._cancelled()\n    49→\n    50→        self._emit_progress(progress_callback, \"Preparing...\")\n    51→\n    52→        try:\n    53→            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n    54→            if not is_valid:\n    55→                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n    56→                detail = message or \"API key not configured\"\n    57→                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n    58→        except Exception as cfg_err:\n    59→            return self._failure(f\"Config validation failed: {cfg_err}\")\n    60→\n    61→        try:\n    62→            api_key = self.unified_config.get_api_key(\"volcengine\")\n    63→        except Exception as key_err:\n    64→            return self._failure(f\"Failed to load API key: {key_err}\")\n    65→\n    66→        if self._is_cancelled(should_cancel):\n    67→            return self._cancelled()\n    68→\n    69→        try:\n    70→            seedream_manager = self._seedream_manager_factory(api_key)\n    71→            self._emit_progress(progress_callback, \"Seedream manager ready\")\n    72→        except Exception as init_err:\n    73→            logger.error(f\"Seedream manager init failed: {init_err}\")\n    74→            return self._failure(f\"Seedream manager init failed: {init_err}\")\n    75→\n    76→        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n    77→        reference_images = params.get(\"reference_images\") or []\n    78→        input_image_path = (\n    79→            params.get(\"input_image_path\")\n    80→            or params.get(\"input_image\")\n    81→            or params.get(\"image_path\")\n    82→            or params.get(\"image\")\n    83→        )\n    84→        base_size = params.get(\"size\", \"1024x1024\")\n    85→        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n    86→        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n    87→        model_variant = params.get(\"model_variant\")\n    88→        generation_id = params.get(\"generation_id\")\n    89→        derived_ids: List[str] = params.get(\"derived_ids\") or []\n    90→\n    91→        try:\n    92→            if generation_count == 1:\n    93→                result = self._generate_single(\n    94→                    seedream_manager=seedream_manager,\n    95→                    prompt=prompt,\n    96→                    size=base_size,\n    97→                    guidance_scale=guidance_scale,\n    98→                    seed=seed,\n    99→                    model_variant=model_variant,\n   100→                    input_image_path=input_image_path,\n   101→                    reference_images=reference_images,\n   102→                    generation_id=generation_id,\n   103→                    progress_callback=progress_callback,\n   104→                    should_cancel=should_cancel,\n   105→                )\n   106→            else:\n   107→                result = self._generate_batch(\n   108→                    seedream_manager=seedream_manager,\n   109→                    prompt=prompt,\n   110→                    count=generation_count,\n   111→                    size=base_size,\n   112→                    guidance_scale=guidance_scale,\n   113→                    seed=seed,\n   114→                    input_image_path=input_image_path,\n   115→                    reference_images=reference_images,\n   116→                    model_variant=model_variant,\n   117→                    generation_id=generation_id,\n   118→                    derived_ids=derived_ids,\n   119→                    progress_callback=progress_callback,\n   120→                    should_cancel=should_cancel,\n   121→                )\n   122→        except Exception as api_error:\n   123→            logger.error(f\"Seedream API error: {api_error}\")\n   124→            return self._failure(f\"API error: {api_error}\")\n   125→\n   126→        if self._is_cancelled(should_cancel):\n   127→            return self._cancelled()\n   128→\n   129→        if result.get(\"success\"):\n   130→            summary = \"Generation completed\"\n   131→            if generation_count > 1:\n   132→                success_count = result.get(\"success_count\", 0)\n   133→                summary = f\"Batch completed {success_count}/{result.get('total_count', generation_count)}\"\n   134→            self._emit_progress(progress_callback, summary, percentage=100.0)\n   135→            self._persist_metadata(result)\n   136→        else:\n   137→            error_msg = result.get(\"error\", \"unknown error\")\n   138→            self._emit_progress(progress_callback, f\"Generation failed: {error_msg}\")\n   139→\n   140→        return result\n   141→\n   142→    # ------------------------------------------------------------------\n   143→    # Internal helpers\n   144→    # ------------------------------------------------------------------\n   145→    def _generate_single(\n   146→        self,\n   147→        *,\n   148→        seedream_manager: SeedreamManager,\n   149→        prompt: str,\n   150→        size: str,\n   151→        guidance_scale: float,\n   152→        seed: int,\n   153→        model_variant: Optional[str],\n   154→        input_image_path: Optional[str],\n   155→        reference_images: List[Dict[str, Any]],\n   156→        generation_id: Optional[str],\n   157→        progress_callback: ProgressCallback,\n   158→        should_cancel: CancelCallback,\n   159→    ) -> Dict[str, Any]:\n   160→        if self._is_cancelled(should_cancel):\n   161→            return self._cancelled()\n   162→\n   163→        if input_image_path:\n   164→            self._emit_progress(progress_callback, \"Generating image-to-image...\")\n   165→            return seedream_manager.generate_image_to_image(\n   166→                prompt=prompt,\n   167→                image=input_image_path,\n   168→                guidance_scale=guidance_scale,\n   169→                seed=seed,\n   170→                save_local=True,\n   171→                reference_images=reference_images or None,\n   172→                generation_id=generation_id,\n   173→            )\n   174→\n   175→        self._emit_progress(progress_callback, \"Generating text-to-image...\")\n   176→        return seedream_manager.generate_text_to_image(\n   177→            prompt=prompt,\n   178→            size=size,\n   179→            guidance_scale=guidance_scale,\n   180→            seed=seed,\n   181→            save_local=True,\n   182→            reference_images=reference_images or None,\n   183→            model_variant=model_variant,\n   184→            generation_id=generation_id,\n   185→        )\n   186→\n   187→    def _generate_batch(\n   188→        self,\n   189→        *,\n   190→        seedream_manager: SeedreamManager,\n   191→        prompt: str,\n   192→        count: int,\n   193→        size: str,\n   194→        guidance_scale: float,\n   195→        seed: int,\n   196→        input_image_path: Optional[str],\n   197→        reference_images: List[Dict[str, Any]],\n   198→        model_variant: Optional[str],\n   199→        generation_id: Optional[str],\n   200→        derived_ids: List[str],\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0aaf1700-3dfc-448b-8121-d2badf649e32","timestamp":"2025-12-09T03:58:07.495Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py","content":"\"\"\"Seedream image generation service layer.\"\"\"\n\nfrom __future__ import annotations\n\nimport uuid\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom config.unified_config import get_unified_config\nfrom modules.repository.manager import RepositoryManager\nfrom modules.seedream.manager import SeedreamManager\nfrom modules.storage import get_v2_storage_manager\nfrom utils.logger import logger\n\nProgressCallback = Optional[Callable[[Optional[float], str], None]]\nCancelCallback = Optional[Callable[[], bool]]\n\n\nclass ImageService:\n    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n\n    def __init__(\n        self,\n        storage_manager=None,\n        repository_manager: Optional[RepositoryManager] = None,\n        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    ) -> None:\n        # Use unified config for storage path and API validation\n        self.unified_config = get_unified_config()\n\n        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n        self.repository_manager = repository_manager\n        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n    def generate_image(\n        self,\n        params: Dict[str, Any],\n        progress_callback: ProgressCallback = None,\n        should_cancel: CancelCallback = None,\n    ) -> Dict[str, Any]:\n        prompt = (params.get(\"prompt\") or \"\").strip()\n        if not prompt:\n            return self._failure(\"Prompt cannot be empty\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        self._emit_progress(progress_callback, \"Preparing...\")\n\n        try:\n            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n            if not is_valid:\n                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n                detail = message or \"API key not configured\"\n                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n        except Exception as cfg_err:\n            return self._failure(f\"Config validation failed: {cfg_err}\")\n\n        try:\n            api_key = self.unified_config.get_api_key(\"volcengine\")\n        except Exception as key_err:\n            return self._failure(f\"Failed to load API key: {key_err}\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        try:\n            seedream_manager = self._seedream_manager_factory(api_key)\n            self._emit_progress(progress_callback, \"Seedream manager ready\")\n        except Exception as init_err:\n            logger.error(f\"Seedream manager init failed: {init_err}\")\n            return self._failure(f\"Seedream manager init failed: {init_err}\")\n\n        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n        reference_images = params.get(\"reference_images\") or []\n        input_image_path = (\n            params.get(\"input_image_path\")\n            or params.get(\"input_image\")\n            or params.get(\"image_path\")\n            or params.get(\"image\")\n        )\n        base_size = params.get(\"size\", \"1024x1024\")\n        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n        model_variant = params.get(\"model_variant\")\n        generation_id = params.get(\"generation_id\")\n        derived_ids: List[str] = params.get(\"derived_ids\") or []\n\n        try:\n            if generation_count == 1:\n                result = self._generate_single(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    model_variant=model_variant,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    generation_id=generation_id,\n                    progress_callback=progress_callback,\n                    should_cancel=should_cancel,\n                )\n            else:\n                result = self._generate_batch(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    count=generation_count,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    model_variant=model_variant,\n                    generation_id=generation_id,\n                    derived_ids=derived_ids,\n                    progress_callback=progress_callback,\n                    should_cancel=should_cancel,\n                )\n        except Exception as api_error:\n            logger.error(f\"Seedream API error: {api_error}\")\n            return self._failure(f\"API error: {api_error}\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        if result.get(\"success\"):\n            summary = \"Generation completed\"\n            if generation_count > 1:\n                success_count = result.get(\"success_count\", 0)\n                summary = f\"Batch completed {success_count}/{result.get('total_count', generation_count)}\"\n            self._emit_progress(progress_callback, summary, percentage=100.0)\n            self._persist_metadata(result)\n        else:\n            error_msg = result.get(\"error\", \"unknown error\")\n            self._emit_progress(progress_callback, f\"Generation failed: {error_msg}\")\n\n        return result\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n    def _generate_single(\n        self,\n        *,\n        seedream_manager: SeedreamManager,\n        prompt: str,\n        size: str,\n        guidance_scale: float,\n        seed: int,\n        model_variant: Optional[str],\n        input_image_path: Optional[str],\n        reference_images: List[Dict[str, Any]],\n        generation_id: Optional[str],\n        progress_callback: ProgressCallback,\n        should_cancel: CancelCallback,\n    ) -> Dict[str, Any]:\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        if input_image_path:\n            self._emit_progress(progress_callback, \"Generating image-to-image...\")\n            return seedream_manager.generate_image_to_image(\n                prompt=prompt,\n                image=input_image_path,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=True,\n                reference_images=reference_images or None,\n                generation_id=generation_id,\n            )\n\n        self._emit_progress(progress_callback, \"Generating text-to-image...\")\n        return seedream_manager.generate_text_to_image(\n            prompt=prompt,\n            size=size,\n            guidance_scale=guidance_scale,\n            seed=seed,\n            save_local=True,\n            reference_images=reference_images or None,\n            model_variant=model_variant,\n            generation_id=generation_id,\n        )\n\n    def _generate_batch(\n        self,\n        *,\n        seedream_manager: SeedreamManager,\n        prompt: str,\n        count: int,\n        size: str,\n        guidance_scale: float,\n        seed: int,\n        input_image_path: Optional[str],\n        reference_images: List[Dict[str, Any]],\n        model_variant: Optional[str],\n        generation_id: Optional[str],\n        derived_ids: List[str],","numLines":200,"startLine":1,"totalLines":391}}}
{"parentUuid":"0aaf1700-3dfc-448b-8121-d2badf649e32","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01APJx6eaBBrj9kTpXW1fnrf","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1890-        server_watermark = bool(API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1891-        camera_fixed = bool(form_values.get('camera_fixed', True))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1892-\ncomponents/modes/video_mode_widget.py:1893:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1894-        use_pro_model = True\ncomponents/modes/video_mode_widget.py-1895-        if self._video_schema and getattr(self._video_schema, 'extra', None):\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1896-            use_pro_model = bool(self._video_schema.extra.get('use_pro_model', use_pro_model))\ncomponents/modes/video_mode_widget.py-1897-        else:\ncomponents/modes/video_mode_widget.py:1898:            use_pro_model = str(model_variant).endswith('pro')\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1899-        model_type = 'pro' if use_pro_model else 'lite'\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1900-\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1901-        fps_value = form_values.get('fps', 24)\n--\ncomponents/modes/video_mode_widget.py-1924-            \"camera_fixed\": camera_fixed,\ncomponents/modes/video_mode_widget.py-1925-            \"seed\": seed if seed is not None else -1,\ncomponents/modes/video_mode_widget.py-1926-            \"model_type\": model_type,\ncomponents/modes/video_mode_widget.py:1927:            \"model_variant\": model_variant,\ncomponents/modes/video_mode_widget.py-1928-            \"first_frame\": first_frame,\ncomponents/modes/video_mode_widget.py-1929-            \"last_frame\": last_frame,\ncomponents/modes/video_mode_widget.py-1930-            \"reference_images\": reference_assets,\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"uuid":"8da81095-25a7-4d64-8dc9-1025a7d16235","timestamp":"2025-12-09T03:58:07.518Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1890-        server_watermark = bool(API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1891-        camera_fixed = bool(form_values.get('camera_fixed', True))\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1892-\ncomponents/modes/video_mode_widget.py:1893:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1894-        use_pro_model = True\ncomponents/modes/video_mode_widget.py-1895-        if self._video_schema and getattr(self._video_schema, 'extra', None):\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1896-            use_pro_model = bool(self._video_schema.extra.get('use_pro_model', use_pro_model))\ncomponents/modes/video_mode_widget.py-1897-        else:\ncomponents/modes/video_mode_widget.py:1898:            use_pro_model = str(model_variant).endswith('pro')\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1899-        model_type = 'pro' if use_pro_model else 'lite'\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1900-\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py-1901-        fps_value = form_values.get('fps', 24)\n--\ncomponents/modes/video_mode_widget.py-1924-            \"camera_fixed\": camera_fixed,\ncomponents/modes/video_mode_widget.py-1925-            \"seed\": seed if seed is not None else -1,\ncomponents/modes/video_mode_widget.py-1926-            \"model_type\": model_type,\ncomponents/modes/video_mode_widget.py:1927:            \"model_variant\": model_variant,\ncomponents/modes/video_mode_widget.py-1928-            \"first_frame\": first_frame,\ncomponents/modes/video_mode_widget.py-1929-            \"last_frame\": last_frame,\ncomponents/modes/video_mode_widget.py-1930-            \"reference_images\": reference_assets,","numLines":20,"appliedLimit":20}}
{"parentUuid":"8da81095-25a7-4d64-8dc9-1025a7d16235","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.62","gitBranch":"main","agentId":"480943a7","slug":"agile-wobbling-lampson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XDfDZFbedTY45baAzKuReb","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive understanding of the Seedream and Seedance module structure. Let me provide a complete summary report.\n\n---\n\n# Gemeng2 项目 - Seedream 和 Seedance 模块实现结构分析报告\n\n## 一、项目架构总览\n\n```\nmodules/\n├── seedream/                 # 图像生成模块 (Seedream)\n│   ├── __init__.py\n│   ├── client.py             # API 客户端\n│   └── manager.py            # 业务逻辑管理器\n├── seedance/                 # 视频生成模块 (Seedance)\n│   ├── __init__.py\n│   ├── config.py             # 配置常量和模型枚举\n│   ├── client.py             # API 客户端\n│   └── manager.py            # 业务逻辑管理器\n├── provider/                 # Provider 抽象层 (参数映射/校验)\n│   ├── __init__.py\n│   ├── base.py               # 基类\n│   ├── factory.py            # 工厂方法\n│   ├── schema.py             # 参数 Schema 和校验逻辑\n│   ├── volc.py               # Volcengine V3 Provider\n│   └── volc_v4.py            # Volcengine V4 Provider (Seedream 4.0)\n└── storage/                  # 统一存储管理器\n```\n\n---\n\n## 二、核心文件和关键路径\n\n### 2.1 Seedream 模块 (图像生成)\n\n| 文件 | 路径 | 职责 |\n|------|------|------|\n| **client.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py` | API 客户端，封装 HTTP 请求 |\n| **manager.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py` | 业务逻辑，包括本地存储、参考图处理、水印 |\n\n### 2.2 Seedance 模块 (视频生成)\n\n| 文件 | 路径 | 职责 |\n|------|------|------|\n| **config.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py` | 模型枚举、状态枚举、配置常量 |\n| **client.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py` | API 客户端，任务创建/查询/轮询 |\n| **manager.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py` | 业务逻辑，包括首尾帧处理、水印、存储 |\n\n### 2.3 Provider 层\n\n| 文件 | 路径 | 职责 |\n|------|------|------|\n| **factory.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py` | Provider 工厂，根据环境变量路由 |\n| **schema.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py` | 参数 Schema、校验、UI Schema 定义 |\n| **volc.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py` | Seedream 3.x / Seedance 参数映射 |\n| **volc_v4.py** | `/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py` | Seedream 4.0 参数映射 |\n\n### 2.4 配置文件\n\n| 文件 | 路径 |\n|------|------|\n| **config_api.py** | `/Users/yunchang/Documents/GitHub/gemeng2/config_api.py` |\n\n---\n\n## 三、模型选择逻辑详解\n\n### 3.1 Seedream 模型路由 (Pro vs Lite → V3 vs V4)\n\n**环境变量控制**: `GEMENG_SEEDREAM_PROVIDER`\n\n```python\n# modules/provider/factory.py - 第 13-23 行\ndef get_default_provider(provider_name: Optional[str] = None) -> BaseProvider:\n    raw_name = provider_name or os.environ.get(\"GEMENG_PROVIDER\", \"volc_v3\")\n    name = str(raw_name).strip().lower()\n    \n    if name in {\"volc_v4\", \"volcengine_v4\", \"seedream_v4\", \"seedream4\", \"volc4\"}:\n        return VolcV4Provider()\n    # 默认返回 v3 实现\n    return VolcProvider()\n```\n\n**模型 ID 定义**:\n\n| 模式 | V3 模型 | V4 模型 |\n|------|---------|---------|\n| 文生图 (T2I) | `doubao-seedream-3-0-t2i-250415` | `doubao-seedream-4-0-250828` |\n| 图生图 (I2I) | `doubao-seededit-3-0-i2i-250628` | `doubao-seedream-4-0-250828` |\n\n**Manager 层路由**:\n```python\n# modules/seedream/manager.py - 第 104-109 行\nif model_variant == 'seedream_v4':\n    os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4\"\nelse:\n    os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v3\"\n```\n\n### 3.2 Seedance 模型路由 (Pro vs Lite)\n\n**模型枚举定义**:\n```python\n# modules/seedance/config.py - 第 8-12 行\nclass SeedanceModels(Enum):\n    PRO = \"doubao-seedance-1-0-pro-250528\"\n    LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n```\n\n**选择逻辑** (在 `volc.py` 第 55-71 行):\n```python\ndef map_video(self, params: VideoParams):\n    # 首尾帧模式 → 强制使用 LITE_I2V\n    if norm.first_frame_path and norm.last_frame_path:\n        model = SeedanceModels.LITE_I2V.value\n        mode = \"首尾帧视频(Lite)\"\n    # Pro 模式\n    elif norm.use_pro_model:\n        model = SeedanceModels.PRO.value\n        mode = \"图生视频(Pro)\" if norm.image_path else \"文生视频(Pro)\"\n    # Lite 模式\n    else:\n        if norm.image_path:\n            model = SeedanceModels.LITE_I2V.value\n            mode = \"图生视频(Lite)\"\n        else:\n            model = SeedanceModels.LITE_T2V.value\n            mode = \"文生视频(Lite)\"\n```\n\n**UI 层路由** (在 `video_mode_widget.py` 第 1893-1898 行):\n```python\nmodel_variant = form_values.get('model_variant') or 'seedance_pro'\nuse_pro_model = True\nif self._video_schema and getattr(self._video_schema, 'extra', None):\n    use_pro_model = bool(self._video_schema.extra.get('use_pro_model', use_pro_model))\nelse:\n    use_pro_model = str(model_variant).endswith('pro')\n```\n\n---\n\n## 四、首尾帧处理逻辑\n\n### 4.1 核心处理流程\n\n**Manager 层** (`modules/seedance/manager.py` 第 133-179 行):\n\n1. **收集帧图片**:\n```python\nframe_inputs = []\nif first_frame_path:\n    frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\nif last_frame_path:\n    frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\nelif image_path and not first_frame_path:\n    frame_inputs.append({'path': image_path, 'type': 'image'})\n```\n\n2. **统一处理（复制到 references 目录）**:\n```python\nref_summary = self._process_reference_assets(all_input_images, ...)\n```\n\n3. **分离帧图片和参考图**:\n```python\nfor asset in ref_assets:\n    asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n    if asset_type in ('first_frame', 'last_frame', 'image'):\n        frame_assets[asset_type] = asset\n    else:\n        pure_ref_assets.append(asset)\n```\n\n### 4.2 API 请求构建\n\n**Client 层** (`modules/seedance/client.py` 第 508-562 行):\n\n```python\nif first_frame_path and last_frame_path:\n    content.append({\n        \"type\": \"image_url\",\n        \"image_url\": {\"url\": self._encode_image(first_frame_path)},\n        \"role\": \"first_frame\"\n    })\n    content.append({\n        \"type\": \"image_url\",\n        \"image_url\": {\"url\": self._encode_image(last_frame_path)},\n        \"role\": \"last_frame\"\n    })\nelif image_path:\n    content.append({\n        \"type\": \"image_url\",\n        \"image_url\": {\"url\": self._encode_image(image_path)},\n        \"role\": \"first_frame\"\n    })\n```\n\n---\n\n## 五、API 参数配置详解\n\n### 5.1 Seedream 参数\n\n**文生图 (T2I)**:\n```python\n# volc.py map_t2i()\ndata = {\n    \"model\": \"doubao-seedream-3-0-t2i-250415\",\n    \"prompt\": norm.prompt,\n    \"size\": norm.size,           # 如 \"1024x1024\"\n    \"response_format\": \"url\",\n    \"watermark\": False,          # 固定禁用服务端水印\n    \"guidance_scale\": norm.guidance_scale,  # 范围 [1.0, 10.0]\n    \"seed\": norm.seed,           # -1 表示随机\n}\n```\n\n**图生图 (I2I)**:\n```python\n# volc.py map_i2i()\ndata = {\n    \"model\": \"doubao-seededit-3-0-i2i-250628\",\n    \"prompt\": norm.prompt,\n    \"image\": norm.image,         # URL 或 data URL\n    \"size\": \"adaptive\",          # 自适应尺寸\n    \"response_format\": \"url\",\n    \"watermark\": False,\n    \"guidance_scale\": norm.guidance_scale,\n}\n```\n\n**Seedream 4.0 特有参数**:\n```python\n# volc_v4.py\ndata = {\n    \"model\": \"doubao-seedream-4-0-250828\",\n    \"size\": _to_v4_size(norm.size),  # 支持 4K\n    \"image\": images_payload,          # 多参考图列表\n    \"sequential_image_generation\": \"disabled\",  # 单图模式\n}\n# 注意：4.0 不支持 seed 参数\n```\n\n### 5.2 Seedance 参数\n\n**视频生成核心参数**:\n```python\n# client.py _validate_and_build_flags()\nflags_text = \"--rs {resolution_grade} --rt {ratio} --dur {duration} --fps {fps} --wm {watermark} --seed {seed} --cf {camera_fixed}\"\n```\n\n| 参数 | 白名单 | 默认值 |\n|------|--------|--------|\n| `resolution_grade` | `480p`, `720p`, `1080p` | `1080p` |\n| `ratio` | `16:9`, `9:16`, `4:3`, `1:1`, `3:4`, `21:9` | `16:9` |\n| `duration` | 3-12 秒 | 8 秒 |\n| `fps` | 正整数 | 24 |\n| `camera_fixed` | true/false | true |\n\n### 5.3 参考图限制\n\n```python\n# schema.py 第 17-18 行\nMAX_REFERENCE_IMAGES = 10   # Seedream 4.0 最多 10 张参考图\nMAX_REFERENCE_BUNDLE = 15   # 参考图 + 生成图数量 <= 15\n```\n\n---\n\n## 六、关键函数索引\n\n### 6.1 Seedream 模块\n\n| 函数 | 文件:行号 | 功能 |\n|------|-----------|------|\n| `SeedreamClient.text_to_image()` | client.py:443-591 | 文生图 API 调用 |\n| `SeedreamClient.image_to_image()` | client.py:593-711 | 图生图 API 调用 |\n| `SeedreamManager.generate_text_to_image()` | manager.py:72-223 | 文生图业务逻辑 |\n| `SeedreamManager.generate_image_to_image()` | manager.py:225-394 | 图生图业务逻辑 |\n| `SeedreamManager._process_reference_assets()` | manager.py:1041-1113 | 参考图处理 |\n| `SeedreamManager._save_image_locally()` | manager.py:846-961 | 本地保存 + 水印 |\n\n### 6.2 Seedance 模块\n\n| 函数 | 文件:行号 | 功能 |\n|------|-----------|------|\n| `SeedanceClient.create_video_task()` | client.py:422-681 | 创建视频任务 |\n| `SeedanceClient.query_video_task()` | client.py:690-764 | 查询任务状态 |\n| `SeedanceClient.wait_for_completion()` | client.py:778-842 | 智能轮询等待 |\n| `SeedanceManager.generate_video()` | manager.py:92-348 | 视频生成业务逻辑 |\n| `SeedanceManager._save_video_locally()` | manager.py:574-807 | 本地保存 + 水印 |\n| `_validate_and_build_flags()` | client.py:32-71 | 参数校验和命令构建 |\n\n### 6.3 Provider 层\n\n| 函数 | 文件:行号 | 功能 |\n|------|-----------|------|\n| `get_default_provider()` | factory.py:13-23 | Provider 工厂路由 |\n| `VolcProvider.map_t2i()` | volc.py:23-36 | V3 文生图映射 |\n| `VolcProvider.map_i2i()` | volc.py:39-52 | V3 图生图映射 |\n| `VolcProvider.map_video()` | volc.py:55-114 | 视频参数映射 |\n| `VolcV4Provider.map_t2i()` | volc_v4.py:55-81 | V4 文生图映射 |\n| `validate_and_normalize_video()` | schema.py:285-343 | 视频参数校验 |\n\n---\n\n## 七、数据流和调用链\n\n### 7.1 图像生成调用链\n\n```\nUI (ImageModeWidget)\n    ↓ params: {prompt, size, seed, model_variant, reference_images}\nImageService.generate_image()\n    ↓\nSeedreamManager.generate_text_to_image() / generate_image_to_image()\n    ↓ 设置环境变量 GEMENG_SEEDREAM_PROVIDER\nSeedreamClient.text_to_image() / image_to_image()\n    ↓ 调用 _call_seedream_provider()\nget_default_provider() → VolcProvider / VolcV4Provider\n    ↓ map_t2i() / map_i2i()\nHTTP POST → https://ark.cn-beijing.volces.com/api/v3/images/generations\n```\n\n### 7.2 视频生成调用链\n\n```\nUI (VideoModeWidget)\n    ↓ params: {prompt, first_frame, last_frame, use_pro_model, resolution_grade, ratio}\nSeedanceManager.generate_video()\n    ↓ _process_reference_assets() 处理帧图片\nSeedanceClient.create_video_task()\n    ↓ 调用 Provider 映射\nget_default_provider() → VolcProvider.map_video()\n    ↓ 构建 content 和 flags_text\nHTTP POST → https://ark.cn-beijing.volces.com/api/v3/contents/generations/tasks\n    ↓\nSeedanceClient.wait_for_completion() 轮询\n    ↓\nSeedanceManager._save_video_locally() 保存 + 水印\n```\n\n---\n\n## 八、总结\n\n该项目采用了清晰的分层架构:\n\n1. **Client 层**: 负责底层 HTTP 请求和响应处理\n2. **Manager 层**: 负责业务逻辑、存储管理、水印处理\n3. **Provider 层**: 负责参数校验、归一化和 API 映射\n4. **Service 层**: 提供给 UI 的统一接口\n\n模型选择通过 `model_variant` 参数和环境变量 (`GEMENG_SEEDREAM_PROVIDER`, `GEMENG_PROVIDER`) 控制，支持运行时动态切换。首尾帧处理统一通过参考图处理管道，确保跨平台路径兼容性。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2692,"cache_creation_input_tokens":992,"cache_read_input_tokens":108373,"cache_creation":{"ephemeral_5m_input_tokens":992,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"c3d38827-efd2-48ce-968d-c80b6c6fe3e4","timestamp":"2025-12-09T03:59:37.602Z"}
