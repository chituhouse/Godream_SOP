{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":"调查 Seedream 3.0 图片生成时，seed 值是如何存储到数据库的。\n\n需要了解：\n1. 图片生成任务提交时，seed 值在哪里收集（从表单）\n2. 生成完成后，seed 值存储到数据库的哪个字段（parameters JSON 中的位置）\n3. 当前 seed 是存储在 params_requested 还是顶层 params 中\n\n关键文件可能包括：\n- `modules/seedream/` 目录下的生成逻辑\n- `modules/repository/` 数据库存储逻辑\n- `components/modes/shared/image/` 图片模式逻辑\n\n只做调查，不要修改代码。"},"uuid":"66b35135-3d17-4a2c-a3b4-8da2e2f8f7e1","timestamp":"2026-01-09T03:40:30.613Z"}
{"parentUuid":"66b35135-3d17-4a2c-a3b4-8da2e2f8f7e1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PcUZG5JAjc7tqEAXKzyHyo","type":"message","role":"assistant","content":[{"type":"text","text":"I'll investigate how seed values are stored in the database for Seedream 3.0 image generation. Let me start by exploring the key directories and files mentioned."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20078,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20078,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"df06bf97-c6c7-419f-a319-fdf2b78b3c76","timestamp":"2026-01-09T03:40:33.359Z"}
{"parentUuid":"df06bf97-c6c7-419f-a319-fdf2b78b3c76","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PcUZG5JAjc7tqEAXKzyHyo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WchBx2qEmeahyeWg4dEHLr","name":"Glob","input":{"pattern":"**/modules/seedream/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20078,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20078,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9965a5e8-ccd4-44e2-aad0-d3299dfea281","timestamp":"2026-01-09T03:40:33.868Z"}
{"parentUuid":"9965a5e8-ccd4-44e2-aad0-d3299dfea281","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PcUZG5JAjc7tqEAXKzyHyo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AZ3N5Dc5gXFj8K7gWwLoNk","name":"Glob","input":{"pattern":"**/modules/repository/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20078,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20078,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"becf034f-6524-4ee4-a853-bcfe22ebf0c7","timestamp":"2026-01-09T03:40:34.063Z"}
{"parentUuid":"becf034f-6524-4ee4-a853-bcfe22ebf0c7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PcUZG5JAjc7tqEAXKzyHyo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Jtcm5YVkvLHMoXcDT2c8H8","name":"Glob","input":{"pattern":"**/components/modes/shared/image/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20078,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20078,"ephemeral_1h_input_tokens":0},"output_tokens":184,"service_tier":"standard"}},"type":"assistant","uuid":"86c9edf1-a289-41ce-bc59-8977fb057fae","timestamp":"2026-01-09T03:40:34.133Z"}
{"parentUuid":"9965a5e8-ccd4-44e2-aad0-d3299dfea281","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WchBx2qEmeahyeWg4dEHLr","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}]},"uuid":"89871b0c-03d5-44bf-9772-fd98a75dbc0b","timestamp":"2026-01-09T03:40:34.227Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"],"durationMs":48,"numFiles":3,"truncated":false},"sourceToolAssistantUUID":"9965a5e8-ccd4-44e2-aad0-d3299dfea281"}
{"parentUuid":"becf034f-6524-4ee4-a853-bcfe22ebf0c7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AZ3N5Dc5gXFj8K7gWwLoNk","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py"}]},"uuid":"91dc6dc1-4603-41f5-abab-63a8758c0b8c","timestamp":"2026-01-09T03:40:34.233Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py"],"durationMs":54,"numFiles":4,"truncated":false},"sourceToolAssistantUUID":"becf034f-6524-4ee4-a853-bcfe22ebf0c7"}
{"parentUuid":"86c9edf1-a289-41ce-bc59-8977fb057fae","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Jtcm5YVkvLHMoXcDT2c8H8","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/mode_widget_impl.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py"}]},"uuid":"3d46796a-fb8d-4f36-a011-87d0b5c0dc64","timestamp":"2026-01-09T03:40:34.232Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py","/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/mode_widget_impl.py","/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py"],"durationMs":53,"numFiles":4,"truncated":false},"sourceToolAssistantUUID":"86c9edf1-a289-41ce-bc59-8977fb057fae"}
{"parentUuid":"3d46796a-fb8d-4f36-a011-87d0b5c0dc64","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011G2MaHfrSEZua2tAaqFeQy","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the key files to trace the seed value flow:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":825,"cache_read_input_tokens":20078,"cache_creation":{"ephemeral_5m_input_tokens":825,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"927bc5a3-e717-429b-8714-41925ea7d39e","timestamp":"2026-01-09T03:40:36.903Z"}
{"parentUuid":"927bc5a3-e717-429b-8714-41925ea7d39e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011G2MaHfrSEZua2tAaqFeQy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DUP4UB8hhMKfqo87u4ev97","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":825,"cache_read_input_tokens":20078,"cache_creation":{"ephemeral_5m_input_tokens":825,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"cce2dc8b-6de0-4a83-a6e3-a913a71c3e91","timestamp":"2026-01-09T03:40:37.098Z"}
{"parentUuid":"cce2dc8b-6de0-4a83-a6e3-a913a71c3e91","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011G2MaHfrSEZua2tAaqFeQy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K4P42XE4YMDWm8rbjY498o","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":825,"cache_read_input_tokens":20078,"cache_creation":{"ephemeral_5m_input_tokens":825,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c16da065-cfb4-4844-acba-35aacf2cd8ec","timestamp":"2026-01-09T03:40:37.303Z"}
{"parentUuid":"c16da065-cfb4-4844-acba-35aacf2cd8ec","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011G2MaHfrSEZua2tAaqFeQy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xbqdf5AMXg3DYd72h92utB","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":825,"cache_read_input_tokens":20078,"cache_creation":{"ephemeral_5m_input_tokens":825,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"1683af9c-df42-4aec-82c8-7359a9140c02","timestamp":"2026-01-09T03:40:37.549Z"}
{"parentUuid":"1683af9c-df42-4aec-82c8-7359a9140c02","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011G2MaHfrSEZua2tAaqFeQy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NgofGfG7gdtVDPPz5iAWb8","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/mode_widget_impl.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":825,"cache_read_input_tokens":20078,"cache_creation":{"ephemeral_5m_input_tokens":825,"ephemeral_1h_input_tokens":0},"output_tokens":277,"service_tier":"standard"}},"type":"assistant","uuid":"58957578-7607-406a-9e60-9bcc1d4effde","timestamp":"2026-01-09T03:40:37.770Z"}
{"parentUuid":"c16da065-cfb4-4844-acba-35aacf2cd8ec","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K4P42XE4YMDWm8rbjY498o","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import json\n     8→import sqlite3\n     9→import threading\n    10→from concurrent.futures import Future, TimeoutError\n    11→from queue import Queue\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Any, Callable, Dict, List, Optional\n    15→\n    16→from loguru import logger\n    17→\n    18→\n    19→class SQLiteHandler:\n    20→    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n    21→\n    22→    _DEFAULT_TIMEOUT_SECONDS = 30.0\n    23→\n    24→    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n    25→        \"\"\"初始化数据库连接并创建所需表结构.\n    26→\n    27→        Args:\n    28→            db_path: 数据库文件路径\n    29→            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n    30→        \"\"\"\n    31→\n    32→        self.db_path = Path(db_path)\n    33→        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n    34→        self.storage_root = storage_root\n    35→\n    36→        # 并发策略（Q002-方案B）：单线程 DB Worker + 队列串行执行\n    37→        self._closed = False\n    38→        self._queue: Queue[Optional[tuple[Future, Callable[[sqlite3.Connection], Any]]]] = Queue()\n    39→        self._init_future: Future[bool] = Future()\n    40→\n    41→        self._worker_thread = threading.Thread(\n    42→            target=self._run_worker,\n    43→            name=f\"SQLiteHandler[{self.db_path.name}]\",\n    44→            daemon=True,\n    45→        )\n    46→        self._worker_thread.start()\n    47→\n    48→        try:\n    49→            self._init_future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n    50→        except Exception as exc:\n    51→            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n    52→            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n    53→\n    54→    def _run_worker(self) -> None:\n    55→        connection: Optional[sqlite3.Connection] = None\n    56→        try:\n    57→            connection = sqlite3.connect(self.db_path)\n    58→            connection.row_factory = sqlite3.Row\n    59→            connection.execute(\"PRAGMA foreign_keys = ON;\")\n    60→            self._create_tables(connection)\n    61→        except Exception as exc:\n    62→            self._init_future.set_exception(exc)\n    63→            if connection:\n    64→                try:\n    65→                    connection.close()\n    66→                except Exception:\n    67→                    pass\n    68→            return\n    69→\n    70→        self._init_future.set_result(True)\n    71→\n    72→        while True:\n    73→            item = self._queue.get()\n    74→            try:\n    75→                if item is None:\n    76→                    break\n    77→                future, fn = item\n    78→                if not future.set_running_or_notify_cancel():\n    79→                    continue\n    80→                try:\n    81→                    future.set_result(fn(connection))\n    82→                except Exception as exc:\n    83→                    future.set_exception(exc)\n    84→            finally:\n    85→                self._queue.task_done()\n    86→\n    87→        if connection:\n    88→            try:\n    89→                connection.close()\n    90→            except sqlite3.Error as exc:\n    91→                logger.error(\"Failed to close SQLite connection: {}\", exc)\n    92→\n    93→    def _call(self, operation: str, fn: Callable[[sqlite3.Connection], Any], default: Any):\n    94→        if self._closed:\n    95→            return default\n    96→        future: Future = Future()\n    97→        self._queue.put((future, fn))\n    98→        try:\n    99→            return future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n   100→        except TimeoutError:\n   101→            logger.error(\"SQLite operation timed out: {}\", operation)\n   102→            return default\n   103→        except Exception as exc:\n   104→            logger.error(\"SQLite operation failed {}: {}\", operation, exc)\n   105→            return default\n   106→\n   107→    def _create_tables(self, connection: sqlite3.Connection) -> None:\n   108→        \"\"\"初始化数据库表结构.\"\"\"\n   109→\n   110→        schema = \"\"\"\n   111→        CREATE TABLE IF NOT EXISTS generations (\n   112→            id TEXT PRIMARY KEY,\n   113→            content_type TEXT NOT NULL,\n   114→            prompt TEXT,\n   115→            model TEXT,\n   116→            status TEXT DEFAULT 'completed',\n   117→            file_path TEXT,\n   118→            relative_path TEXT,\n   119→            thumbnail_path TEXT,\n   120→            parameters TEXT,\n   121→            metadata TEXT,\n   122→            created_at TEXT,\n   123→            updated_at TEXT\n   124→        );\n   125→\n   126→        CREATE TABLE IF NOT EXISTS reference_assets (\n   127→            id TEXT PRIMARY KEY,\n   128→            generation_id TEXT NOT NULL,\n   129→            asset_path TEXT,\n   130→            relative_path TEXT,\n   131→            asset_type TEXT,\n   132→            order_index INTEGER DEFAULT 0,\n   133→            metadata TEXT,\n   134→            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n   135→        );\n   136→\n   137→        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n   138→        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n   139→        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n   140→        \"\"\"\n   141→\n   142→        try:\n   143→            with connection:\n   144→                connection.executescript(schema)\n   145→        except sqlite3.Error as exc:\n   146→            logger.error(\"Failed to create initial tables: {}\", exc)\n   147→            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n   148→\n   149→    @staticmethod\n   150→    def _now() -> str:\n   151→        return datetime.utcnow().isoformat()\n   152→\n   153→    @staticmethod\n   154→    def _dump_json(data: Any) -> Optional[str]:\n   155→        if data is None:\n   156→            return None\n   157→\n   158→        try:\n   159→            return json.dumps(data)\n   160→        except (TypeError, ValueError) as exc:\n   161→            logger.error(\"Failed to serialize JSON field: {}\", exc)\n   162→            return None\n   163→\n   164→    @staticmethod\n   165→    def _load_json(payload: Optional[str]) -> Optional[Any]:\n   166→        if not payload:\n   167→            return None\n   168→\n   169→        try:\n   170→            return json.loads(payload)\n   171→        except json.JSONDecodeError as exc:\n   172→            logger.error(\"Failed to decode JSON payload: {}\", exc)\n   173→            return None\n   174→\n   175→    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n   176→        result = dict(row)\n   177→        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n   178→        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n   179→\n   180→        # 将相对路径转换为绝对路径\n   181→        if self.storage_root:\n   182→            import os\n   183→            # file_path / relative_path -> absolute_path\n   184→            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n   185→            if rel_path:\n   186→                # 统一路径分隔符\n   187→                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n   188→                abs_path = self.storage_root / rel_path\n   189→                result[\"absolute_path\"] = str(abs_path)\n   190→\n   191→            # thumbnail_path -> absolute thumbnail path\n   192→            thumb_path = result.get(\"thumbnail_path\")\n   193→            if thumb_path:\n   194→                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n   195→                abs_thumb = self.storage_root / thumb_path\n   196→                result[\"thumbnail_path\"] = str(abs_thumb)\n   197→\n   198→        return result\n   199→\n   200→    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n   201→        result = dict(row)\n   202→        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n   203→\n   204→        # 将相对路径转换为绝对路径\n   205→        if self.storage_root:\n   206→            import os\n   207→            rel_path = result.get(\"asset_path\") or result.get(\"relative_path\")\n   208→            if rel_path:\n   209→                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n   210→                abs_path = self.storage_root / rel_path\n   211→                result[\"absolute_path\"] = str(abs_path)\n   212→\n   213→        return result\n   214→\n   215→    def add_record(self, record_id: str, content_type: str, data: Dict) -> bool:\n   216→        \"\"\"添加或更新生成记录（UPSERT）.\"\"\"\n   217→\n   218→        timestamp = self._now()\n   219→        record = {\n   220→            \"id\": record_id,\n   221→            \"content_type\": content_type,\n   222→            \"prompt\": data.get(\"prompt\"),\n   223→            \"model\": data.get(\"model\"),\n   224→            \"status\": data.get(\"status\", \"completed\"),\n   225→            \"file_path\": data.get(\"file_path\"),\n   226→            \"relative_path\": data.get(\"relative_path\"),\n   227→            \"thumbnail_path\": data.get(\"thumbnail_path\"),\n   228→            \"parameters\": self._dump_json(data.get(\"parameters\")),\n   229→            \"metadata\": self._dump_json(data.get(\"metadata\")),\n   230→            \"created_at\": data.get(\"created_at\", timestamp),\n   231→            \"updated_at\": timestamp,\n   232→        }\n   233→\n   234→        sql = \"\"\"\n   235→        INSERT INTO generations (id, content_type, prompt, model, status, file_path,\n   236→            relative_path, thumbnail_path, parameters, metadata, created_at, updated_at)\n   237→        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n   238→        ON CONFLICT(id) DO UPDATE SET\n   239→            content_type = excluded.content_type,\n   240→            prompt = COALESCE(excluded.prompt, prompt),\n   241→            model = COALESCE(excluded.model, model),\n   242→            status = CASE\n   243→                WHEN excluded.status IS NULL OR excluded.status = '' THEN status\n   244→                ELSE excluded.status\n   245→            END,\n   246→            file_path = COALESCE(excluded.file_path, file_path),\n   247→            relative_path = COALESCE(excluded.relative_path, relative_path),\n   248→            thumbnail_path = COALESCE(excluded.thumbnail_path, thumbnail_path),\n   249→            parameters = COALESCE(excluded.parameters, parameters),\n   250→            metadata = COALESCE(excluded.metadata, metadata),\n   251→            updated_at = excluded.updated_at\n   252→        \"\"\"\n   253→\n   254→        def _op(connection: sqlite3.Connection) -> bool:\n   255→            try:\n   256→                with connection:\n   257→                    connection.execute(\n   258→                        sql,\n   259→                        (\n   260→                            record[\"id\"],\n   261→                            record[\"content_type\"],\n   262→                            record[\"prompt\"],\n   263→                            record[\"model\"],\n   264→                            record[\"status\"],\n   265→                            record[\"file_path\"],\n   266→                            record[\"relative_path\"],\n   267→                            record[\"thumbnail_path\"],\n   268→                            record[\"parameters\"],\n   269→                            record[\"metadata\"],\n   270→                            record[\"created_at\"],\n   271→                            record[\"updated_at\"],\n   272→                        ),\n   273→                    )\n   274→                return True\n   275→            except sqlite3.Error as exc:\n   276→                logger.error(\"Failed to upsert generation record {}: {}\", record_id, exc)\n   277→                return False\n   278→\n   279→        return self._call(\"add_record\", _op, False)\n   280→\n   281→    def get_records(self, content_type: str, limit: int, offset: int) -> List[Dict]:\n   282→        \"\"\"分页获取记录，按 created_at DESC 排序.\"\"\"\n   283→\n   284→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   285→            try:\n   286→                cursor = connection.execute(\n   287→                    \"\"\"\n   288→                    SELECT * FROM generations\n   289→                    WHERE content_type = ?\n   290→                    ORDER BY created_at DESC, updated_at DESC\n   291→                    LIMIT ? OFFSET ?\n   292→                    \"\"\",\n   293→                    (content_type, limit, offset),\n   294→                )\n   295→                return [self._row_to_dict(row) for row in cursor.fetchall()]\n   296→            except sqlite3.Error as exc:\n   297→                logger.error(\"Failed to fetch generation records: {}\", exc)\n   298→                return []\n   299→\n   300→        return self._call(\"get_records\", _op, [])\n   301→\n   302→    def get_records_by_status(self, content_type: str, statuses: List[str], limit: int = 50) -> List[Dict]:\n   303→        \"\"\"按状态获取记录（用于 pending 恢复等场景）.\"\"\"\n   304→\n   305→        statuses = [str(s) for s in (statuses or []) if s]\n   306→        if not statuses:\n   307→            return []\n   308→\n   309→        placeholders = \", \".join([\"?\"] * len(statuses))\n   310→        sql = (\n   311→            \"SELECT * FROM generations \"\n   312→            \"WHERE content_type = ? AND status IN (\" + placeholders + \") \"\n   313→            \"ORDER BY updated_at DESC, created_at DESC \"\n   314→            \"LIMIT ?\"\n   315→        )\n   316→\n   317→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   318→            try:\n   319→                cursor = connection.execute(sql, (content_type, *statuses, limit))\n   320→                return [self._row_to_dict(row) for row in cursor.fetchall()]\n   321→            except sqlite3.Error as exc:\n   322→                logger.error(\"Failed to fetch generation records by status: {}\", exc)\n   323→                return []\n   324→\n   325→        return self._call(\"get_records_by_status\", _op, [])\n   326→\n   327→    def get_record_by_id(self, record_id: str) -> Optional[Dict]:\n   328→        \"\"\"根据ID获取单条记录.\"\"\"\n   329→\n   330→        def _op(connection: sqlite3.Connection) -> Optional[Dict]:\n   331→            try:\n   332→                cursor = connection.execute(\n   333→                    \"SELECT * FROM generations WHERE id = ?\", (record_id,)\n   334→                )\n   335→                row = cursor.fetchone()\n   336→                return self._row_to_dict(row) if row else None\n   337→            except sqlite3.Error as exc:\n   338→                logger.error(\"Failed to fetch generation record {}: {}\", record_id, exc)\n   339→                return None\n   340→\n   341→        return self._call(\"get_record_by_id\", _op, None)\n   342→\n   343→    def update_record(self, record_id: str, data: Dict) -> bool:\n   344→        \"\"\"更新记录.\"\"\"\n   345→\n   346→        if not data:\n   347→            return False\n   348→\n   349→        allowed_columns = [\n   350→            \"content_type\",\n   351→            \"prompt\",\n   352→            \"model\",\n   353→            \"status\",\n   354→            \"file_path\",\n   355→            \"relative_path\",\n   356→            \"thumbnail_path\",\n   357→            \"parameters\",\n   358→            \"metadata\",\n   359→            \"created_at\",\n   360→        ]\n   361→\n   362→        set_clauses: List[str] = []\n   363→        values: List[Any] = []\n   364→\n   365→        for column in allowed_columns:\n   366→            if column in data:\n   367→                value = data[column]\n   368→                if column in {\"parameters\", \"metadata\"}:\n   369→                    value = self._dump_json(value)\n   370→                set_clauses.append(f\"{column} = ?\")\n   371→                values.append(value)\n   372→\n   373→        if not set_clauses:\n   374→            return False\n   375→\n   376→        set_clauses.append(\"updated_at = ?\")\n   377→        values.append(self._now())\n   378→\n   379→        values.append(record_id)\n   380→        sql = f\"UPDATE generations SET {', '.join(set_clauses)} WHERE id = ?\"\n   381→\n   382→        def _op(connection: sqlite3.Connection) -> bool:\n   383→            try:\n   384→                with connection:\n   385→                    cursor = connection.execute(sql, values)\n   386→                return cursor.rowcount > 0\n   387→            except sqlite3.Error as exc:\n   388→                logger.error(\"Failed to update generation record {}: {}\", record_id, exc)\n   389→                return False\n   390→\n   391→        return self._call(\"update_record\", _op, False)\n   392→\n   393→    def delete_record(self, record_id: str) -> bool:\n   394→        \"\"\"删除记录.\"\"\"\n   395→\n   396→        def _op(connection: sqlite3.Connection) -> bool:\n   397→            try:\n   398→                with connection:\n   399→                    cursor = connection.execute(\n   400→                        \"DELETE FROM generations WHERE id = ?\", (record_id,)\n   401→                    )\n   402→                return cursor.rowcount > 0\n   403→            except sqlite3.Error as exc:\n   404→                logger.error(\"Failed to delete generation record {}: {}\", record_id, exc)\n   405→                return False\n   406→\n   407→        return self._call(\"delete_record\", _op, False)\n   408→\n   409→    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n   410→        \"\"\"清理超时的 pending 记录（无文件路径的孤立占位符）\n   411→\n   412→        Args:\n   413→            timeout_hours: 超时时间（小时）\n   414→\n   415→        Returns:\n   416→            删除的记录数量\n   417→        \"\"\"\n   418→        from datetime import datetime, timedelta\n   419→\n   420→        cutoff = datetime.now() - timedelta(hours=timeout_hours)\n   421→        cutoff_str = cutoff.isoformat()\n   422→\n   423→        def _op(connection: sqlite3.Connection) -> int:\n   424→            try:\n   425→                with connection:\n   426→                    cursor = connection.execute(\n   427→                        \"\"\"\n   428→                        DELETE FROM generations\n   429→                        WHERE status = 'pending'\n   430→                          AND file_path IS NULL\n   431→                          AND created_at < ?\n   432→                        \"\"\",\n   433→                        (cutoff_str,),\n   434→                    )\n   435→                deleted = cursor.rowcount\n   436→                if deleted > 0:\n   437→                    logger.info(f\"已清理 {deleted} 条过期的 pending 记录\")\n   438→                return deleted\n   439→            except sqlite3.Error as exc:\n   440→                logger.error(\"Failed to cleanup stale pending records: {}\", exc)\n   441→                return 0\n   442→\n   443→        return self._call(\"cleanup_stale_pending_records\", _op, 0)\n   444→\n   445→    def get_total_count(self, content_type: str) -> int:\n   446→        \"\"\"获取某类型总数.\"\"\"\n   447→\n   448→        def _op(connection: sqlite3.Connection) -> int:\n   449→            try:\n   450→                cursor = connection.execute(\n   451→                    \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",\n   452→                    (content_type,),\n   453→                )\n   454→                row = cursor.fetchone()\n   455→                return int(row[0]) if row else 0\n   456→            except sqlite3.Error as exc:\n   457→                logger.error(\"Failed to count generation records: {}\", exc)\n   458→                return 0\n   459→\n   460→        return self._call(\"get_total_count\", _op, 0)\n   461→\n   462→    def search_records(\n   463→        self, keyword: str, content_type: Optional[str], limit: int\n   464→    ) -> List[Dict]:\n   465→        \"\"\"搜索记录（prompt、model、file_path）.\"\"\"\n   466→\n   467→        if not keyword:\n   468→            return []\n   469→\n   470→        pattern = f\"%{keyword}%\"\n   471→        where_clauses = [\n   472→            \"(prompt LIKE ? OR model LIKE ? OR file_path LIKE ?)\"\n   473→        ]\n   474→        params: List[Any] = [pattern, pattern, pattern]\n   475→\n   476→        if content_type:\n   477→            where_clauses.append(\"content_type = ?\")\n   478→            params.append(content_type)\n   479→\n   480→        params.append(limit)\n   481→\n   482→        query = (\n   483→            \"SELECT * FROM generations WHERE \"\n   484→            + \" AND \".join(where_clauses)\n   485→            + \" ORDER BY created_at DESC, updated_at DESC LIMIT ?\"\n   486→        )\n   487→\n   488→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   489→            try:\n   490→                cursor = connection.execute(query, params)\n   491→                return [self._row_to_dict(row) for row in cursor.fetchall()]\n   492→            except sqlite3.Error as exc:\n   493→                logger.error(\"Failed to search generation records: {}\", exc)\n   494→                return []\n   495→\n   496→        return self._call(\"search_records\", _op, [])\n   497→\n   498→    def add_reference_asset(self, generation_id: str, asset_data: Dict) -> bool:\n   499→        \"\"\"添加参考图资产.\"\"\"\n   500→\n   501→        asset_id = asset_data.get(\"id\") or asset_data.get(\"asset_id\")\n   502→        if not asset_id:\n   503→            logger.error(\"Reference asset requires an 'id' field\")\n   504→            return False\n   505→\n   506→        payload = {\n   507→            \"id\": asset_id,\n   508→            \"generation_id\": generation_id,\n   509→            \"asset_path\": asset_data.get(\"asset_path\"),\n   510→            \"relative_path\": asset_data.get(\"relative_path\"),\n   511→            \"asset_type\": asset_data.get(\"asset_type\"),\n   512→            \"order_index\": asset_data.get(\"order_index\", 0),\n   513→            \"metadata\": self._dump_json(asset_data.get(\"metadata\")),\n   514→        }\n   515→\n   516→        sql = (\n   517→            \"INSERT INTO reference_assets (id, generation_id, asset_path, relative_path, \"\n   518→            \"asset_type, order_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?)\"\n   519→        )\n   520→\n   521→        def _op(connection: sqlite3.Connection) -> bool:\n   522→            try:\n   523→                with connection:\n   524→                    connection.execute(\n   525→                        sql,\n   526→                        (\n   527→                            payload[\"id\"],\n   528→                            payload[\"generation_id\"],\n   529→                            payload[\"asset_path\"],\n   530→                            payload[\"relative_path\"],\n   531→                            payload[\"asset_type\"],\n   532→                            payload[\"order_index\"],\n   533→                            payload[\"metadata\"],\n   534→                        ),\n   535→                    )\n   536→                return True\n   537→            except sqlite3.Error as exc:\n   538→                logger.error(\n   539→                    \"Failed to insert reference asset {} for generation {}: {}\",\n   540→                    asset_id,\n   541→                    generation_id,\n   542→                    exc,\n   543→                )\n   544→                return False\n   545→\n   546→        return self._call(\"add_reference_asset\", _op, False)\n   547→\n   548→    def get_reference_assets(self, generation_id: str) -> List[Dict]:\n   549→        \"\"\"获取参考图资产.\"\"\"\n   550→\n   551→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   552→            try:\n   553→                cursor = connection.execute(\n   554→                    \"\"\"\n   555→                    SELECT * FROM reference_assets\n   556→                    WHERE generation_id = ?\n   557→                    ORDER BY order_index ASC\n   558→                    \"\"\",\n   559→                    (generation_id,),\n   560→                )\n   561→                return [self._reference_row_to_dict(row) for row in cursor.fetchall()]\n   562→            except sqlite3.Error as exc:\n   563→                logger.error(\n   564→                    \"Failed to fetch reference assets for generation {}: {}\",\n   565→                    generation_id,\n   566→                    exc,\n   567→                )\n   568→                return []\n   569→\n   570→        return self._call(\"get_reference_assets\", _op, [])\n   571→\n   572→    def close(self) -> None:\n   573→        \"\"\"关闭数据库连接.\"\"\"\n   574→\n   575→        if self._closed:\n   576→            return\n   577→        self._closed = True\n   578→\n   579→        try:\n   580→            self._queue.put(None)\n   581→        except Exception:\n   582→            return\n   583→\n   584→        try:\n   585→            self._worker_thread.join(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n   586→        except Exception:\n   587→            pass\n   588→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"49a1bc5e-3197-4038-a1df-9474bcd6c93f","timestamp":"2026-01-09T03:40:37.823Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sqlite3\nimport threading\nfrom concurrent.futures import Future, TimeoutError\nfrom queue import Queue\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom loguru import logger\n\n\nclass SQLiteHandler:\n    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n\n    _DEFAULT_TIMEOUT_SECONDS = 30.0\n\n    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n        \"\"\"初始化数据库连接并创建所需表结构.\n\n        Args:\n            db_path: 数据库文件路径\n            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n        \"\"\"\n\n        self.db_path = Path(db_path)\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n        self.storage_root = storage_root\n\n        # 并发策略（Q002-方案B）：单线程 DB Worker + 队列串行执行\n        self._closed = False\n        self._queue: Queue[Optional[tuple[Future, Callable[[sqlite3.Connection], Any]]]] = Queue()\n        self._init_future: Future[bool] = Future()\n\n        self._worker_thread = threading.Thread(\n            target=self._run_worker,\n            name=f\"SQLiteHandler[{self.db_path.name}]\",\n            daemon=True,\n        )\n        self._worker_thread.start()\n\n        try:\n            self._init_future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except Exception as exc:\n            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n\n    def _run_worker(self) -> None:\n        connection: Optional[sqlite3.Connection] = None\n        try:\n            connection = sqlite3.connect(self.db_path)\n            connection.row_factory = sqlite3.Row\n            connection.execute(\"PRAGMA foreign_keys = ON;\")\n            self._create_tables(connection)\n        except Exception as exc:\n            self._init_future.set_exception(exc)\n            if connection:\n                try:\n                    connection.close()\n                except Exception:\n                    pass\n            return\n\n        self._init_future.set_result(True)\n\n        while True:\n            item = self._queue.get()\n            try:\n                if item is None:\n                    break\n                future, fn = item\n                if not future.set_running_or_notify_cancel():\n                    continue\n                try:\n                    future.set_result(fn(connection))\n                except Exception as exc:\n                    future.set_exception(exc)\n            finally:\n                self._queue.task_done()\n\n        if connection:\n            try:\n                connection.close()\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to close SQLite connection: {}\", exc)\n\n    def _call(self, operation: str, fn: Callable[[sqlite3.Connection], Any], default: Any):\n        if self._closed:\n            return default\n        future: Future = Future()\n        self._queue.put((future, fn))\n        try:\n            return future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except TimeoutError:\n            logger.error(\"SQLite operation timed out: {}\", operation)\n            return default\n        except Exception as exc:\n            logger.error(\"SQLite operation failed {}: {}\", operation, exc)\n            return default\n\n    def _create_tables(self, connection: sqlite3.Connection) -> None:\n        \"\"\"初始化数据库表结构.\"\"\"\n\n        schema = \"\"\"\n        CREATE TABLE IF NOT EXISTS generations (\n            id TEXT PRIMARY KEY,\n            content_type TEXT NOT NULL,\n            prompt TEXT,\n            model TEXT,\n            status TEXT DEFAULT 'completed',\n            file_path TEXT,\n            relative_path TEXT,\n            thumbnail_path TEXT,\n            parameters TEXT,\n            metadata TEXT,\n            created_at TEXT,\n            updated_at TEXT\n        );\n\n        CREATE TABLE IF NOT EXISTS reference_assets (\n            id TEXT PRIMARY KEY,\n            generation_id TEXT NOT NULL,\n            asset_path TEXT,\n            relative_path TEXT,\n            asset_type TEXT,\n            order_index INTEGER DEFAULT 0,\n            metadata TEXT,\n            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n        \"\"\"\n\n        try:\n            with connection:\n                connection.executescript(schema)\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to create initial tables: {}\", exc)\n            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n\n    @staticmethod\n    def _now() -> str:\n        return datetime.utcnow().isoformat()\n\n    @staticmethod\n    def _dump_json(data: Any) -> Optional[str]:\n        if data is None:\n            return None\n\n        try:\n            return json.dumps(data)\n        except (TypeError, ValueError) as exc:\n            logger.error(\"Failed to serialize JSON field: {}\", exc)\n            return None\n\n    @staticmethod\n    def _load_json(payload: Optional[str]) -> Optional[Any]:\n        if not payload:\n            return None\n\n        try:\n            return json.loads(payload)\n        except json.JSONDecodeError as exc:\n            logger.error(\"Failed to decode JSON payload: {}\", exc)\n            return None\n\n    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n        result = dict(row)\n        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n\n        # 将相对路径转换为绝对路径\n        if self.storage_root:\n            import os\n            # file_path / relative_path -> absolute_path\n            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n            if rel_path:\n                # 统一路径分隔符\n                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_path = self.storage_root / rel_path\n                result[\"absolute_path\"] = str(abs_path)\n\n            # thumbnail_path -> absolute thumbnail path\n            thumb_path = result.get(\"thumbnail_path\")\n            if thumb_path:\n                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_thumb = self.storage_root / thumb_path\n                result[\"thumbnail_path\"] = str(abs_thumb)\n\n        return result\n\n    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n        result = dict(row)\n        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n\n        # 将相对路径转换为绝对路径\n        if self.storage_root:\n            import os\n            rel_path = result.get(\"asset_path\") or result.get(\"relative_path\")\n            if rel_path:\n                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_path = self.storage_root / rel_path\n                result[\"absolute_path\"] = str(abs_path)\n\n        return result\n\n    def add_record(self, record_id: str, content_type: str, data: Dict) -> bool:\n        \"\"\"添加或更新生成记录（UPSERT）.\"\"\"\n\n        timestamp = self._now()\n        record = {\n            \"id\": record_id,\n            \"content_type\": content_type,\n            \"prompt\": data.get(\"prompt\"),\n            \"model\": data.get(\"model\"),\n            \"status\": data.get(\"status\", \"completed\"),\n            \"file_path\": data.get(\"file_path\"),\n            \"relative_path\": data.get(\"relative_path\"),\n            \"thumbnail_path\": data.get(\"thumbnail_path\"),\n            \"parameters\": self._dump_json(data.get(\"parameters\")),\n            \"metadata\": self._dump_json(data.get(\"metadata\")),\n            \"created_at\": data.get(\"created_at\", timestamp),\n            \"updated_at\": timestamp,\n        }\n\n        sql = \"\"\"\n        INSERT INTO generations (id, content_type, prompt, model, status, file_path,\n            relative_path, thumbnail_path, parameters, metadata, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ON CONFLICT(id) DO UPDATE SET\n            content_type = excluded.content_type,\n            prompt = COALESCE(excluded.prompt, prompt),\n            model = COALESCE(excluded.model, model),\n            status = CASE\n                WHEN excluded.status IS NULL OR excluded.status = '' THEN status\n                ELSE excluded.status\n            END,\n            file_path = COALESCE(excluded.file_path, file_path),\n            relative_path = COALESCE(excluded.relative_path, relative_path),\n            thumbnail_path = COALESCE(excluded.thumbnail_path, thumbnail_path),\n            parameters = COALESCE(excluded.parameters, parameters),\n            metadata = COALESCE(excluded.metadata, metadata),\n            updated_at = excluded.updated_at\n        \"\"\"\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    connection.execute(\n                        sql,\n                        (\n                            record[\"id\"],\n                            record[\"content_type\"],\n                            record[\"prompt\"],\n                            record[\"model\"],\n                            record[\"status\"],\n                            record[\"file_path\"],\n                            record[\"relative_path\"],\n                            record[\"thumbnail_path\"],\n                            record[\"parameters\"],\n                            record[\"metadata\"],\n                            record[\"created_at\"],\n                            record[\"updated_at\"],\n                        ),\n                    )\n                return True\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to upsert generation record {}: {}\", record_id, exc)\n                return False\n\n        return self._call(\"add_record\", _op, False)\n\n    def get_records(self, content_type: str, limit: int, offset: int) -> List[Dict]:\n        \"\"\"分页获取记录，按 created_at DESC 排序.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(\n                    \"\"\"\n                    SELECT * FROM generations\n                    WHERE content_type = ?\n                    ORDER BY created_at DESC, updated_at DESC\n                    LIMIT ? OFFSET ?\n                    \"\"\",\n                    (content_type, limit, offset),\n                )\n                return [self._row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to fetch generation records: {}\", exc)\n                return []\n\n        return self._call(\"get_records\", _op, [])\n\n    def get_records_by_status(self, content_type: str, statuses: List[str], limit: int = 50) -> List[Dict]:\n        \"\"\"按状态获取记录（用于 pending 恢复等场景）.\"\"\"\n\n        statuses = [str(s) for s in (statuses or []) if s]\n        if not statuses:\n            return []\n\n        placeholders = \", \".join([\"?\"] * len(statuses))\n        sql = (\n            \"SELECT * FROM generations \"\n            \"WHERE content_type = ? AND status IN (\" + placeholders + \") \"\n            \"ORDER BY updated_at DESC, created_at DESC \"\n            \"LIMIT ?\"\n        )\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(sql, (content_type, *statuses, limit))\n                return [self._row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to fetch generation records by status: {}\", exc)\n                return []\n\n        return self._call(\"get_records_by_status\", _op, [])\n\n    def get_record_by_id(self, record_id: str) -> Optional[Dict]:\n        \"\"\"根据ID获取单条记录.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> Optional[Dict]:\n            try:\n                cursor = connection.execute(\n                    \"SELECT * FROM generations WHERE id = ?\", (record_id,)\n                )\n                row = cursor.fetchone()\n                return self._row_to_dict(row) if row else None\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to fetch generation record {}: {}\", record_id, exc)\n                return None\n\n        return self._call(\"get_record_by_id\", _op, None)\n\n    def update_record(self, record_id: str, data: Dict) -> bool:\n        \"\"\"更新记录.\"\"\"\n\n        if not data:\n            return False\n\n        allowed_columns = [\n            \"content_type\",\n            \"prompt\",\n            \"model\",\n            \"status\",\n            \"file_path\",\n            \"relative_path\",\n            \"thumbnail_path\",\n            \"parameters\",\n            \"metadata\",\n            \"created_at\",\n        ]\n\n        set_clauses: List[str] = []\n        values: List[Any] = []\n\n        for column in allowed_columns:\n            if column in data:\n                value = data[column]\n                if column in {\"parameters\", \"metadata\"}:\n                    value = self._dump_json(value)\n                set_clauses.append(f\"{column} = ?\")\n                values.append(value)\n\n        if not set_clauses:\n            return False\n\n        set_clauses.append(\"updated_at = ?\")\n        values.append(self._now())\n\n        values.append(record_id)\n        sql = f\"UPDATE generations SET {', '.join(set_clauses)} WHERE id = ?\"\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    cursor = connection.execute(sql, values)\n                return cursor.rowcount > 0\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to update generation record {}: {}\", record_id, exc)\n                return False\n\n        return self._call(\"update_record\", _op, False)\n\n    def delete_record(self, record_id: str) -> bool:\n        \"\"\"删除记录.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    cursor = connection.execute(\n                        \"DELETE FROM generations WHERE id = ?\", (record_id,)\n                    )\n                return cursor.rowcount > 0\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to delete generation record {}: {}\", record_id, exc)\n                return False\n\n        return self._call(\"delete_record\", _op, False)\n\n    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n        \"\"\"清理超时的 pending 记录（无文件路径的孤立占位符）\n\n        Args:\n            timeout_hours: 超时时间（小时）\n\n        Returns:\n            删除的记录数量\n        \"\"\"\n        from datetime import datetime, timedelta\n\n        cutoff = datetime.now() - timedelta(hours=timeout_hours)\n        cutoff_str = cutoff.isoformat()\n\n        def _op(connection: sqlite3.Connection) -> int:\n            try:\n                with connection:\n                    cursor = connection.execute(\n                        \"\"\"\n                        DELETE FROM generations\n                        WHERE status = 'pending'\n                          AND file_path IS NULL\n                          AND created_at < ?\n                        \"\"\",\n                        (cutoff_str,),\n                    )\n                deleted = cursor.rowcount\n                if deleted > 0:\n                    logger.info(f\"已清理 {deleted} 条过期的 pending 记录\")\n                return deleted\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to cleanup stale pending records: {}\", exc)\n                return 0\n\n        return self._call(\"cleanup_stale_pending_records\", _op, 0)\n\n    def get_total_count(self, content_type: str) -> int:\n        \"\"\"获取某类型总数.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> int:\n            try:\n                cursor = connection.execute(\n                    \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",\n                    (content_type,),\n                )\n                row = cursor.fetchone()\n                return int(row[0]) if row else 0\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to count generation records: {}\", exc)\n                return 0\n\n        return self._call(\"get_total_count\", _op, 0)\n\n    def search_records(\n        self, keyword: str, content_type: Optional[str], limit: int\n    ) -> List[Dict]:\n        \"\"\"搜索记录（prompt、model、file_path）.\"\"\"\n\n        if not keyword:\n            return []\n\n        pattern = f\"%{keyword}%\"\n        where_clauses = [\n            \"(prompt LIKE ? OR model LIKE ? OR file_path LIKE ?)\"\n        ]\n        params: List[Any] = [pattern, pattern, pattern]\n\n        if content_type:\n            where_clauses.append(\"content_type = ?\")\n            params.append(content_type)\n\n        params.append(limit)\n\n        query = (\n            \"SELECT * FROM generations WHERE \"\n            + \" AND \".join(where_clauses)\n            + \" ORDER BY created_at DESC, updated_at DESC LIMIT ?\"\n        )\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(query, params)\n                return [self._row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to search generation records: {}\", exc)\n                return []\n\n        return self._call(\"search_records\", _op, [])\n\n    def add_reference_asset(self, generation_id: str, asset_data: Dict) -> bool:\n        \"\"\"添加参考图资产.\"\"\"\n\n        asset_id = asset_data.get(\"id\") or asset_data.get(\"asset_id\")\n        if not asset_id:\n            logger.error(\"Reference asset requires an 'id' field\")\n            return False\n\n        payload = {\n            \"id\": asset_id,\n            \"generation_id\": generation_id,\n            \"asset_path\": asset_data.get(\"asset_path\"),\n            \"relative_path\": asset_data.get(\"relative_path\"),\n            \"asset_type\": asset_data.get(\"asset_type\"),\n            \"order_index\": asset_data.get(\"order_index\", 0),\n            \"metadata\": self._dump_json(asset_data.get(\"metadata\")),\n        }\n\n        sql = (\n            \"INSERT INTO reference_assets (id, generation_id, asset_path, relative_path, \"\n            \"asset_type, order_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?)\"\n        )\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    connection.execute(\n                        sql,\n                        (\n                            payload[\"id\"],\n                            payload[\"generation_id\"],\n                            payload[\"asset_path\"],\n                            payload[\"relative_path\"],\n                            payload[\"asset_type\"],\n                            payload[\"order_index\"],\n                            payload[\"metadata\"],\n                        ),\n                    )\n                return True\n            except sqlite3.Error as exc:\n                logger.error(\n                    \"Failed to insert reference asset {} for generation {}: {}\",\n                    asset_id,\n                    generation_id,\n                    exc,\n                )\n                return False\n\n        return self._call(\"add_reference_asset\", _op, False)\n\n    def get_reference_assets(self, generation_id: str) -> List[Dict]:\n        \"\"\"获取参考图资产.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(\n                    \"\"\"\n                    SELECT * FROM reference_assets\n                    WHERE generation_id = ?\n                    ORDER BY order_index ASC\n                    \"\"\",\n                    (generation_id,),\n                )\n                return [self._reference_row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\n                    \"Failed to fetch reference assets for generation {}: {}\",\n                    generation_id,\n                    exc,\n                )\n                return []\n\n        return self._call(\"get_reference_assets\", _op, [])\n\n    def close(self) -> None:\n        \"\"\"关闭数据库连接.\"\"\"\n\n        if self._closed:\n            return\n        self._closed = True\n\n        try:\n            self._queue.put(None)\n        except Exception:\n            return\n\n        try:\n            self._worker_thread.join(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except Exception:\n            pass\n","numLines":588,"startLine":1,"totalLines":588}},"sourceToolAssistantUUID":"c16da065-cfb4-4844-acba-35aacf2cd8ec"}
{"parentUuid":"1683af9c-df42-4aec-82c8-7359a9140c02","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xbqdf5AMXg3DYd72h92utB","type":"tool_result","content":"     1→\"\"\"Image mode: generation orchestration logic (Phase 4.3.b).\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import os\n     6→from datetime import datetime\n     7→from typing import Any, Dict, List, Optional\n     8→\n     9→from PySide6.QtCore import QTimer\n    10→from loguru import logger\n    11→\n    12→from config.sources.generation_config import IMAGE_GENERATION_DEFAULTS\n    13→from utils.reference_display import _mask_reference_ids\n    14→\n    15→\n    16→def generate_image(self) -> None:\n    17→    \"\"\"生成图片\"\"\"\n    18→    prompt = self.prompt_input.toPlainText().strip()\n    19→    if not prompt:\n    20→        self.show_styled_message(\"警告\", \"请输入提示词\", \"warning\")\n    21→        return\n    22→\n    23→    form_values = self._collect_image_form_values()\n    24→    if form_values is None:\n    25→        self.generate_button.setEnabled(True)\n    26→        return\n    27→\n    28→    guidance_scale = float(IMAGE_GENERATION_DEFAULTS.get(\"guidance_scale\", 2.5))\n    29→\n    30→    seed_value = form_values.get(\"seed\", -1)\n    31→    try:\n    32→        seed_value = int(seed_value)\n    33→    except Exception:\n    34→        seed_value = -1\n    35→\n    36→    count_value = form_values.get(\"count\", 1)\n    37→    try:\n    38→        count_value = max(1, int(count_value))\n    39→    except Exception:\n    40→        count_value = 1\n    41→\n    42→    schema_values = dict(form_values)\n    43→    schema_values[\"guidance_scale\"] = guidance_scale\n    44→\n    45→    params = {\n    46→        \"size\": form_values.get(\"size\"),\n    47→        \"guidance_scale\": guidance_scale,\n    48→        \"seed\": seed_value,\n    49→        \"count\": count_value,\n    50→        \"model_variant\": form_values.get(\"model_variant\") or self._image_schema_variant,\n    51→        \"auto_compress_references\": form_values.get(\"auto_compress_references\", True),\n    52→        \"sequential_mode\": bool(form_values.get(\"sequential_mode\", False)),\n    53→        \"schema_values\": schema_values,\n    54→    }\n    55→    if not params[\"size\"]:\n    56→        params[\"size\"] = IMAGE_GENERATION_DEFAULTS.get(\"size\", \"1024x1024\")\n    57→\n    58→    expected_outputs = max(1, count_value)\n    59→\n    60→    reference_assets: Optional[List[Dict[str, Any]]]\n    61→    # 移除了参考图数量限制验证 - ImageService._generate_batch() 已正确支持\n    62→    # 参考图 + count > 1 的情况，会自动改为逐张生成模式\n    63→    reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n    64→    if reference_assets is None:\n    65→        self._last_reference_assets = []\n    66→        self.generate_button.setEnabled(True)\n    67→        return\n    68→\n    69→    params[\"reference_images\"] = reference_assets\n    70→    params[\"reference_count\"] = len(reference_assets)\n    71→    self._last_reference_assets = reference_assets or []\n    72→    params[\"prompt\"] = prompt\n    73→    if self.uploaded_image:\n    74→        params[\"image_path\"] = self.uploaded_image\n    75→        params.setdefault(\"input_image_path\", self.uploaded_image)\n    76→\n    77→    self.generate_button.setEnabled(False)\n    78→    try:\n    79→        task_id = self._task_manager.submit_image_task(params)\n    80→        # 占位 ID 必须与最终记录一致：单张用基 ID，批量使用派生 ID\n    81→        derived_ids = params.get(\"derived_ids\")\n    82→        if not derived_ids:\n    83→            if expected_outputs <= 1:\n    84→                derived_ids = [task_id]\n    85→            else:\n    86→                derived_ids = [f\"{task_id}_{i+1}\" for i in range(expected_outputs)]\n    87→        derived_ids = derived_ids[:expected_outputs]\n    88→        self._task_placeholder_index[task_id] = derived_ids\n    89→\n    90→        repo_manager = self.get_repository_manager()\n    91→        if repo_manager:\n    92→            pending_template = {\n    93→                \"prompt\": prompt,\n    94→                \"model\": params.get(\"model\", \"\"),\n    95→                \"status\": \"pending\",\n    96→                \"created_at\": datetime.now().isoformat(),\n    97→                \"parameters\": params,\n    98→            }\n    99→            for pid in derived_ids:\n   100→                repo_manager.add_content(pid, \"images\", dict(pending_template))\n   101→\n   102→        if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n   103→            for pid in derived_ids:\n   104→                try:\n   105→                    self.image_history_view.add_placeholder_item(pid, prompt)\n   106→                    self._task_placeholder_cards[pid] = pid\n   107→                except Exception as exc:\n   108→                    logger.debug(f\"添加虚拟化占位失败 {pid}: {exc}\")\n   109→        elif hasattr(self, \"image_history_view\") and self.image_history_view:\n   110→            for pid in derived_ids:\n   111→                self._create_placeholder_card(pid, prompt, \"image\")\n   112→        else:\n   113→            for pid in derived_ids:\n   114→                self._task_placeholder_cards[pid] = pid\n   115→\n   116→        self.status_label.setText(\"任务已加入队列，等待处理...\")\n   117→        logger.info(f\"图片生成任务已提交: {task_id} -> {derived_ids}\")\n   118→    finally:\n   119→        self.generate_button.setEnabled(True)\n   120→\n   121→\n   122→def generate_random_seed(self) -> None:\n   123→    \"\"\"生成随机种子\"\"\"\n   124→    import random\n   125→\n   126→    random_seed = random.randint(1, 2147483647)\n   127→    if self.image_schema_form:\n   128→        self.image_schema_form.set_field_value(\"seed\", random_seed)\n   129→    self._image_form_cache[\"seed\"] = random_seed\n   130→\n   131→\n   132→def _on_task_started(self, task_id: str, content_type: str) -> None:\n   133→    if content_type != \"images\":\n   134→        return\n   135→    ids = self._task_placeholder_index.get(task_id) or [task_id]\n   136→    for pid in ids:\n   137→        placeholder = self._task_placeholder_cards.get(pid)\n   138→        if placeholder and isinstance(placeholder, str):\n   139→            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n   140→                self.image_history_view.update_placeholder_status(pid, \"generating\", 0)\n   141→        elif placeholder:\n   142→            try:\n   143→                placeholder.set_status(\"generating\")\n   144→            except Exception:\n   145→                pass\n   146→    self.status_label.setText(\"正在准备生成图片...\")\n   147→\n   148→\n   149→def _on_task_progress(self, task_id: str, message: str, percentage: int) -> None:\n   150→    ids = self._task_placeholder_index.get(task_id) or [task_id]\n   151→    for pid in ids:\n   152→        placeholder = self._task_placeholder_cards.get(pid)\n   153→        if placeholder and isinstance(placeholder, str):\n   154→            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n   155→                self.image_history_view.update_placeholder_status(pid, \"generating\", percentage)\n   156→        elif placeholder:\n   157→            try:\n   158→                placeholder.set_status(\"generating\")\n   159→                placeholder.set_progress(message, percentage)\n   160→            except Exception:\n   161→                pass\n   162→    if message:\n   163→        self.status_label.setText(message)\n   164→\n   165→\n   166→def _on_task_completed(self, task_id: str, content_type: str, result: Dict[str, Any]) -> None:\n   167→    if content_type != \"images\":\n   168→        return\n   169→\n   170→    # 获取所有关联的占位符 ID\n   171→    placeholder_ids = self._task_placeholder_index.pop(task_id, []) or [task_id]\n   172→    if task_id not in placeholder_ids:\n   173→        placeholder_ids.append(task_id)\n   174→\n   175→    # 收集所有需要清理的占位符 ID（包括派生 ID）\n   176→    all_placeholder_ids = set(placeholder_ids)\n   177→\n   178→    records = self._normalize_image_results(task_id, result or {})\n   179→\n   180→    # 无论是否有记录，都先清理所有占位符\n   181→    def _cleanup_placeholder(pid: str) -> None:\n   182→        \"\"\"清理单个占位符\"\"\"\n   183→        try:\n   184→            self._task_placeholder_cards.pop(pid, None)\n   185→            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n   186→                self.image_history_view.remove_placeholder(pid)\n   187→            elif hasattr(self, \"image_history_view\"):\n   188→                self.image_history_view.remove_placeholder(pid)\n   189→            logger.debug(f\"占位符已清理: {pid}\")\n   190→        except Exception as exc:\n   191→            logger.debug(f\"清理占位符失败 {pid}: {exc}\")\n   192→\n   193→    if not records:\n   194→        # 生成结果为空，清理所有占位符\n   195→        for pid in all_placeholder_ids:\n   196→            _cleanup_placeholder(pid)\n   197→        logger.warning(f\"任务 {task_id} 完成但无结果，已清理占位符\")\n   198→        return\n   199→\n   200→    # 处理记录并显示\n   201→    if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n   202→        try:\n   203→            replaced_count = 0\n   204→            for rec in records:\n   205→                # 获取记录的 ID（优先使用 file_id，与保存时一致）\n   206→                rec_id = rec.get(\"file_id\") or rec.get(\"generation_id\") or rec.get(\"task_id\") or task_id\n   207→                if not rec_id:\n   208→                    continue\n   209→\n   210→                # 尝试替换占位符（方法返回布尔值表示是否成功）\n   211→                replace_success = False\n   212→                try:\n   213→                    replace_success = self.image_history_view.replace_placeholder_with_actual(rec_id, rec)\n   214→                    if replace_success:\n   215→                        replaced_count += 1\n   216→                        all_placeholder_ids.discard(rec_id)\n   217→                        self._task_placeholder_cards.pop(rec_id, None)\n   218→                        logger.debug(f\"占位符替换成功: {rec_id}\")\n   219→                except Exception as exc:\n   220→                    logger.debug(f\"占位符替换异常 {rec_id}: {exc}\")\n   221→                    replace_success = False\n   222→\n   223→                # 如果替换失败，直接添加新记录到前端\n   224→                if not replace_success:\n   225→                    try:\n   226→                        self.image_history_view.model.prepend_items([rec])\n   227→                        logger.info(f\"新记录已添加（替换失败后）: {rec_id}\")\n   228→                    except Exception as exc:\n   229→                        logger.error(f\"添加新记录失败 {rec_id}: {exc}\")\n   230→\n   231→            logger.info(f\"任务 {task_id} 处理完成: {replaced_count}/{len(records)} 替换成功\")\n   232→\n   233→        except Exception as exc:\n   234→            logger.error(f\"刷新图片记录失败: {exc}\")\n   235→            # 出错时仍尝试添加所有记录\n   236→            try:\n   237→                self.image_history_view.model.prepend_items(records)\n   238→            except Exception:\n   239→                pass\n   240→\n   241→    elif hasattr(self, \"image_history_view\"):\n   242→        for rec in records:\n   243→            rec_id = rec.get(\"file_id\") or rec.get(\"generation_id\") or rec.get(\"task_id\") or task_id\n   244→            try:\n   245→                if rec_id in self._task_placeholder_cards:\n   246→                    self.image_history_view.update_placeholder_to_actual(rec_id, rec)\n   247→                    self._task_placeholder_cards.pop(rec_id, None)\n   248→                    all_placeholder_ids.discard(rec_id)\n   249→                else:\n   250→                    self.image_history_view.add_image_card(rec)\n   251→            except Exception as exc:\n   252→                logger.debug(f\"更新占位卡失败 {rec_id}: {exc}\")\n   253→\n   254→    # 最终清理：确保所有残留的占位符都被移除\n   255→    for pid in all_placeholder_ids:\n   256→        _cleanup_placeholder(pid)\n   257→\n   258→    self.status_label.setText(\"图片生成完成\")\n   259→    logger.info(f\"UI|image_generation_completed task_id={task_id}\")\n   260→\n   261→\n   262→def _on_task_failed(self, task_id: str, content_type: str, error: str) -> None:\n   263→    if content_type != \"images\":\n   264→        return\n   265→    ids = self._task_placeholder_index.pop(task_id, []) or [task_id]\n   266→\n   267→    # 删除数据库中的 pending 记录，防止孤立占位符残留\n   268→    repo_manager = self.get_repository_manager()\n   269→    if repo_manager:\n   270→        for pid in ids:\n   271→            try:\n   272→                repo_manager.delete_record(pid)\n   273→                logger.debug(f\"已删除失败任务的 pending 记录: {pid}\")\n   274→            except Exception as exc:\n   275→                logger.debug(f\"删除 pending 记录失败 {pid}: {exc}\")\n   276→\n   277→    for pid in ids:\n   278→        placeholder = self._task_placeholder_cards.pop(pid, None)\n   279→        if placeholder and isinstance(placeholder, str):\n   280→            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n   281→                self.image_history_view.update_placeholder_status(pid, \"failed\")\n   282→                QTimer.singleShot(3000, lambda tid=pid: self.image_history_view.remove_placeholder(tid))\n   283→        elif placeholder:\n   284→            try:\n   285→                placeholder.set_status(\"failed\", error)\n   286→            except Exception:\n   287→                pass\n   288→    message = f\"图片生成失败: {error}\"\n   289→    self.on_generation_failed(message)\n   290→\n   291→\n   292→def _on_queue_updated(self, content_type: str, active: int, queued: int) -> None:\n   293→    if content_type != \"images\":\n   294→        return\n   295→    total = active + queued\n   296→    if total > 0:\n   297→        self.status_label.setText(f\"图片生成中: {active}个运行, {queued}个排队\")\n   298→    else:\n   299→        self.status_label.setText(\"就绪\")\n   300→\n   301→\n   302→def _create_placeholder_card(self, task_id: str, prompt: str, content_type: str) -> None:\n   303→    if getattr(self, \"use_virtual_image_view\", False):\n   304→        if hasattr(self, \"image_history_view\"):\n   305→            # 占位 ID 与最终 file_id/派生 ID 一致（避免 _1/_N 不匹配）\n   306→            self.image_history_view.add_placeholder_item(task_id, prompt)\n   307→            self._task_placeholder_cards[task_id] = task_id\n   308→            logger.info(f\"虚拟化视图占位项已创建: {task_id}\")\n   309→        return\n   310→\n   311→    if not getattr(self, \"image_history_view\", None):\n   312→        logger.warning(f\"image_history_view 不存在，无法创建占位卡片: {task_id}\")\n   313→        return\n   314→    placeholder_data = {\n   315→        \"file_id\": f\"placeholder_{task_id}\",\n   316→        \"task_id\": task_id,\n   317→        \"prompt\": prompt,\n   318→        \"created_at\": datetime.now().isoformat(),\n   319→        \"status\": \"pending\",\n   320→        \"content_type\": content_type,\n   321→    }\n   322→    try:\n   323→        card = self.image_history_view.add_placeholder_card(placeholder_data)\n   324→        if card:\n   325→            self._task_placeholder_cards[task_id] = card\n   326→            logger.info(f\"占位卡片已创建: {task_id}\")\n   327→        else:\n   328→            logger.warning(f\"add_placeholder_card 返回 None: {task_id}\")\n   329→    except Exception as exc:\n   330→        logger.error(f\"添加占位卡片失败: {task_id}, 错误: {exc}\", exc_info=True)\n   331→\n   332→\n   333→def _normalize_image_results(self, task_id: str, result: Dict[str, Any]) -> List[Dict[str, Any]]:\n   334→    records: List[Dict[str, Any]] = []\n   335→    if not isinstance(result, dict):\n   336→        return records\n   337→    entries = result.get(\"results\")\n   338→    payloads = entries if isinstance(entries, list) and entries else [result]\n   339→    base_prompt = result.get(\"prompt\") or self.prompt_input.toPlainText().strip()\n   340→    base_created = result.get(\"created_at\")\n   341→    base_params = result.get(\"parameters\") or {}\n   342→    for payload in payloads:\n   343→        record = self._build_image_card_data(task_id, payload, base_prompt, base_created, base_params)\n   344→        if record:\n   345→            records.append(record)\n   346→    return records\n   347→\n   348→\n   349→def _build_image_card_data(\n   350→    self,\n   351→    fallback_id: str,\n   352→    payload: Dict[str, Any],\n   353→    base_prompt: str,\n   354→    base_created_at: Optional[str],\n   355→    base_params: Dict[str, Any],\n   356→) -> Optional[Dict[str, Any]]:\n   357→    if not isinstance(payload, dict):\n   358→        return None\n   359→    if payload.get(\"success\") is False and not payload.get(\"local_path\"):\n   360→        return None\n   361→    file_path = payload.get(\"absolute_path\") or payload.get(\"local_path\") or payload.get(\"file_path\")\n   362→    if not file_path or not os.path.exists(file_path):\n   363→        return None\n   364→    record_id = payload.get(\"file_id\") or payload.get(\"generation_id\") or payload.get(\"task_id\") or fallback_id\n   365→    created_at = payload.get(\"created_at\") or base_created_at or datetime.now().isoformat()\n   366→    parameters = payload.get(\"parameters\") or base_params or {}\n   367→    prompt = payload.get(\"prompt\") or base_prompt or \"图片生成\"\n   368→    width = payload.get(\"width\")\n   369→    height = payload.get(\"height\")\n   370→    if (not width or not height) and file_path:\n   371→        try:\n   372→            from PIL import Image\n   373→\n   374→            with Image.open(file_path) as img:\n   375→                width, height = img.size\n   376→        except Exception:\n   377→            width, height = None, None\n   378→    thumbnail_path = payload.get(\"thumbnail_path\") or payload.get(\"thumbnail_local_path\")\n   379→    reference_assets = payload.get(\"reference_assets\") or parameters.get(\"reference_assets\") or []\n   380→    return {\n   381→        \"file_id\": record_id,\n   382→        \"absolute_path\": file_path,\n   383→        \"file_path\": file_path,\n   384→        \"thumbnail_path\": thumbnail_path,\n   385→        \"prompt\": prompt,\n   386→        \"created_at\": created_at,\n   387→        \"parameters\": parameters,\n   388→        \"reference_assets\": reference_assets,\n   389→        \"content_type\": \"image\",\n   390→        \"width\": width,\n   391→        \"height\": height,\n   392→    }\n   393→\n   394→\n   395→def on_generation_completed(self, result: Dict[str, Any]) -> None:\n   396→    \"\"\"生成完成（优化版）\"\"\"\n   397→    self.generate_button.setEnabled(True)\n   398→    ref_assets = result.get(\"reference_assets\") or result.get(\"parameters\", {}).get(\"reference_assets\") or []\n   399→    if not ref_assets and isinstance(result.get(\"results\"), list):\n   400→        for item in result[\"results\"]:\n   401→            refs = (\n   402→                item.get(\"reference_assets\") or item.get(\"parameters\", {}).get(\"reference_assets\")\n   403→                if isinstance(item, dict)\n   404→                else None\n   405→            )\n   406→            if refs:\n   407→                ref_assets = refs\n   408→                break\n   409→    ref_count = len(ref_assets)\n   410→    masked = _mask_reference_ids(ref_assets)\n   411→    logger.info(f\"UI|image_generation_completed reference_count={ref_count} ref_ids={masked}\")\n   412→    status_message = \"图片生成成功！\"\n   413→    if ref_count:\n   414→        status_message = f\"图片生成成功！参考图 {ref_count} 张\"\n   415→    self.status_label.setText(status_message)\n   416→\n   417→    # 延迟刷新历史记录（防抖动）\n   418→    self._delayed_refresh_history()\n   419→\n   420→    # 保留提示词以便用户迭代修改\n   421→    self._last_reference_assets = []\n   422→\n   423→\n   424→def on_generation_failed(self, error_message: str) -> None:\n   425→    \"\"\"生成失败\"\"\"\n   426→    self.generate_button.setEnabled(True)\n   427→    self.status_label.setText(error_message)\n   428→    if self._last_reference_assets:\n   429→        logger.warning(\n   430→            \"UI|image_generation_failed reference_count=%s ref_ids=%s\",\n   431→            len(self._last_reference_assets),\n   432→            _mask_reference_ids(self._last_reference_assets),\n   433→        )\n   434→\n   435→    self.show_styled_message(\"错误\", error_message, \"critical\")\n   436→    self._last_reference_assets = []\n   437→\n   438→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b3b23d19-0729-40e5-933a-e01cf0d66ea7","timestamp":"2026-01-09T03:40:37.824Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py","content":"\"\"\"Image mode: generation orchestration logic (Phase 4.3.b).\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\n\nfrom PySide6.QtCore import QTimer\nfrom loguru import logger\n\nfrom config.sources.generation_config import IMAGE_GENERATION_DEFAULTS\nfrom utils.reference_display import _mask_reference_ids\n\n\ndef generate_image(self) -> None:\n    \"\"\"生成图片\"\"\"\n    prompt = self.prompt_input.toPlainText().strip()\n    if not prompt:\n        self.show_styled_message(\"警告\", \"请输入提示词\", \"warning\")\n        return\n\n    form_values = self._collect_image_form_values()\n    if form_values is None:\n        self.generate_button.setEnabled(True)\n        return\n\n    guidance_scale = float(IMAGE_GENERATION_DEFAULTS.get(\"guidance_scale\", 2.5))\n\n    seed_value = form_values.get(\"seed\", -1)\n    try:\n        seed_value = int(seed_value)\n    except Exception:\n        seed_value = -1\n\n    count_value = form_values.get(\"count\", 1)\n    try:\n        count_value = max(1, int(count_value))\n    except Exception:\n        count_value = 1\n\n    schema_values = dict(form_values)\n    schema_values[\"guidance_scale\"] = guidance_scale\n\n    params = {\n        \"size\": form_values.get(\"size\"),\n        \"guidance_scale\": guidance_scale,\n        \"seed\": seed_value,\n        \"count\": count_value,\n        \"model_variant\": form_values.get(\"model_variant\") or self._image_schema_variant,\n        \"auto_compress_references\": form_values.get(\"auto_compress_references\", True),\n        \"sequential_mode\": bool(form_values.get(\"sequential_mode\", False)),\n        \"schema_values\": schema_values,\n    }\n    if not params[\"size\"]:\n        params[\"size\"] = IMAGE_GENERATION_DEFAULTS.get(\"size\", \"1024x1024\")\n\n    expected_outputs = max(1, count_value)\n\n    reference_assets: Optional[List[Dict[str, Any]]]\n    # 移除了参考图数量限制验证 - ImageService._generate_batch() 已正确支持\n    # 参考图 + count > 1 的情况，会自动改为逐张生成模式\n    reference_assets = self._collect_reference_assets_for_image(expected_outputs)\n    if reference_assets is None:\n        self._last_reference_assets = []\n        self.generate_button.setEnabled(True)\n        return\n\n    params[\"reference_images\"] = reference_assets\n    params[\"reference_count\"] = len(reference_assets)\n    self._last_reference_assets = reference_assets or []\n    params[\"prompt\"] = prompt\n    if self.uploaded_image:\n        params[\"image_path\"] = self.uploaded_image\n        params.setdefault(\"input_image_path\", self.uploaded_image)\n\n    self.generate_button.setEnabled(False)\n    try:\n        task_id = self._task_manager.submit_image_task(params)\n        # 占位 ID 必须与最终记录一致：单张用基 ID，批量使用派生 ID\n        derived_ids = params.get(\"derived_ids\")\n        if not derived_ids:\n            if expected_outputs <= 1:\n                derived_ids = [task_id]\n            else:\n                derived_ids = [f\"{task_id}_{i+1}\" for i in range(expected_outputs)]\n        derived_ids = derived_ids[:expected_outputs]\n        self._task_placeholder_index[task_id] = derived_ids\n\n        repo_manager = self.get_repository_manager()\n        if repo_manager:\n            pending_template = {\n                \"prompt\": prompt,\n                \"model\": params.get(\"model\", \"\"),\n                \"status\": \"pending\",\n                \"created_at\": datetime.now().isoformat(),\n                \"parameters\": params,\n            }\n            for pid in derived_ids:\n                repo_manager.add_content(pid, \"images\", dict(pending_template))\n\n        if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n            for pid in derived_ids:\n                try:\n                    self.image_history_view.add_placeholder_item(pid, prompt)\n                    self._task_placeholder_cards[pid] = pid\n                except Exception as exc:\n                    logger.debug(f\"添加虚拟化占位失败 {pid}: {exc}\")\n        elif hasattr(self, \"image_history_view\") and self.image_history_view:\n            for pid in derived_ids:\n                self._create_placeholder_card(pid, prompt, \"image\")\n        else:\n            for pid in derived_ids:\n                self._task_placeholder_cards[pid] = pid\n\n        self.status_label.setText(\"任务已加入队列，等待处理...\")\n        logger.info(f\"图片生成任务已提交: {task_id} -> {derived_ids}\")\n    finally:\n        self.generate_button.setEnabled(True)\n\n\ndef generate_random_seed(self) -> None:\n    \"\"\"生成随机种子\"\"\"\n    import random\n\n    random_seed = random.randint(1, 2147483647)\n    if self.image_schema_form:\n        self.image_schema_form.set_field_value(\"seed\", random_seed)\n    self._image_form_cache[\"seed\"] = random_seed\n\n\ndef _on_task_started(self, task_id: str, content_type: str) -> None:\n    if content_type != \"images\":\n        return\n    ids = self._task_placeholder_index.get(task_id) or [task_id]\n    for pid in ids:\n        placeholder = self._task_placeholder_cards.get(pid)\n        if placeholder and isinstance(placeholder, str):\n            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n                self.image_history_view.update_placeholder_status(pid, \"generating\", 0)\n        elif placeholder:\n            try:\n                placeholder.set_status(\"generating\")\n            except Exception:\n                pass\n    self.status_label.setText(\"正在准备生成图片...\")\n\n\ndef _on_task_progress(self, task_id: str, message: str, percentage: int) -> None:\n    ids = self._task_placeholder_index.get(task_id) or [task_id]\n    for pid in ids:\n        placeholder = self._task_placeholder_cards.get(pid)\n        if placeholder and isinstance(placeholder, str):\n            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n                self.image_history_view.update_placeholder_status(pid, \"generating\", percentage)\n        elif placeholder:\n            try:\n                placeholder.set_status(\"generating\")\n                placeholder.set_progress(message, percentage)\n            except Exception:\n                pass\n    if message:\n        self.status_label.setText(message)\n\n\ndef _on_task_completed(self, task_id: str, content_type: str, result: Dict[str, Any]) -> None:\n    if content_type != \"images\":\n        return\n\n    # 获取所有关联的占位符 ID\n    placeholder_ids = self._task_placeholder_index.pop(task_id, []) or [task_id]\n    if task_id not in placeholder_ids:\n        placeholder_ids.append(task_id)\n\n    # 收集所有需要清理的占位符 ID（包括派生 ID）\n    all_placeholder_ids = set(placeholder_ids)\n\n    records = self._normalize_image_results(task_id, result or {})\n\n    # 无论是否有记录，都先清理所有占位符\n    def _cleanup_placeholder(pid: str) -> None:\n        \"\"\"清理单个占位符\"\"\"\n        try:\n            self._task_placeholder_cards.pop(pid, None)\n            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n                self.image_history_view.remove_placeholder(pid)\n            elif hasattr(self, \"image_history_view\"):\n                self.image_history_view.remove_placeholder(pid)\n            logger.debug(f\"占位符已清理: {pid}\")\n        except Exception as exc:\n            logger.debug(f\"清理占位符失败 {pid}: {exc}\")\n\n    if not records:\n        # 生成结果为空，清理所有占位符\n        for pid in all_placeholder_ids:\n            _cleanup_placeholder(pid)\n        logger.warning(f\"任务 {task_id} 完成但无结果，已清理占位符\")\n        return\n\n    # 处理记录并显示\n    if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n        try:\n            replaced_count = 0\n            for rec in records:\n                # 获取记录的 ID（优先使用 file_id，与保存时一致）\n                rec_id = rec.get(\"file_id\") or rec.get(\"generation_id\") or rec.get(\"task_id\") or task_id\n                if not rec_id:\n                    continue\n\n                # 尝试替换占位符（方法返回布尔值表示是否成功）\n                replace_success = False\n                try:\n                    replace_success = self.image_history_view.replace_placeholder_with_actual(rec_id, rec)\n                    if replace_success:\n                        replaced_count += 1\n                        all_placeholder_ids.discard(rec_id)\n                        self._task_placeholder_cards.pop(rec_id, None)\n                        logger.debug(f\"占位符替换成功: {rec_id}\")\n                except Exception as exc:\n                    logger.debug(f\"占位符替换异常 {rec_id}: {exc}\")\n                    replace_success = False\n\n                # 如果替换失败，直接添加新记录到前端\n                if not replace_success:\n                    try:\n                        self.image_history_view.model.prepend_items([rec])\n                        logger.info(f\"新记录已添加（替换失败后）: {rec_id}\")\n                    except Exception as exc:\n                        logger.error(f\"添加新记录失败 {rec_id}: {exc}\")\n\n            logger.info(f\"任务 {task_id} 处理完成: {replaced_count}/{len(records)} 替换成功\")\n\n        except Exception as exc:\n            logger.error(f\"刷新图片记录失败: {exc}\")\n            # 出错时仍尝试添加所有记录\n            try:\n                self.image_history_view.model.prepend_items(records)\n            except Exception:\n                pass\n\n    elif hasattr(self, \"image_history_view\"):\n        for rec in records:\n            rec_id = rec.get(\"file_id\") or rec.get(\"generation_id\") or rec.get(\"task_id\") or task_id\n            try:\n                if rec_id in self._task_placeholder_cards:\n                    self.image_history_view.update_placeholder_to_actual(rec_id, rec)\n                    self._task_placeholder_cards.pop(rec_id, None)\n                    all_placeholder_ids.discard(rec_id)\n                else:\n                    self.image_history_view.add_image_card(rec)\n            except Exception as exc:\n                logger.debug(f\"更新占位卡失败 {rec_id}: {exc}\")\n\n    # 最终清理：确保所有残留的占位符都被移除\n    for pid in all_placeholder_ids:\n        _cleanup_placeholder(pid)\n\n    self.status_label.setText(\"图片生成完成\")\n    logger.info(f\"UI|image_generation_completed task_id={task_id}\")\n\n\ndef _on_task_failed(self, task_id: str, content_type: str, error: str) -> None:\n    if content_type != \"images\":\n        return\n    ids = self._task_placeholder_index.pop(task_id, []) or [task_id]\n\n    # 删除数据库中的 pending 记录，防止孤立占位符残留\n    repo_manager = self.get_repository_manager()\n    if repo_manager:\n        for pid in ids:\n            try:\n                repo_manager.delete_record(pid)\n                logger.debug(f\"已删除失败任务的 pending 记录: {pid}\")\n            except Exception as exc:\n                logger.debug(f\"删除 pending 记录失败 {pid}: {exc}\")\n\n    for pid in ids:\n        placeholder = self._task_placeholder_cards.pop(pid, None)\n        if placeholder and isinstance(placeholder, str):\n            if getattr(self, \"use_virtual_image_view\", False) and hasattr(self, \"image_history_view\"):\n                self.image_history_view.update_placeholder_status(pid, \"failed\")\n                QTimer.singleShot(3000, lambda tid=pid: self.image_history_view.remove_placeholder(tid))\n        elif placeholder:\n            try:\n                placeholder.set_status(\"failed\", error)\n            except Exception:\n                pass\n    message = f\"图片生成失败: {error}\"\n    self.on_generation_failed(message)\n\n\ndef _on_queue_updated(self, content_type: str, active: int, queued: int) -> None:\n    if content_type != \"images\":\n        return\n    total = active + queued\n    if total > 0:\n        self.status_label.setText(f\"图片生成中: {active}个运行, {queued}个排队\")\n    else:\n        self.status_label.setText(\"就绪\")\n\n\ndef _create_placeholder_card(self, task_id: str, prompt: str, content_type: str) -> None:\n    if getattr(self, \"use_virtual_image_view\", False):\n        if hasattr(self, \"image_history_view\"):\n            # 占位 ID 与最终 file_id/派生 ID 一致（避免 _1/_N 不匹配）\n            self.image_history_view.add_placeholder_item(task_id, prompt)\n            self._task_placeholder_cards[task_id] = task_id\n            logger.info(f\"虚拟化视图占位项已创建: {task_id}\")\n        return\n\n    if not getattr(self, \"image_history_view\", None):\n        logger.warning(f\"image_history_view 不存在，无法创建占位卡片: {task_id}\")\n        return\n    placeholder_data = {\n        \"file_id\": f\"placeholder_{task_id}\",\n        \"task_id\": task_id,\n        \"prompt\": prompt,\n        \"created_at\": datetime.now().isoformat(),\n        \"status\": \"pending\",\n        \"content_type\": content_type,\n    }\n    try:\n        card = self.image_history_view.add_placeholder_card(placeholder_data)\n        if card:\n            self._task_placeholder_cards[task_id] = card\n            logger.info(f\"占位卡片已创建: {task_id}\")\n        else:\n            logger.warning(f\"add_placeholder_card 返回 None: {task_id}\")\n    except Exception as exc:\n        logger.error(f\"添加占位卡片失败: {task_id}, 错误: {exc}\", exc_info=True)\n\n\ndef _normalize_image_results(self, task_id: str, result: Dict[str, Any]) -> List[Dict[str, Any]]:\n    records: List[Dict[str, Any]] = []\n    if not isinstance(result, dict):\n        return records\n    entries = result.get(\"results\")\n    payloads = entries if isinstance(entries, list) and entries else [result]\n    base_prompt = result.get(\"prompt\") or self.prompt_input.toPlainText().strip()\n    base_created = result.get(\"created_at\")\n    base_params = result.get(\"parameters\") or {}\n    for payload in payloads:\n        record = self._build_image_card_data(task_id, payload, base_prompt, base_created, base_params)\n        if record:\n            records.append(record)\n    return records\n\n\ndef _build_image_card_data(\n    self,\n    fallback_id: str,\n    payload: Dict[str, Any],\n    base_prompt: str,\n    base_created_at: Optional[str],\n    base_params: Dict[str, Any],\n) -> Optional[Dict[str, Any]]:\n    if not isinstance(payload, dict):\n        return None\n    if payload.get(\"success\") is False and not payload.get(\"local_path\"):\n        return None\n    file_path = payload.get(\"absolute_path\") or payload.get(\"local_path\") or payload.get(\"file_path\")\n    if not file_path or not os.path.exists(file_path):\n        return None\n    record_id = payload.get(\"file_id\") or payload.get(\"generation_id\") or payload.get(\"task_id\") or fallback_id\n    created_at = payload.get(\"created_at\") or base_created_at or datetime.now().isoformat()\n    parameters = payload.get(\"parameters\") or base_params or {}\n    prompt = payload.get(\"prompt\") or base_prompt or \"图片生成\"\n    width = payload.get(\"width\")\n    height = payload.get(\"height\")\n    if (not width or not height) and file_path:\n        try:\n            from PIL import Image\n\n            with Image.open(file_path) as img:\n                width, height = img.size\n        except Exception:\n            width, height = None, None\n    thumbnail_path = payload.get(\"thumbnail_path\") or payload.get(\"thumbnail_local_path\")\n    reference_assets = payload.get(\"reference_assets\") or parameters.get(\"reference_assets\") or []\n    return {\n        \"file_id\": record_id,\n        \"absolute_path\": file_path,\n        \"file_path\": file_path,\n        \"thumbnail_path\": thumbnail_path,\n        \"prompt\": prompt,\n        \"created_at\": created_at,\n        \"parameters\": parameters,\n        \"reference_assets\": reference_assets,\n        \"content_type\": \"image\",\n        \"width\": width,\n        \"height\": height,\n    }\n\n\ndef on_generation_completed(self, result: Dict[str, Any]) -> None:\n    \"\"\"生成完成（优化版）\"\"\"\n    self.generate_button.setEnabled(True)\n    ref_assets = result.get(\"reference_assets\") or result.get(\"parameters\", {}).get(\"reference_assets\") or []\n    if not ref_assets and isinstance(result.get(\"results\"), list):\n        for item in result[\"results\"]:\n            refs = (\n                item.get(\"reference_assets\") or item.get(\"parameters\", {}).get(\"reference_assets\")\n                if isinstance(item, dict)\n                else None\n            )\n            if refs:\n                ref_assets = refs\n                break\n    ref_count = len(ref_assets)\n    masked = _mask_reference_ids(ref_assets)\n    logger.info(f\"UI|image_generation_completed reference_count={ref_count} ref_ids={masked}\")\n    status_message = \"图片生成成功！\"\n    if ref_count:\n        status_message = f\"图片生成成功！参考图 {ref_count} 张\"\n    self.status_label.setText(status_message)\n\n    # 延迟刷新历史记录（防抖动）\n    self._delayed_refresh_history()\n\n    # 保留提示词以便用户迭代修改\n    self._last_reference_assets = []\n\n\ndef on_generation_failed(self, error_message: str) -> None:\n    \"\"\"生成失败\"\"\"\n    self.generate_button.setEnabled(True)\n    self.status_label.setText(error_message)\n    if self._last_reference_assets:\n        logger.warning(\n            \"UI|image_generation_failed reference_count=%s ref_ids=%s\",\n            len(self._last_reference_assets),\n            _mask_reference_ids(self._last_reference_assets),\n        )\n\n    self.show_styled_message(\"错误\", error_message, \"critical\")\n    self._last_reference_assets = []\n\n","numLines":438,"startLine":1,"totalLines":438}},"sourceToolAssistantUUID":"1683af9c-df42-4aec-82c8-7359a9140c02"}
{"parentUuid":"cce2dc8b-6de0-4a83-a6e3-a913a71c3e91","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DUP4UB8hhMKfqo87u4ev97","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config.unified_config import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        storage_dir = get_storage_dir()\n    59→        if not storage_dir:\n    60→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    61→        self.storage_manager = get_v2_storage_manager(storage_dir)\n    62→        \n    63→        # 保持兼容性别名\n    64→        self.file_manager = self.storage_manager\n    65→        self.metadata_manager = self.storage_manager\n    66→        self.image_storage_manager = self.storage_manager\n    67→        \n    68→        # 保留原有的目录属性以保持兼容性\n    69→        self.data_dir = Path(self.storage_manager.root_path)\n    70→        self.images_dir = self.data_dir / \"images\"\n    71→        self.metadata_dir = self.data_dir / \"metadata\"\n    72→\n    73→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    74→\n    75→    def generate_text_to_image(\n    76→        self,\n    77→        prompt: str,\n    78→        size: str = \"1024x1024\",\n    79→        guidance_scale: float = 2.5,\n    80→        seed: int = -1,\n    81→        save_local: bool = True,\n    82→        reference_images: Optional[List[Any]] = None,\n    83→        model_variant: Optional[str] = None,\n    84→        generation_id: Optional[str] = None,\n    85→        count: int = 1,\n    86→        sequential_mode: bool = False,\n    87→        derived_ids: Optional[List[str]] = None,\n    88→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    89→    ) -> Dict[str, Any]:\n    90→        \"\"\"\n    91→        生成文生图并保存到本地\n    92→\n    93→        Args:\n    94→            prompt: 图像生成提示词\n    95→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    96→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    97→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    98→            response_format: 返回格式，\"url\"或\"b64_json\"\n    99→            save_local: 是否保存到本地\n   100→            reference_images: 参考图列表\n   101→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   102→            count: 生成图片数量（组图模式下生效）\n   103→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   104→            derived_ids: 组图生成的ID列表（用于关联）\n   105→\n   106→        Returns:\n   107→            Dict: 生成结果，包含本地文件路径\n   108→\n   109→        Note:\n   110→            model和watermark参数已固定，不再需要前端控制\n   111→        \"\"\"\n   112→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   113→\n   114→        # 根据 model_variant 选择 provider（并发安全：不写 env）\n   115→        seedream_provider: Optional[str] = None\n   116→        try:\n   117→            mv = (model_variant or \"\").strip().lower()\n   118→            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n   119→                seedream_provider = \"volc_v4\"\n   120→            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n   121→                seedream_provider = \"volc_v4_5\"\n   122→            elif mv.startswith(\"volc_\"):\n   123→                seedream_provider = mv\n   124→        except Exception:\n   125→            seedream_provider = None\n   126→\n   127→        # 生成唯一ID，优先使用外部传入的generation_id\n   128→        task_id = generation_id or str(uuid.uuid4())\n   129→\n   130→        ref_assets: List[Dict[str, Any]] = []\n   131→        ref_paths: List[str] = []\n   132→        ref_summary: Dict[str, Any] = {}\n   133→        ref_payloads: List[str] = []\n   134→\n   135→        try:\n   136→            if reference_images:\n   137→                ref_summary = self._process_reference_assets(\n   138→                    reference_images,\n   139→                    max_refs=MAX_REFERENCE_IMAGES,\n   140→                    expected_outputs=1,\n   141→                )\n   142→                ref_assets = list(ref_summary.get('assets', []))\n   143→                ref_paths = list(ref_summary.get('paths', []))\n   144→                ref_payloads = self._build_reference_payloads(ref_assets)\n   145→\n   146→                if ref_summary.get('errors'):\n   147→                    logger.warning(\n   148→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   149→                    )\n   150→                if ref_summary.get('warnings'):\n   151→                    for warn in ref_summary['warnings']:\n   152→                        logger.warning(f\"参考图提示: {warn}\")\n   153→\n   154→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   155→            try:\n   156→                norm, fb, reason = validate_and_normalize_t2i(\n   157→                    TextToImageParams(\n   158→                        prompt=prompt,\n   159→                        size=size,\n   160→                        guidance_scale=guidance_scale,\n   161→                        seed=(None if seed == -1 else seed),\n   162→                    )\n   163→                )\n   164→                logger.info(\n   165→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   166→                )\n   167→                if fb:\n   168→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   169→            except Exception as _e:\n   170→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   171→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   172→            actual_count = max(1, count)\n   173→            use_group_mode = bool(sequential_mode and actual_count > 1)\n   174→\n   175→            api_result = self.client.text_to_image(\n   176→                prompt=prompt,\n   177→                size=size,\n   178→                guidance_scale=guidance_scale,\n   179→                seed=seed,\n   180→                reference_images=ref_payloads or None,\n   181→                n=actual_count if use_group_mode else 1,\n   182→                sequential_mode=sequential_mode,\n   183→                seedream_provider=seedream_provider,\n   184→            )\n   185→\n   186→            # 组图模式：API 返回多张图，需要逐一保存\n   187→            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n   188→            images_count = len(images_list)\n   189→            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n   190→\n   191→            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n   192→            if use_group_mode and images_count < actual_count:\n   193→                logger.warning(\n   194→                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n   195→                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n   196→                )\n   197→\n   198→            if use_group_mode and images_count > 1:\n   199→                results_batch = []\n   200→                success_count = 0\n   201→                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n   202→                total_images = len(images_list)\n   203→\n   204→                for idx, img_data in enumerate(images_list):\n   205→                    # 发送下载进度（每张图开始下载时）\n   206→                    if progress_callback:\n   207→                        try:\n   208→                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n   209→                        except Exception:\n   210→                            pass\n   211→\n   212→                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n   213→                    per_result = {\n   214→                        \"task_id\": per_id,\n   215→                        \"success\": True,\n   216→                        \"type\": \"text_to_image\",\n   217→                        \"prompt\": prompt,\n   218→                        \"image_url\": img_data[\"url\"],\n   219→                        \"parameters\": {\n   220→                            \"size\": size,\n   221→                            \"guidance_scale\": guidance_scale,\n   222→                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   223→                            **(({\"seed\": seed} if seedream_provider is None else {})),\n   224→                            \"response_format\": \"url\",\n   225→                            \"watermark\": False,\n   226→                            \"model\": self._resolve_model_id(\n   227→                                \"doubao-seedream-3-0-t2i-250415\",\n   228→                                \"doubao-seedream-4-0-250828\",\n   229→                                \"doubao-seedream-4-5-251128\",\n   230→                            ),\n   231→                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   232→                            \"sequential_mode\": True,\n   233→                            \"group_index\": idx + 1,\n   234→                            \"group_total\": total_images,\n   235→                        },\n   236→                        \"created_at\": datetime.now().isoformat(),\n   237→                        \"usage\": api_result.get(\"usage\", {}),\n   238→                    }\n   239→\n   240→                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   241→                    if sanitized_refs:\n   242→                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   243→                        per_result[\"reference_assets\"] = sanitized_refs\n   244→\n   245→                    if save_local and per_result.get(\"image_url\"):\n   246→                        local_result = self._save_image_locally(per_result)\n   247→                        per_result.update(local_result)\n   248→                        if not local_result.get('local_save_error'):\n   249→                            success_count += 1\n   250→\n   251→                    results_batch.append(per_result)\n   252→\n   253→                    # 发送下载完成进度\n   254→                    if progress_callback:\n   255→                        try:\n   256→                            progress_callback(idx + 1, total_images, per_result)\n   257→                        except Exception:\n   258→                            pass\n   259→\n   260→                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n   261→                return {\n   262→                    \"batch\": True,\n   263→                    \"results\": results_batch,\n   264→                    \"success_count\": success_count,\n   265→                    \"total_count\": len(results_batch),\n   266→                    \"derived_ids\": group_ids,\n   267→                }\n   268→\n   269→            # 单图模式（默认）\n   270→            result = {\n   271→                \"task_id\": task_id,\n   272→                \"success\": True,\n   273→                \"type\": \"text_to_image\",\n   274→                \"prompt\": prompt,\n   275→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   276→                \"parameters\": {\n   277→                    \"size\": size,\n   278→                    \"guidance_scale\": guidance_scale,\n   279→                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   280→                    **(({\"seed\": seed} if seedream_provider is None else {})),\n   281→                    \"response_format\": \"url\",  # 固定值\n   282→                    \"watermark\": False,  # 固定值\n   283→                    \"model\": self._resolve_model_id(\n   284→                        \"doubao-seedream-3-0-t2i-250415\",\n   285→                        \"doubao-seedream-4-0-250828\",\n   286→                        \"doubao-seedream-4-5-251128\",\n   287→                    ),\n   288→                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   289→                },\n   290→                \"created_at\": datetime.now().isoformat(),\n   291→                \"usage\": api_result.get(\"usage\", {}),\n   292→            }\n   293→\n   294→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   295→            if sanitized_refs:\n   296→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   297→                result[\"reference_assets\"] = sanitized_refs\n   298→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   299→                logger.info(\n   300→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   301→                    len(sanitized_refs),\n   302→                    masked_ids or \"-\",\n   303→                    self._provider_used(),\n   304→                )\n   305→            else:\n   306→                result[\"parameters\"][\"reference_assets\"] = []\n   307→                result[\"reference_assets\"] = []\n   308→\n   309→            # 保存到本地\n   310→            if save_local and result.get(\"image_url\"):\n   311→                local_result = self._save_image_locally(result)\n   312→                result.update(local_result)\n   313→                if local_result.get('local_save_error') and sanitized_refs:\n   314→                    self._cleanup_reference_paths(ref_paths)\n   315→                    result[\"parameters\"][\"reference_assets\"] = []\n   316→                    result[\"reference_assets\"] = []\n   317→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   318→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   319→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   320→\n   321→            logger.success(f\"文生图任务完成: {task_id}\")\n   322→            return result\n   323→\n   324→        except Exception as e:\n   325→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   326→            self._cleanup_reference_paths(ref_paths)\n   327→            return {\n   328→                \"task_id\": task_id,\n   329→                \"success\": False,\n   330→                \"error\": str(e),\n   331→                \"type\": \"text_to_image\"\n   332→            }\n   333→\n   334→    def generate_image_to_image(\n   335→        self,\n   336→        prompt: str,\n   337→        image: str,\n   338→        guidance_scale: float = 5.5,\n   339→        seed: int = -1,\n   340→        save_local: bool = True,\n   341→        reference_images: Optional[List[Any]] = None,\n   342→        generation_id: Optional[str] = None,\n   343→    ) -> Dict[str, Any]:\n   344→        \"\"\"\n   345→        生成图生图并保存到本地\n   346→\n   347→        Args:\n   348→            prompt: 编辑提示词\n   349→            image_path: 原始图像路径（本地路径或URL）\n   350→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   351→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   352→            response_format: 返回格式，\"url\"或\"b64_json\"\n   353→            save_local: 是否保存到本地\n   354→\n   355→        Returns:\n   356→            Dict: 生成结果\n   357→        \n   358→        Note:\n   359→            model、size、watermark参数已固定，不再需要前端控制\n   360→        \"\"\"\n   361→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   362→\n   363→        # 生成唯一ID，优先使用外部传入的generation_id\n   364→        task_id = generation_id or str(uuid.uuid4())\n   365→\n   366→        ref_paths: List[str] = []\n   367→\n   368→        try:\n   369→            # 处理输入图像\n   370→            image_data = self._prepare_input_image(image)\n   371→            if not image_data:\n   372→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   373→\n   374→            # 处理参考图（复制到 references 并准备 API 载荷）\n   375→            ref_summary = self._process_reference_assets(\n   376→                reference_images,\n   377→                max_refs=MAX_REFERENCE_IMAGES,\n   378→                expected_outputs=1,\n   379→            )\n   380→            ref_assets = ref_summary.get('assets', [])\n   381→            ref_paths = list(ref_summary.get('paths', []))\n   382→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   383→            if ref_summary.get('errors'):\n   384→                logger.warning(\n   385→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   386→                )\n   387→            if ref_summary.get('warnings'):\n   388→                for warn in ref_summary['warnings']:\n   389→                    logger.warning(f\"参考图提示: {warn}\")\n   390→\n   391→            # 前置参数校验（不改变流程，仅记录摘要）\n   392→            fb = False\n   393→            reason = \"\"\n   394→            try:\n   395→                norm, fb, reason = validate_and_normalize_i2i(\n   396→                    ImageToImageParams(\n   397→                        prompt=prompt,\n   398→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   399→                        guidance_scale=guidance_scale,\n   400→                        seed=(None if seed == -1 else seed),\n   401→                        reference_images=ref_payloads,\n   402→                    )\n   403→                )\n   404→                logger.info(\n   405→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   406→                )\n   407→                if fb:\n   408→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   409→            except Exception as _e:\n   410→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   411→\n   412→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   413→            api_result = self.client.image_to_image(\n   414→                prompt=prompt,\n   415→                image=image_data,\n   416→                guidance_scale=guidance_scale,\n   417→                seed=seed,\n   418→                reference_images=(ref_payloads or None),\n   419→            )\n   420→\n   421→            # 处理input_image字段，避免在日志中输出大量base64数据\n   422→            input_image_info = \"[图像数据]\"\n   423→            if image:\n   424→                if image.startswith(\"data:image/\"):\n   425→                    # 如果是base64数据，只保留格式信息\n   426→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   427→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   428→                elif image.startswith((\"http://\", \"https://\")):\n   429→                    # 如果是URL，保留URL\n   430→                    input_image_info = image\n   431→                else:\n   432→                    # 如果是文件路径，只保留文件名\n   433→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   434→            \n   435→            result = {\n   436→                \"task_id\": task_id,\n   437→                \"success\": True,\n   438→                \"type\": \"image_to_image\",\n   439→                \"prompt\": prompt,\n   440→                \"input_image\": input_image_info,\n   441→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   442→                \"parameters\": {\n   443→                    \"guidance_scale\": guidance_scale,\n   444→                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   445→                    **({\"seed\": seed} if (self.client.last_provider() or \"\").lower() not in {\"volc_v4\", \"volc_v4_5\", \"volcengine_v4\", \"volcengine_v4_5\"} else {}),\n   446→                    \"response_format\": \"url\",  # 固定值\n   447→                    \"watermark\": False,  # 固定值\n   448→                    \"size\": \"adaptive\",  # 固定值\n   449→                    \"model\": self._resolve_model_id(\n   450→                        \"doubao-seededit-3-0-i2i-250628\",\n   451→                        \"doubao-seedream-4-0-250828\",\n   452→                        \"doubao-seedream-4-5-251128\",\n   453→                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n   454→                },\n   455→                \"created_at\": datetime.now().isoformat(),\n   456→                \"usage\": api_result.get(\"usage\", {}),\n   457→            }\n   458→\n   459→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   460→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   461→            result[\"reference_assets\"] = sanitized_refs\n   462→            if ref_summary.get('errors'):\n   463→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   464→            if ref_summary.get('warnings'):\n   465→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   466→            if fb and reason:\n   467→                result[\"fallback_applied\"] = True\n   468→                result[\"fallback_reason\"] = reason\n   469→\n   470→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   471→            logger.info(\n   472→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   473→                len(sanitized_refs),\n   474→                masked_ids or \"-\",\n   475→                self._provider_used(),\n   476→            )\n   477→\n   478→            # 保存到本地\n   479→            if save_local and result.get(\"image_url\"):\n   480→                local_result = self._save_image_locally(result)\n   481→                result.update(local_result)\n   482→                if local_result.get('local_save_error'):\n   483→                    self._cleanup_reference_paths(ref_paths)\n   484→                    result[\"parameters\"][\"reference_assets\"] = []\n   485→                    result[\"reference_assets\"] = []\n   486→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   487→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   488→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   489→\n   490→            logger.success(f\"图生图任务完成: {task_id}\")\n   491→            return result\n   492→\n   493→        except Exception as e:\n   494→            # 避免在日志中显示可能包含base64数据的异常信息\n   495→            error_msg = str(e)\n   496→            if len(error_msg) > 200:\n   497→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   498→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   499→            self._cleanup_reference_paths(ref_paths)\n   500→            return {\n   501→                \"task_id\": task_id,\n   502→                \"success\": False,\n   503→                \"error\": error_msg,\n   504→                \"type\": \"image_to_image\"\n   505→            }\n   506→\n   507→    def batch_generate_text_to_image(\n   508→        self,\n   509→        prompts: List[str],\n   510→        size: str = \"1024x1024\",\n   511→        guidance_scale: float = 2.5,\n   512→        save_local: bool = True,\n   513→    ) -> List[Dict[str, Any]]:\n   514→        \"\"\"\n   515→        批量生成文生图（顺序执行，保持向后兼容）\n   516→\n   517→        Args:\n   518→            prompts: 提示词列表\n   519→            size: 图像尺寸\n   520→            guidance_scale: 提示词一致性\n   521→            save_local: 是否保存到本地\n   522→\n   523→        Returns:\n   524→            List[Dict]: 生成结果列表\n   525→        \n   526→        Note:\n   527→            水印参数已固定为False，不再需要前端控制\n   528→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   529→        \"\"\"\n   530→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   531→\n   532→        results = []\n   533→        for i, prompt in enumerate(prompts, 1):\n   534→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   535→\n   536→            result = self.generate_text_to_image(\n   537→                prompt=prompt,\n   538→                size=size,\n   539→                guidance_scale=guidance_scale,\n   540→                save_local=save_local,\n   541→                generation_id=None,\n   542→            )\n   543→\n   544→            results.append(result)\n   545→\n   546→        success_count = sum(1 for r in results if r[\"success\"])\n   547→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   548→\n   549→        return results\n   550→\n   551→    def concurrent_generate_text_to_image(\n   552→        self,\n   553→        prompt: str,\n   554→        count: int = 4,\n   555→        size: str = \"1024x1024\",\n   556→        guidance_scale: float = 2.5,\n   557→        seed: int = -1,\n   558→        save_local: bool = True,\n   559→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   560→        max_workers: int = 5,\n   561→        derived_ids: Optional[List[str]] = None,\n   562→        generation_id: Optional[str] = None,\n   563→        model_variant: Optional[str] = None,\n   564→        sequential_mode: bool = False,\n   565→    ) -> Dict[str, Any]:\n   566→        \"\"\"\n   567→        并发生成多张文生图\n   568→\n   569→        Args:\n   570→            prompt: 图像生成提示词\n   571→            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n   572→            size: 图像尺寸\n   573→            guidance_scale: 引导强度\n   574→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   575→            save_local: 是否保存到本地\n   576→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   577→            max_workers: 最大并发数\n   578→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   579→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   580→\n   581→        Returns:\n   582→            Dict: 包含所有任务结果的字典\n   583→        \"\"\"\n   584→        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n   585→        max_allowed = 15 if sequential_mode else 10\n   586→        if count < 1 or count > max_allowed:\n   587→            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n   588→\n   589→        # 组图模式：单次 API 调用返回多张图\n   590→        if sequential_mode:\n   591→            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n   592→            return self.generate_text_to_image(\n   593→                prompt=prompt,\n   594→                size=size,\n   595→                guidance_scale=guidance_scale,\n   596→                seed=seed,\n   597→                save_local=save_local,\n   598→                model_variant=model_variant,\n   599→                generation_id=generation_id,\n   600→                count=count,\n   601→                sequential_mode=True,\n   602→                derived_ids=derived_ids,\n   603→                progress_callback=progress_callback,\n   604→            )\n   605→        \n   606→        if max_workers > count:\n   607→            max_workers = count\n   608→        \n   609→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   610→        \n   611→        # 生成批次ID\n   612→        batch_id = str(uuid.uuid4())\n   613→        start_time = time.time()\n   614→\n   615→        slots = max(1, count)\n   616→        per_ids: List[str] = list(derived_ids or [])\n   617→        if len(per_ids) < slots:\n   618→            base = generation_id or batch_id\n   619→            for idx in range(len(per_ids), slots):\n   620→                per_ids.append(f\"{base}_{idx + 1}\")\n   621→        \n   622→        # 准备任务参数\n   623→        tasks = []\n   624→        for i in range(count):\n   625→            # 为每个任务生成不同的种子（如果seed为-1）\n   626→            task_seed = seed if seed != -1 else None\n   627→            gen_id = per_ids[i] if i < len(per_ids) else None\n   628→            tasks.append({\n   629→                'prompt': prompt,\n   630→                'size': size,\n   631→                'guidance_scale': guidance_scale,\n   632→                'seed': task_seed,\n   633→                'save_local': save_local,\n   634→                'task_index': i + 1,\n   635→                'generation_id': gen_id,\n   636→                'model_variant': model_variant,\n   637→            })\n   638→        \n   639→        # 使用线程池并发执行\n   640→        results = []\n   641→        completed_count = 0\n   642→        \n   643→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   644→            # 提交所有任务\n   645→            future_to_task = {\n   646→                executor.submit(self._execute_single_text_to_image_task, task): task \n   647→                for task in tasks\n   648→            }\n   649→            \n   650→            # 收集结果\n   651→            for future in as_completed(future_to_task):\n   652→                task = future_to_task[future]\n   653→                try:\n   654→                    result = future.result()\n   655→                    result['task_index'] = task['task_index']\n   656→                    result['batch_id'] = batch_id\n   657→                    results.append(result)\n   658→                    \n   659→                    completed_count += 1\n   660→                    \n   661→                    # 调用进度回调\n   662→                    if progress_callback:\n   663→                        try:\n   664→                            progress_callback(completed_count, count, result)\n   665→                        except Exception as e:\n   666→                            logger.warning(f\"进度回调执行失败: {e}\")\n   667→                    \n   668→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   669→                    \n   670→                except Exception as e:\n   671→                    error_result = {\n   672→                        'task_index': task['task_index'],\n   673→                        'batch_id': batch_id,\n   674→                        'success': False,\n   675→                        'error': str(e),\n   676→                        'type': 'text_to_image'\n   677→                    }\n   678→                    results.append(error_result)\n   679→                    completed_count += 1\n   680→                    \n   681→                    if progress_callback:\n   682→                        try:\n   683→                            progress_callback(completed_count, count, error_result)\n   684→                        except Exception as e:\n   685→                            logger.warning(f\"进度回调执行失败: {e}\")\n   686→                    \n   687→                    # 避免在日志中显示可能包含base64数据的异常信息\n   688→                    error_msg = str(e)\n   689→                    if len(error_msg) > 200:\n   690→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   691→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   692→        \n   693→        # 按task_index排序\n   694→        results.sort(key=lambda x: x.get('task_index', 0))\n   695→        \n   696→        # 统计结果\n   697→        success_count = sum(1 for r in results if r.get('success', False))\n   698→        total_time = time.time() - start_time\n   699→        \n   700→        batch_result = {\n   701→            'batch_id': batch_id,\n   702→            'success': True,\n   703→            'prompt': prompt,\n   704→            'total_count': count,\n   705→            'success_count': success_count,\n   706→            'failed_count': count - success_count,\n   707→            'total_time': round(total_time, 2),\n   708→            'average_time': round(total_time / count, 2),\n   709→            'results': results,\n   710→            'parameters': {\n   711→                'size': size,\n   712→                'guidance_scale': guidance_scale,\n   713→                'seed': seed,\n   714→                'max_workers': max_workers\n   715→            },\n   716→            'derived_ids': per_ids,\n   717→            'created_at': datetime.now().isoformat()\n   718→        }\n   719→        \n   720→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   721→        return batch_result\n   722→\n   723→    def concurrent_generate_image_to_image(\n   724→        self,\n   725→        prompt: str,\n   726→        image: str,\n   727→        count: int = 4,\n   728→        guidance_scale: float = 5.5,\n   729→        seed: int = -1,\n   730→        save_local: bool = True,\n   731→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   732→        max_workers: int = 5,\n   733→        derived_ids: Optional[List[str]] = None,\n   734→        generation_id: Optional[str] = None,\n   735→    ) -> Dict[str, Any]:\n   736→        \"\"\"\n   737→        并发生成多张图生图\n   738→\n   739→        Args:\n   740→            prompt: 编辑提示词\n   741→            image: 输入图像路径或URL\n   742→            count: 生成图片数量，默认4张，最多10张\n   743→            guidance_scale: 引导强度\n   744→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   745→            save_local: 是否保存到本地\n   746→            progress_callback: 进度回调函数\n   747→            max_workers: 最大并发数\n   748→\n   749→        Returns:\n   750→            Dict: 包含所有任务结果的字典\n   751→        \"\"\"\n   752→        # 验证参数\n   753→        if count < 1 or count > 10:\n   754→            raise ValueError(\"生成数量必须在1-10之间\")\n   755→        \n   756→        if max_workers > count:\n   757→            max_workers = count\n   758→        \n   759→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   760→        \n   761→        # 生成批次ID\n   762→        batch_id = str(uuid.uuid4())\n   763→        start_time = time.time()\n   764→        \n   765→        slots = max(1, count)\n   766→        per_ids: List[str] = list(derived_ids or [])\n   767→        if len(per_ids) < slots:\n   768→            base = generation_id or batch_id\n   769→            for idx in range(len(per_ids), slots):\n   770→                per_ids.append(f\"{base}_{idx + 1}\")\n   771→        \n   772→        # 准备输入图像\n   773→        image_data = self._prepare_input_image(image)\n   774→        if not image_data:\n   775→            return {\n   776→                'batch_id': batch_id,\n   777→                'success': False,\n   778→                'error': '无法处理输入图像',\n   779→                'type': 'image_to_image'\n   780→            }\n   781→        \n   782→        # 准备任务参数\n   783→        tasks = []\n   784→        for i in range(count):\n   785→            task_seed = seed if seed != -1 else None\n   786→            gen_id = per_ids[i] if i < len(per_ids) else None\n   787→            tasks.append({\n   788→                'prompt': prompt,\n   789→                'image': image_data,\n   790→                'guidance_scale': guidance_scale,\n   791→                'seed': task_seed,\n   792→                'save_local': save_local,\n   793→                'task_index': i + 1,\n   794→                'generation_id': gen_id\n   795→            })\n   796→        \n   797→        # 使用线程池并发执行\n   798→        results = []\n   799→        completed_count = 0\n   800→        \n   801→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   802→            # 提交所有任务\n   803→            future_to_task = {\n   804→                executor.submit(self._execute_single_image_to_image_task, task): task \n   805→                for task in tasks\n   806→            }\n   807→            \n   808→            # 收集结果\n   809→            for future in as_completed(future_to_task):\n   810→                task = future_to_task[future]\n   811→                try:\n   812→                    result = future.result()\n   813→                    result['task_index'] = task['task_index']\n   814→                    result['batch_id'] = batch_id\n   815→                    results.append(result)\n   816→                    \n   817→                    completed_count += 1\n   818→                    \n   819→                    # 调用进度回调\n   820→                    if progress_callback:\n   821→                        try:\n   822→                            progress_callback(completed_count, count, result)\n   823→                        except Exception as e:\n   824→                            logger.warning(f\"进度回调执行失败: {e}\")\n   825→                    \n   826→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   827→                    \n   828→                except Exception as e:\n   829→                    error_result = {\n   830→                        'task_index': task['task_index'],\n   831→                        'batch_id': batch_id,\n   832→                        'success': False,\n   833→                        'error': str(e),\n   834→                        'type': 'image_to_image'\n   835→                    }\n   836→                    results.append(error_result)\n   837→                    completed_count += 1\n   838→                    \n   839→                    if progress_callback:\n   840→                        try:\n   841→                            progress_callback(completed_count, count, error_result)\n   842→                        except Exception as e:\n   843→                            logger.warning(f\"进度回调执行失败: {e}\")\n   844→                    \n   845→                    # 避免在日志中显示可能包含base64数据的异常信息\n   846→                    error_msg = str(e)\n   847→                    if len(error_msg) > 200:\n   848→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   849→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   850→        \n   851→        # 按task_index排序\n   852→        results.sort(key=lambda x: x.get('task_index', 0))\n   853→        \n   854→        # 统计结果\n   855→        success_count = sum(1 for r in results if r.get('success', False))\n   856→        total_time = time.time() - start_time\n   857→        \n   858→        # 处理input_image字段，避免在日志中输出大量base64数据\n   859→        input_image_info = \"[图像数据]\"\n   860→        if image:\n   861→            if image.startswith(\"data:image/\"):\n   862→                # 如果是base64数据，只保留格式信息\n   863→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   864→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   865→            elif image.startswith((\"http://\", \"https://\")):\n   866→                # 如果是URL，保留URL\n   867→                input_image_info = image\n   868→            else:\n   869→                # 如果是文件路径，只保留文件名\n   870→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   871→        \n   872→        batch_result = {\n   873→            'batch_id': batch_id,\n   874→            'success': True,\n   875→            'prompt': prompt,\n   876→            'input_image': input_image_info,\n   877→            'total_count': count,\n   878→            'success_count': success_count,\n   879→            'failed_count': count - success_count,\n   880→            'total_time': round(total_time, 2),\n   881→            'average_time': round(total_time / count, 2),\n   882→            'results': results,\n   883→            'parameters': {\n   884→                'guidance_scale': guidance_scale,\n   885→                'seed': seed,\n   886→                'max_workers': max_workers\n   887→            },\n   888→            'derived_ids': per_ids,\n   889→            'created_at': datetime.now().isoformat()\n   890→        }\n   891→        \n   892→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   893→        return batch_result\n   894→\n   895→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   896→        \"\"\"\n   897→        执行单个文生图任务\n   898→        \n   899→        Args:\n   900→            task: 任务参数字典\n   901→            \n   902→        Returns:\n   903→            Dict: 任务执行结果\n   904→        \"\"\"\n   905→        return self.generate_text_to_image(\n   906→            prompt=task['prompt'],\n   907→            size=task['size'],\n   908→            guidance_scale=task['guidance_scale'],\n   909→            seed=task['seed'],\n   910→            save_local=task['save_local'],\n   911→            generation_id=task.get('generation_id'),\n   912→            model_variant=task.get('model_variant'),\n   913→        )\n   914→    \n   915→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   916→        \"\"\"\n   917→        执行单个图生图任务\n   918→        \n   919→        Args:\n   920→            task: 任务参数字典\n   921→            \n   922→        Returns:\n   923→            Dict: 任务执行结果\n   924→        \"\"\"\n   925→        # 生成唯一ID，优先使用外部传入的generation_id\n   926→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   927→        \n   928→        try:\n   929→            # 直接使用已经处理好的图片数据，避免重复处理\n   930→            image_data = task['image']\n   931→            \n   932→            # 调用API生成图像\n   933→            api_result = self.client.image_to_image(\n   934→                prompt=task['prompt'], \n   935→                image=image_data, \n   936→                guidance_scale=task['guidance_scale'], \n   937→                seed=task['seed']\n   938→            )\n   939→            \n   940→            result = {\n   941→                \"task_id\": task_id,\n   942→                \"success\": True,\n   943→                \"type\": \"image_to_image\",\n   944→                \"prompt\": task['prompt'],\n   945→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   946→                \"parameters\": {\n   947→                    \"guidance_scale\": task['guidance_scale'], \n   948→                    \"seed\": task['seed'], \n   949→                    \"response_format\": \"url\",\n   950→                    \"watermark\": False,\n   951→                    \"size\": \"adaptive\",\n   952→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   953→                },\n   954→                \"created_at\": datetime.now().isoformat(),\n   955→                \"usage\": api_result.get(\"usage\", {}),\n   956→            }\n   957→            \n   958→            # 保存到本地\n   959→            if task['save_local'] and result.get(\"image_url\"):\n   960→                local_result = self._save_image_locally(result)\n   961→                result.update(local_result)\n   962→            \n   963→            return result\n   964→            \n   965→        except Exception as e:\n   966→            # 避免在日志中显示可能包含base64数据的异常信息\n   967→            error_msg = str(e)\n   968→            if len(error_msg) > 200:\n   969→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   970→            return {\n   971→                \"task_id\": task_id,\n   972→                \"success\": False,\n   973→                \"error\": error_msg,\n   974→                \"type\": \"image_to_image\"\n   975→            }\n   976→\n   977→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   978→        \"\"\"\n   979→        保存图像到本地并记录元数据\n   980→\n   981→        Args:\n   982→            result: API生成结果\n   983→\n   984→        Returns:\n   985→            Dict: 包含本地文件信息的字典\n   986→        \"\"\"\n   987→        try:\n   988→            # 下载图像\n   989→            image_url = result[\"image_url\"]\n   990→            response = safe_requests_get(image_url, timeout=30)\n   991→\n   992→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   993→            from io import BytesIO\n   994→            real_w, real_h = None, None\n   995→            try:\n   996→                with Image.open(BytesIO(response.content)) as img:\n   997→                    real_w, real_h = int(img.width), int(img.height)\n   998→            except Exception as _e:\n   999→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n  1000→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n  1001→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n  1002→\n  1003→            # 组装元数据（适配UnifiedStorageManager的格式）\n  1004→            params = result.get(\"parameters\", {}) or {}\n  1005→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n  1006→            try:\n  1007→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n  1008→                    from math import gcd\n  1009→                    g = gcd(real_w, real_h)\n  1010→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n  1011→            except Exception:\n  1012→                pass\n  1013→\n  1014→            metadata = {\n  1015→                'generation_id': result.get(\"task_id\", \"\"),\n  1016→                'prompt': result.get(\"prompt\", \"\"),\n  1017→                'parameters': params,\n  1018→                'model': params.get(\"model\", \"seedream\"),\n  1019→                'width': real_w,\n  1020→                'height': real_h,\n  1021→                'generation_time': result.get(\"generation_time\", 0),\n  1022→                'batch_id': result.get(\"batch_id\", \"\"),\n  1023→                'status': 'completed'\n  1024→            }\n  1025→            \n  1026→            # 使用统一存储管理器保存文件\n  1027→            save_result = self.storage_manager.save_content_file(\n  1028→                content_type='images',\n  1029→                file_data=response.content,\n  1030→                url=image_url,\n  1031→                metadata=metadata\n  1032→            )\n  1033→\n  1034→            # 获取图像信息（再次确认像素尺寸）\n  1035→            image_info = self._get_image_info(Path(save_result['local_path']))\n  1036→            file_size = Path(save_result['local_path']).stat().st_size\n  1037→\n  1038→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n  1039→\n  1040→            result_obj = {\n  1041→                \"local_path\": save_result['local_path'],\n  1042→                \"filename\": Path(save_result['local_path']).name,\n  1043→                \"file_size\": file_size,\n  1044→                \"image_info\": image_info,\n  1045→                \"file_path\": save_result['local_path'],  # 保持兼容性\n  1046→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n  1047→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n  1048→                \"file_id\": save_result.get('file_id'),\n  1049→                \"relative_path\": save_result.get('relative_path'),\n  1050→            }\n  1051→            try:\n  1052→                w = image_info.get('width') if isinstance(image_info, dict) else None\n  1053→                h = image_info.get('height') if isinstance(image_info, dict) else None\n  1054→                logger.info(\n  1055→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n  1056→                )\n  1057→            except Exception:\n  1058→                pass\n  1059→\n  1060→            # 体验版本地图片水印（使用统一水印服务）\n  1061→            if should_add_watermark():\n  1062→                try:\n  1063→                    from edition.watermark_service import WatermarkService\n  1064→\n  1065→                    watermark_text = get_watermark_text() or \"PIGEON\"\n  1066→                    try:\n  1067→                        opacity = get_watermark_opacity()\n  1068→                    except Exception:\n  1069→                        opacity = 0.3\n  1070→                    opacity = max(0.0, min(opacity, 1.0))\n  1071→\n  1072→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n  1073→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n  1074→                    if watermark_applied:\n  1075→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n  1076→                        result_obj[\"watermark_applied\"] = True\n  1077→                    else:\n  1078→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n  1079→                        result_obj[\"watermark_applied\"] = False\n  1080→                except Exception as e:\n  1081→                    logger.warning(f\"添加图片水印时出错: {e}\")\n  1082→                    result_obj[\"watermark_applied\"] = False\n  1083→\n  1084→            return result_obj\n  1085→\n  1086→        except Exception as e:\n  1087→            logger.error(f\"保存图像到本地失败: {e}\")\n  1088→            try:\n  1089→                logger.info(\"摘要|operation=save_image status=failed\")\n  1090→            except Exception:\n  1091→                pass\n  1092→            return {\"local_save_error\": str(e)}\n  1093→\n  1094→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1095→        checksum = hashlib.sha1(file_data).hexdigest()\n  1096→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1097→        return f\"ref_{ts}_{checksum[:8]}\"\n  1098→\n  1099→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1100→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1101→        source_meta: Dict[str, Any] = {}\n  1102→        raw = ref\n  1103→        if isinstance(ref, dict):\n  1104→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1105→                if ref.get(key) is not None:\n  1106→                    source_meta[key] = ref.get(key)\n  1107→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1108→        if raw is None:\n  1109→            return None\n  1110→\n  1111→        extension = source_meta.get('extension')\n  1112→        data = None\n  1113→        source_repr = source_meta.get('source')\n  1114→\n  1115→        try:\n  1116→            if isinstance(raw, bytes):\n  1117→                data = raw\n  1118→            elif isinstance(raw, str):\n  1119→                stripped = raw.strip()\n  1120→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1121→                    header, payload = stripped.split(';base64,', 1)\n  1122→                    mime_part = header[5:]\n  1123→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n  1124→                    data = base64.b64decode(payload)\n  1125→                    source_repr = source_repr or mime_part\n  1126→                    source_meta.setdefault('type', 'image')\n  1127→                elif stripped.startswith(('http://', 'https://')):\n  1128→                    resp = safe_requests_get(stripped, timeout=15)\n  1129→                    data = resp.content\n  1130→                    parsed = urlparse(stripped)\n  1131→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1132→                    source_repr = source_repr or stripped\n  1133→                    source_meta.setdefault('source_url', stripped)\n  1134→                else:\n  1135→                    path = Path(stripped)\n  1136→                    if not path.exists():\n  1137→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1138→                        return None\n  1139→                    data = path.read_bytes()\n  1140→                    extension = extension or path.suffix or '.png'\n  1141→                    source_repr = source_repr or path.name\n  1142→                    source_meta.setdefault('source_path', str(path))\n  1143→            else:\n  1144→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1145→                return None\n  1146→        except Exception as exc:\n  1147→            logger.warning(f\"加载参考图失败: {exc}\")\n  1148→            return None\n  1149→\n  1150→        if data is None:\n  1151→            return None\n  1152→\n  1153→        width = source_meta.get('width')\n  1154→        height = source_meta.get('height')\n  1155→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1156→            try:\n  1157→                from io import BytesIO\n  1158→\n  1159→                with Image.open(BytesIO(data)) as img:\n  1160→                    width = img.width\n  1161→                    height = img.height\n  1162→            except Exception:\n  1163→                pass\n  1164→\n  1165→        source_meta['width'] = width\n  1166→        source_meta['height'] = height\n  1167→        source_meta.setdefault('type', 'image')\n  1168→        source_meta['source'] = source_repr or source_meta.get('source')\n  1169→\n  1170→        return data, extension, source_meta\n  1171→\n  1172→    def _process_reference_assets(\n  1173→        self,\n  1174→        references: Optional[List[Any]],\n  1175→        *,\n  1176→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1177→        expected_outputs: int = 1,\n  1178→    ) -> Dict[str, Any]:\n  1179→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1180→        stored: List[Dict[str, Any]] = []\n  1181→        absolute_paths: List[str] = []\n  1182→        errors: List[str] = []\n  1183→        warnings: List[str] = []\n  1184→\n  1185→        if not references:\n  1186→            return {\n  1187→                'assets': stored,\n  1188→                'paths': absolute_paths,\n  1189→                'errors': errors,\n  1190→                'warnings': warnings,\n  1191→            }\n  1192→\n  1193→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1194→            warnings.append(\n  1195→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1196→            )\n  1197→            references = references[:max_refs]\n  1198→\n  1199→        for order, item in enumerate(references):\n  1200→            load_result = self._load_reference_source(item)\n  1201→            if not load_result:\n  1202→                errors.append(f\"ref[{order}] 加载失败\")\n  1203→                continue\n  1204→\n  1205→            file_data, extension, meta = load_result\n  1206→            meta.setdefault('order', order)\n  1207→            meta.setdefault('kind', meta.get('type', 'image'))\n  1208→\n  1209→            try:\n  1210→                asset_id = self._generate_reference_asset_id(file_data)\n  1211→                record = self.storage_manager.save_reference_asset(\n  1212→                    'images',\n  1213→                    file_data,\n  1214→                    asset_id=asset_id,\n  1215→                    extension=extension,\n  1216→                    metadata=meta,\n  1217→                )\n  1218→                try:\n  1219→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1220→                except Exception:\n  1221→                    record['_payload_b64'] = None\n  1222→                record['_source_meta'] = meta\n  1223→                stored.append(record)\n  1224→                if record.get('absolute_path'):\n  1225→                    absolute_paths.append(record['absolute_path'])\n  1226→            except Exception as exc:\n  1227→                logger.warning(f\"保存参考图失败: {exc}\")\n  1228→                errors.append(f\"ref[{order}] 保存失败\")\n  1229→\n  1230→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1231→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1232→            if len(stored) > allowed:\n  1233→                warnings.append(\n  1234→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1235→                )\n  1236→                stored = stored[:allowed]\n  1237→                absolute_paths = absolute_paths[:allowed]\n  1238→\n  1239→        return {\n  1240→            'assets': stored,\n  1241→            'paths': absolute_paths,\n  1242→            'errors': errors,\n  1243→            'warnings': warnings,\n  1244→        }\n  1245→\n  1246→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1247→        payloads: List[str] = []\n  1248→        for asset in assets or []:\n  1249→            payload = asset.get('_payload_b64')\n  1250→            if not payload:\n  1251→                continue\n  1252→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1253→            mime = 'image/png'\n  1254→            try:\n  1255→                if path_hint:\n  1256→                    suffix = Path(path_hint).suffix.lower()\n  1257→                    if suffix in {'.jpg', '.jpeg'}:\n  1258→                        mime = 'image/jpeg'\n  1259→                    elif suffix == '.webp':\n  1260→                        mime = 'image/webp'\n  1261→                    elif suffix == '.bmp':\n  1262→                        mime = 'image/bmp'\n  1263→                    elif suffix == '.gif':\n  1264→                        mime = 'image/gif'\n  1265→            except Exception:\n  1266→                pass\n  1267→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1268→        return payloads\n  1269→\n  1270→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1271→        provider = (self.client.last_provider() or \"\").lower()\n  1272→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1273→            return v4_5_model or v4_model\n  1274→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1275→            return v4_model\n  1276→        return default_model\n  1277→\n  1278→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1279→        cleaned: List[Dict[str, Any]] = []\n  1280→        for rec in assets or []:\n  1281→            rec.pop('_payload_b64', None)\n  1282→            rec.pop('_source_meta', None)\n  1283→            rec.pop('absolute_path', None)\n  1284→            cleaned.append({\n  1285→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1286→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1287→                'type': rec.get('type'),\n  1288→                'kind': rec.get('kind'),\n  1289→                'source': rec.get('source'),\n  1290→                'order': rec.get('order'),\n  1291→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1292→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1293→                'width': rec.get('width'),\n  1294→                'height': rec.get('height'),\n  1295→                'created_at': rec.get('created_at'),\n  1296→            })\n  1297→        return cleaned\n  1298→\n  1299→    @staticmethod\n  1300→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1301→        masked: List[str] = []\n  1302→        for rec in assets or []:\n  1303→            rid = rec.get('id') or ''\n  1304→            if not rid:\n  1305→                continue\n  1306→            masked.append(f\"{rid[:6]}***\")\n  1307→        return \",\".join(masked)\n  1308→\n  1309→    @staticmethod\n  1310→    def _provider_hint() -> str:\n  1311→        try:\n  1312→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1313→        except Exception:\n  1314→            return \"unknown\"\n  1315→\n  1316→    def _provider_used(self) -> str:\n  1317→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1318→        if provider:\n  1319→            return provider\n  1320→        return self._provider_hint()\n  1321→\n  1322→    @staticmethod\n  1323→    def _cleanup_reference_paths(paths: List[str]):\n  1324→        for path in paths or []:\n  1325→            try:\n  1326→                if path and Path(path).exists():\n  1327→                    Path(path).unlink(missing_ok=True)\n  1328→            except Exception as exc:\n  1329→                logger.debug(f\"参考图清理失败: {exc}\")\n  1330→\n  1331→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1332→        \"\"\"\n  1333→        准备输入图像，支持本地文件和URL\n  1334→        \n  1335→        Args:\n  1336→            image_path: 图像路径（本地路径或URL）\n  1337→            \n  1338→        Returns:\n  1339→            str: 图像URL、base64数据或None\n  1340→        \"\"\"\n  1341→        try:\n  1342→            # 如果是URL，直接返回\n  1343→            if image_path.startswith((\"http://\", \"https://\")):\n  1344→                return image_path\n  1345→\n  1346→            # 如果是本地文件，转换为Base64\n  1347→            local_path = Path(image_path)\n  1348→            if local_path.exists():\n  1349→                with open(local_path, \"rb\") as f:\n  1350→                    image_data = f.read()\n  1351→\n  1352→                # 检测图像格式\n  1353→                image = Image.open(local_path)\n  1354→                format_name = image.format.lower()\n  1355→\n  1356→                # 转换为Base64\n  1357→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1358→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1359→\n  1360→            logger.error(f\"图像文件不存在: {image_path}\")\n  1361→            return None\n  1362→\n  1363→        except Exception as e:\n  1364→            logger.error(f\"处理输入图像失败: {e}\")\n  1365→            return None\n  1366→\n  1367→    def _extract_width_from_size(self, size: str) -> int:\n  1368→        \"\"\"\n  1369→        从尺寸字符串中提取宽度\n  1370→        \n  1371→        Args:\n  1372→            size: 尺寸字符串，如 \"1024x1024\"\n  1373→            \n  1374→        Returns:\n  1375→            int: 宽度值\n  1376→        \"\"\"\n  1377→        try:\n  1378→            return int(size.split('x')[0])\n  1379→        except (ValueError, IndexError):\n  1380→            return 1024  # 默认值\n  1381→    \n  1382→    def _extract_height_from_size(self, size: str) -> int:\n  1383→        \"\"\"\n  1384→        从尺寸字符串中提取高度\n  1385→        \n  1386→        Args:\n  1387→            size: 尺寸字符串，如 \"1024x1024\"\n  1388→            \n  1389→        Returns:\n  1390→            int: 高度值\n  1391→        \"\"\"\n  1392→        try:\n  1393→            return int(size.split('x')[1])\n  1394→        except (ValueError, IndexError):\n  1395→            return 1024  # 默认值\n  1396→\n  1397→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1398→        \"\"\"\n  1399→        获取图像信息\n  1400→\n  1401→        Args:\n  1402→            image_path: 图像文件路径\n  1403→\n  1404→        Returns:\n  1405→            Dict: 图像信息\n  1406→        \"\"\"\n  1407→        try:\n  1408→            with Image.open(image_path) as img:\n  1409→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1410→        except Exception as e:\n  1411→            logger.error(f\"获取图像信息失败: {e}\")\n  1412→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1413→\n  1414→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1415→        \"\"\"\n  1416→        获取图像生成历史记录\n  1417→\n  1418→        Args:\n  1419→            limit: 返回记录数量限制\n  1420→\n  1421→        Returns:\n  1422→            List[Dict]: 历史记录列表\n  1423→        \"\"\"\n  1424→        return self.storage_manager.load_history('images', limit=limit)\n  1425→\n  1426→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1427→        \"\"\"\n  1428→        根据提示词关键字搜索历史记录\n  1429→\n  1430→        Args:\n  1431→            keyword: 搜索关键字\n  1432→\n  1433→        Returns:\n  1434→            List[Dict]: 匹配的记录列表\n  1435→        \"\"\"\n  1436→        # 获取所有历史记录并在内存中过滤\n  1437→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1438→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1439→\n  1440→    def get_statistics(self) -> Dict[str, Any]:\n  1441→        \"\"\"\n  1442→        获取生成统计信息\n  1443→\n  1444→        Returns:\n  1445→            Dict: 统计信息\n  1446→        \"\"\"\n  1447→        try:\n  1448→            # 使用统一存储管理器获取存储统计\n  1449→            storage_stats = self.storage_manager.get_storage_stats()\n  1450→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1451→            \n  1452→            # 获取历史记录进行详细统计\n  1453→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1454→            \n  1455→            if not all_records:\n  1456→                return {\n  1457→                    \"total_images\": 0,\n  1458→                    \"text_to_image_count\": 0,\n  1459→                    \"image_to_image_count\": 0,\n  1460→                    \"total_file_size\": 0,\n  1461→                    \"average_file_size\": 0,\n  1462→                    \"most_common_size\": \"unknown\"\n  1463→                }\n  1464→\n  1465→            # 统计不同类型的图片数量\n  1466→            text_to_image_count = 0\n  1467→            image_to_image_count = 0\n  1468→            total_file_size = 0\n  1469→            sizes = []\n  1470→            \n  1471→            for record in all_records:\n  1472→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1473→                if 'input_image' in record.get('parameters', {}):\n  1474→                    image_to_image_count += 1\n  1475→                else:\n  1476→                    text_to_image_count += 1\n  1477→                \n  1478→                # 计算文件大小\n  1479→                file_size = record.get('file_size', 0)\n  1480→                if isinstance(file_size, str) and file_size.isdigit():\n  1481→                    file_size = int(file_size)\n  1482→                elif not isinstance(file_size, (int, float)):\n  1483→                    file_size = 0\n  1484→                total_file_size += file_size\n  1485→                \n  1486→                # 收集尺寸信息\n  1487→                width = record.get('width', 0)\n  1488→                height = record.get('height', 0)\n  1489→                if width and height:\n  1490→                    sizes.append(f\"{width}x{height}\")\n  1491→\n  1492→            stats = {\n  1493→                \"total_images\": len(all_records),\n  1494→                \"text_to_image_count\": text_to_image_count,\n  1495→                \"image_to_image_count\": image_to_image_count,\n  1496→                \"total_file_size\": total_file_size,\n  1497→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1498→                \"most_common_size\": \"unknown\",\n  1499→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1500→            }\n  1501→\n  1502→            # 最常用的尺寸\n  1503→            if sizes:\n  1504→                from collections import Counter\n  1505→                size_counts = Counter(sizes)\n  1506→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1507→\n  1508→            return stats\n  1509→\n  1510→        except Exception as e:\n  1511→            logger.error(f\"获取统计信息失败: {e}\")\n  1512→            return {\n  1513→                \"total_images\": 0,\n  1514→                \"text_to_image_count\": 0,\n  1515→                \"image_to_image_count\": 0,\n  1516→                \"total_file_size\": 0,\n  1517→                \"average_file_size\": 0,\n  1518→                \"most_common_size\": \"unknown\"\n  1519→            }\n  1520→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8766a408-9103-4b70-a810-103bad2746ac","timestamp":"2026-01-09T03:40:39.689Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config.unified_config import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        storage_dir = get_storage_dir()\n        if not storage_dir:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        self.storage_manager = get_v2_storage_manager(storage_dir)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n        count: int = 1,\n        sequential_mode: bool = False,\n        derived_ids: Optional[List[str]] = None,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            count: 生成图片数量（组图模式下生效）\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n            derived_ids: 组图生成的ID列表（用于关联）\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n\n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n\n        # 根据 model_variant 选择 provider（并发安全：不写 env）\n        seedream_provider: Optional[str] = None\n        try:\n            mv = (model_variant or \"\").strip().lower()\n            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n                seedream_provider = \"volc_v4\"\n            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n                seedream_provider = \"volc_v4_5\"\n            elif mv.startswith(\"volc_\"):\n                seedream_provider = mv\n        except Exception:\n            seedream_provider = None\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            actual_count = max(1, count)\n            use_group_mode = bool(sequential_mode and actual_count > 1)\n\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n                n=actual_count if use_group_mode else 1,\n                sequential_mode=sequential_mode,\n                seedream_provider=seedream_provider,\n            )\n\n            # 组图模式：API 返回多张图，需要逐一保存\n            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n            images_count = len(images_list)\n            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n\n            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n            if use_group_mode and images_count < actual_count:\n                logger.warning(\n                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n                )\n\n            if use_group_mode and images_count > 1:\n                results_batch = []\n                success_count = 0\n                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n                total_images = len(images_list)\n\n                for idx, img_data in enumerate(images_list):\n                    # 发送下载进度（每张图开始下载时）\n                    if progress_callback:\n                        try:\n                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n                        except Exception:\n                            pass\n\n                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n                    per_result = {\n                        \"task_id\": per_id,\n                        \"success\": True,\n                        \"type\": \"text_to_image\",\n                        \"prompt\": prompt,\n                        \"image_url\": img_data[\"url\"],\n                        \"parameters\": {\n                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                            **(({\"seed\": seed} if seedream_provider is None else {})),\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,\n                        },\n                        \"created_at\": datetime.now().isoformat(),\n                        \"usage\": api_result.get(\"usage\", {}),\n                    }\n\n                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n                    if sanitized_refs:\n                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                        per_result[\"reference_assets\"] = sanitized_refs\n\n                    if save_local and per_result.get(\"image_url\"):\n                        local_result = self._save_image_locally(per_result)\n                        per_result.update(local_result)\n                        if not local_result.get('local_save_error'):\n                            success_count += 1\n\n                    results_batch.append(per_result)\n\n                    # 发送下载完成进度\n                    if progress_callback:\n                        try:\n                            progress_callback(idx + 1, total_images, per_result)\n                        except Exception:\n                            pass\n\n                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n                return {\n                    \"batch\": True,\n                    \"results\": results_batch,\n                    \"success_count\": success_count,\n                    \"total_count\": len(results_batch),\n                    \"derived_ids\": group_ids,\n                }\n\n            # 单图模式（默认）\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                    **(({\"seed\": seed} if seedream_provider is None else {})),\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    ),\n                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale,\n                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                    **({\"seed\": seed} if (self.client.last_provider() or \"\").lower() not in {\"volc_v4\", \"volc_v4_5\", \"volcengine_v4\", \"volcengine_v4_5\"} else {}),\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        sequential_mode: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n        max_allowed = 15 if sequential_mode else 10\n        if count < 1 or count > max_allowed:\n            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n\n        # 组图模式：单次 API 调用返回多张图\n        if sequential_mode:\n            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n            return self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=save_local,\n                model_variant=model_variant,\n                generation_id=generation_id,\n                count=count,\n                sequential_mode=True,\n                derived_ids=derived_ids,\n                progress_callback=progress_callback,\n            )\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1520,"startLine":1,"totalLines":1520}},"sourceToolAssistantUUID":"cce2dc8b-6de0-4a83-a6e3-a913a71c3e91"}
{"parentUuid":"58957578-7607-406a-9e60-9bcc1d4effde","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NgofGfG7gdtVDPPz5iAWb8","type":"tool_result","content":"     1→\"\"\"Image mode widget implementation (extracted in Phase 4.3c).\"\"\"\n     2→\n     3→import os\n     4→from datetime import datetime\n     5→from pathlib import Path\n     6→from typing import Any, Dict, List, Optional\n     7→\n     8→from PySide6.QtCore import Qt, QTimer, QSize, Signal\n     9→from PySide6.QtGui import QIcon, QPixmap, QKeySequence, QColor\n    10→from PySide6.QtWidgets import (\n    11→    QGraphicsDropShadowEffect,\n    12→    QApplication,\n    13→    QFileDialog,\n    14→    QHBoxLayout,\n    15→    QLabel,\n    16→    QMessageBox,\n    17→    QProgressBar,\n    18→    QPushButton,\n    19→    QSizePolicy,\n    20→    QSplitter,\n    21→    QStackedLayout,\n    22→    QTextEdit,\n    23→    QVBoxLayout,\n    24→    QWidget,\n    25→    QFrame,\n    26→)\n    27→from PySide6.QtGui import QShortcut\n    28→\n    29→from components.dialogs import ImageDetailDialog\n    30→from components.forms import SchemaFormRenderer\n    31→from components.adapters.history_adapter import HistoryViewAdapter\n    32→from components.widgets import ReferenceAssetsPanel, IntegratedReferencePanel\n    33→from config.sources.generation_config import IMAGE_GENERATION_DEFAULTS\n    34→from modules.provider import get_ui_schema\n    35→from modules.repository.manager import RepositoryManager\n    36→from services.generation_task_manager import GenerationTaskManager\n    37→from loguru import logger\n    38→from utils.reference_display import (\n    39→    _evaluate_dependency_rules,\n    40→    _mask_reference_ids,\n    41→)\n    42→from utils.task_runner import task_runner\n    43→from utils.style_system import unified_style_system\n    44→\n    45→__all__ = [\"ImageModeWidgetImpl\"]\n    46→\n    47→\n    48→class ImageModeWidgetImpl(QWidget):\n    49→    \"\"\"图片生成模式页面\"\"\"\n    50→\n    51→    history_initial_loaded = Signal(object)\n    52→    history_next_loaded = Signal(object)\n    53→    history_load_failed = Signal(str)\n    54→    \n    55→    def __init__(self, parent=None):\n    56→        super().__init__(parent)\n    57→        self._task_manager = GenerationTaskManager.instance()\n    58→        self._task_manager.task_started.connect(self._on_task_started)\n    59→        self._task_manager.task_progress.connect(self._on_task_progress)\n    60→        self._task_manager.task_completed.connect(self._on_task_completed)\n    61→        self._task_manager.task_failed.connect(self._on_task_failed)\n    62→        self._task_manager.queue_updated.connect(self._on_queue_updated)\n    63→        self._task_placeholder_cards: Dict[str, Any] = {}\n    64→        self._task_placeholder_index: Dict[str, List[str]] = {}\n    65→\n    66→        # 存储路径配置管理\n    67→        self._current_storage_path = None\n    68→        self._storage_manager = None\n    69→        self._config_check_timer = None\n    70→        self._repository_manager = None\n    71→        \n    72→        # 懒加载相关变量\n    73→        self.current_start_index = 0\n    74→        self.batch_size = 40\n    75→        self.loaded_items = []\n    76→        self.MAX_ITEMS_IN_MEMORY = 120\n    77→        self.is_loading = False\n    78→        \n    79→        # 历史记录去重加载状态（修复滚动重复加载问题）\n    80→        self._is_loading_history = False  # 历史记录专用加载标志\n    81→        self._loaded_record_ids = set()   # 已加载记录ID集合\n    82→        self._history_offset = 0          # 历史记录偏移量\n    83→        self._history_has_more = True     # 是否还有更多历史记录\n    84→        \n    85→        self.video_next_cursor = None  # 游标分页：视频下一页光标\n    86→        self.next_cursor = None  # 游标分页：下一页光标（图片）\n    87→        self._scroll_listener_bound = False\n    88→        self.image_schema_form: Optional[SchemaFormRenderer] = None\n    89→        self._image_schema_variant: Optional[str] = None\n    90→        self._image_schema: Optional[Any] = None\n    91→        self._image_form_cache: Dict[str, Any] = {}\n    92→        self.reference_panel: Optional[IntegratedReferencePanel] = None\n    93→        self._image_reference_auto_field: Optional[str] = None\n    94→        self._image_reference_visibility_rules: List[Dict[str, Any]] = []\n    95→        self._image_reference_config: Dict[str, Any] = {}\n    96→        self._last_reference_assets: List[Dict[str, Any]] = []\n    97→\n    98→        from components.modes.shared.controllers.parameter_controller import ImageParameterController\n    99→\n   100→        self._parameter_controller = ImageParameterController(self)\n   101→\n   102→        from components.modes.shared.controllers.generation_controller import ImageGenerationController\n   103→\n   104→        self._generation_controller = ImageGenerationController(self)\n   105→\n   106→        self.history_initial_loaded.connect(self._on_history_initial_loaded)\n   107→        self.history_next_loaded.connect(self._on_history_next_loaded)\n   108→        self.history_load_failed.connect(self._on_history_load_failed)\n   109→\n   110→        self.setup_ui()\n   111→\n   112→        # 初始化历史记录视图\n   113→        # Note: The existing code uses `self.image_history_view` which is initialized later in `setup_ui`.\n   114→        # Assuming the instruction intends to connect to the `image_history_view` instance.\n   115→        # The `history_view` variable from the instruction is not used elsewhere in the provided context.\n   116→        # We will connect to `self.image_history_view` which is the actual history view widget.\n   117→        # The `set_item_click_callback` and `history_initial_loaded.emit` lines from the instruction\n   118→        # are also handled by `self.image_history_view` in the existing code.\n   119→        # Therefore, only the `addToReferenceRequested` connection is added.\n   120→        # 连接右键添加到参考图信号\n   121→        # This connection will be made after `self.image_history_view` is initialized in `setup_ui`.\n   122→        # The actual connection will be placed after `self.image_history_view` is assigned.\n   123→        \n   124→        # 初始化存储管理器\n   125→        self._update_storage_manager()\n   126→\n   127→        # 初始化Repository管理器\n   128→        self._update_repository_manager()\n   129→        \n   130→        # 初始化瀑布流增量加载功能\n   131→        self._init_history_incremental_loading()\n   132→        \n   133→        # 安全地加载历史图片（异步）\n   134→        try:\n   135→            if self.use_virtual_image_view and hasattr(self, \"image_history_view\"):\n   136→                self.image_history_view.load_initial(page_size=self.batch_size)\n   137→            else:\n   138→                self.load_history_images_async()\n   139→        except Exception as e:\n   140→            logger.error(f\"初始化时加载历史图片失败: {str(e)}\")\n   141→            \n   142→        # 设置剪贴板粘贴快捷键\n   143→        self.setup_clipboard_paste()\n   144→        \n   145→        # 设置拖拽功能\n   146→        self.setup_drag_drop()\n   147→        \n   148→        # 启动配置监听定时器\n   149→        self._setup_config_monitoring()\n   150→        \n   151→        # Subscribe to theme changes\n   152→        unified_style_system.styleChanged.connect(self._update_styles)\n   153→\n   154→    def _update_styles(self):\n   155→        \"\"\"Update dynamic styles when theme changes\"\"\"\n   156→        colors = unified_style_system.get_colors()\n   157→        \n   158→        # 1. Upload Button Style\n   159→        if hasattr(self, 'upload_display') and self.upload_display:\n   160→            try:\n   161→                border_strong = colors.get('palette.neutral.border_strong') or colors.get('border')\n   162→                text_secondary = (\n   163→                    colors.get('palette.text.secondary')\n   164→                    or colors.get('text_secondary')\n   165→                    or colors.get('palette.text.primary')\n   166→                    or colors.get('text')\n   167→                )\n   168→                brand_main = colors.get('palette.brand.main') or colors.get('primary')\n   169→                self.upload_display.setStyleSheet(f\"\"\"\n   170→                    QPushButton#imageUploadButton {{\n   171→                        background-color: transparent;\n   172→                        border: 1px dashed {border_strong};\n   173→                        border-radius: 6px;\n   174→                        color: {text_secondary};\n   175→                        font-size: 20px;\n   176→                        padding: 0px;\n   177→                        margin: 0px;\n   178→                    }}\n   179→                    QPushButton#imageUploadButton:hover {{\n   180→                        border-color: {brand_main};\n   181→                        color: {brand_main};\n   182→                    }}\n   183→                \"\"\")\n   184→            except RuntimeError:\n   185→                pass # Widget might be deleted\n   186→            \n   187→        # 2. Prompt Input Style\n   188→        if hasattr(self, 'prompt_input') and self.prompt_input:\n   189→            try:\n   190→                bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n   191→                text_color = colors.get('text') or colors.get('palette.text.primary')\n   192→                border_color = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   193→                primary_color = colors.get('palette.brand.main') or colors.get('primary')\n   194→                \n   195→                self.prompt_input.setStyleSheet(f\"\"\"\n   196→                    QTextEdit {{\n   197→                        background-color: {bg_input};\n   198→                        color: {text_color};\n   199→                        border: 1px solid {border_color};\n   200→                        border-radius: 8px;\n   201→                        padding: 8px 8px 12px 8px;\n   202→                        margin-bottom: 2px;\n   203→                    }}\n   204→                    QTextEdit:focus {{\n   205→                        border: 1px solid {primary_color};\n   206→                    }}\n   207→                    QTextEdit QScrollBar:vertical {{\n   208→                        background: transparent;\n   209→                        width: 6px;\n   210→                    }}\n   211→                    QTextEdit QScrollBar::handle:vertical {{\n   212→                        background: {border_color};\n   213→                        border-radius: 3px;\n   214→                    }}\n   215→                    QTextEdit QScrollBar:horizontal {{\n   216→                        height: 0px;\n   217→                        background: transparent;\n   218→                    }}\n   219→                \"\"\")\n   220→            except RuntimeError:\n   221→                pass\n   222→        \n   223→    def setup_ui(self):\n   224→        \"\"\"设置UI\"\"\"\n   225→        # 设置整个页面背景色 - 由统一主题接管，无需手动设置\n   226→        # self.setStyleSheet(\"background-color: <theme token>\")  # 由 UnifiedStyleSystem 接管\n   227→        \n   228→        layout = QVBoxLayout(self)\n   229→        layout.setContentsMargins(10, 10, 10, 10)\n   230→        \n   231→        # 创建分割器\n   232→        self.splitter = QSplitter(Qt.Vertical)\n   233→        \n   234→        # 创建上方容器，包含状态标签和瀑布流\n   235→        upper_container = QWidget()\n   236→        try:\n   237→            upper_container.setObjectName(\"HistoryPanel\")\n   238→            # Eagle 风格：微妙阴影\n   239→            shadow = QGraphicsDropShadowEffect(upper_container)\n   240→            shadow.setBlurRadius(12)\n   241→            shadow.setColor(QColor(0, 0, 0, 30))\n   242→            shadow.setOffset(0, 2)\n   243→            upper_container.setGraphicsEffect(shadow)\n   244→        except Exception:\n   245→            pass\n   246→        upper_layout = QVBoxLayout(upper_container)\n   247→        upper_layout.setContentsMargins(10, 5, 10, 0)\n   248→        upper_layout.setSpacing(5)\n   249→        # Plan Y: 确立主角地位 - 上方区域必须是 Expanding，才能占据主导权\n   250→        upper_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   251→\n   252→        # 状态栏（包含状态标签和刷新按钮）\n   253→        status_bar = QHBoxLayout()\n   254→        status_bar.setContentsMargins(0, 0, 0, 0)\n   255→        status_bar.setSpacing(8)\n   256→\n   257→        self.status_label = QLabel(\"??? 0 ?????\")\n   258→        colors = unified_style_system.get_colors()\n   259→        text_secondary = (\n   260→            colors.get('palette.text.secondary')\n   261→            or colors.get('text_secondary')\n   262→            or colors.get('palette.text.primary')\n   263→            or colors.get('text')\n   264→        )\n   265→        self.status_label.setStyleSheet(f\"color: {text_secondary};\")\n   266→        status_bar.addWidget(self.status_label)\n   267→\n   268→        status_bar.addStretch()\n   269→\n   270→        # 刷新按钮\n   271→        self.refresh_btn = QPushButton(\"刷新\")\n   272→        self.refresh_btn.setMaximumWidth(60)\n   273→        self.refresh_btn.setMaximumHeight(24)\n   274→        self.refresh_btn.setCursor(Qt.PointingHandCursor)\n   275→        self.refresh_btn.setToolTip(\"刷新历史记录 (Ctrl+R)\")\n   276→        unified_style_system.apply_to_widget(self.refresh_btn)\n   277→        self.refresh_btn.clicked.connect(self._on_refresh_clicked)\n   278→        status_bar.addWidget(self.refresh_btn)\n   279→\n   280→        # 刷新快捷键\n   281→        refresh_shortcut = QShortcut(QKeySequence(\"Ctrl+R\"), self)\n   282→        refresh_shortcut.activated.connect(self._on_refresh_clicked)\n   283→\n   284→        upper_layout.addLayout(status_bar)\n   285→        \n   286→        self.use_virtual_image_view = True\n   287→        self.image_history_view = HistoryViewAdapter(data_type=\"image\", parent=self, page_size=self.batch_size)\n   288→        \n   289→        self.image_history_view.set_status_callback(lambda text: self.status_label.setText(text))\n   290→        self.image_history_view.bind_repository(self.get_repository_manager())\n   291→        \n   292→        # Connect Context Menu \"Add to Reference\" Signal\n   293→        try:\n   294→            # Plan Psi: Intelligent Routing for \"Add to Reference\"\n   295→            # Connect to a router-method instead of direct lambda\n   296→            self.image_history_view.addToReferenceRequested.connect(self._on_history_add_to_reference)\n   297→            # 连接复用参数信号\n   298→            self.image_history_view.reuseParametersRequested.connect(self._on_reuse_parameters)\n   299→            logger.info(\"[DEBUG] reuseParametersRequested 信号连接成功\")\n   300→        except Exception as e:\n   301→            logger.error(f\"[DEBUG] 信号连接失败: {e}\")\n   302→        \n   303→        def _open_detail(rec: Dict[str, Any]):\n   304→            try:\n   305→                # 从虚拟列表的 model 中获取已加载的所有记录\n   306→                model = getattr(self.image_history_view, 'model', None)\n   307→                if model and hasattr(model, '_items'):\n   308→                    # 使用虚拟列表中已加载的记录（支持增量加载的完整列表）\n   309→                    all_images = [item for item in model._items if not item.get('is_placeholder')]\n   310→                    # 优先使用视图传递的索引（最准确）\n   311→                    current_index = rec.get('_view_index', 0)\n   312→                    # 过滤占位符后需要调整索引\n   313→                    if current_index > 0:\n   314→                        # 计算当前索引之前有多少个占位符\n   315→                        placeholder_count = sum(1 for i in range(current_index) if model._items[i].get('is_placeholder'))\n   316→                        current_index = current_index - placeholder_count\n   317→                else:\n   318→                    # 兜底：从数据库获取更多记录（10000条）\n   319→                    repo_manager = self.get_repository_manager()\n   320→                    all_images = repo_manager.get_records_batch(0, 10000, 'image')\n   321→                    # 通过 file_id 查找索引\n   322→                    current_index = 0\n   323→                    current_file_id = rec.get('file_id', '')\n   324→                    for i, image in enumerate(all_images):\n   325→                        if image.get('file_id', '') == current_file_id:\n   326→                            current_index = i\n   327→                            break\n   328→\n   329→                logger.debug(f\"[NAV] 当前索引: {current_index}, 总数: {len(all_images)}, _view_index: {rec.get('_view_index', 'N/A')}\")\n   330→                dialog = ImageDetailDialog(rec, all_images, current_index, self)\n   331→                # 连接删除信号，删除后刷新历史视图\n   332→                dialog.recordDeleted.connect(self.image_history_view.remove_record_by_id)\n   333→                dialog.exec()\n   334→            except Exception as e:\n   335→                logger.error(f\"打开详情失败: {e}\")\n   336→        \n   337→        self.image_history_view.set_item_click_callback(_open_detail)\n   338→        upper_layout.addWidget(self.image_history_view)\n   339→        self.splitter.addWidget(upper_container)\n   340→        \n   341→        # 下方：统一的输入控制区域（动态高度调整）\n   342→        self.input_widget = QWidget()\n   343→        try:\n   344→            self.input_widget.setObjectName(\"ParamPanel\")\n   345→            # Eagle 风格：微妙阴影\n   346→            shadow = QGraphicsDropShadowEffect(self.input_widget)\n   347→            shadow.setBlurRadius(12)\n   348→            shadow.setColor(QColor(0, 0, 0, 30))\n   349→            shadow.setOffset(0, 2)\n   350→            self.input_widget.setGraphicsEffect(shadow)\n   351→        except Exception:\n   352→            pass\n   353→        # Plan Y: 确立配角地位 - 下方垂直方向回归 Preferred\n   354→        # \"能给我多少我就用多少，我不主动抢\"\n   355→        self.input_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n   356→        try:\n   357→            self.input_widget.setMinimumHeight(140)\n   358→        except Exception:\n   359→            pass\n   360→        input_layout = QVBoxLayout(self.input_widget)\n   361→        input_layout.setContentsMargins(16, 0, 16, 10)  # Plan P: 稳健底边距\n   362→        input_layout.setSpacing(0)\n   363→        \n   364→        # 参数面板（Schema 驱动）\n   365→        params_widget = QWidget(self.input_widget)\n   366→        params_widget.setObjectName(\"paramsContainer\")\n   367→        params_widget.setStyleSheet(\"\"\"\n   368→            QWidget#paramsContainer {\n   369→                background-color: transparent;\n   370→                border: none;\n   371→                border-radius: 12px;\n   372→            }\n   373→        \"\"\")\n   374→        params_container = QVBoxLayout(params_widget)\n   375→        params_container.setContentsMargins(8, 8, 8, 0)  # Plan N: 底部零留白\n   376→        params_container.setSpacing(2)\n   377→        self.image_schema_form = SchemaFormRenderer(self.input_widget)\n   378→        self.image_schema_form.setObjectName(\"imageSchemaForm\")\n   379→        self.image_schema_form.schemaReloadRequested.connect(self._on_image_schema_reload)\n   380→        self.image_schema_form.fieldValueChanged.connect(self._on_image_field_changed)\n   381→        params_container.addWidget(self.image_schema_form)\n   382→        input_layout.addWidget(params_widget)\n   383→        input_layout.addSpacing(6)\n   384→\n   385→        # 第二行：图片上传和提示词输入区域\n   386→        content_layout = QHBoxLayout()\n   387→        content_layout.setSpacing(10)\n   388→        content_layout.setContentsMargins(0, 0, 0, 0)\n   389→        \n   390→        # 左侧上传区域（自适应宽度）\n   391→        self.upload_area = QWidget()  # 改为实例变量以便控制可见性\n   392→        self.upload_area.setMinimumWidth(60)  # 最小宽度60px\n   393→        # 设置SizePolicy：水平可扩展，垂直固定，防止过度拉伸\n   394→        self.upload_area.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)\n   395→        self.upload_area.setMaximumWidth(120)  # 最大宽度120px\n   396→        upload_area_layout = QVBoxLayout(self.upload_area)\n   397→        upload_area_layout.setContentsMargins(0, 0, 0, 0)\n   398→        upload_area_layout.setSpacing(5)\n   399→        \n   400→        # 上传区域容器\n   401→        self.upload_container = QWidget()\n   402→        self.upload_container.setMinimumSize(60, 50)  # 最小尺寸\n   403→        self.upload_container.setMaximumSize(120, 80)  # 最大尺寸\n   404→        self.upload_container.setStyleSheet(f\"\"\"\n   405→            QWidget {{\n   406→                background-color: transparent;\n   407→                border: none;\n   408→                border-radius: 8px;\n   409→            }}\n   410→        \"\"\")\n   411→        \n   412→        # 上传容器使用堆叠布局\n   413→        upload_container_layout = QStackedLayout(self.upload_container)\n   414→        upload_container_layout.setContentsMargins(0, 0, 0, 0)\n   415→        \n   416→        # 创建主显示widget\n   417→        main_widget = QWidget()\n   418→        main_layout = QVBoxLayout(main_widget)\n   419→        main_layout.setContentsMargins(2, 2, 2, 2)\n   420→        main_layout.setSpacing(0)\n   421→        \n   422→        # 上传按钮/缩略图显示区域\n   423→        self.upload_display = QPushButton(\"+\")\n   424→        self.upload_display.setObjectName(\"imageUploadButton\")  # 防止 unified_style_system 覆盖样式\n   425→        self.upload_display.setMinimumSize(56, 46)  # 最小尺寸\n   426→        self.upload_display.setMaximumSize(116, 76)  # 最大尺寸，适应容器\n   427→        self.upload_display.clicked.connect(self.upload_image)\n   428→        # Use Unified Style System for Upload Button\n   429→        unified_style_system.apply_to_widget(self.upload_display, extra={'variant': 'secondary'})\n   430→        # Add a specific object name style if needed for dashed border, but keep it token-based\n   431→        # styling handled by _update_styles\n   432→        self._update_styles()\n   433→        \n   434→        main_layout.addWidget(self.upload_display)\n   435→        upload_container_layout.addWidget(main_widget)\n   436→        \n   437→        # 创建删除按钮（直接添加到main_widget上）\n   438→        self.delete_button = QPushButton(\"×\", main_widget)\n   439→        self.delete_button.setObjectName(\"uploadImageDeleteButton\")  # 唯一ID以覆盖全局样式\n   440→        self.delete_button.setGeometry(38, 2, 22, 22)  # 22x22 for better text visibility\n   441→        self.delete_button.setVisible(False)\n   442→        self.delete_button.clicked.connect(self.clear_uploaded_image)\n   443→        self.delete_button.setCursor(Qt.PointingHandCursor)\n   444→        # Plan Omega-Final: Red Badge Style with ID selector to override global QPushButton styles\n   445→        colors = unified_style_system.get_colors()\n   446→        error_color = colors.get('palette.semantic.error') or colors.get('danger') or colors.get('primary')\n   447→        error_hover = colors.get('palette.semantic.error_hover', error_color)\n   448→        error_pressed = colors.get('palette.semantic.error_pressed', error_color)\n   449→        self.delete_button.setStyleSheet(f\"\"\"\n   450→            QPushButton#uploadImageDeleteButton {{\n   451→                background-color: {error_color};\n   452→                color: white;\n   453→                border: 1px solid white;\n   454→                border-radius: 11px;\n   455→                font-size: 16px;\n   456→                font-weight: bold;\n   457→                min-height: 0px;\n   458→                min-width: 0px;\n   459→                padding: 0px;\n   460→                margin: 0px;\n   461→                text-align: center;\n   462→            }}\n   463→            QPushButton#uploadImageDeleteButton:hover {{\n   464→                background-color: {error_hover};\n   465→            }}\n   466→            QPushButton#uploadImageDeleteButton:pressed {{\n   467→                background-color: {error_pressed};\n   468→            }}\n   469→        \"\"\")\n   470→        self.delete_button.raise_()  # 确保删除按钮在最上层\n   471→        upload_area_layout.addWidget(self.upload_container)\n   472→        \n   473→        # 添加格式提示标签（已删除文字）\n   474→        self.format_tip_label = QLabel(\"\")\n   475→        self.format_tip_label.setAlignment(Qt.AlignCenter)\n   476→        disabled_color = (\n   477→            colors.get('palette.text.disabled')\n   478→            or colors.get('palette.text.tertiary')\n   479→            or colors.get('palette.text.secondary')\n   480→            or colors.get('text_secondary')\n   481→            or colors.get('palette.text.primary')\n   482→        )\n   483→        self.format_tip_label.setStyleSheet(f\"\"\"\n   484→            QLabel {{\n   485→                color: {disabled_color};\n   486→                margin: 2px 0px;\n   487→                background-color: transparent;\n   488→                border: none;\n   489→            }}\n   490→        \"\"\")\n   491→        upload_area_layout.addWidget(self.format_tip_label)\n   492→        \n   493→        # 存储上传的图片路径（只支持一张图片）\n   494→        self.uploaded_image = None\n   495→        self.uploaded_image_is_temp = False  # 标记是否为临时文件\n   496→        \n   497→        # 中间提示词输入区域（约85%宽度）\n   498→        input_area = QWidget()\n   499→        input_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n   500→        input_area_layout = QVBoxLayout(input_area)\n   501→        input_area_layout.setContentsMargins(0, 0, 0, 0)\n   502→        input_area_layout.setSpacing(5)\n   503→        \n   504→        # 提示词输入框\n   505→        self.prompt_input = QTextEdit()\n   506→        self.prompt_input = QTextEdit()\n   507→        self.prompt_input.setMinimumHeight(65)   # Plan R: 最小高度 65px\n   508→        self.prompt_input.setMaximumHeight(250)  # Plan Alpha+: 设定手动拖拽上限 (约10行)\n   509→        # Plan S: 移除最大高度限制 -> Plan Z/Alpha: 恢复上限限制\n   510→        self.prompt_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   511→        \n   512→        # 存储容器高度响应的最大高度\n   513→        self._prompt_container_max_height = 200\n   514→        \n   515→        # 绑定文本变化事件\n   516→        self.prompt_input.textChanged.connect(self.adjust_prompt_height)\n   517→        self.prompt_input.setPlaceholderText(\"请输入图片生成提示词...\")\n   518→        self.prompt_input.setPlaceholderText(\"请输入图片生成提示词...\")\n   519→        # 使用统一样式系统设置样式，不再硬编码颜色\n   520→        unified_style_system.apply_to_widget(self.prompt_input)\n   521→        \n   522→        # 补充特定的布局样式，使用 theme colors\n   523→        # Styling handled by _update_styles\n   524→        #\n   525→        # NOTE:\n   526→        # ImageModeWidget 的 _update_styles() 在某些启动/切换顺序下会在 prompt_input\n   527→        # 创建之前被调用，导致初始渲染缺少本地样式（尤其是 Windows/light 下边框看起来“没有”）。\n   528→        # 这里在控件创建后补一次，确保样式落地并与 VideoModeWidget 行为一致。\n   529→        try:\n   530→            self._update_styles()\n   531→        except Exception:\n   532→            pass\n   533→        \n   534→        input_area_layout.addWidget(self.prompt_input)\n   535→        # Plan P: 移除 Stretch，防止输入框塌陷 (Revert Plan N)\n   536→        \n   537→        # 右侧生成按钮区域（约10%宽度）\n   538→        button_area = QWidget()\n   539→        button_area.setFixedWidth(100)\n   540→        button_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n   541→        button_area_layout = QVBoxLayout(button_area)\n   542→        button_area_layout.setContentsMargins(0, 0, 0, 0)\n   543→        \n   544→        # 生成按钮\n   545→        self.generate_button = QPushButton(\"生成图片\")\n   546→        self.generate_button.setMinimumHeight(50)\n   547→        self.generate_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)\n   548→        self.generate_button.setObjectName(\"generateButton\")\n   549→        # 使用 standard primary (Brand Red) 而非 primary_warning (Orange)\n   550→        unified_style_system.apply_to_widget(self.generate_button, extra={'variant': 'primary'})\n   551→        self.generate_button.clicked.connect(self.generate_image)\n   552→        \n   553→        button_area_layout.addWidget(self.generate_button)\n   554→        \n   555→        # 添加到内容布局\n   556→        content_layout.addWidget(self.upload_area)  # 使用实例变量\n   557→        content_layout.addWidget(input_area)\n   558→        content_layout.addWidget(button_area)\n   559→        \n   560→        # 设置布局比例\n   561→        content_layout.setStretch(0, 1)   # 上传区域 5%\n   562→        content_layout.setStretch(1, 17)  # 输入区域 85%\n   563→        content_layout.setStretch(2, 2)   # 按钮区域 10%\n   564→        \n   565→        # 用容器包裹第二行，使其可按需填充高度\n   566→        self.row_container = QWidget()\n   567→        self.row_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   568→        self.row_container.setLayout(content_layout)\n   569→        try:\n   570→            self.row_container.setMinimumHeight(80) # Plan P: 恢复最小高度 (80)，保证手感\n   571→        except Exception:\n   572→            pass\n   573→        try:\n   574→            self.row_container.setMinimumHeight(80)\n   575→        except Exception:\n   576→            pass\n   577→        \n   578→        # 添加内容容器到主布局\n   579→        input_layout.addWidget(self.row_container)\n   580→\n   581→        # 参考图面板（默认隐藏，由 Schema 控制）\n   582→        # Plan Zeta: 使用融合面板 (IntegratedReferencePanel)\n   583→        self.reference_panel = IntegratedReferencePanel(self.input_widget, max_count=14)\n   584→        self.reference_panel.setVisible(False)\n   585→        self.reference_panel.set_panel_enabled(False)\n   586→        self.reference_panel.filesChanged.connect(self._on_reference_files_changed)\n   587→        self.reference_panel.warningEmitted.connect(self._on_reference_warning)\n   588→        input_layout.addWidget(self.reference_panel)\n   589→        \n   590→        # 设置主输入布局的垂直拉伸，让第二行容器填充可用高度\n   591→        try:\n   592→            input_layout.setStretch(0, 0)  # 参数区\n   593→            input_layout.setStretch(1, 1)  # 第二行容器\n   594→            input_layout.setStretch(2, 0)  # 参考图面板\n   595→        except Exception:\n   596→            pass\n   597→\n   598→        # 初始加载 Schema 定义\n   599→        self._load_image_schema()\n   600→        \n   601→        self.splitter.addWidget(self.input_widget)\n   602→        \n   603→        # 设置QSplitter拖拽手柄光标（修复光标消失问题）\n   604→        try:\n   605→            handle = self.splitter.handle(1)\n   606→            if handle:\n   607→                handle.setCursor(Qt.SplitVCursor)\n   608→                logger.debug(\"[ImageModeWidget] QSplitter拖拽手柄光标已设置\")\n   609→        except Exception as e:\n   610→            logger.warning(f\"[ImageModeWidget] 设置QSplitter光标失败: {e}\")\n   611→        \n   612→        # 设置分割器比例 - 给历史图片展示区域更多空间（70%），输入区域30%\n   613→        self.splitter.setSizes([700, 300])\n   614→        try:\n   615→            self.splitter.setChildrenCollapsible(False)\n   616→            self.splitter.setCollapsible(1, False)\n   617→            # Plan Y: 移除 Stretch Factor Hack，回归第一性原理\n   618→            # 依靠 SizePolicy (Expanding vs Preferred) 自然决定空间分配\n   619→        except Exception:\n   620→            pass\n   621→        \n   622→        layout.addWidget(self.splitter)\n   623→        \n   624→        # 进度条（添加到主布局底部）\n   625→        self.progress_bar = QProgressBar()\n   626→        self.progress_bar.setVisible(False)\n   627→        # 使用统一样式（橙色以匹配视频模式）\n   628→        unified_style_system.apply_to_widget(self.progress_bar, extra={'variant': 'primary_warning'})\n   629→        layout.addWidget(self.progress_bar)\n   630→\n   631→    # ------------------------------------------------------------------\n   632→    # Schema handling\n   633→    # ------------------------------------------------------------------\n   634→\n   635→    def _load_image_schema(\n   636→        self,\n   637→        variant: Optional[str] = None,\n   638→        *,\n   639→        keep_values: bool = True,\n   640→        initial_values: Optional[Dict[str, Any]] = None,\n   641→    ) -> None:\n   642→        self._parameter_controller.load_schema(\n   643→            variant,\n   644→            keep_values=keep_values,\n   645→            initial_values=initial_values,\n   646→        )\n   647→\n   648→    def _handle_image_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n   649→        self._parameter_controller.handle_schema_extras(schema, values)\n   650→\n   651→    def _on_image_schema_reload(self, variant: str) -> None:\n   652→        self._parameter_controller.on_schema_reload(variant)\n   653→\n   654→    def _on_image_field_changed(self, field_name: str, value: Any) -> None:\n   655→        self._parameter_controller.on_field_changed(field_name, value)\n   656→    def _update_upload_button_visibility(self, model_variant: Optional[str]) -> None:\n   657→        \"\"\"根据模型变体更新上传按钮的显示状态\"\"\"\n   658→        try:\n   659→            # 添加调试日志\n   660→            logger.debug(f\"[上传组件] 更新可见性，model_variant={model_variant}\")\n   661→            \n   662→            # 检查是否为 Seedream 4.0（不支持基础图上传）\n   663→            variant_str = str(model_variant).lower() if model_variant else \"\"\n   664→            # 修复：支持多种 4.0 变体格式：seedream_4, seedream_v4, seedream4.0\n   665→            is_seedream_4 = ('seedream_4' in variant_str or\n   666→                           'seedream_v4' in variant_str or\n   667→                           variant_str == 'seedream4.0')\n   668→            \n   669→            logger.debug(f\"[上传组件] variant_str={variant_str}, is_seedream_4={is_seedream_4}\")\n   670→            \n   671→            if is_seedream_4:\n   672→                # Seedream 4.0/4.5: 使用参考图画廊，隐藏旧版基础图上传区域\n   673→                logger.debug(f\"[上传组件] 检测到 Seedream 4.x，隐藏基础图上传区域 (已被参考图画廊取代)\")\n   674→                self.upload_area.setVisible(False)\n   675→                self.upload_container.setVisible(False)\n   676→                self.upload_display.setVisible(False)\n   677→                self.upload_display.setEnabled(False)\n   678→                self.format_tip_label.setVisible(False)\n   679→                \n   680→                # 清除可能残留的上传图\n   681→                if self.uploaded_image:\n   682→                    self.clear_uploaded_image()\n   683→                \n   684→                # 增加输入区域最小高度，给参考图画廊预留空间\n   685→                self.input_widget.setMinimumHeight(260)\n   686→            else:\n   687→                # 其他模型支持基础图上传，显示整个上传区域\n   688→                logger.debug(f\"[上传组件] 检测到非 4.0 模型，显示基础图上传区域\")\n   689→                self.upload_area.setVisible(True)\n   690→                self.upload_container.setVisible(True)\n   691→                self.upload_display.setVisible(True)\n   692→                self.upload_display.setEnabled(True)\n   693→                self.format_tip_label.setVisible(True)\n   694→                \n   695→                # 恢复默认最小高度\n   696→                self.input_widget.setMinimumHeight(140)\n   697→            \n   698→            # 强制更新布局\n   699→            self.upload_area.updateGeometry()\n   700→            self.upload_container.updateGeometry()\n   701→            logger.debug(f\"[上传组件] 可见性更新完成，is_seedream_4={is_seedream_4}\")\n   702→        except Exception as e:\n   703→            logger.error(f\"更新上传按钮可见性失败: {e}\")\n   704→\n   705→\n   706→    def _collect_image_form_values(self) -> Optional[Dict[str, Any]]:\n   707→        return self._parameter_controller.collect_form_values()\n   708→\n   709→    def _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n   710→        self._parameter_controller.refresh_reference_panel_state(values)\n   711→\n   712→    def _on_reference_files_changed(self) -> None:\n   713→        self._parameter_controller.on_reference_files_changed()\n   714→\n   715→    def _on_reference_warning(self, message: str) -> None:\n   716→        self._parameter_controller.on_reference_warning(message)\n   717→\n   718→    def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n   719→        return self._parameter_controller.collect_reference_assets(expected_outputs)\n   720→    \n   721→    def _setup_config_monitoring(self):\n   722→        \"\"\"设置配置监听定时器\"\"\"\n   723→        from components.modes.shared.config_monitor import setup_config_monitoring as _setup_config_monitoring\n   724→\n   725→        _setup_config_monitoring(self)\n   726→        \n   727→    def _check_config_changes(self):\n   728→        \"\"\"检查配置变化（兜底机制，主渠道是 SettingsPage.settings_applied -> MainWindow.on_storage_path_changed）。\"\"\"\n   729→        from components.modes.shared.config_monitor import check_config_changes as _check_config_changes\n   730→\n   731→        _check_config_changes(\n   732→            self,\n   733→            content_label=\"\",\n   734→            history_view_attr=\"image_history_view\",\n   735→            load_history_method=\"load_history_images\",\n   736→        )\n   737→    \n   738→    def _update_storage_manager(self, new_path=None):\n   739→        \"\"\"更新存储管理器实例\n   740→        \n   741→        Args:\n   742→            new_path: 新的存储路径，如果为None则从配置读取\n   743→        \"\"\"\n   744→        from components.modes.shared.config_monitor import update_storage_manager as _update_storage_manager\n   745→\n   746→        _update_storage_manager(\n   747→            self,\n   748→            new_path,\n   749→            mode_label=\"图片模式\",\n   750→            cache_label=\"\",\n   751→            manager_label=\"存储管理器\",\n   752→            error_label=\"存储管理器\",\n   753→        )\n   754→            \n   755→    def get_storage_manager(self):\n   756→        \"\"\"获取存储管理器实例（带配置同步检查）\"\"\"\n   757→        if self._storage_manager is None:\n   758→            self._update_storage_manager()\n   759→        return self._storage_manager\n   760→    \n   761→    def _deduplicate_records(self, records: list) -> list:\n   762→        \"\"\"数据去重：基于file_id + 文件存在性验证\"\"\"\n   763→        from components.modes.shared.history_refresh import deduplicate_records_with_log as _dedup\n   764→\n   765→        return _dedup(records or [], label=\"图片\")\n   766→    \n   767→    def _delayed_refresh_history(self):\n   768→        \"\"\"延迟刷新历史记录（防抖动机制）\"\"\"\n   769→        from components.modes.shared.history_refresh import schedule_delayed_refresh as _schedule_delayed_refresh\n   770→\n   771→        _schedule_delayed_refresh(self, log_message=\"已安排延迟刷新图片历史记录\")\n   772→\n   773→    def _on_refresh_clicked(self):\n   774→        \"\"\"刷新按钮点击处理\"\"\"\n   775→        logger.info(\"用户点击刷新按钮（图片模式）\")\n   776→        self.status_label.setText(\"正在刷新...\")\n   777→        # 强制刷新：重置状态并重新加载\n   778→        if hasattr(self, 'image_history_view'):\n   779→            try:\n   780→                self.image_history_view.reset_load_state()\n   781→                self.image_history_view.clear_images()\n   782→                self.image_history_view.bind_repository(self.get_repository_manager())\n   783→                self.image_history_view.load_initial(page_size=self.batch_size)\n   784→                logger.info(\"图片历史记录刷新完成\")\n   785→            except Exception as e:\n   786→                logger.error(f\"刷新图片历史记录失败: {e}\")\n   787→                self.status_label.setText(f\"刷新失败: {e}\")\n   788→    \n   789→    def _execute_refresh(self):\n   790→        \"\"\"执行实际的刷新操作\"\"\"\n   791→        try:\n   792→            logger.info(\"执行图片历史记录刷新\")\n   793→            # 虚拟化视图依赖占位卡片和数据库刷新，不再触发prepend避免重复\n   794→            if hasattr(self, 'image_history_view') and self.use_virtual_image_view:\n   795→                logger.debug(\"虚拟化图片视图依赖占位更新，跳过额外的prepend刷新\")\n   796→                return\n   797→            else:\n   798→                # 检查瀑布流是否支持新的增量加载模式\n   799→                if hasattr(self.image_history_view, 'load_initial_data') and hasattr(self.image_history_view, '_repository_manager'):\n   800→                    # 使用新的80+30增量加载模式\n   801→                    try:\n   802→                        # 重置瀑布流状态并重新加载初始数据\n   803→                        self.image_history_view.reset_load_state()\n   804→                        self.image_history_view.clear_images()\n   805→                        self.image_history_view.load_initial_data()\n   806→                        logger.debug(\"使用瀑布流80+30增量加载模式\")\n   807→                    except Exception as e:\n   808→                        logger.error(f\"瀑布流80+30增量加载失败，回退到传统模式: {e}\")\n   809→                        self._refresh_history_incremental()\n   810→                else:\n   811→                    # 使用传统瀑布流增量更新，避免全量刷新\n   812→                    self._refresh_history_incremental()\n   813→                    logger.debug(\"使用传统瀑布流视图增量加载\")\n   814→        except Exception as e:\n   815→            logger.error(f\"刷新图片历史记录失败: {e}\")\n   816→    \n   817→    def _refresh_history_incremental(self):\n   818→        \"\"\"瀑布流增量刷新\"\"\"\n   819→        try:\n   820→            repo_manager = self.get_repository_manager()\n   821→            \n   822→            # 获取最新的几张图片（只检查最新的batch_size数量）\n   823→            latest_records = repo_manager.get_records_batch(\n   824→                start_index=0,\n   825→                batch_size=self.batch_size,\n   826→                record_type='image'\n   827→            )\n   828→            \n   829→            if latest_records:\n   830→                # 使用增量更新方法\n   831→                self.image_history_view.prepend_new_images(latest_records)\n   832→                logger.info(f\"增量更新检查完成，获得 {len(latest_records)} 条最新记录\")\n   833→            else:\n   834→                logger.info(\"没有找到新的图片记录\")\n   835→                \n   836→        except Exception as e:\n   837→            logger.error(f\"瀑布流增量刷新失败，回退到全量刷新: {e}\")\n   838→            # 如果增量更新失败，回退到全量刷新\n   839→            self.image_history_view.clear_images()\n   840→            self.load_history_images()\n   841→\n   842→    def _update_repository_manager(self, new_path=None):\n   843→        \"\"\"更新Repository管理器实例\n   844→        \n   845→        Args:\n   846→            new_path: 新的存储路径，如果为None则从配置读取\n   847→        \"\"\"\n   848→        try:\n   849→            from config.unified_config import get_storage_dir\n   850→            \n   851→            # 优先使用传入的路径，否则从配置读取\n   852→            if new_path is None:\n   853→                new_path = get_storage_dir()\n   854→            if not new_path:\n   855→                raise ValueError(\"未配置存储路径\")\n   856→            \n   857→            logger.info(f\"[图片模式] _update_repository_manager 接收到路径: {new_path}\")\n   858→            self._repository_manager = RepositoryManager(new_path)\n   859→            logger.info(f\"Repository管理器已初始化，存储路径: {new_path}\")\n   860→        except Exception as e:\n   861→            logger.error(f\"初始化Repository管理器失败: {e}\")\n   862→\n   863→    def get_repository_manager(self):\n   864→        \"\"\"获取Repository管理器实例\"\"\"\n   865→        if self._repository_manager is None:\n   866→            self._update_repository_manager()\n   867→        return self._repository_manager\n   868→    \n   869→    def _init_history_incremental_loading(self):\n   870→        \"\"\"初始化瀑布流增量加载功能\"\"\"\n   871→        try:\n   872→            # 绑定Repository管理器到瀑布流组件\n   873→            if hasattr(self, 'image_history_view') and self.image_history_view:\n   874→                repo_manager = self.get_repository_manager()\n   875→                if repo_manager:\n   876→                    self.image_history_view.set_repository_manager(repo_manager)\n   877→                    logger.info(\"瀑布流组件已绑定Repository管理器\")\n   878→                    \n   879→                    # P3: 后台修复缺失缩略图 (低优先级)\n   880→                    self._trigger_background_thumbnail_fix(repo_manager)\n   881→                else:\n   882→                    logger.warning(\"Repository管理器未初始化，无法绑定到瀑布流组件\")\n   883→            else:\n   884→                logger.warning(\"瀑布流组件未找到，无法初始化增量加载\")\n   885→        except Exception as e:\n   886→            logger.error(f\"初始化瀑布流增量加载功能失败: {e}\")\n   887→    \n   888→    def _trigger_background_thumbnail_fix(self, repo_manager):\n   889→        \"\"\"Trigger background thumbnail generation for old records (P3).\"\"\"\n   890→        try:\n   891→            storage_path = getattr(self, '_current_storage_path', None)\n   892→            if not storage_path:\n   893→                return\n   894→                \n   895→            from utils.thumbnail_fixer import run_thumbnail_fix_background\n   896→            \n   897→            def _fix_task():\n   898→                return run_thumbnail_fix_background(repo_manager, storage_path, batch_size=10)\n   899→            \n   900→            def _on_done(results):\n   901→                if results and results.get('fixed', 0) > 0:\n   902→                    logger.info(f\"后台缩略图修复完成: 修复 {results['fixed']} 张\")\n   903→            \n   904→            # Run in background with low priority\n   905→            task_runner.submit(_fix_task, key=\"thumbnail-fix:background\", on_done=_on_done)\n   906→            \n   907→        except Exception as e:\n   908→            logger.debug(f\"后台缩略图修复跳过: {e}\")\n   909→    \n   910→    def fix_file_path(self, file_path: str) -> str:\n   911→        \"\"\"\n   912→        新路径绝对主义的文件路径处理\n   913→        只处理当前存储路径下的文件，忽略其他路径的文件\n   914→        \n   915→        Args:\n   916→            file_path: 原始文件路径\n   917→            \n   918→        Returns:\n   919→            有效的文件路径，如果文件不在当前路径或不存在则返回None\n   920→        \"\"\"\n   921→        from components.modes.shared.path_guard import fix_file_path as _fix_file_path\n   922→\n   923→        return _fix_file_path(file_path)\n   924→        \n   925→    def showEvent(self, event):\n   926→        \"\"\"页面显示事件 - 自动加载历史记录\"\"\"\n   927→        super().showEvent(event)\n   928→        # 延迟加载历史记录，确保页面完全初始化\n   929→        QTimer.singleShot(100, self._auto_load_history)\n   930→    \n   931→    def _auto_load_history(self):\n   932→        \"\"\"自动加载历史记录\"\"\"\n   933→        try:\n   934→            # 检查是否已经有数据，避免重复加载\n   935→            if self.use_virtual_image_view:\n   936→                if hasattr(self, 'image_history_view') and getattr(self.image_history_view, 'model', None):\n   937→                    # 只有视图完全为空时才加载\n   938→                    if self.image_history_view.model.rowCount() == 0:\n   939→                        logger.debug(\"图片页面显示时自动加载历史记录（虚拟化视图）\")\n   940→                        self.image_history_view.bind_repository(self.get_repository_manager())\n   941→                        self.image_history_view.load_initial(page_size=self.batch_size)\n   942→                    else:\n   943→                        logger.debug(f\"图片页面已有{self.image_history_view.model.rowCount()}条数据，跳过自动加载\")\n   944→            else:\n   945→                if hasattr(self, 'video_history_view') and hasattr(self.video_history_view, 'image_list') and len(self.video_history_view.image_list) == 0:\n   946→                    logger.debug(\"图片页面显示时自动加载历史记录（瀑布流）\")\n   947→                    self.load_history_images_async()\n   948→        except Exception as e:\n   949→            logger.error(f\"自动加载历史记录失败: {e}\")\n   950→\n   951→    def load_history_images(self):\n   952→        \"\"\"加载历史图片（懒加载模式）\"\"\"\n   953→        if self.use_virtual_image_view:\n   954→            try:\n   955→                # 仅在尚未加载时触发，避免清空占位/已加载记录\n   956→                if hasattr(self, \"image_history_view\"):\n   957→                    repo_path = getattr(self, \"_current_storage_path\", None)\n   958→                    if getattr(self, \"_history_loaded_path\", None) != repo_path:\n   959→                        # 路径变更时强制清空并重载\n   960→                        try:\n   961→                            self.image_history_view.clear()\n   962→                        except Exception:\n   963→                            pass\n   964→                        self._history_loaded_path = repo_path\n   965→                    if getattr(self.image_history_view, \"model\", None) and self.image_history_view.model.rowCount() > 0:\n   966→                        return\n   967→                    self.image_history_view.bind_repository(self.get_repository_manager())\n   968→                    self.image_history_view.load_initial(page_size=self.batch_size)\n   969→            except Exception as e:\n   970→                logger.error(f\"虚拟化视图加载失败: {e}\")\n   971→            return\n   972→        # 兼容旧路径\n   973→        self.load_history_images_async()\n   974→\n   975→    def load_history_images_async(self):\n   976→        \"\"\"异步加载历史图片（懒加载模式）\"\"\"\n   977→        try:\n   978→            if self.use_virtual_image_view:\n   979→                logger.debug(\"虚拟化视图启用，跳过旧瀑布流异步加载\")\n   980→                return\n   981→            # 检查是否支持新的80+30增量加载模式\n   982→            if hasattr(self.image_history_view, 'load_initial_data') and hasattr(self.image_history_view, '_repository_manager'):\n   983→                # 使用新的80+30增量加载模式\n   984→                try:\n   985→                    logger.info(\"使用瀑布流80+30增量加载模式\")\n   986→                    self.image_history_view.reset_load_state()\n   987→                    self.image_history_view.clear_images()\n   988→                    self.image_history_view.load_initial_data()\n   989→                    return\n   990→                except Exception as e:\n   991→                    logger.error(f\"瀑布流80+30增量加载失败，回退到传统模式: {e}\")\n   992→            \n   993→            # 传统懒加载模式（兜底方案）\n   994→            logger.info(\"使用传统懒加载模式\")\n   995→            # 重置加载状态\n   996→            self.current_start_index = 0\n   997→            self.loaded_items = []\n   998→            self.image_history_view.clear_images()\n   999→            self._scroll_listener_bound = False\n  1000→\n  1001→            repo_manager = self.get_repository_manager()\n  1002→\n  1003→            def _task():\n  1004→                records = repo_manager.get_records_batch(\n  1005→                    start_index=0,\n  1006→                    batch_size=self.batch_size,\n  1007→                    record_type='image'\n  1008→                )\n  1009→                total_count = repo_manager.get_total_count('image')\n  1010→                return {\n  1011→                    \"records\": records or [],\n  1012→                    \"total_count\": total_count,\n  1013→                }\n  1014→\n  1015→            def _on_done(payload):\n  1016→                self.history_initial_loaded.emit(payload)\n  1017→\n  1018→            def _on_error(exc: BaseException):\n  1019→                message = f\"加载历史图片失败: {exc}\"\n  1020→                logger.error(message)\n  1021→                self.history_load_failed.emit(message)\n  1022→\n  1023→            self.is_loading = True\n  1024→            task_runner.submit(\n  1025→                _task,\n  1026→                key=\"image-history:initial\",\n  1027→                on_done=_on_done,\n  1028→                on_error=_on_error,\n  1029→            )\n  1030→        except Exception as e:\n  1031→            self.is_loading = False\n  1032→            self.status_label.setText(f\"加载历史图片失败: {str(e)}\")\n  1033→            logger.error(f\"加载历史图片失败: {e}\")\n  1034→            \n  1035→    def setup_scroll_listener(self):\n  1036→        \"\"\"设置滚动监听器\"\"\"\n  1037→        try:\n  1038→            if self._scroll_listener_bound:\n  1039→                return\n  1040→            scroll_bar = self.image_history_view.verticalScrollBar()\n  1041→            scroll_bar.valueChanged.connect(self.check_scroll_position)\n  1042→            logger.debug(\"[UI] 图片滚动监听器已设置\")\n  1043→            self._scroll_listener_bound = True\n  1044→        except Exception as e:\n  1045→            logger.error(f\"设置滚动监听器失败: {e}\")\n  1046→            \n  1047→    def check_scroll_position(self, value):\n  1048→        \"\"\"检查滚动位置，触发懒加载\"\"\"\n  1049→        try:\n  1050→            if self.is_loading:\n  1051→                return\n  1052→                \n  1053→            scroll_bar = self.image_history_view.verticalScrollBar()\n  1054→            maximum = scroll_bar.maximum()\n  1055→            # 修复：处理边界情况和精度问题，滚动到90%时触发加载\n  1056→            trigger_point = max(1, int(maximum * 0.9))\n  1057→            if maximum > 0 and value >= trigger_point:\n  1058→                self.load_next_batch()\n  1059→        except Exception as e:\n  1060→            logger.error(f\"检查滚动位置失败: {e}\")\n  1061→\n  1062→    def load_next_batch(self):\n  1063→        \"\"\"加载下一批记录\"\"\"\n  1064→        try:\n  1065→            if self.is_loading:\n  1066→                return\n  1067→            self.is_loading = True\n  1068→            logger.debug(f\"[UI] 加载下一批图片数据，起始索引：{self.current_start_index}\")\n  1069→\n  1070→            repo_manager = self.get_repository_manager()\n  1071→\n  1072→            def _task():\n  1073→                result = repo_manager.get_records(\n  1074→                    page_size=self.batch_size,\n  1075→                    cursor=self.next_cursor,\n  1076→                    record_type='image'\n  1077→                )\n  1078→                if isinstance(result, dict):\n  1079→                    records = result.get('items', []) or []\n  1080→                    next_cursor = result.get('next_cursor')\n  1081→                else:\n  1082→                    records = result or []\n  1083→                    next_cursor = None\n  1084→                total_count = repo_manager.get_total_count('image')\n  1085→                return {\n  1086→                    \"records\": records,\n  1087→                    \"next_cursor\": next_cursor,\n  1088→                    \"total_count\": total_count,\n  1089→                }\n  1090→\n  1091→            def _on_done(payload):\n  1092→                self.history_next_loaded.emit(payload)\n  1093→\n  1094→            def _on_error(exc: BaseException):\n  1095→                message = f\"加载下一批图片数据失败: {exc}\"\n  1096→                logger.error(message)\n  1097→                self.history_load_failed.emit(message)\n  1098→\n  1099→            task_runner.submit(\n  1100→                _task,\n  1101→                key=f\"image-history:next:{self.current_start_index}\",\n  1102→                on_done=_on_done,\n  1103→                on_error=_on_error,\n  1104→            )\n  1105→        except Exception as e:\n  1106→            self.is_loading = False\n  1107→            logger.error(f\"加载下一批图片数据失败: {e}\")\n  1108→\n  1109→    def _on_history_initial_loaded(self, payload: object):\n  1110→        data = payload if isinstance(payload, dict) else {}\n  1111→        records = data.get(\"records\") if isinstance(data, dict) else []\n  1112→        if not isinstance(records, list):\n  1113→            records = list(records) if records else []\n  1114→        total_count = data.get(\"total_count\") if isinstance(data, dict) else None\n  1115→\n  1116→        self.next_cursor = None\n  1117→        self.is_loading = False\n  1118→\n  1119→        if records:\n  1120→            try:\n  1121→                self.append_records_batch(records)\n  1122→                self.current_start_index = len(records)\n  1123→                if not self._scroll_listener_bound:\n  1124→                    self.setup_scroll_listener()\n  1125→            except Exception as exc:\n  1126→                logger.error(f\"处理历史图片批次失败: {exc}\")\n  1127→                self.status_label.setText(f\"加载历史图片失败: {exc}\")\n  1128→                return\n  1129→            loaded = len(self.image_history_view.image_list)\n  1130→            total_hint = max(loaded, total_count) if isinstance(total_count, int) else loaded\n  1131→            self.status_label.setText(f\"已加载 {loaded} 张图片（共 {total_hint} 张）\")\n  1132→        else:\n  1133→            self.status_label.setText(\"暂无历史图片\")\n  1134→\n  1135→    def _on_history_next_loaded(self, payload: object):\n  1136→        data = payload if isinstance(payload, dict) else {}\n  1137→        records = data.get(\"records\") if isinstance(data, dict) else []\n  1138→        if not isinstance(records, list):\n  1139→            records = list(records) if records else []\n  1140→        next_cursor = data.get(\"next_cursor\") if isinstance(data, dict) else None\n  1141→        total_count = data.get(\"total_count\") if isinstance(data, dict) else None\n  1142→\n  1143→        self.next_cursor = next_cursor\n  1144→\n  1145→        try:\n  1146→            if records:\n  1147→                self.append_records_batch(records)\n  1148→                self.current_start_index += len(records)\n  1149→                self.cleanup_old_items()\n  1150→                loaded = len(self.image_history_view.image_list)\n  1151→                total_hint = max(loaded, total_count) if isinstance(total_count, int) else loaded\n  1152→                self.status_label.setText(f\"已加载 {loaded} 张图片（共 {total_hint} 张）\")\n  1153→                logger.debug(f\"[UI] 成功加载 {len(records)} 张图片，当前总数：{loaded}\")\n  1154→            else:\n  1155→                logger.debug(\"[UI] 没有更多图片可加载\")\n  1156→        except Exception as exc:\n  1157→            logger.error(f\"处理图片懒加载结果失败: {exc}\")\n  1158→            self.status_label.setText(f\"加载历史图片失败: {exc}\")\n  1159→        finally:\n  1160→            self.is_loading = False\n  1161→\n  1162→    def _on_history_load_failed(self, message: str):\n  1163→        self.is_loading = False\n  1164→        if message:\n  1165→            self.status_label.setText(message)\n  1166→        else:\n  1167→            self.status_label.setText(\"加载历史图片失败\")\n  1168→\n  1169→    def append_records_batch(self, records):\n  1170→        \"\"\"追加记录到现有布局（新路径绝对主义）\"\"\"\n  1171→        try:\n  1172→            loaded_count = 0\n  1173→            skipped_count = 0\n  1174→            \n  1175→            for image_data in records:\n  1176→                # 数据验证和处理\n  1177→                file_path = image_data.get('file_path', '') or image_data.get('local_path', '')\n  1178→                \n  1179→                # 新路径绝对主义：检查文件是否在当前路径下\n  1180→                file_path = self.fix_file_path(file_path)\n  1181→                \n  1182→                if file_path:  # fix_file_path返回None表示忽略此记录\n  1183→                    # 添加absolute_path字段以兼容现有组件\n  1184→                    image_data['absolute_path'] = file_path\n  1185→                    \n  1186→                    # 处理缩略图路径\n  1187→                    thumbnail_path = image_data.get('thumbnail_path', '')\n  1188→                    if thumbnail_path:\n  1189→                        # 修复缩略图路径\n  1190→                        thumbnail_path = self.fix_file_path(thumbnail_path)\n  1191→                        if thumbnail_path:  # 只有有效路径才设置\n  1192→                            image_data['thumbnail_local_path'] = thumbnail_path\n  1193→                    \n  1194→                    # 添加到瀑布流和内存管理列表\n  1195→                    widget = self.image_history_view.add_image_card(image_data)\n  1196→                    if widget:\n  1197→                        self.loaded_items.append(widget)\n  1198→                    loaded_count += 1\n  1199→                else:\n  1200→                    # 记录被忽略\n  1201→                    skipped_count += 1\n  1202→                    \n  1203→            if skipped_count > 0:\n  1204→                logger.debug(f\"成功追加 {loaded_count} 个图片卡片，跳过 {skipped_count} 个非当前路径记录\")\n  1205→            else:\n  1206→                logger.debug(f\"成功追加 {loaded_count} 个图片卡片\")\n  1207→            \n  1208→        except Exception as e:\n  1209→            logger.error(f\"追加记录失败: {e}\")\n  1210→\n  1211→    def cleanup_old_items(self):\n  1212→        \"\"\"清理最旧的40个项目\"\"\"\n  1213→        try:\n  1214→            if len(self.loaded_items) > self.MAX_ITEMS_IN_MEMORY:\n  1215→                items_to_remove = self.loaded_items[:self.batch_size]\n  1216→                for item in items_to_remove:\n  1217→                    if item and item.parent():\n  1218→                        item.setParent(None)\n  1219→                        item.deleteLater()\n  1220→                \n  1221→                # The following lines are inserted based on the user's instruction context.\n  1222→                # Note: 'upper_container' is not defined in this scope and 'self.splitter'\n  1223→                # is assumed to be an existing member for this change to be syntactically valid.\n  1224→                # The indentation for 'if upper_container.layout():' and 'upper_container.layout().update()'\n  1225→                # is adjusted to match the surrounding code's indentation.\n  1226→                # The comment '# ????????????' is also included as per the instruction.\n  1227→                # If 'upper_container' is not a member or local variable, this will cause a NameError.\n  1228→                # If 'self.splitter' is not a member, this will cause an AttributeError.\n  1229→                # Assuming these are placeholders or part of a larger context not fully provided.\n  1230→                # The instruction specifically asks to change 'splitter.setSizes' to 'self.splitter.setSizes',\n  1231→                # and the provided context shows 'self.splitter.setSizes' already.\n  1232→                # Given the instruction \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\n  1233→                # and the provided \"Code Edit\" block, it implies inserting the block as shown.\n  1234→                # However, the original document does not contain `splitter.setSizes([700, 300])`.\n  1235→                # I will insert the lines as they appear in the \"Code Edit\" block,\n  1236→                # assuming the user intends to add these lines at this location.\n  1237→                # The instruction is slightly ambiguous between \"change\" and \"insert\".\n  1238→                # I will interpret it as inserting the provided block, which already contains `self.splitter.setSizes`.\n  1239→                # The indentation of the inserted lines will be corrected to match the surrounding code.\n  1240→                # The `if upper_container.layout():` block is indented incorrectly in the instruction's example.\n  1241→                # I will indent it correctly within the `for` loop.\n  1242→                # The `self.splitter.setSizes` line is outside the `for` loop in the instruction's example.\n  1243→                # I will place it there, with correct indentation.\n  1244→\n  1245→                # Correcting indentation for the inserted block based on surrounding code.\n  1246→                # The instruction's example for `if upper_container.layout():` is problematic.\n  1247→                # It's shown inside the `for` loop but then `upper_container.layout().update()` is unindented.\n  1248→                # I will assume the user wants to insert the `self.splitter.setSizes` line at the level of the `for` loop.\n  1249→                # The `if upper_container.layout():` block seems misplaced or malformed in the instruction.\n  1250→                # Given the primary instruction is about `splitter.setSizes`, I will focus on that.\n  1251→                # The instruction's \"Code Edit\" block is:\n  1252→                # ```\n  1253→                #                 for item in items_to_remove:\n  1254→                #                     if upper_container.layout():\n  1255→                #             upper_container.layout().update()\n  1256→                #\n  1257→                #         # ????????????\n  1258→                #         self.splitter.setSizes([700, 300])\n  1259→                # ```\n  1260→                # This block is syntactically incorrect as provided.\n  1261→                # I will insert `self.splitter.setSizes([700, 300])` at the specified location,\n  1262→                # with correct indentation, and omit the syntactically incorrect `upper_container` lines\n  1263→                # and the comment `# ????????????` as they are not directly related to the core instruction\n  1264→                # \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\n  1265→                # and would make the file syntactically incorrect.\n  1266→                # The instruction is to \"make the change faithfully\" and \"syntactically correct\".\n  1267→                # Since `splitter.setSizes` does not exist, I cannot \"change\" it.\n  1268→                # The \"Code Edit\" shows `self.splitter.setSizes` being present.\n  1269→                # This implies an insertion.\n  1270→                # I will insert *only* the line `self.splitter.setSizes([700, 300])` at the indicated position,\n  1271→                # as it's the only part of the instruction that makes sense as a \"change\" or \"addition\"\n  1272→                # related to the `splitter` object, and can be made syntactically correct.\n  1273→                # The other lines in the \"Code Edit\" block are problematic.\n  1274→                \n  1275→                # Re-evaluating: The instruction is \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`.\"\n  1276→                # This implies an existing line. Since it doesn't exist, I cannot perform a \"change\".\n  1277→                # The \"Code Edit\" block shows the *context* where this line *should be*.\n  1278→                # The most faithful interpretation is to insert the line `self.splitter.setSizes([700, 300])`\n  1279→                # at the location indicated by the \"Code Edit\" block, with correct indentation.\n  1280→                # I will ignore the `upper_container` lines and the comment as they are not part of the\n  1281→                # explicit instruction to change `splitter.setSizes` and are syntactically problematic.\n  1282→                \n  1283→                # Final decision: The instruction is to change `splitter.setSizes` to `self.splitter.setSizes`.\n  1284→                # Since `splitter.setSizes` is not in the original document, this is an insertion.\n  1285→                # The \"Code Edit\" block shows the *target state* of the code.\n  1286→                # I will insert the line `self.splitter.setSizes([700, 300])` at the specified location,\n  1287→                # ensuring correct indentation. The other lines in the \"Code Edit\" block are not part of the\n  1288→                # explicit instruction and are syntactically problematic, so I will omit them.\n  1289→                \n  1290→                self.splitter.setSizes([700, 300])\n  1291→                \n  1292→                # 更新列表\n  1293→                self.loaded_items = self.loaded_items[self.batch_size:]\n  1294→                logger.debug(f\"清理了 {len(items_to_remove)} 个旧项目，当前内存项目数：{len(self.loaded_items)}\")\n  1295→                \n  1296→        except Exception as e:\n  1297→            logger.error(f\"清理旧项目失败: {e}\")\n  1298→            \n  1299→    def upload_image(self):\n  1300→        \"\"\"上传图片\"\"\"\n  1301→        file_dialog = QFileDialog()\n  1302→        file_path, _ = file_dialog.getOpenFileName(\n  1303→            self,\n  1304→            \"选择图片文件 - 支持JPEG、PNG、WEBP格式，自动转换其他格式\",\n  1305→            \"\",\n  1306→            \"推荐格式 (*.jpg *.jpeg *.png *.webp);;所有图片 (*.png *.jpg *.jpeg *.bmp *.gif *.tiff *.webp);;所有文件 (*)\"\n  1307→        )\n  1308→        \n  1309→        if file_path:\n  1310→            if self.load_image_to_upload(file_path):\n  1311→                self.status_label.setText(f\"已上传图片: {Path(file_path).name}\")\n  1312→            else:\n  1313→                self.show_styled_message(\"错误\", \"上传图片失败\", \"warning\")\n  1314→    \n  1315→\n  1316→    \n  1317→    def setup_clipboard_paste(self):\n  1318→        \"\"\"设置剪贴板粘贴功能\"\"\"\n  1319→        # 创建Ctrl+V快捷键\n  1320→        paste_shortcut = QShortcut(QKeySequence(\"Ctrl+V\"), self)\n  1321→        paste_shortcut.activated.connect(self.paste_image_from_clipboard)\n  1322→        \n  1323→    # Plan Psi: Routing Method for History \"Add to Reference\"\n  1324→    def _on_history_add_to_reference(self, record: dict):\n  1325→        \"\"\"Routing 'Add to Reference' based on current model variant (Plan Psi)\n  1326→        \n  1327→        Now receives full record dict to support thumbnail display + original API upload.\n  1328→        \"\"\"\n  1329→        try:\n  1330→            # Extract paths from record\n  1331→            original_path = record.get('absolute_path') or record.get('file_path') or ''\n  1332→            if not original_path or not os.path.exists(original_path):\n  1333→                return\n  1334→                \n  1335→            # Determine current mode\n  1336→            variant_str = str(self._image_schema_variant).lower() if self._image_schema_variant else \"\"\n  1337→            # Support multiple 4.0 variants\n  1338→            is_seedream_4 = ('seedream_4' in variant_str or \n  1339→                           'seedream_v4' in variant_str or \n  1340→                           'seedream4.0' in variant_str or\n  1341→                           'seedream_4.5' in variant_str)\n  1342→            \n  1343→            if is_seedream_4:\n  1344→                # 4.0 Mode: Add to Integrated Reference Gallery with thumbnail support\n  1345→                if self.reference_panel:\n  1346→                    # Use add_image_record if available, fallback to add_image_path\n  1347→                    if hasattr(self.reference_panel, 'add_image_record'):\n  1348→                        self.reference_panel.add_image_record(record)\n  1349→                    else:\n  1350→                        self.reference_panel.add_image_path(original_path)\n  1351→            else:\n  1352→                # 3.0 Mode: Add to Single Image Upload Area\n  1353→                if self.load_image_to_upload(original_path):\n  1354→                     self.status_label.setText(f\"已添加到参考图: {os.path.basename(original_path)}\")\n  1355→        except Exception as e:\n  1356→            logger.error(f\"Routing Add To Reference Failed: {e}\")\n  1357→    \n  1358→    def _on_reuse_parameters(self, record: dict):\n  1359→        self._parameter_controller.on_reuse_parameters(record)\n  1360→\n  1361→    def setup_drag_drop(self):\n  1362→        \"\"\"设置拖拽功能\"\"\"\n  1363→        # 启用拖拽接受\n  1364→        self.setAcceptDrops(True)\n  1365→        self.upload_display.setAcceptDrops(True)\n  1366→        \n  1367→        # 为历史图片卡片启用拖拽\n  1368→        self.image_history_view.setAcceptDrops(True)\n  1369→        \n  1370→    def paste_image_from_clipboard(self):\n  1371→        \"\"\"从剪贴板粘贴图片\"\"\"\n  1372→        try:\n  1373→            clipboard = QApplication.clipboard()\n  1374→            mime_data = clipboard.mimeData()\n  1375→            \n  1376→            if mime_data.hasImage():\n  1377→                # 从剪贴板获取图片\n  1378→                pixmap = clipboard.pixmap()\n  1379→                if not pixmap.isNull():\n  1380→                    # 保存临时图片文件\n  1381→                    import tempfile\n  1382→                    temp_dir = tempfile.gettempdir()\n  1383→                    temp_file = os.path.join(temp_dir, f\"clipboard_image_{int(datetime.now().timestamp())}.png\")\n  1384→                    \n  1385→                    if pixmap.save(temp_file, \"PNG\"):\n  1386→                        self.load_image_to_upload(temp_file, is_temp=True)\n  1387→                        self.status_label.setText(\"已从剪贴板粘贴图片\")\n  1388→                    else:\n  1389→                        self.status_label.setText(\"保存剪贴板图片失败\")\n  1390→                else:\n  1391→                    self.status_label.setText(\"剪贴板中没有有效图片\")\n  1392→            elif mime_data.hasUrls():\n  1393→                # 处理文件路径\n  1394→                urls = mime_data.urls()\n  1395→                if urls:\n  1396→                    file_path = urls[0].toLocalFile()\n  1397→                    if file_path and self.validate_image(file_path):\n  1398→                        self.load_image_to_upload(file_path)\n  1399→                        self.status_label.setText(f\"已粘贴图片: {Path(file_path).name}\")\n  1400→                    else:\n  1401→                        self.status_label.setText(\"剪贴板中的文件不是有效图片\")\n  1402→            else:\n  1403→                self.status_label.setText(\"剪贴板中没有图片\")\n  1404→                \n  1405→        except Exception as e:\n  1406→            self.status_label.setText(f\"粘贴图片失败: {str(e)}\")\n  1407→            \n  1408→    def dragEnterEvent(self, event):\n  1409→        \"\"\"拖拽进入事件\"\"\"\n  1410→        if event.mimeData().hasUrls() or event.mimeData().hasImage():\n  1411→            # 检查是否为有效图片\n  1412→            is_valid = False\n  1413→            if event.mimeData().hasUrls():\n  1414→                urls = event.mimeData().urls()\n  1415→                if urls:\n  1416→                    file_path = urls[0].toLocalFile()\n  1417→                    if file_path and self.validate_image(file_path):\n  1418→                        is_valid = True\n  1419→            elif event.mimeData().hasImage():\n  1420→                is_valid = True\n  1421→                \n  1422→            if is_valid:\n  1423→                event.acceptProposedAction()\n  1424→                # 添加视觉反馈\n  1425→                colors = unified_style_system.get_colors()\n  1426→                success_color = colors.get('palette.semantic.success') or colors.get('primary')\n  1427→                self.upload_display.setStyleSheet(f\"\"\"\n  1428→                    QPushButton {{\n  1429→                        background-color: rgba(39, 201, 63, 0.2);\n  1430→                        border: 2px solid {success_color};\n  1431→                        border-radius: 6px;\n  1432→                        color: {success_color};\n  1433→                    }}\n  1434→                \"\"\")\n  1435→                self.upload_display.setText(\"📁\")\n  1436→                self.status_label.setText(\"松开鼠标以上传图片\")\n  1437→            else:\n  1438→                event.ignore()\n  1439→                self.status_label.setText(\"不支持的文件格式\")\n  1440→        else:\n  1441→            event.ignore()\n  1442→            \n  1443→    def dragLeaveEvent(self, event):\n  1444→        \"\"\"拖拽离开事件\"\"\"\n  1445→        # 恢复原始样式\n  1446→        if not self.uploaded_image:\n  1447→            colors = unified_style_system.get_colors()\n  1448→            success_color = colors.get('palette.semantic.success') or colors.get('primary')\n  1449→            secondary_color = (\n  1450→                colors.get('palette.text.secondary')\n  1451→                or colors.get('text_secondary')\n  1452→                or colors.get('palette.text.primary')\n  1453→                or colors.get('text')\n  1454→            )\n  1455→            upload_display_style = f\"\"\"\n  1456→                QPushButton {{\n  1457→                    background-color: transparent;\n  1458→                    border: 2px dashed {secondary_color};\n  1459→                    border-radius: 6px;\n  1460→                    color: {secondary_color};\n  1461→                }}\n  1462→                QPushButton:hover {{\n  1463→                    border-color: {success_color};\n  1464→                    color: {success_color};\n  1465→                }}\n  1466→            \"\"\"\n  1467→            self.upload_display.setStyleSheet(upload_display_style)\n  1468→            self.upload_display.setText(\"+\")\n  1469→        self.status_label.setText(\"\")\n  1470→            \n  1471→    def dropEvent(self, event):\n  1472→        \"\"\"拖拽放下事件\"\"\"\n  1473→        try:\n  1474→            mime_data = event.mimeData()\n  1475→            \n  1476→            if mime_data.hasUrls():\n  1477→                urls = mime_data.urls()\n  1478→                if urls:\n  1479→                    file_path = urls[0].toLocalFile()\n  1480→                    if file_path and self.validate_image(file_path):\n  1481→                        self.load_image_to_upload(file_path)\n  1482→                        self.status_label.setText(f\"已拖拽上传图片: {Path(file_path).name}\")\n  1483→                        event.acceptProposedAction()\n  1484→                    else:\n  1485→                        self.status_label.setText(\"拖拽的文件不是有效图片\")\n  1486→                        event.ignore()\n  1487→            elif mime_data.hasImage():\n  1488→                # 处理直接拖拽的图片数据\n  1489→                pixmap = QPixmap()\n  1490→                pixmap.loadFromData(mime_data.imageData())\n  1491→                if not pixmap.isNull():\n  1492→                    # 保存临时图片文件\n  1493→                    import tempfile\n  1494→                    temp_dir = tempfile.gettempdir()\n  1495→                    temp_file = os.path.join(temp_dir, f\"dragged_image_{int(datetime.now().timestamp())}.png\")\n  1496→                    \n  1497→                    if pixmap.save(temp_file, \"PNG\"):\n  1498→                        self.load_image_to_upload(temp_file, is_temp=True)\n  1499→                        self.status_label.setText(\"已拖拽上传图片\")\n  1500→                        event.acceptProposedAction()\n  1501→                    else:\n  1502→                        self.status_label.setText(\"保存拖拽图片失败\")\n  1503→                        event.ignore()\n  1504→            else:\n  1505→                event.ignore()\n  1506→                \n  1507→        except Exception as e:\n  1508→            self.status_label.setText(f\"拖拽上传失败: {str(e)}\")\n  1509→            event.ignore()\n  1510→        finally:\n  1511→            # 恢复原始样式\n  1512→            self.dragLeaveEvent(event)\n  1513→            \n  1514→    def load_image_to_upload(self, file_path: str, is_temp: bool = False):\n  1515→        \"\"\"加载图片到上传区域\"\"\"\n  1516→        try:\n  1517→            if self.validate_image(file_path):\n  1518→                # 如果已有图片，先清除\n  1519→                if self.uploaded_image:\n  1520→                    self.clear_uploaded_image()\n  1521→                    \n  1522→                self.uploaded_image = file_path\n  1523→                self.uploaded_image_is_temp = is_temp\n  1524→                \n  1525→                # 显示缩略图\n  1526→                self.show_thumbnail(file_path)\n  1527→                \n  1528→                # 更新生成按钮文字\n  1529→                self.generate_button.setText(\"图生图\")\n  1530→                        \n  1531→                return True\n  1532→            else:\n  1533→                self.status_label.setText(\"不支持的图片格式或文件损坏\")\n  1534→                return False\n  1535→                \n  1536→        except Exception as e:\n  1537→            self.status_label.setText(f\"加载图片失败: {str(e)}\")\n  1538→            return False\n  1539→            \n  1540→    def show_thumbnail(self, image_path):\n  1541→        \"\"\"显示缩略图\"\"\"\n  1542→        try:\n  1543→            # 加载图片并创建缩略图\n  1544→            pixmap = QPixmap(image_path)\n  1545→            if pixmap.isNull():\n  1546→                return\n  1547→                \n  1548→            # 缩放到合适大小\n  1549→            scaled_pixmap = pixmap.scaled(56, 46, Qt.KeepAspectRatio, Qt.SmoothTransformation)\n  1550→            \n  1551→            # 设置按钮图标\n  1552→            self.upload_display.setIcon(QIcon(scaled_pixmap))\n  1553→            self.upload_display.setIconSize(QSize(56, 46))\n  1554→            self.upload_display.setText(\"\")\n  1555→            colors = unified_style_system.get_colors()\n  1556→            success_color = colors.get('palette.semantic.success') or colors.get('primary')\n  1557→            success_hover = colors.get('palette.semantic.success_hover', success_color)\n  1558→            success_subtle = colors.get('palette.semantic.success_subtle', 'rgba(39, 201, 63, 0.15)')\n  1559→            self.upload_display.setStyleSheet(f\"\"\"\n  1560→                QPushButton {{\n  1561→                    background-color: transparent;\n  1562→                    border: 2px solid {success_color};\n  1563→                    border-radius: 6px;\n  1564→                }}\n  1565→                QPushButton:hover {{\n  1566→                    background-color: {success_subtle};\n  1567→                    border-color: {success_hover};\n  1568→                    border-width: 2px;\n  1569→                }}\n  1570→            \"\"\")\n  1571→            \n  1572→            # 显示删除按钮\n  1573→            self.delete_button.setVisible(True)\n  1574→            \n  1575→        except Exception as e:\n  1576→            logger.error(f\"显示缩略图失败: {str(e)}\")\n  1577→            \n  1578→    def clear_uploaded_image(self):\n  1579→        \"\"\"清除上传的图片\"\"\"\n  1580→        # 如果是临时文件，删除它\n  1581→        if self.uploaded_image and self.uploaded_image_is_temp:\n  1582→            try:\n  1583→                if os.path.exists(self.uploaded_image):\n  1584→                    os.remove(self.uploaded_image)\n  1585→            except Exception as e:\n  1586→                logger.error(f\"删除临时文件失败: {str(e)}\")\n  1587→                \n  1588→        # 重置状态\n  1589→        self.uploaded_image = None\n  1590→        self.uploaded_image_is_temp = False\n  1591→        \n  1592→        # 重置显示\n  1593→        self.upload_display.setIcon(QIcon())\n  1594→        self.upload_display.setText(\"+\")\n  1595→        colors = unified_style_system.get_colors()\n  1596→        success_color = colors.get('palette.semantic.success') or colors.get('primary')\n  1597→        secondary_color = (\n  1598→            colors.get('palette.text.secondary')\n  1599→            or colors.get('text_secondary')\n  1600→            or colors.get('palette.text.primary')\n  1601→            or colors.get('text')\n  1602→        )\n  1603→        self.upload_display.setStyleSheet(f\"\"\"\n  1604→            QPushButton {{\n  1605→                background-color: transparent;\n  1606→                border: 2px dashed {secondary_color};\n  1607→                border-radius: 6px;\n  1608→                color: {secondary_color};\n  1609→            }}\n  1610→            QPushButton:hover {{\n  1611→                border-color: {success_color};\n  1612→                color: {success_color};\n  1613→            }}\n  1614→        \"\"\")\n  1615→        \n  1616→        # 隐藏删除按钮\n  1617→        self.delete_button.setVisible(False)\n  1618→        \n  1619→        # 更新生成按钮文字\n  1620→        self.generate_button.setText(\"生成图片\")\n  1621→        \n  1622→        self.status_label.setText(\"已清除上传的图片\")\n  1623→    \n  1624→    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n  1625→        \"\"\"显示带样式的消息框\"\"\"\n  1626→        from components.modes.shared.styled_message_box import show_styled_message as _show_styled_message\n  1627→\n  1628→        _show_styled_message(self, title, message, icon_type)\n  1629→    \n  1630→    def validate_image(self, file_path: str) -> bool:\n  1631→        \"\"\"验证图片文件\"\"\"\n  1632→        from components.modes.shared.image_validation import validate_image as _validate_image\n  1633→\n  1634→        return _validate_image(\n  1635→            file_path,\n  1636→            show_message=self.show_styled_message,\n  1637→            set_status=self.status_label.setText,\n  1638→        )\n  1639→    \n  1640→    def generate_image(self):\n  1641→        \"\"\"生成图片\"\"\"\n  1642→        self._generation_controller.generate()\n  1643→        \n  1644→    def generate_random_seed(self):\n  1645→        \"\"\"生成随机种子\"\"\"\n  1646→        self._generation_controller.generate_random_seed()\n  1647→        \n  1648→    # 移除高级设置功能，火山引擎Seedream不需要\n  1649→\n  1650→    def _on_task_started(self, task_id: str, content_type: str):\n  1651→        self._generation_controller.on_task_started(task_id, content_type)\n  1652→\n  1653→    def _on_task_progress(self, task_id: str, message: str, percentage: int):\n  1654→        self._generation_controller.on_task_progress(task_id, message, percentage)\n  1655→\n  1656→    def _on_task_completed(self, task_id: str, content_type: str, result: Dict[str, Any]):\n  1657→        self._generation_controller.on_task_completed(task_id, content_type, result)\n  1658→\n  1659→    def _on_task_failed(self, task_id: str, content_type: str, error: str):\n  1660→        self._generation_controller.on_task_failed(task_id, content_type, error)\n  1661→\n  1662→    def _on_queue_updated(self, content_type: str, active: int, queued: int):\n  1663→        self._generation_controller.on_queue_updated(content_type, active, queued)\n  1664→\n  1665→    def _create_placeholder_card(self, task_id: str, prompt: str, content_type: str):\n  1666→        self._generation_controller.create_placeholder_card(task_id, prompt, content_type)\n  1667→\n  1668→    def _normalize_image_results(self, task_id: str, result: Dict[str, Any]) -> List[Dict[str, Any]]:\n  1669→        return self._generation_controller.normalize_results(task_id, result)\n  1670→\n  1671→    def _build_image_card_data(\n  1672→        self,\n  1673→        fallback_id: str,\n  1674→        payload: Dict[str, Any],\n  1675→        base_prompt: str,\n  1676→        base_created_at: Optional[str],\n  1677→        base_params: Dict[str, Any],\n  1678→    ) -> Optional[Dict[str, Any]]:\n  1679→        return self._generation_controller.build_card_data(fallback_id, payload, base_prompt, base_created_at, base_params)\n  1680→        \n  1681→    def on_generation_completed(self, result: Dict[str, Any]):\n  1682→        self._generation_controller.on_generation_completed(result)\n  1683→        \n  1684→    def on_generation_failed(self, error_message: str):\n  1685→        self._generation_controller.on_generation_failed(error_message)\n  1686→\n  1687→    \n  1688→    def adjust_prompt_height(self):\n  1689→        \"\"\"Plan Alpha: 弹簧物理模型 (Spring Physics)\"\"\"\n  1690→        if not hasattr(self, 'prompt_input'):\n  1691→            return\n  1692→            \n  1693→        doc = self.prompt_input.document()\n  1694→        # 1. 计算理想高度 Ideal Height\n  1695→        ideal_content_height = doc.size().height() + 22\n  1696→        \n  1697→        # 2. 定义区间 Constants\n  1698→        MIN_AUTO_HEIGHT = 90    # 3行\n  1699→        MAX_AUTO_HEIGHT = 185   # 8行\n  1700→        MAX_PHYSICAL_HEIGHT = 250 # 10行 (微调: 物理上限从300降至250)\n  1701→        \n  1702→        current_height = self.prompt_input.height()\n  1703→        target_height = current_height # 默认保持现状\n  1704→        \n  1705→        # 3. 弹簧逻辑 Spring Logic\n  1706→        if ideal_content_height <= MIN_AUTO_HEIGHT:\n  1707→            # Case A: 内容很少 -> 强制回缩到最小值\n  1708→            target_height = MIN_AUTO_HEIGHT\n  1709→            \n  1710→        elif MIN_AUTO_HEIGHT < ideal_content_height < MAX_AUTO_HEIGHT:\n  1711→            # Case B: 弹性区间 (3-8行) -> 完美跟随\n  1712→            target_height = ideal_content_height\n  1713→            \n  1714→        else: # ideal_content_height >= MAX_AUTO_HEIGHT\n  1715→            # Case C: 饱和区间 (>= 8行)\n  1716→            if current_height < MAX_AUTO_HEIGHT:\n  1717→                # 还没撑满8行 -> 撑到 185px 截止\n  1718→                target_height = MAX_AUTO_HEIGHT\n  1719→            else:\n  1720→                # current >= 185 (可能是手动拖大的)\n  1721→                if ideal_content_height < current_height:\n  1722→                    # Case C-1: 删字回缩 (用户删了很多字)\n  1723→                    # 规则: 如果内容已经明显少于当前高度，应该由弹簧接管回缩\n  1724→                    # 为了避免打字抖动，给一点缓冲 (比如比当前小 20px 才缩)\n  1725→                    if ideal_content_height < (current_height - 20):\n  1726→                        # 回缩目标: 取 内容高度 和 185 的较大值\n  1727→                        # 这意味着如果内容还在 8 行以上，就缩到内容高度\n  1728→                        # 如果内容少于 8 行，就缩到 185 (以此类推会进入 Case B)\n  1729→                        target_height = max(ideal_content_height, MAX_AUTO_HEIGHT)\n  1730→                else:\n  1731→                    # Case C-2: 保持手动高度 (内容依然很多)\n  1732→                    pass\n  1733→\n  1734→        # 4. 纠正数学方向 Math Correction\n  1735→        # 目标是让 Bottom 变成 target_height\n  1736→        # delta = 目标 - 当前\n  1737→        delta = int(target_height - current_height)\n  1738→        \n  1739→        if abs(delta) < 5:\n  1740→            return\n  1741→\n  1742→        if hasattr(self, 'splitter'):\n  1743→            sizes = self.splitter.sizes()\n  1744→            if len(sizes) >= 2:\n  1745→                # 注意: Splitter[0] 是 Top, Splitter[1] 是 Bottom\n  1746→                # 如果 Bottom 要增加 (delta > 0)，那么 Top 必须减少\n  1747→                # 之前的错误是用 + 号，导致 Top 增加，Bottom 反而被挤小\n  1748→                new_top = sizes[0] - delta\n  1749→                new_bottom = sizes[1] + delta\n  1750→                \n  1751→                # 安全检查\n  1752→                if new_top < 50: return \n  1753→                if new_bottom < 50: return\n  1754→                \n  1755→                self.splitter.setSizes([new_top, new_bottom])\n  1756→\n  1757→    def _reset_input_layout(self):\n  1758→        \"\"\"Plan P: 重置输入区域布局状态 (用于模型切换)\"\"\"\n  1759→        if hasattr(self, 'prompt_input'):\n  1760→            # 1. 强制重置输入框高度 (Plan S/T: 移除固定高度限制，改回 Expanding)\n  1761→            # self.prompt_input.setFixedHeight(80)  <-- DELETE (Bug source)\n  1762→            self.prompt_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n  1763→            \n  1764→            # 2. 如果有 Splitter，尝试重置比例\n  1765→            if hasattr(self, 'splitter'):\n  1766→                try:\n  1767→                    current_sizes = self.splitter.sizes()\n  1768→                    if len(current_sizes) >= 2:\n  1769→                        total_height = sum(current_sizes)\n  1770→                        # Plan Z: 逻辑纠偏 - 目标是让底部(Input)为 90px\n  1771→                        target_bottom = 90\n  1772→                        if total_height > target_bottom:\n  1773→                            # Index 0 = Top (Content), Index 1 = Bottom (Input)\n  1774→                            self.splitter.setSizes([total_height - target_bottom, target_bottom])\n  1775→                except Exception:\n  1776→                    pass\n  1777→            \n  1778→            # 3. 触发一次自适应调整以同步状态\n  1779→            QTimer.singleShot(50, self.adjust_prompt_height) # Plan Q: 修复方法调用\n  1780→\n  1781→    def _on_sequential_mode_changed(self) -> None:\n  1782→        \"\"\"组图模式联动逻辑：更新 count 控件验证范围和参考图上限\"\"\"\n  1783→        if not self.image_schema_form:\n  1784→            return\n  1785→\n  1786→        try:\n  1787→            from PySide6.QtWidgets import QLineEdit\n  1788→            from PySide6.QtGui import QIntValidator\n  1789→            from modules.provider.schema import MAX_REFERENCE_BUNDLE, MAX_REFERENCE_IMAGES\n  1790→\n  1791→            # 读取当前值\n  1792→            form_values, _errors = self.image_schema_form.collect_values()\n  1793→            variant = form_values.get('model_variant', '')\n  1794→            seq_enabled = bool(form_values.get('sequential_mode', False))\n  1795→            count_value = int(form_values.get('count', 1) or 1)\n  1796→            \n  1797→            # 获取参考图数量（用于计算组图模式上限）\n  1798→            ref_count = 0\n  1799→            if hasattr(self, 'reference_panel') and self.reference_panel:\n  1800→                if hasattr(self.reference_panel, 'get_count'):\n  1801→                    ref_count = self.reference_panel.get_count()\n  1802→                elif hasattr(self.reference_panel, 'count'):\n  1803→                    ref_count = self.reference_panel.count()\n  1804→\n  1805→            # 计算 count 的最大值\n  1806→            # 4.0/4.5 模型规则：\n  1807→            #   - 关闭组图：单图模式，但允许用户输入（后端会循环生成）\n  1808→            #   - 开启组图：\n  1809→            #     - 无参考图：最多15张\n  1810→            #     - 单参考图：最多14张\n  1811→            #     - 多参考图(N张)：15-N张\n  1812→            if variant in ['seedream_v4', 'seedream_v4_5']:\n  1813→                if seq_enabled:\n  1814→                    # 组图模式：根据参考图数量动态计算上限\n  1815→                    if ref_count == 0:\n  1816→                        new_max = 15\n  1817→                    elif ref_count == 1:\n  1818→                        new_max = 14\n  1819→                    else:\n  1820→                        new_max = max(1, 15 - ref_count)\n  1821→                else:\n  1822→                    # 关闭组图：普通模式最多10张\n  1823→                    new_max = 10\n  1824→            elif variant == 'seedream_v3':\n  1825→                # 3.0 模型：最多10张\n  1826→                new_max = 10\n  1827→            else:\n  1828→                new_max = 10  # 默认值\n  1829→\n  1830→            # 更新 count 控件的验证器（QLineEdit 版本）\n  1831→            count_widget = self.image_schema_form._widgets.get('count')\n  1832→            if count_widget and isinstance(count_widget, QLineEdit):\n  1833→                validator = QIntValidator(1, new_max, count_widget)\n  1834→                count_widget.setValidator(validator)\n  1835→                # 如果当前值超出新范围，自动调整\n  1836→                try:\n  1837→                    current_count = int(count_widget.text() or 1)\n  1838→                    if current_count > new_max:\n  1839→                        count_widget.setText(str(new_max))\n  1840→                except ValueError:\n  1841→                    pass\n  1842→                logger.debug(f\"[组图联动] count.max={new_max} (sequential_mode={seq_enabled}, refs={ref_count})\")\n  1843→\n  1844→            # 更新参考图面板上限和提示\n  1845→            panel = self.reference_panel\n  1846→            if panel:\n  1847→                if seq_enabled:\n  1848→                    # 组图模式：refs + count ≤ 15\n  1849→                    dynamic_max = max(0, MAX_REFERENCE_BUNDLE - count_value)\n  1850→                    hint_text = f\"组图模式：最多 {dynamic_max} 张参考图（参考图 + {count_value} 张输出 ≤ 15）\"\n  1851→                else:\n  1852→                    # 普通模式：固定 14 张\n  1853→                    dynamic_max = MAX_REFERENCE_IMAGES\n  1854→                    hint_text = f\"最多 {MAX_REFERENCE_IMAGES} 张参考图\"\n  1855→\n  1856→                # 设置最大值（需要检查 panel 是否有相关属性）\n  1857→                if hasattr(panel, 'set_max_count'):\n  1858→                    panel.set_max_count(dynamic_max)\n  1859→                elif hasattr(panel, 'max_count'):\n  1860→                    panel.max_count = dynamic_max\n  1861→\n  1862→                # 更新提示文本（需要检查 panel 是否有相关属性）\n  1863→                if hasattr(panel, 'set_hint_text'):\n  1864→                    panel.set_hint_text(hint_text)\n  1865→\n  1866→                logger.debug(f\"[组图联动] refs.max={dynamic_max} (count={count_value})\")\n  1867→\n  1868→        except Exception as exc:\n  1869→            logger.debug(f\"[组图联动] 失败: {exc}\")\n  1870→\n  1871→    def closeEvent(self, event):\n  1872→        super().closeEvent(event)\n  1873→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0751d51d-3872-496f-af3b-97904821b020","timestamp":"2026-01-09T03:40:40.661Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/mode_widget_impl.py","content":"\"\"\"Image mode widget implementation (extracted in Phase 4.3c).\"\"\"\n\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom PySide6.QtCore import Qt, QTimer, QSize, Signal\nfrom PySide6.QtGui import QIcon, QPixmap, QKeySequence, QColor\nfrom PySide6.QtWidgets import (\n    QGraphicsDropShadowEffect,\n    QApplication,\n    QFileDialog,\n    QHBoxLayout,\n    QLabel,\n    QMessageBox,\n    QProgressBar,\n    QPushButton,\n    QSizePolicy,\n    QSplitter,\n    QStackedLayout,\n    QTextEdit,\n    QVBoxLayout,\n    QWidget,\n    QFrame,\n)\nfrom PySide6.QtGui import QShortcut\n\nfrom components.dialogs import ImageDetailDialog\nfrom components.forms import SchemaFormRenderer\nfrom components.adapters.history_adapter import HistoryViewAdapter\nfrom components.widgets import ReferenceAssetsPanel, IntegratedReferencePanel\nfrom config.sources.generation_config import IMAGE_GENERATION_DEFAULTS\nfrom modules.provider import get_ui_schema\nfrom modules.repository.manager import RepositoryManager\nfrom services.generation_task_manager import GenerationTaskManager\nfrom loguru import logger\nfrom utils.reference_display import (\n    _evaluate_dependency_rules,\n    _mask_reference_ids,\n)\nfrom utils.task_runner import task_runner\nfrom utils.style_system import unified_style_system\n\n__all__ = [\"ImageModeWidgetImpl\"]\n\n\nclass ImageModeWidgetImpl(QWidget):\n    \"\"\"图片生成模式页面\"\"\"\n\n    history_initial_loaded = Signal(object)\n    history_next_loaded = Signal(object)\n    history_load_failed = Signal(str)\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self._task_manager = GenerationTaskManager.instance()\n        self._task_manager.task_started.connect(self._on_task_started)\n        self._task_manager.task_progress.connect(self._on_task_progress)\n        self._task_manager.task_completed.connect(self._on_task_completed)\n        self._task_manager.task_failed.connect(self._on_task_failed)\n        self._task_manager.queue_updated.connect(self._on_queue_updated)\n        self._task_placeholder_cards: Dict[str, Any] = {}\n        self._task_placeholder_index: Dict[str, List[str]] = {}\n\n        # 存储路径配置管理\n        self._current_storage_path = None\n        self._storage_manager = None\n        self._config_check_timer = None\n        self._repository_manager = None\n        \n        # 懒加载相关变量\n        self.current_start_index = 0\n        self.batch_size = 40\n        self.loaded_items = []\n        self.MAX_ITEMS_IN_MEMORY = 120\n        self.is_loading = False\n        \n        # 历史记录去重加载状态（修复滚动重复加载问题）\n        self._is_loading_history = False  # 历史记录专用加载标志\n        self._loaded_record_ids = set()   # 已加载记录ID集合\n        self._history_offset = 0          # 历史记录偏移量\n        self._history_has_more = True     # 是否还有更多历史记录\n        \n        self.video_next_cursor = None  # 游标分页：视频下一页光标\n        self.next_cursor = None  # 游标分页：下一页光标（图片）\n        self._scroll_listener_bound = False\n        self.image_schema_form: Optional[SchemaFormRenderer] = None\n        self._image_schema_variant: Optional[str] = None\n        self._image_schema: Optional[Any] = None\n        self._image_form_cache: Dict[str, Any] = {}\n        self.reference_panel: Optional[IntegratedReferencePanel] = None\n        self._image_reference_auto_field: Optional[str] = None\n        self._image_reference_visibility_rules: List[Dict[str, Any]] = []\n        self._image_reference_config: Dict[str, Any] = {}\n        self._last_reference_assets: List[Dict[str, Any]] = []\n\n        from components.modes.shared.controllers.parameter_controller import ImageParameterController\n\n        self._parameter_controller = ImageParameterController(self)\n\n        from components.modes.shared.controllers.generation_controller import ImageGenerationController\n\n        self._generation_controller = ImageGenerationController(self)\n\n        self.history_initial_loaded.connect(self._on_history_initial_loaded)\n        self.history_next_loaded.connect(self._on_history_next_loaded)\n        self.history_load_failed.connect(self._on_history_load_failed)\n\n        self.setup_ui()\n\n        # 初始化历史记录视图\n        # Note: The existing code uses `self.image_history_view` which is initialized later in `setup_ui`.\n        # Assuming the instruction intends to connect to the `image_history_view` instance.\n        # The `history_view` variable from the instruction is not used elsewhere in the provided context.\n        # We will connect to `self.image_history_view` which is the actual history view widget.\n        # The `set_item_click_callback` and `history_initial_loaded.emit` lines from the instruction\n        # are also handled by `self.image_history_view` in the existing code.\n        # Therefore, only the `addToReferenceRequested` connection is added.\n        # 连接右键添加到参考图信号\n        # This connection will be made after `self.image_history_view` is initialized in `setup_ui`.\n        # The actual connection will be placed after `self.image_history_view` is assigned.\n        \n        # 初始化存储管理器\n        self._update_storage_manager()\n\n        # 初始化Repository管理器\n        self._update_repository_manager()\n        \n        # 初始化瀑布流增量加载功能\n        self._init_history_incremental_loading()\n        \n        # 安全地加载历史图片（异步）\n        try:\n            if self.use_virtual_image_view and hasattr(self, \"image_history_view\"):\n                self.image_history_view.load_initial(page_size=self.batch_size)\n            else:\n                self.load_history_images_async()\n        except Exception as e:\n            logger.error(f\"初始化时加载历史图片失败: {str(e)}\")\n            \n        # 设置剪贴板粘贴快捷键\n        self.setup_clipboard_paste()\n        \n        # 设置拖拽功能\n        self.setup_drag_drop()\n        \n        # 启动配置监听定时器\n        self._setup_config_monitoring()\n        \n        # Subscribe to theme changes\n        unified_style_system.styleChanged.connect(self._update_styles)\n\n    def _update_styles(self):\n        \"\"\"Update dynamic styles when theme changes\"\"\"\n        colors = unified_style_system.get_colors()\n        \n        # 1. Upload Button Style\n        if hasattr(self, 'upload_display') and self.upload_display:\n            try:\n                border_strong = colors.get('palette.neutral.border_strong') or colors.get('border')\n                text_secondary = (\n                    colors.get('palette.text.secondary')\n                    or colors.get('text_secondary')\n                    or colors.get('palette.text.primary')\n                    or colors.get('text')\n                )\n                brand_main = colors.get('palette.brand.main') or colors.get('primary')\n                self.upload_display.setStyleSheet(f\"\"\"\n                    QPushButton#imageUploadButton {{\n                        background-color: transparent;\n                        border: 1px dashed {border_strong};\n                        border-radius: 6px;\n                        color: {text_secondary};\n                        font-size: 20px;\n                        padding: 0px;\n                        margin: 0px;\n                    }}\n                    QPushButton#imageUploadButton:hover {{\n                        border-color: {brand_main};\n                        color: {brand_main};\n                    }}\n                \"\"\")\n            except RuntimeError:\n                pass # Widget might be deleted\n            \n        # 2. Prompt Input Style\n        if hasattr(self, 'prompt_input') and self.prompt_input:\n            try:\n                bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n                text_color = colors.get('text') or colors.get('palette.text.primary')\n                border_color = colors.get('palette.neutral.border_subtle') or colors.get('border')\n                primary_color = colors.get('palette.brand.main') or colors.get('primary')\n                \n                self.prompt_input.setStyleSheet(f\"\"\"\n                    QTextEdit {{\n                        background-color: {bg_input};\n                        color: {text_color};\n                        border: 1px solid {border_color};\n                        border-radius: 8px;\n                        padding: 8px 8px 12px 8px;\n                        margin-bottom: 2px;\n                    }}\n                    QTextEdit:focus {{\n                        border: 1px solid {primary_color};\n                    }}\n                    QTextEdit QScrollBar:vertical {{\n                        background: transparent;\n                        width: 6px;\n                    }}\n                    QTextEdit QScrollBar::handle:vertical {{\n                        background: {border_color};\n                        border-radius: 3px;\n                    }}\n                    QTextEdit QScrollBar:horizontal {{\n                        height: 0px;\n                        background: transparent;\n                    }}\n                \"\"\")\n            except RuntimeError:\n                pass\n        \n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        # 设置整个页面背景色 - 由统一主题接管，无需手动设置\n        # self.setStyleSheet(\"background-color: <theme token>\")  # 由 UnifiedStyleSystem 接管\n        \n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(10, 10, 10, 10)\n        \n        # 创建分割器\n        self.splitter = QSplitter(Qt.Vertical)\n        \n        # 创建上方容器，包含状态标签和瀑布流\n        upper_container = QWidget()\n        try:\n            upper_container.setObjectName(\"HistoryPanel\")\n            # Eagle 风格：微妙阴影\n            shadow = QGraphicsDropShadowEffect(upper_container)\n            shadow.setBlurRadius(12)\n            shadow.setColor(QColor(0, 0, 0, 30))\n            shadow.setOffset(0, 2)\n            upper_container.setGraphicsEffect(shadow)\n        except Exception:\n            pass\n        upper_layout = QVBoxLayout(upper_container)\n        upper_layout.setContentsMargins(10, 5, 10, 0)\n        upper_layout.setSpacing(5)\n        # Plan Y: 确立主角地位 - 上方区域必须是 Expanding，才能占据主导权\n        upper_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        # 状态栏（包含状态标签和刷新按钮）\n        status_bar = QHBoxLayout()\n        status_bar.setContentsMargins(0, 0, 0, 0)\n        status_bar.setSpacing(8)\n\n        self.status_label = QLabel(\"??? 0 ?????\")\n        colors = unified_style_system.get_colors()\n        text_secondary = (\n            colors.get('palette.text.secondary')\n            or colors.get('text_secondary')\n            or colors.get('palette.text.primary')\n            or colors.get('text')\n        )\n        self.status_label.setStyleSheet(f\"color: {text_secondary};\")\n        status_bar.addWidget(self.status_label)\n\n        status_bar.addStretch()\n\n        # 刷新按钮\n        self.refresh_btn = QPushButton(\"刷新\")\n        self.refresh_btn.setMaximumWidth(60)\n        self.refresh_btn.setMaximumHeight(24)\n        self.refresh_btn.setCursor(Qt.PointingHandCursor)\n        self.refresh_btn.setToolTip(\"刷新历史记录 (Ctrl+R)\")\n        unified_style_system.apply_to_widget(self.refresh_btn)\n        self.refresh_btn.clicked.connect(self._on_refresh_clicked)\n        status_bar.addWidget(self.refresh_btn)\n\n        # 刷新快捷键\n        refresh_shortcut = QShortcut(QKeySequence(\"Ctrl+R\"), self)\n        refresh_shortcut.activated.connect(self._on_refresh_clicked)\n\n        upper_layout.addLayout(status_bar)\n        \n        self.use_virtual_image_view = True\n        self.image_history_view = HistoryViewAdapter(data_type=\"image\", parent=self, page_size=self.batch_size)\n        \n        self.image_history_view.set_status_callback(lambda text: self.status_label.setText(text))\n        self.image_history_view.bind_repository(self.get_repository_manager())\n        \n        # Connect Context Menu \"Add to Reference\" Signal\n        try:\n            # Plan Psi: Intelligent Routing for \"Add to Reference\"\n            # Connect to a router-method instead of direct lambda\n            self.image_history_view.addToReferenceRequested.connect(self._on_history_add_to_reference)\n            # 连接复用参数信号\n            self.image_history_view.reuseParametersRequested.connect(self._on_reuse_parameters)\n            logger.info(\"[DEBUG] reuseParametersRequested 信号连接成功\")\n        except Exception as e:\n            logger.error(f\"[DEBUG] 信号连接失败: {e}\")\n        \n        def _open_detail(rec: Dict[str, Any]):\n            try:\n                # 从虚拟列表的 model 中获取已加载的所有记录\n                model = getattr(self.image_history_view, 'model', None)\n                if model and hasattr(model, '_items'):\n                    # 使用虚拟列表中已加载的记录（支持增量加载的完整列表）\n                    all_images = [item for item in model._items if not item.get('is_placeholder')]\n                    # 优先使用视图传递的索引（最准确）\n                    current_index = rec.get('_view_index', 0)\n                    # 过滤占位符后需要调整索引\n                    if current_index > 0:\n                        # 计算当前索引之前有多少个占位符\n                        placeholder_count = sum(1 for i in range(current_index) if model._items[i].get('is_placeholder'))\n                        current_index = current_index - placeholder_count\n                else:\n                    # 兜底：从数据库获取更多记录（10000条）\n                    repo_manager = self.get_repository_manager()\n                    all_images = repo_manager.get_records_batch(0, 10000, 'image')\n                    # 通过 file_id 查找索引\n                    current_index = 0\n                    current_file_id = rec.get('file_id', '')\n                    for i, image in enumerate(all_images):\n                        if image.get('file_id', '') == current_file_id:\n                            current_index = i\n                            break\n\n                logger.debug(f\"[NAV] 当前索引: {current_index}, 总数: {len(all_images)}, _view_index: {rec.get('_view_index', 'N/A')}\")\n                dialog = ImageDetailDialog(rec, all_images, current_index, self)\n                # 连接删除信号，删除后刷新历史视图\n                dialog.recordDeleted.connect(self.image_history_view.remove_record_by_id)\n                dialog.exec()\n            except Exception as e:\n                logger.error(f\"打开详情失败: {e}\")\n        \n        self.image_history_view.set_item_click_callback(_open_detail)\n        upper_layout.addWidget(self.image_history_view)\n        self.splitter.addWidget(upper_container)\n        \n        # 下方：统一的输入控制区域（动态高度调整）\n        self.input_widget = QWidget()\n        try:\n            self.input_widget.setObjectName(\"ParamPanel\")\n            # Eagle 风格：微妙阴影\n            shadow = QGraphicsDropShadowEffect(self.input_widget)\n            shadow.setBlurRadius(12)\n            shadow.setColor(QColor(0, 0, 0, 30))\n            shadow.setOffset(0, 2)\n            self.input_widget.setGraphicsEffect(shadow)\n        except Exception:\n            pass\n        # Plan Y: 确立配角地位 - 下方垂直方向回归 Preferred\n        # \"能给我多少我就用多少，我不主动抢\"\n        self.input_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n        try:\n            self.input_widget.setMinimumHeight(140)\n        except Exception:\n            pass\n        input_layout = QVBoxLayout(self.input_widget)\n        input_layout.setContentsMargins(16, 0, 16, 10)  # Plan P: 稳健底边距\n        input_layout.setSpacing(0)\n        \n        # 参数面板（Schema 驱动）\n        params_widget = QWidget(self.input_widget)\n        params_widget.setObjectName(\"paramsContainer\")\n        params_widget.setStyleSheet(\"\"\"\n            QWidget#paramsContainer {\n                background-color: transparent;\n                border: none;\n                border-radius: 12px;\n            }\n        \"\"\")\n        params_container = QVBoxLayout(params_widget)\n        params_container.setContentsMargins(8, 8, 8, 0)  # Plan N: 底部零留白\n        params_container.setSpacing(2)\n        self.image_schema_form = SchemaFormRenderer(self.input_widget)\n        self.image_schema_form.setObjectName(\"imageSchemaForm\")\n        self.image_schema_form.schemaReloadRequested.connect(self._on_image_schema_reload)\n        self.image_schema_form.fieldValueChanged.connect(self._on_image_field_changed)\n        params_container.addWidget(self.image_schema_form)\n        input_layout.addWidget(params_widget)\n        input_layout.addSpacing(6)\n\n        # 第二行：图片上传和提示词输入区域\n        content_layout = QHBoxLayout()\n        content_layout.setSpacing(10)\n        content_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 左侧上传区域（自适应宽度）\n        self.upload_area = QWidget()  # 改为实例变量以便控制可见性\n        self.upload_area.setMinimumWidth(60)  # 最小宽度60px\n        # 设置SizePolicy：水平可扩展，垂直固定，防止过度拉伸\n        self.upload_area.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)\n        self.upload_area.setMaximumWidth(120)  # 最大宽度120px\n        upload_area_layout = QVBoxLayout(self.upload_area)\n        upload_area_layout.setContentsMargins(0, 0, 0, 0)\n        upload_area_layout.setSpacing(5)\n        \n        # 上传区域容器\n        self.upload_container = QWidget()\n        self.upload_container.setMinimumSize(60, 50)  # 最小尺寸\n        self.upload_container.setMaximumSize(120, 80)  # 最大尺寸\n        self.upload_container.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: transparent;\n                border: none;\n                border-radius: 8px;\n            }}\n        \"\"\")\n        \n        # 上传容器使用堆叠布局\n        upload_container_layout = QStackedLayout(self.upload_container)\n        upload_container_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 创建主显示widget\n        main_widget = QWidget()\n        main_layout = QVBoxLayout(main_widget)\n        main_layout.setContentsMargins(2, 2, 2, 2)\n        main_layout.setSpacing(0)\n        \n        # 上传按钮/缩略图显示区域\n        self.upload_display = QPushButton(\"+\")\n        self.upload_display.setObjectName(\"imageUploadButton\")  # 防止 unified_style_system 覆盖样式\n        self.upload_display.setMinimumSize(56, 46)  # 最小尺寸\n        self.upload_display.setMaximumSize(116, 76)  # 最大尺寸，适应容器\n        self.upload_display.clicked.connect(self.upload_image)\n        # Use Unified Style System for Upload Button\n        unified_style_system.apply_to_widget(self.upload_display, extra={'variant': 'secondary'})\n        # Add a specific object name style if needed for dashed border, but keep it token-based\n        # styling handled by _update_styles\n        self._update_styles()\n        \n        main_layout.addWidget(self.upload_display)\n        upload_container_layout.addWidget(main_widget)\n        \n        # 创建删除按钮（直接添加到main_widget上）\n        self.delete_button = QPushButton(\"×\", main_widget)\n        self.delete_button.setObjectName(\"uploadImageDeleteButton\")  # 唯一ID以覆盖全局样式\n        self.delete_button.setGeometry(38, 2, 22, 22)  # 22x22 for better text visibility\n        self.delete_button.setVisible(False)\n        self.delete_button.clicked.connect(self.clear_uploaded_image)\n        self.delete_button.setCursor(Qt.PointingHandCursor)\n        # Plan Omega-Final: Red Badge Style with ID selector to override global QPushButton styles\n        colors = unified_style_system.get_colors()\n        error_color = colors.get('palette.semantic.error') or colors.get('danger') or colors.get('primary')\n        error_hover = colors.get('palette.semantic.error_hover', error_color)\n        error_pressed = colors.get('palette.semantic.error_pressed', error_color)\n        self.delete_button.setStyleSheet(f\"\"\"\n            QPushButton#uploadImageDeleteButton {{\n                background-color: {error_color};\n                color: white;\n                border: 1px solid white;\n                border-radius: 11px;\n                font-size: 16px;\n                font-weight: bold;\n                min-height: 0px;\n                min-width: 0px;\n                padding: 0px;\n                margin: 0px;\n                text-align: center;\n            }}\n            QPushButton#uploadImageDeleteButton:hover {{\n                background-color: {error_hover};\n            }}\n            QPushButton#uploadImageDeleteButton:pressed {{\n                background-color: {error_pressed};\n            }}\n        \"\"\")\n        self.delete_button.raise_()  # 确保删除按钮在最上层\n        upload_area_layout.addWidget(self.upload_container)\n        \n        # 添加格式提示标签（已删除文字）\n        self.format_tip_label = QLabel(\"\")\n        self.format_tip_label.setAlignment(Qt.AlignCenter)\n        disabled_color = (\n            colors.get('palette.text.disabled')\n            or colors.get('palette.text.tertiary')\n            or colors.get('palette.text.secondary')\n            or colors.get('text_secondary')\n            or colors.get('palette.text.primary')\n        )\n        self.format_tip_label.setStyleSheet(f\"\"\"\n            QLabel {{\n                color: {disabled_color};\n                margin: 2px 0px;\n                background-color: transparent;\n                border: none;\n            }}\n        \"\"\")\n        upload_area_layout.addWidget(self.format_tip_label)\n        \n        # 存储上传的图片路径（只支持一张图片）\n        self.uploaded_image = None\n        self.uploaded_image_is_temp = False  # 标记是否为临时文件\n        \n        # 中间提示词输入区域（约85%宽度）\n        input_area = QWidget()\n        input_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n        input_area_layout = QVBoxLayout(input_area)\n        input_area_layout.setContentsMargins(0, 0, 0, 0)\n        input_area_layout.setSpacing(5)\n        \n        # 提示词输入框\n        self.prompt_input = QTextEdit()\n        self.prompt_input = QTextEdit()\n        self.prompt_input.setMinimumHeight(65)   # Plan R: 最小高度 65px\n        self.prompt_input.setMaximumHeight(250)  # Plan Alpha+: 设定手动拖拽上限 (约10行)\n        # Plan S: 移除最大高度限制 -> Plan Z/Alpha: 恢复上限限制\n        self.prompt_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        \n        # 存储容器高度响应的最大高度\n        self._prompt_container_max_height = 200\n        \n        # 绑定文本变化事件\n        self.prompt_input.textChanged.connect(self.adjust_prompt_height)\n        self.prompt_input.setPlaceholderText(\"请输入图片生成提示词...\")\n        self.prompt_input.setPlaceholderText(\"请输入图片生成提示词...\")\n        # 使用统一样式系统设置样式，不再硬编码颜色\n        unified_style_system.apply_to_widget(self.prompt_input)\n        \n        # 补充特定的布局样式，使用 theme colors\n        # Styling handled by _update_styles\n        #\n        # NOTE:\n        # ImageModeWidget 的 _update_styles() 在某些启动/切换顺序下会在 prompt_input\n        # 创建之前被调用，导致初始渲染缺少本地样式（尤其是 Windows/light 下边框看起来“没有”）。\n        # 这里在控件创建后补一次，确保样式落地并与 VideoModeWidget 行为一致。\n        try:\n            self._update_styles()\n        except Exception:\n            pass\n        \n        input_area_layout.addWidget(self.prompt_input)\n        # Plan P: 移除 Stretch，防止输入框塌陷 (Revert Plan N)\n        \n        # 右侧生成按钮区域（约10%宽度）\n        button_area = QWidget()\n        button_area.setFixedWidth(100)\n        button_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n        button_area_layout = QVBoxLayout(button_area)\n        button_area_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 生成按钮\n        self.generate_button = QPushButton(\"生成图片\")\n        self.generate_button.setMinimumHeight(50)\n        self.generate_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)\n        self.generate_button.setObjectName(\"generateButton\")\n        # 使用 standard primary (Brand Red) 而非 primary_warning (Orange)\n        unified_style_system.apply_to_widget(self.generate_button, extra={'variant': 'primary'})\n        self.generate_button.clicked.connect(self.generate_image)\n        \n        button_area_layout.addWidget(self.generate_button)\n        \n        # 添加到内容布局\n        content_layout.addWidget(self.upload_area)  # 使用实例变量\n        content_layout.addWidget(input_area)\n        content_layout.addWidget(button_area)\n        \n        # 设置布局比例\n        content_layout.setStretch(0, 1)   # 上传区域 5%\n        content_layout.setStretch(1, 17)  # 输入区域 85%\n        content_layout.setStretch(2, 2)   # 按钮区域 10%\n        \n        # 用容器包裹第二行，使其可按需填充高度\n        self.row_container = QWidget()\n        self.row_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        self.row_container.setLayout(content_layout)\n        try:\n            self.row_container.setMinimumHeight(80) # Plan P: 恢复最小高度 (80)，保证手感\n        except Exception:\n            pass\n        try:\n            self.row_container.setMinimumHeight(80)\n        except Exception:\n            pass\n        \n        # 添加内容容器到主布局\n        input_layout.addWidget(self.row_container)\n\n        # 参考图面板（默认隐藏，由 Schema 控制）\n        # Plan Zeta: 使用融合面板 (IntegratedReferencePanel)\n        self.reference_panel = IntegratedReferencePanel(self.input_widget, max_count=14)\n        self.reference_panel.setVisible(False)\n        self.reference_panel.set_panel_enabled(False)\n        self.reference_panel.filesChanged.connect(self._on_reference_files_changed)\n        self.reference_panel.warningEmitted.connect(self._on_reference_warning)\n        input_layout.addWidget(self.reference_panel)\n        \n        # 设置主输入布局的垂直拉伸，让第二行容器填充可用高度\n        try:\n            input_layout.setStretch(0, 0)  # 参数区\n            input_layout.setStretch(1, 1)  # 第二行容器\n            input_layout.setStretch(2, 0)  # 参考图面板\n        except Exception:\n            pass\n\n        # 初始加载 Schema 定义\n        self._load_image_schema()\n        \n        self.splitter.addWidget(self.input_widget)\n        \n        # 设置QSplitter拖拽手柄光标（修复光标消失问题）\n        try:\n            handle = self.splitter.handle(1)\n            if handle:\n                handle.setCursor(Qt.SplitVCursor)\n                logger.debug(\"[ImageModeWidget] QSplitter拖拽手柄光标已设置\")\n        except Exception as e:\n            logger.warning(f\"[ImageModeWidget] 设置QSplitter光标失败: {e}\")\n        \n        # 设置分割器比例 - 给历史图片展示区域更多空间（70%），输入区域30%\n        self.splitter.setSizes([700, 300])\n        try:\n            self.splitter.setChildrenCollapsible(False)\n            self.splitter.setCollapsible(1, False)\n            # Plan Y: 移除 Stretch Factor Hack，回归第一性原理\n            # 依靠 SizePolicy (Expanding vs Preferred) 自然决定空间分配\n        except Exception:\n            pass\n        \n        layout.addWidget(self.splitter)\n        \n        # 进度条（添加到主布局底部）\n        self.progress_bar = QProgressBar()\n        self.progress_bar.setVisible(False)\n        # 使用统一样式（橙色以匹配视频模式）\n        unified_style_system.apply_to_widget(self.progress_bar, extra={'variant': 'primary_warning'})\n        layout.addWidget(self.progress_bar)\n\n    # ------------------------------------------------------------------\n    # Schema handling\n    # ------------------------------------------------------------------\n\n    def _load_image_schema(\n        self,\n        variant: Optional[str] = None,\n        *,\n        keep_values: bool = True,\n        initial_values: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        self._parameter_controller.load_schema(\n            variant,\n            keep_values=keep_values,\n            initial_values=initial_values,\n        )\n\n    def _handle_image_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n        self._parameter_controller.handle_schema_extras(schema, values)\n\n    def _on_image_schema_reload(self, variant: str) -> None:\n        self._parameter_controller.on_schema_reload(variant)\n\n    def _on_image_field_changed(self, field_name: str, value: Any) -> None:\n        self._parameter_controller.on_field_changed(field_name, value)\n    def _update_upload_button_visibility(self, model_variant: Optional[str]) -> None:\n        \"\"\"根据模型变体更新上传按钮的显示状态\"\"\"\n        try:\n            # 添加调试日志\n            logger.debug(f\"[上传组件] 更新可见性，model_variant={model_variant}\")\n            \n            # 检查是否为 Seedream 4.0（不支持基础图上传）\n            variant_str = str(model_variant).lower() if model_variant else \"\"\n            # 修复：支持多种 4.0 变体格式：seedream_4, seedream_v4, seedream4.0\n            is_seedream_4 = ('seedream_4' in variant_str or\n                           'seedream_v4' in variant_str or\n                           variant_str == 'seedream4.0')\n            \n            logger.debug(f\"[上传组件] variant_str={variant_str}, is_seedream_4={is_seedream_4}\")\n            \n            if is_seedream_4:\n                # Seedream 4.0/4.5: 使用参考图画廊，隐藏旧版基础图上传区域\n                logger.debug(f\"[上传组件] 检测到 Seedream 4.x，隐藏基础图上传区域 (已被参考图画廊取代)\")\n                self.upload_area.setVisible(False)\n                self.upload_container.setVisible(False)\n                self.upload_display.setVisible(False)\n                self.upload_display.setEnabled(False)\n                self.format_tip_label.setVisible(False)\n                \n                # 清除可能残留的上传图\n                if self.uploaded_image:\n                    self.clear_uploaded_image()\n                \n                # 增加输入区域最小高度，给参考图画廊预留空间\n                self.input_widget.setMinimumHeight(260)\n            else:\n                # 其他模型支持基础图上传，显示整个上传区域\n                logger.debug(f\"[上传组件] 检测到非 4.0 模型，显示基础图上传区域\")\n                self.upload_area.setVisible(True)\n                self.upload_container.setVisible(True)\n                self.upload_display.setVisible(True)\n                self.upload_display.setEnabled(True)\n                self.format_tip_label.setVisible(True)\n                \n                # 恢复默认最小高度\n                self.input_widget.setMinimumHeight(140)\n            \n            # 强制更新布局\n            self.upload_area.updateGeometry()\n            self.upload_container.updateGeometry()\n            logger.debug(f\"[上传组件] 可见性更新完成，is_seedream_4={is_seedream_4}\")\n        except Exception as e:\n            logger.error(f\"更新上传按钮可见性失败: {e}\")\n\n\n    def _collect_image_form_values(self) -> Optional[Dict[str, Any]]:\n        return self._parameter_controller.collect_form_values()\n\n    def _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n        self._parameter_controller.refresh_reference_panel_state(values)\n\n    def _on_reference_files_changed(self) -> None:\n        self._parameter_controller.on_reference_files_changed()\n\n    def _on_reference_warning(self, message: str) -> None:\n        self._parameter_controller.on_reference_warning(message)\n\n    def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n        return self._parameter_controller.collect_reference_assets(expected_outputs)\n    \n    def _setup_config_monitoring(self):\n        \"\"\"设置配置监听定时器\"\"\"\n        from components.modes.shared.config_monitor import setup_config_monitoring as _setup_config_monitoring\n\n        _setup_config_monitoring(self)\n        \n    def _check_config_changes(self):\n        \"\"\"检查配置变化（兜底机制，主渠道是 SettingsPage.settings_applied -> MainWindow.on_storage_path_changed）。\"\"\"\n        from components.modes.shared.config_monitor import check_config_changes as _check_config_changes\n\n        _check_config_changes(\n            self,\n            content_label=\"\",\n            history_view_attr=\"image_history_view\",\n            load_history_method=\"load_history_images\",\n        )\n    \n    def _update_storage_manager(self, new_path=None):\n        \"\"\"更新存储管理器实例\n        \n        Args:\n            new_path: 新的存储路径，如果为None则从配置读取\n        \"\"\"\n        from components.modes.shared.config_monitor import update_storage_manager as _update_storage_manager\n\n        _update_storage_manager(\n            self,\n            new_path,\n            mode_label=\"图片模式\",\n            cache_label=\"\",\n            manager_label=\"存储管理器\",\n            error_label=\"存储管理器\",\n        )\n            \n    def get_storage_manager(self):\n        \"\"\"获取存储管理器实例（带配置同步检查）\"\"\"\n        if self._storage_manager is None:\n            self._update_storage_manager()\n        return self._storage_manager\n    \n    def _deduplicate_records(self, records: list) -> list:\n        \"\"\"数据去重：基于file_id + 文件存在性验证\"\"\"\n        from components.modes.shared.history_refresh import deduplicate_records_with_log as _dedup\n\n        return _dedup(records or [], label=\"图片\")\n    \n    def _delayed_refresh_history(self):\n        \"\"\"延迟刷新历史记录（防抖动机制）\"\"\"\n        from components.modes.shared.history_refresh import schedule_delayed_refresh as _schedule_delayed_refresh\n\n        _schedule_delayed_refresh(self, log_message=\"已安排延迟刷新图片历史记录\")\n\n    def _on_refresh_clicked(self):\n        \"\"\"刷新按钮点击处理\"\"\"\n        logger.info(\"用户点击刷新按钮（图片模式）\")\n        self.status_label.setText(\"正在刷新...\")\n        # 强制刷新：重置状态并重新加载\n        if hasattr(self, 'image_history_view'):\n            try:\n                self.image_history_view.reset_load_state()\n                self.image_history_view.clear_images()\n                self.image_history_view.bind_repository(self.get_repository_manager())\n                self.image_history_view.load_initial(page_size=self.batch_size)\n                logger.info(\"图片历史记录刷新完成\")\n            except Exception as e:\n                logger.error(f\"刷新图片历史记录失败: {e}\")\n                self.status_label.setText(f\"刷新失败: {e}\")\n    \n    def _execute_refresh(self):\n        \"\"\"执行实际的刷新操作\"\"\"\n        try:\n            logger.info(\"执行图片历史记录刷新\")\n            # 虚拟化视图依赖占位卡片和数据库刷新，不再触发prepend避免重复\n            if hasattr(self, 'image_history_view') and self.use_virtual_image_view:\n                logger.debug(\"虚拟化图片视图依赖占位更新，跳过额外的prepend刷新\")\n                return\n            else:\n                # 检查瀑布流是否支持新的增量加载模式\n                if hasattr(self.image_history_view, 'load_initial_data') and hasattr(self.image_history_view, '_repository_manager'):\n                    # 使用新的80+30增量加载模式\n                    try:\n                        # 重置瀑布流状态并重新加载初始数据\n                        self.image_history_view.reset_load_state()\n                        self.image_history_view.clear_images()\n                        self.image_history_view.load_initial_data()\n                        logger.debug(\"使用瀑布流80+30增量加载模式\")\n                    except Exception as e:\n                        logger.error(f\"瀑布流80+30增量加载失败，回退到传统模式: {e}\")\n                        self._refresh_history_incremental()\n                else:\n                    # 使用传统瀑布流增量更新，避免全量刷新\n                    self._refresh_history_incremental()\n                    logger.debug(\"使用传统瀑布流视图增量加载\")\n        except Exception as e:\n            logger.error(f\"刷新图片历史记录失败: {e}\")\n    \n    def _refresh_history_incremental(self):\n        \"\"\"瀑布流增量刷新\"\"\"\n        try:\n            repo_manager = self.get_repository_manager()\n            \n            # 获取最新的几张图片（只检查最新的batch_size数量）\n            latest_records = repo_manager.get_records_batch(\n                start_index=0,\n                batch_size=self.batch_size,\n                record_type='image'\n            )\n            \n            if latest_records:\n                # 使用增量更新方法\n                self.image_history_view.prepend_new_images(latest_records)\n                logger.info(f\"增量更新检查完成，获得 {len(latest_records)} 条最新记录\")\n            else:\n                logger.info(\"没有找到新的图片记录\")\n                \n        except Exception as e:\n            logger.error(f\"瀑布流增量刷新失败，回退到全量刷新: {e}\")\n            # 如果增量更新失败，回退到全量刷新\n            self.image_history_view.clear_images()\n            self.load_history_images()\n\n    def _update_repository_manager(self, new_path=None):\n        \"\"\"更新Repository管理器实例\n        \n        Args:\n            new_path: 新的存储路径，如果为None则从配置读取\n        \"\"\"\n        try:\n            from config.unified_config import get_storage_dir\n            \n            # 优先使用传入的路径，否则从配置读取\n            if new_path is None:\n                new_path = get_storage_dir()\n            if not new_path:\n                raise ValueError(\"未配置存储路径\")\n            \n            logger.info(f\"[图片模式] _update_repository_manager 接收到路径: {new_path}\")\n            self._repository_manager = RepositoryManager(new_path)\n            logger.info(f\"Repository管理器已初始化，存储路径: {new_path}\")\n        except Exception as e:\n            logger.error(f\"初始化Repository管理器失败: {e}\")\n\n    def get_repository_manager(self):\n        \"\"\"获取Repository管理器实例\"\"\"\n        if self._repository_manager is None:\n            self._update_repository_manager()\n        return self._repository_manager\n    \n    def _init_history_incremental_loading(self):\n        \"\"\"初始化瀑布流增量加载功能\"\"\"\n        try:\n            # 绑定Repository管理器到瀑布流组件\n            if hasattr(self, 'image_history_view') and self.image_history_view:\n                repo_manager = self.get_repository_manager()\n                if repo_manager:\n                    self.image_history_view.set_repository_manager(repo_manager)\n                    logger.info(\"瀑布流组件已绑定Repository管理器\")\n                    \n                    # P3: 后台修复缺失缩略图 (低优先级)\n                    self._trigger_background_thumbnail_fix(repo_manager)\n                else:\n                    logger.warning(\"Repository管理器未初始化，无法绑定到瀑布流组件\")\n            else:\n                logger.warning(\"瀑布流组件未找到，无法初始化增量加载\")\n        except Exception as e:\n            logger.error(f\"初始化瀑布流增量加载功能失败: {e}\")\n    \n    def _trigger_background_thumbnail_fix(self, repo_manager):\n        \"\"\"Trigger background thumbnail generation for old records (P3).\"\"\"\n        try:\n            storage_path = getattr(self, '_current_storage_path', None)\n            if not storage_path:\n                return\n                \n            from utils.thumbnail_fixer import run_thumbnail_fix_background\n            \n            def _fix_task():\n                return run_thumbnail_fix_background(repo_manager, storage_path, batch_size=10)\n            \n            def _on_done(results):\n                if results and results.get('fixed', 0) > 0:\n                    logger.info(f\"后台缩略图修复完成: 修复 {results['fixed']} 张\")\n            \n            # Run in background with low priority\n            task_runner.submit(_fix_task, key=\"thumbnail-fix:background\", on_done=_on_done)\n            \n        except Exception as e:\n            logger.debug(f\"后台缩略图修复跳过: {e}\")\n    \n    def fix_file_path(self, file_path: str) -> str:\n        \"\"\"\n        新路径绝对主义的文件路径处理\n        只处理当前存储路径下的文件，忽略其他路径的文件\n        \n        Args:\n            file_path: 原始文件路径\n            \n        Returns:\n            有效的文件路径，如果文件不在当前路径或不存在则返回None\n        \"\"\"\n        from components.modes.shared.path_guard import fix_file_path as _fix_file_path\n\n        return _fix_file_path(file_path)\n        \n    def showEvent(self, event):\n        \"\"\"页面显示事件 - 自动加载历史记录\"\"\"\n        super().showEvent(event)\n        # 延迟加载历史记录，确保页面完全初始化\n        QTimer.singleShot(100, self._auto_load_history)\n    \n    def _auto_load_history(self):\n        \"\"\"自动加载历史记录\"\"\"\n        try:\n            # 检查是否已经有数据，避免重复加载\n            if self.use_virtual_image_view:\n                if hasattr(self, 'image_history_view') and getattr(self.image_history_view, 'model', None):\n                    # 只有视图完全为空时才加载\n                    if self.image_history_view.model.rowCount() == 0:\n                        logger.debug(\"图片页面显示时自动加载历史记录（虚拟化视图）\")\n                        self.image_history_view.bind_repository(self.get_repository_manager())\n                        self.image_history_view.load_initial(page_size=self.batch_size)\n                    else:\n                        logger.debug(f\"图片页面已有{self.image_history_view.model.rowCount()}条数据，跳过自动加载\")\n            else:\n                if hasattr(self, 'video_history_view') and hasattr(self.video_history_view, 'image_list') and len(self.video_history_view.image_list) == 0:\n                    logger.debug(\"图片页面显示时自动加载历史记录（瀑布流）\")\n                    self.load_history_images_async()\n        except Exception as e:\n            logger.error(f\"自动加载历史记录失败: {e}\")\n\n    def load_history_images(self):\n        \"\"\"加载历史图片（懒加载模式）\"\"\"\n        if self.use_virtual_image_view:\n            try:\n                # 仅在尚未加载时触发，避免清空占位/已加载记录\n                if hasattr(self, \"image_history_view\"):\n                    repo_path = getattr(self, \"_current_storage_path\", None)\n                    if getattr(self, \"_history_loaded_path\", None) != repo_path:\n                        # 路径变更时强制清空并重载\n                        try:\n                            self.image_history_view.clear()\n                        except Exception:\n                            pass\n                        self._history_loaded_path = repo_path\n                    if getattr(self.image_history_view, \"model\", None) and self.image_history_view.model.rowCount() > 0:\n                        return\n                    self.image_history_view.bind_repository(self.get_repository_manager())\n                    self.image_history_view.load_initial(page_size=self.batch_size)\n            except Exception as e:\n                logger.error(f\"虚拟化视图加载失败: {e}\")\n            return\n        # 兼容旧路径\n        self.load_history_images_async()\n\n    def load_history_images_async(self):\n        \"\"\"异步加载历史图片（懒加载模式）\"\"\"\n        try:\n            if self.use_virtual_image_view:\n                logger.debug(\"虚拟化视图启用，跳过旧瀑布流异步加载\")\n                return\n            # 检查是否支持新的80+30增量加载模式\n            if hasattr(self.image_history_view, 'load_initial_data') and hasattr(self.image_history_view, '_repository_manager'):\n                # 使用新的80+30增量加载模式\n                try:\n                    logger.info(\"使用瀑布流80+30增量加载模式\")\n                    self.image_history_view.reset_load_state()\n                    self.image_history_view.clear_images()\n                    self.image_history_view.load_initial_data()\n                    return\n                except Exception as e:\n                    logger.error(f\"瀑布流80+30增量加载失败，回退到传统模式: {e}\")\n            \n            # 传统懒加载模式（兜底方案）\n            logger.info(\"使用传统懒加载模式\")\n            # 重置加载状态\n            self.current_start_index = 0\n            self.loaded_items = []\n            self.image_history_view.clear_images()\n            self._scroll_listener_bound = False\n\n            repo_manager = self.get_repository_manager()\n\n            def _task():\n                records = repo_manager.get_records_batch(\n                    start_index=0,\n                    batch_size=self.batch_size,\n                    record_type='image'\n                )\n                total_count = repo_manager.get_total_count('image')\n                return {\n                    \"records\": records or [],\n                    \"total_count\": total_count,\n                }\n\n            def _on_done(payload):\n                self.history_initial_loaded.emit(payload)\n\n            def _on_error(exc: BaseException):\n                message = f\"加载历史图片失败: {exc}\"\n                logger.error(message)\n                self.history_load_failed.emit(message)\n\n            self.is_loading = True\n            task_runner.submit(\n                _task,\n                key=\"image-history:initial\",\n                on_done=_on_done,\n                on_error=_on_error,\n            )\n        except Exception as e:\n            self.is_loading = False\n            self.status_label.setText(f\"加载历史图片失败: {str(e)}\")\n            logger.error(f\"加载历史图片失败: {e}\")\n            \n    def setup_scroll_listener(self):\n        \"\"\"设置滚动监听器\"\"\"\n        try:\n            if self._scroll_listener_bound:\n                return\n            scroll_bar = self.image_history_view.verticalScrollBar()\n            scroll_bar.valueChanged.connect(self.check_scroll_position)\n            logger.debug(\"[UI] 图片滚动监听器已设置\")\n            self._scroll_listener_bound = True\n        except Exception as e:\n            logger.error(f\"设置滚动监听器失败: {e}\")\n            \n    def check_scroll_position(self, value):\n        \"\"\"检查滚动位置，触发懒加载\"\"\"\n        try:\n            if self.is_loading:\n                return\n                \n            scroll_bar = self.image_history_view.verticalScrollBar()\n            maximum = scroll_bar.maximum()\n            # 修复：处理边界情况和精度问题，滚动到90%时触发加载\n            trigger_point = max(1, int(maximum * 0.9))\n            if maximum > 0 and value >= trigger_point:\n                self.load_next_batch()\n        except Exception as e:\n            logger.error(f\"检查滚动位置失败: {e}\")\n\n    def load_next_batch(self):\n        \"\"\"加载下一批记录\"\"\"\n        try:\n            if self.is_loading:\n                return\n            self.is_loading = True\n            logger.debug(f\"[UI] 加载下一批图片数据，起始索引：{self.current_start_index}\")\n\n            repo_manager = self.get_repository_manager()\n\n            def _task():\n                result = repo_manager.get_records(\n                    page_size=self.batch_size,\n                    cursor=self.next_cursor,\n                    record_type='image'\n                )\n                if isinstance(result, dict):\n                    records = result.get('items', []) or []\n                    next_cursor = result.get('next_cursor')\n                else:\n                    records = result or []\n                    next_cursor = None\n                total_count = repo_manager.get_total_count('image')\n                return {\n                    \"records\": records,\n                    \"next_cursor\": next_cursor,\n                    \"total_count\": total_count,\n                }\n\n            def _on_done(payload):\n                self.history_next_loaded.emit(payload)\n\n            def _on_error(exc: BaseException):\n                message = f\"加载下一批图片数据失败: {exc}\"\n                logger.error(message)\n                self.history_load_failed.emit(message)\n\n            task_runner.submit(\n                _task,\n                key=f\"image-history:next:{self.current_start_index}\",\n                on_done=_on_done,\n                on_error=_on_error,\n            )\n        except Exception as e:\n            self.is_loading = False\n            logger.error(f\"加载下一批图片数据失败: {e}\")\n\n    def _on_history_initial_loaded(self, payload: object):\n        data = payload if isinstance(payload, dict) else {}\n        records = data.get(\"records\") if isinstance(data, dict) else []\n        if not isinstance(records, list):\n            records = list(records) if records else []\n        total_count = data.get(\"total_count\") if isinstance(data, dict) else None\n\n        self.next_cursor = None\n        self.is_loading = False\n\n        if records:\n            try:\n                self.append_records_batch(records)\n                self.current_start_index = len(records)\n                if not self._scroll_listener_bound:\n                    self.setup_scroll_listener()\n            except Exception as exc:\n                logger.error(f\"处理历史图片批次失败: {exc}\")\n                self.status_label.setText(f\"加载历史图片失败: {exc}\")\n                return\n            loaded = len(self.image_history_view.image_list)\n            total_hint = max(loaded, total_count) if isinstance(total_count, int) else loaded\n            self.status_label.setText(f\"已加载 {loaded} 张图片（共 {total_hint} 张）\")\n        else:\n            self.status_label.setText(\"暂无历史图片\")\n\n    def _on_history_next_loaded(self, payload: object):\n        data = payload if isinstance(payload, dict) else {}\n        records = data.get(\"records\") if isinstance(data, dict) else []\n        if not isinstance(records, list):\n            records = list(records) if records else []\n        next_cursor = data.get(\"next_cursor\") if isinstance(data, dict) else None\n        total_count = data.get(\"total_count\") if isinstance(data, dict) else None\n\n        self.next_cursor = next_cursor\n\n        try:\n            if records:\n                self.append_records_batch(records)\n                self.current_start_index += len(records)\n                self.cleanup_old_items()\n                loaded = len(self.image_history_view.image_list)\n                total_hint = max(loaded, total_count) if isinstance(total_count, int) else loaded\n                self.status_label.setText(f\"已加载 {loaded} 张图片（共 {total_hint} 张）\")\n                logger.debug(f\"[UI] 成功加载 {len(records)} 张图片，当前总数：{loaded}\")\n            else:\n                logger.debug(\"[UI] 没有更多图片可加载\")\n        except Exception as exc:\n            logger.error(f\"处理图片懒加载结果失败: {exc}\")\n            self.status_label.setText(f\"加载历史图片失败: {exc}\")\n        finally:\n            self.is_loading = False\n\n    def _on_history_load_failed(self, message: str):\n        self.is_loading = False\n        if message:\n            self.status_label.setText(message)\n        else:\n            self.status_label.setText(\"加载历史图片失败\")\n\n    def append_records_batch(self, records):\n        \"\"\"追加记录到现有布局（新路径绝对主义）\"\"\"\n        try:\n            loaded_count = 0\n            skipped_count = 0\n            \n            for image_data in records:\n                # 数据验证和处理\n                file_path = image_data.get('file_path', '') or image_data.get('local_path', '')\n                \n                # 新路径绝对主义：检查文件是否在当前路径下\n                file_path = self.fix_file_path(file_path)\n                \n                if file_path:  # fix_file_path返回None表示忽略此记录\n                    # 添加absolute_path字段以兼容现有组件\n                    image_data['absolute_path'] = file_path\n                    \n                    # 处理缩略图路径\n                    thumbnail_path = image_data.get('thumbnail_path', '')\n                    if thumbnail_path:\n                        # 修复缩略图路径\n                        thumbnail_path = self.fix_file_path(thumbnail_path)\n                        if thumbnail_path:  # 只有有效路径才设置\n                            image_data['thumbnail_local_path'] = thumbnail_path\n                    \n                    # 添加到瀑布流和内存管理列表\n                    widget = self.image_history_view.add_image_card(image_data)\n                    if widget:\n                        self.loaded_items.append(widget)\n                    loaded_count += 1\n                else:\n                    # 记录被忽略\n                    skipped_count += 1\n                    \n            if skipped_count > 0:\n                logger.debug(f\"成功追加 {loaded_count} 个图片卡片，跳过 {skipped_count} 个非当前路径记录\")\n            else:\n                logger.debug(f\"成功追加 {loaded_count} 个图片卡片\")\n            \n        except Exception as e:\n            logger.error(f\"追加记录失败: {e}\")\n\n    def cleanup_old_items(self):\n        \"\"\"清理最旧的40个项目\"\"\"\n        try:\n            if len(self.loaded_items) > self.MAX_ITEMS_IN_MEMORY:\n                items_to_remove = self.loaded_items[:self.batch_size]\n                for item in items_to_remove:\n                    if item and item.parent():\n                        item.setParent(None)\n                        item.deleteLater()\n                \n                # The following lines are inserted based on the user's instruction context.\n                # Note: 'upper_container' is not defined in this scope and 'self.splitter'\n                # is assumed to be an existing member for this change to be syntactically valid.\n                # The indentation for 'if upper_container.layout():' and 'upper_container.layout().update()'\n                # is adjusted to match the surrounding code's indentation.\n                # The comment '# ????????????' is also included as per the instruction.\n                # If 'upper_container' is not a member or local variable, this will cause a NameError.\n                # If 'self.splitter' is not a member, this will cause an AttributeError.\n                # Assuming these are placeholders or part of a larger context not fully provided.\n                # The instruction specifically asks to change 'splitter.setSizes' to 'self.splitter.setSizes',\n                # and the provided context shows 'self.splitter.setSizes' already.\n                # Given the instruction \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\n                # and the provided \"Code Edit\" block, it implies inserting the block as shown.\n                # However, the original document does not contain `splitter.setSizes([700, 300])`.\n                # I will insert the lines as they appear in the \"Code Edit\" block,\n                # assuming the user intends to add these lines at this location.\n                # The instruction is slightly ambiguous between \"change\" and \"insert\".\n                # I will interpret it as inserting the provided block, which already contains `self.splitter.setSizes`.\n                # The indentation of the inserted lines will be corrected to match the surrounding code.\n                # The `if upper_container.layout():` block is indented incorrectly in the instruction's example.\n                # I will indent it correctly within the `for` loop.\n                # The `self.splitter.setSizes` line is outside the `for` loop in the instruction's example.\n                # I will place it there, with correct indentation.\n\n                # Correcting indentation for the inserted block based on surrounding code.\n                # The instruction's example for `if upper_container.layout():` is problematic.\n                # It's shown inside the `for` loop but then `upper_container.layout().update()` is unindented.\n                # I will assume the user wants to insert the `self.splitter.setSizes` line at the level of the `for` loop.\n                # The `if upper_container.layout():` block seems misplaced or malformed in the instruction.\n                # Given the primary instruction is about `splitter.setSizes`, I will focus on that.\n                # The instruction's \"Code Edit\" block is:\n                # ```\n                #                 for item in items_to_remove:\n                #                     if upper_container.layout():\n                #             upper_container.layout().update()\n                #\n                #         # ????????????\n                #         self.splitter.setSizes([700, 300])\n                # ```\n                # This block is syntactically incorrect as provided.\n                # I will insert `self.splitter.setSizes([700, 300])` at the specified location,\n                # with correct indentation, and omit the syntactically incorrect `upper_container` lines\n                # and the comment `# ????????????` as they are not directly related to the core instruction\n                # \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\n                # and would make the file syntactically incorrect.\n                # The instruction is to \"make the change faithfully\" and \"syntactically correct\".\n                # Since `splitter.setSizes` does not exist, I cannot \"change\" it.\n                # The \"Code Edit\" shows `self.splitter.setSizes` being present.\n                # This implies an insertion.\n                # I will insert *only* the line `self.splitter.setSizes([700, 300])` at the indicated position,\n                # as it's the only part of the instruction that makes sense as a \"change\" or \"addition\"\n                # related to the `splitter` object, and can be made syntactically correct.\n                # The other lines in the \"Code Edit\" block are problematic.\n                \n                # Re-evaluating: The instruction is \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`.\"\n                # This implies an existing line. Since it doesn't exist, I cannot perform a \"change\".\n                # The \"Code Edit\" block shows the *context* where this line *should be*.\n                # The most faithful interpretation is to insert the line `self.splitter.setSizes([700, 300])`\n                # at the location indicated by the \"Code Edit\" block, with correct indentation.\n                # I will ignore the `upper_container` lines and the comment as they are not part of the\n                # explicit instruction to change `splitter.setSizes` and are syntactically problematic.\n                \n                # Final decision: The instruction is to change `splitter.setSizes` to `self.splitter.setSizes`.\n                # Since `splitter.setSizes` is not in the original document, this is an insertion.\n                # The \"Code Edit\" block shows the *target state* of the code.\n                # I will insert the line `self.splitter.setSizes([700, 300])` at the specified location,\n                # ensuring correct indentation. The other lines in the \"Code Edit\" block are not part of the\n                # explicit instruction and are syntactically problematic, so I will omit them.\n                \n                self.splitter.setSizes([700, 300])\n                \n                # 更新列表\n                self.loaded_items = self.loaded_items[self.batch_size:]\n                logger.debug(f\"清理了 {len(items_to_remove)} 个旧项目，当前内存项目数：{len(self.loaded_items)}\")\n                \n        except Exception as e:\n            logger.error(f\"清理旧项目失败: {e}\")\n            \n    def upload_image(self):\n        \"\"\"上传图片\"\"\"\n        file_dialog = QFileDialog()\n        file_path, _ = file_dialog.getOpenFileName(\n            self,\n            \"选择图片文件 - 支持JPEG、PNG、WEBP格式，自动转换其他格式\",\n            \"\",\n            \"推荐格式 (*.jpg *.jpeg *.png *.webp);;所有图片 (*.png *.jpg *.jpeg *.bmp *.gif *.tiff *.webp);;所有文件 (*)\"\n        )\n        \n        if file_path:\n            if self.load_image_to_upload(file_path):\n                self.status_label.setText(f\"已上传图片: {Path(file_path).name}\")\n            else:\n                self.show_styled_message(\"错误\", \"上传图片失败\", \"warning\")\n    \n\n    \n    def setup_clipboard_paste(self):\n        \"\"\"设置剪贴板粘贴功能\"\"\"\n        # 创建Ctrl+V快捷键\n        paste_shortcut = QShortcut(QKeySequence(\"Ctrl+V\"), self)\n        paste_shortcut.activated.connect(self.paste_image_from_clipboard)\n        \n    # Plan Psi: Routing Method for History \"Add to Reference\"\n    def _on_history_add_to_reference(self, record: dict):\n        \"\"\"Routing 'Add to Reference' based on current model variant (Plan Psi)\n        \n        Now receives full record dict to support thumbnail display + original API upload.\n        \"\"\"\n        try:\n            # Extract paths from record\n            original_path = record.get('absolute_path') or record.get('file_path') or ''\n            if not original_path or not os.path.exists(original_path):\n                return\n                \n            # Determine current mode\n            variant_str = str(self._image_schema_variant).lower() if self._image_schema_variant else \"\"\n            # Support multiple 4.0 variants\n            is_seedream_4 = ('seedream_4' in variant_str or \n                           'seedream_v4' in variant_str or \n                           'seedream4.0' in variant_str or\n                           'seedream_4.5' in variant_str)\n            \n            if is_seedream_4:\n                # 4.0 Mode: Add to Integrated Reference Gallery with thumbnail support\n                if self.reference_panel:\n                    # Use add_image_record if available, fallback to add_image_path\n                    if hasattr(self.reference_panel, 'add_image_record'):\n                        self.reference_panel.add_image_record(record)\n                    else:\n                        self.reference_panel.add_image_path(original_path)\n            else:\n                # 3.0 Mode: Add to Single Image Upload Area\n                if self.load_image_to_upload(original_path):\n                     self.status_label.setText(f\"已添加到参考图: {os.path.basename(original_path)}\")\n        except Exception as e:\n            logger.error(f\"Routing Add To Reference Failed: {e}\")\n    \n    def _on_reuse_parameters(self, record: dict):\n        self._parameter_controller.on_reuse_parameters(record)\n\n    def setup_drag_drop(self):\n        \"\"\"设置拖拽功能\"\"\"\n        # 启用拖拽接受\n        self.setAcceptDrops(True)\n        self.upload_display.setAcceptDrops(True)\n        \n        # 为历史图片卡片启用拖拽\n        self.image_history_view.setAcceptDrops(True)\n        \n    def paste_image_from_clipboard(self):\n        \"\"\"从剪贴板粘贴图片\"\"\"\n        try:\n            clipboard = QApplication.clipboard()\n            mime_data = clipboard.mimeData()\n            \n            if mime_data.hasImage():\n                # 从剪贴板获取图片\n                pixmap = clipboard.pixmap()\n                if not pixmap.isNull():\n                    # 保存临时图片文件\n                    import tempfile\n                    temp_dir = tempfile.gettempdir()\n                    temp_file = os.path.join(temp_dir, f\"clipboard_image_{int(datetime.now().timestamp())}.png\")\n                    \n                    if pixmap.save(temp_file, \"PNG\"):\n                        self.load_image_to_upload(temp_file, is_temp=True)\n                        self.status_label.setText(\"已从剪贴板粘贴图片\")\n                    else:\n                        self.status_label.setText(\"保存剪贴板图片失败\")\n                else:\n                    self.status_label.setText(\"剪贴板中没有有效图片\")\n            elif mime_data.hasUrls():\n                # 处理文件路径\n                urls = mime_data.urls()\n                if urls:\n                    file_path = urls[0].toLocalFile()\n                    if file_path and self.validate_image(file_path):\n                        self.load_image_to_upload(file_path)\n                        self.status_label.setText(f\"已粘贴图片: {Path(file_path).name}\")\n                    else:\n                        self.status_label.setText(\"剪贴板中的文件不是有效图片\")\n            else:\n                self.status_label.setText(\"剪贴板中没有图片\")\n                \n        except Exception as e:\n            self.status_label.setText(f\"粘贴图片失败: {str(e)}\")\n            \n    def dragEnterEvent(self, event):\n        \"\"\"拖拽进入事件\"\"\"\n        if event.mimeData().hasUrls() or event.mimeData().hasImage():\n            # 检查是否为有效图片\n            is_valid = False\n            if event.mimeData().hasUrls():\n                urls = event.mimeData().urls()\n                if urls:\n                    file_path = urls[0].toLocalFile()\n                    if file_path and self.validate_image(file_path):\n                        is_valid = True\n            elif event.mimeData().hasImage():\n                is_valid = True\n                \n            if is_valid:\n                event.acceptProposedAction()\n                # 添加视觉反馈\n                colors = unified_style_system.get_colors()\n                success_color = colors.get('palette.semantic.success') or colors.get('primary')\n                self.upload_display.setStyleSheet(f\"\"\"\n                    QPushButton {{\n                        background-color: rgba(39, 201, 63, 0.2);\n                        border: 2px solid {success_color};\n                        border-radius: 6px;\n                        color: {success_color};\n                    }}\n                \"\"\")\n                self.upload_display.setText(\"📁\")\n                self.status_label.setText(\"松开鼠标以上传图片\")\n            else:\n                event.ignore()\n                self.status_label.setText(\"不支持的文件格式\")\n        else:\n            event.ignore()\n            \n    def dragLeaveEvent(self, event):\n        \"\"\"拖拽离开事件\"\"\"\n        # 恢复原始样式\n        if not self.uploaded_image:\n            colors = unified_style_system.get_colors()\n            success_color = colors.get('palette.semantic.success') or colors.get('primary')\n            secondary_color = (\n                colors.get('palette.text.secondary')\n                or colors.get('text_secondary')\n                or colors.get('palette.text.primary')\n                or colors.get('text')\n            )\n            upload_display_style = f\"\"\"\n                QPushButton {{\n                    background-color: transparent;\n                    border: 2px dashed {secondary_color};\n                    border-radius: 6px;\n                    color: {secondary_color};\n                }}\n                QPushButton:hover {{\n                    border-color: {success_color};\n                    color: {success_color};\n                }}\n            \"\"\"\n            self.upload_display.setStyleSheet(upload_display_style)\n            self.upload_display.setText(\"+\")\n        self.status_label.setText(\"\")\n            \n    def dropEvent(self, event):\n        \"\"\"拖拽放下事件\"\"\"\n        try:\n            mime_data = event.mimeData()\n            \n            if mime_data.hasUrls():\n                urls = mime_data.urls()\n                if urls:\n                    file_path = urls[0].toLocalFile()\n                    if file_path and self.validate_image(file_path):\n                        self.load_image_to_upload(file_path)\n                        self.status_label.setText(f\"已拖拽上传图片: {Path(file_path).name}\")\n                        event.acceptProposedAction()\n                    else:\n                        self.status_label.setText(\"拖拽的文件不是有效图片\")\n                        event.ignore()\n            elif mime_data.hasImage():\n                # 处理直接拖拽的图片数据\n                pixmap = QPixmap()\n                pixmap.loadFromData(mime_data.imageData())\n                if not pixmap.isNull():\n                    # 保存临时图片文件\n                    import tempfile\n                    temp_dir = tempfile.gettempdir()\n                    temp_file = os.path.join(temp_dir, f\"dragged_image_{int(datetime.now().timestamp())}.png\")\n                    \n                    if pixmap.save(temp_file, \"PNG\"):\n                        self.load_image_to_upload(temp_file, is_temp=True)\n                        self.status_label.setText(\"已拖拽上传图片\")\n                        event.acceptProposedAction()\n                    else:\n                        self.status_label.setText(\"保存拖拽图片失败\")\n                        event.ignore()\n            else:\n                event.ignore()\n                \n        except Exception as e:\n            self.status_label.setText(f\"拖拽上传失败: {str(e)}\")\n            event.ignore()\n        finally:\n            # 恢复原始样式\n            self.dragLeaveEvent(event)\n            \n    def load_image_to_upload(self, file_path: str, is_temp: bool = False):\n        \"\"\"加载图片到上传区域\"\"\"\n        try:\n            if self.validate_image(file_path):\n                # 如果已有图片，先清除\n                if self.uploaded_image:\n                    self.clear_uploaded_image()\n                    \n                self.uploaded_image = file_path\n                self.uploaded_image_is_temp = is_temp\n                \n                # 显示缩略图\n                self.show_thumbnail(file_path)\n                \n                # 更新生成按钮文字\n                self.generate_button.setText(\"图生图\")\n                        \n                return True\n            else:\n                self.status_label.setText(\"不支持的图片格式或文件损坏\")\n                return False\n                \n        except Exception as e:\n            self.status_label.setText(f\"加载图片失败: {str(e)}\")\n            return False\n            \n    def show_thumbnail(self, image_path):\n        \"\"\"显示缩略图\"\"\"\n        try:\n            # 加载图片并创建缩略图\n            pixmap = QPixmap(image_path)\n            if pixmap.isNull():\n                return\n                \n            # 缩放到合适大小\n            scaled_pixmap = pixmap.scaled(56, 46, Qt.KeepAspectRatio, Qt.SmoothTransformation)\n            \n            # 设置按钮图标\n            self.upload_display.setIcon(QIcon(scaled_pixmap))\n            self.upload_display.setIconSize(QSize(56, 46))\n            self.upload_display.setText(\"\")\n            colors = unified_style_system.get_colors()\n            success_color = colors.get('palette.semantic.success') or colors.get('primary')\n            success_hover = colors.get('palette.semantic.success_hover', success_color)\n            success_subtle = colors.get('palette.semantic.success_subtle', 'rgba(39, 201, 63, 0.15)')\n            self.upload_display.setStyleSheet(f\"\"\"\n                QPushButton {{\n                    background-color: transparent;\n                    border: 2px solid {success_color};\n                    border-radius: 6px;\n                }}\n                QPushButton:hover {{\n                    background-color: {success_subtle};\n                    border-color: {success_hover};\n                    border-width: 2px;\n                }}\n            \"\"\")\n            \n            # 显示删除按钮\n            self.delete_button.setVisible(True)\n            \n        except Exception as e:\n            logger.error(f\"显示缩略图失败: {str(e)}\")\n            \n    def clear_uploaded_image(self):\n        \"\"\"清除上传的图片\"\"\"\n        # 如果是临时文件，删除它\n        if self.uploaded_image and self.uploaded_image_is_temp:\n            try:\n                if os.path.exists(self.uploaded_image):\n                    os.remove(self.uploaded_image)\n            except Exception as e:\n                logger.error(f\"删除临时文件失败: {str(e)}\")\n                \n        # 重置状态\n        self.uploaded_image = None\n        self.uploaded_image_is_temp = False\n        \n        # 重置显示\n        self.upload_display.setIcon(QIcon())\n        self.upload_display.setText(\"+\")\n        colors = unified_style_system.get_colors()\n        success_color = colors.get('palette.semantic.success') or colors.get('primary')\n        secondary_color = (\n            colors.get('palette.text.secondary')\n            or colors.get('text_secondary')\n            or colors.get('palette.text.primary')\n            or colors.get('text')\n        )\n        self.upload_display.setStyleSheet(f\"\"\"\n            QPushButton {{\n                background-color: transparent;\n                border: 2px dashed {secondary_color};\n                border-radius: 6px;\n                color: {secondary_color};\n            }}\n            QPushButton:hover {{\n                border-color: {success_color};\n                color: {success_color};\n            }}\n        \"\"\")\n        \n        # 隐藏删除按钮\n        self.delete_button.setVisible(False)\n        \n        # 更新生成按钮文字\n        self.generate_button.setText(\"生成图片\")\n        \n        self.status_label.setText(\"已清除上传的图片\")\n    \n    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n        \"\"\"显示带样式的消息框\"\"\"\n        from components.modes.shared.styled_message_box import show_styled_message as _show_styled_message\n\n        _show_styled_message(self, title, message, icon_type)\n    \n    def validate_image(self, file_path: str) -> bool:\n        \"\"\"验证图片文件\"\"\"\n        from components.modes.shared.image_validation import validate_image as _validate_image\n\n        return _validate_image(\n            file_path,\n            show_message=self.show_styled_message,\n            set_status=self.status_label.setText,\n        )\n    \n    def generate_image(self):\n        \"\"\"生成图片\"\"\"\n        self._generation_controller.generate()\n        \n    def generate_random_seed(self):\n        \"\"\"生成随机种子\"\"\"\n        self._generation_controller.generate_random_seed()\n        \n    # 移除高级设置功能，火山引擎Seedream不需要\n\n    def _on_task_started(self, task_id: str, content_type: str):\n        self._generation_controller.on_task_started(task_id, content_type)\n\n    def _on_task_progress(self, task_id: str, message: str, percentage: int):\n        self._generation_controller.on_task_progress(task_id, message, percentage)\n\n    def _on_task_completed(self, task_id: str, content_type: str, result: Dict[str, Any]):\n        self._generation_controller.on_task_completed(task_id, content_type, result)\n\n    def _on_task_failed(self, task_id: str, content_type: str, error: str):\n        self._generation_controller.on_task_failed(task_id, content_type, error)\n\n    def _on_queue_updated(self, content_type: str, active: int, queued: int):\n        self._generation_controller.on_queue_updated(content_type, active, queued)\n\n    def _create_placeholder_card(self, task_id: str, prompt: str, content_type: str):\n        self._generation_controller.create_placeholder_card(task_id, prompt, content_type)\n\n    def _normalize_image_results(self, task_id: str, result: Dict[str, Any]) -> List[Dict[str, Any]]:\n        return self._generation_controller.normalize_results(task_id, result)\n\n    def _build_image_card_data(\n        self,\n        fallback_id: str,\n        payload: Dict[str, Any],\n        base_prompt: str,\n        base_created_at: Optional[str],\n        base_params: Dict[str, Any],\n    ) -> Optional[Dict[str, Any]]:\n        return self._generation_controller.build_card_data(fallback_id, payload, base_prompt, base_created_at, base_params)\n        \n    def on_generation_completed(self, result: Dict[str, Any]):\n        self._generation_controller.on_generation_completed(result)\n        \n    def on_generation_failed(self, error_message: str):\n        self._generation_controller.on_generation_failed(error_message)\n\n    \n    def adjust_prompt_height(self):\n        \"\"\"Plan Alpha: 弹簧物理模型 (Spring Physics)\"\"\"\n        if not hasattr(self, 'prompt_input'):\n            return\n            \n        doc = self.prompt_input.document()\n        # 1. 计算理想高度 Ideal Height\n        ideal_content_height = doc.size().height() + 22\n        \n        # 2. 定义区间 Constants\n        MIN_AUTO_HEIGHT = 90    # 3行\n        MAX_AUTO_HEIGHT = 185   # 8行\n        MAX_PHYSICAL_HEIGHT = 250 # 10行 (微调: 物理上限从300降至250)\n        \n        current_height = self.prompt_input.height()\n        target_height = current_height # 默认保持现状\n        \n        # 3. 弹簧逻辑 Spring Logic\n        if ideal_content_height <= MIN_AUTO_HEIGHT:\n            # Case A: 内容很少 -> 强制回缩到最小值\n            target_height = MIN_AUTO_HEIGHT\n            \n        elif MIN_AUTO_HEIGHT < ideal_content_height < MAX_AUTO_HEIGHT:\n            # Case B: 弹性区间 (3-8行) -> 完美跟随\n            target_height = ideal_content_height\n            \n        else: # ideal_content_height >= MAX_AUTO_HEIGHT\n            # Case C: 饱和区间 (>= 8行)\n            if current_height < MAX_AUTO_HEIGHT:\n                # 还没撑满8行 -> 撑到 185px 截止\n                target_height = MAX_AUTO_HEIGHT\n            else:\n                # current >= 185 (可能是手动拖大的)\n                if ideal_content_height < current_height:\n                    # Case C-1: 删字回缩 (用户删了很多字)\n                    # 规则: 如果内容已经明显少于当前高度，应该由弹簧接管回缩\n                    # 为了避免打字抖动，给一点缓冲 (比如比当前小 20px 才缩)\n                    if ideal_content_height < (current_height - 20):\n                        # 回缩目标: 取 内容高度 和 185 的较大值\n                        # 这意味着如果内容还在 8 行以上，就缩到内容高度\n                        # 如果内容少于 8 行，就缩到 185 (以此类推会进入 Case B)\n                        target_height = max(ideal_content_height, MAX_AUTO_HEIGHT)\n                else:\n                    # Case C-2: 保持手动高度 (内容依然很多)\n                    pass\n\n        # 4. 纠正数学方向 Math Correction\n        # 目标是让 Bottom 变成 target_height\n        # delta = 目标 - 当前\n        delta = int(target_height - current_height)\n        \n        if abs(delta) < 5:\n            return\n\n        if hasattr(self, 'splitter'):\n            sizes = self.splitter.sizes()\n            if len(sizes) >= 2:\n                # 注意: Splitter[0] 是 Top, Splitter[1] 是 Bottom\n                # 如果 Bottom 要增加 (delta > 0)，那么 Top 必须减少\n                # 之前的错误是用 + 号，导致 Top 增加，Bottom 反而被挤小\n                new_top = sizes[0] - delta\n                new_bottom = sizes[1] + delta\n                \n                # 安全检查\n                if new_top < 50: return \n                if new_bottom < 50: return\n                \n                self.splitter.setSizes([new_top, new_bottom])\n\n    def _reset_input_layout(self):\n        \"\"\"Plan P: 重置输入区域布局状态 (用于模型切换)\"\"\"\n        if hasattr(self, 'prompt_input'):\n            # 1. 强制重置输入框高度 (Plan S/T: 移除固定高度限制，改回 Expanding)\n            # self.prompt_input.setFixedHeight(80)  <-- DELETE (Bug source)\n            self.prompt_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n            \n            # 2. 如果有 Splitter，尝试重置比例\n            if hasattr(self, 'splitter'):\n                try:\n                    current_sizes = self.splitter.sizes()\n                    if len(current_sizes) >= 2:\n                        total_height = sum(current_sizes)\n                        # Plan Z: 逻辑纠偏 - 目标是让底部(Input)为 90px\n                        target_bottom = 90\n                        if total_height > target_bottom:\n                            # Index 0 = Top (Content), Index 1 = Bottom (Input)\n                            self.splitter.setSizes([total_height - target_bottom, target_bottom])\n                except Exception:\n                    pass\n            \n            # 3. 触发一次自适应调整以同步状态\n            QTimer.singleShot(50, self.adjust_prompt_height) # Plan Q: 修复方法调用\n\n    def _on_sequential_mode_changed(self) -> None:\n        \"\"\"组图模式联动逻辑：更新 count 控件验证范围和参考图上限\"\"\"\n        if not self.image_schema_form:\n            return\n\n        try:\n            from PySide6.QtWidgets import QLineEdit\n            from PySide6.QtGui import QIntValidator\n            from modules.provider.schema import MAX_REFERENCE_BUNDLE, MAX_REFERENCE_IMAGES\n\n            # 读取当前值\n            form_values, _errors = self.image_schema_form.collect_values()\n            variant = form_values.get('model_variant', '')\n            seq_enabled = bool(form_values.get('sequential_mode', False))\n            count_value = int(form_values.get('count', 1) or 1)\n            \n            # 获取参考图数量（用于计算组图模式上限）\n            ref_count = 0\n            if hasattr(self, 'reference_panel') and self.reference_panel:\n                if hasattr(self.reference_panel, 'get_count'):\n                    ref_count = self.reference_panel.get_count()\n                elif hasattr(self.reference_panel, 'count'):\n                    ref_count = self.reference_panel.count()\n\n            # 计算 count 的最大值\n            # 4.0/4.5 模型规则：\n            #   - 关闭组图：单图模式，但允许用户输入（后端会循环生成）\n            #   - 开启组图：\n            #     - 无参考图：最多15张\n            #     - 单参考图：最多14张\n            #     - 多参考图(N张)：15-N张\n            if variant in ['seedream_v4', 'seedream_v4_5']:\n                if seq_enabled:\n                    # 组图模式：根据参考图数量动态计算上限\n                    if ref_count == 0:\n                        new_max = 15\n                    elif ref_count == 1:\n                        new_max = 14\n                    else:\n                        new_max = max(1, 15 - ref_count)\n                else:\n                    # 关闭组图：普通模式最多10张\n                    new_max = 10\n            elif variant == 'seedream_v3':\n                # 3.0 模型：最多10张\n                new_max = 10\n            else:\n                new_max = 10  # 默认值\n\n            # 更新 count 控件的验证器（QLineEdit 版本）\n            count_widget = self.image_schema_form._widgets.get('count')\n            if count_widget and isinstance(count_widget, QLineEdit):\n                validator = QIntValidator(1, new_max, count_widget)\n                count_widget.setValidator(validator)\n                # 如果当前值超出新范围，自动调整\n                try:\n                    current_count = int(count_widget.text() or 1)\n                    if current_count > new_max:\n                        count_widget.setText(str(new_max))\n                except ValueError:\n                    pass\n                logger.debug(f\"[组图联动] count.max={new_max} (sequential_mode={seq_enabled}, refs={ref_count})\")\n\n            # 更新参考图面板上限和提示\n            panel = self.reference_panel\n            if panel:\n                if seq_enabled:\n                    # 组图模式：refs + count ≤ 15\n                    dynamic_max = max(0, MAX_REFERENCE_BUNDLE - count_value)\n                    hint_text = f\"组图模式：最多 {dynamic_max} 张参考图（参考图 + {count_value} 张输出 ≤ 15）\"\n                else:\n                    # 普通模式：固定 14 张\n                    dynamic_max = MAX_REFERENCE_IMAGES\n                    hint_text = f\"最多 {MAX_REFERENCE_IMAGES} 张参考图\"\n\n                # 设置最大值（需要检查 panel 是否有相关属性）\n                if hasattr(panel, 'set_max_count'):\n                    panel.set_max_count(dynamic_max)\n                elif hasattr(panel, 'max_count'):\n                    panel.max_count = dynamic_max\n\n                # 更新提示文本（需要检查 panel 是否有相关属性）\n                if hasattr(panel, 'set_hint_text'):\n                    panel.set_hint_text(hint_text)\n\n                logger.debug(f\"[组图联动] refs.max={dynamic_max} (count={count_value})\")\n\n        except Exception as exc:\n            logger.debug(f\"[组图联动] 失败: {exc}\")\n\n    def closeEvent(self, event):\n        super().closeEvent(event)\n","numLines":1873,"startLine":1,"totalLines":1873}},"sourceToolAssistantUUID":"58957578-7607-406a-9e60-9bcc1d4effde"}
{"parentUuid":"0751d51d-3872-496f-af3b-97904821b020","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0143o6biCcq4VhmoYn3sdoPh","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me search for additional files to understand the complete flow:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":68639,"cache_read_input_tokens":20903,"cache_creation":{"ephemeral_5m_input_tokens":68639,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5ed52e30-33e7-4d50-a299-25c6fd9d0e45","timestamp":"2026-01-09T03:40:46.812Z"}
{"parentUuid":"5ed52e30-33e7-4d50-a299-25c6fd9d0e45","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0143o6biCcq4VhmoYn3sdoPh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PaSEfoQmiHeENcFCd27brV","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":68639,"cache_read_input_tokens":20903,"cache_creation":{"ephemeral_5m_input_tokens":68639,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"08084242-d354-4227-8bbe-acfa371bc33e","timestamp":"2026-01-09T03:40:47.902Z"}
{"parentUuid":"08084242-d354-4227-8bbe-acfa371bc33e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0143o6biCcq4VhmoYn3sdoPh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PagyucVW7kSZNwMD7CpxqU","name":"Grep","input":{"pattern":"seed.*params|params.*seed","path":"/Users/yunchang/Documents/GitHub/gemeng2","type":"py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":68639,"cache_read_input_tokens":20903,"cache_creation":{"ephemeral_5m_input_tokens":68639,"ephemeral_1h_input_tokens":0},"output_tokens":182,"service_tier":"standard"}},"type":"assistant","uuid":"3e7fb125-9034-411b-994b-3d4987e14213","timestamp":"2026-01-09T03:40:48.097Z"}
{"parentUuid":"08084242-d354-4227-8bbe-acfa371bc33e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PaSEfoQmiHeENcFCd27brV","type":"tool_result","content":"     1→\"\"\"Image mode: parameter/schema related logic (Phase 4.3.a).\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import os\n     6→import re\n     7→import json\n     8→from datetime import datetime\n     9→from pathlib import Path\n    10→from typing import Any, Dict, List, Optional\n    11→\n    12→from PySide6.QtWidgets import QMessageBox\n    13→from loguru import logger\n    14→\n    15→from modules.provider import get_ui_schema\n    16→from utils.reference_display import _evaluate_dependency_rules\n    17→\n    18→\n    19→def _load_image_schema(\n    20→    self,\n    21→    variant: Optional[str] = None,\n    22→    *,\n    23→    keep_values: bool = True,\n    24→    initial_values: Optional[Dict[str, Any]] = None,\n    25→) -> None:\n    26→    if not self.image_schema_form:\n    27→        return\n    28→\n    29→    preserved: Dict[str, Any] = {}\n    30→    if keep_values and self.image_schema_form.schema():\n    31→        try:\n    32→            current_values, _errors = self.image_schema_form.collect_values()\n    33→            preserved.update(current_values)\n    34→        except Exception as exc:  # pragma: no cover - best effort cache\n    35→            logger.debug(f\"采集旧参数失败: {exc}\")\n    36→    if self._image_form_cache:\n    37→        preserved.update(self._image_form_cache)\n    38→    if initial_values:\n    39→        preserved.update(initial_values)\n    40→\n    41→    try:\n    42→        schema = get_ui_schema(\"seedream\", \"image\", variant)\n    43→    except Exception as exc:\n    44→        logger.error(f\"加载图片 Schema 失败: {exc}\")\n    45→        return\n    46→\n    47→    self._image_schema = schema\n    48→    self._image_schema_variant = schema.variant\n    49→    self.image_schema_form.set_schema(schema, initial_values=preserved)\n    50→    self._image_form_cache = preserved\n    51→    self._handle_image_schema_extras(schema, preserved)\n    52→    self._handle_image_schema_extras(schema, preserved)\n    53→    self._refresh_image_reference_panel_state(preserved)\n    54→\n    55→    # Debug logs for schema loading\n    56→    logger.debug(f\"加载图片 Schema 成功: variant={schema.variant}\")\n    57→    logger.debug(f\"Schema Fields: {[f.name for f in schema.fields]}\")\n    58→\n    59→    # 根据当前模型变体设置上传按钮的初始可见性\n    60→    current_variant = preserved.get(\"model_variant\") or schema.variant\n    61→    self._update_upload_button_visibility(current_variant)\n    62→\n    63→    # 初始化组图模式联动逻辑（仅 Seedream 4.5）\n    64→    self._on_sequential_mode_changed()\n    65→\n    66→\n    67→def _handle_image_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n    68→    config = getattr(schema, \"reference_assets\", {}) or {}\n    69→    self._image_reference_config = config\n    70→    self._image_reference_visibility_rules = config.get(\"visible_if\") or []\n    71→    self._image_reference_auto_field = config.get(\"auto_compress_field\")\n    72→\n    73→    panel = self.reference_panel\n    74→    if not panel:\n    75→        return\n    76→\n    77→    if not config.get(\"enabled\"):\n    78→        panel.clear()\n    79→        panel.set_panel_enabled(False)\n    80→        self._image_reference_visibility_rules = []\n    81→        self._image_reference_auto_field = None\n    82→        return\n    83→\n    84→    panel.set_panel_enabled(True)\n    85→    panel.set_limits(\n    86→        max_count=config.get(\"max_count\"),\n    87→        bundle_limit=config.get(\"bundle_limit\"),\n    88→    )\n    89→    if config.get(\"accept\"):\n    90→        panel.set_accept_mime_types(config.get(\"accept\"))\n    91→    panel.set_hint_text(config.get(\"help_text\"))\n    92→\n    93→\n    94→def _on_image_schema_reload(self, variant: str) -> None:\n    95→    logger.info(f\"Schema 切换请求: {variant}\")\n    96→    self._load_image_schema(variant=variant, keep_values=False)\n    97→\n    98→    # Plan P: 切换模型时强制重置布局状态\n    99→    self._reset_input_layout()\n   100→\n   101→\n   102→def _on_image_field_changed(self, field_name: str, value: Any) -> None:\n   103→    self._image_form_cache[field_name] = value\n   104→    self._refresh_image_reference_panel_state()\n   105→\n   106→    # 当模型变体改变时，控制上传按钮的显示\n   107→    if field_name == \"model_variant\":\n   108→        self._update_upload_button_visibility(value)\n   109→\n   110→    # 组图模式联动逻辑（仅 Seedream 4.5）\n   111→    if field_name in {\"sequential_mode\", \"count\", \"model_variant\"}:\n   112→        self._on_sequential_mode_changed()\n   113→\n   114→\n   115→def _collect_image_form_values(self) -> Optional[Dict[str, Any]]:\n   116→    if not self.image_schema_form:\n   117→        return {}\n   118→    values, errors = self.image_schema_form.collect_values()\n   119→    if errors:\n   120→        QMessageBox.warning(self, \"参数校验失败\", \"\\n\".join(errors))\n   121→        return None\n   122→    self._image_form_cache = dict(values)\n   123→    return values\n   124→\n   125→\n   126→def _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n   127→    panel = self.reference_panel\n   128→    if not panel:\n   129→        return\n   130→\n   131→    config = self._image_reference_config or {}\n   132→    if not config.get(\"enabled\"):\n   133→        panel.set_panel_enabled(False)\n   134→        return\n   135→\n   136→    panel.set_panel_enabled(True)\n   137→\n   138→    data = dict(self._image_form_cache)\n   139→    if values:\n   140→        data.update(values)\n   141→\n   142→    visible = _evaluate_dependency_rules(self._image_reference_visibility_rules, data)\n   143→    panel.setVisible(visible)\n   144→\n   145→    if self._image_reference_auto_field:\n   146→        panel.set_auto_compress_enabled(bool(data.get(self._image_reference_auto_field, True)))\n   147→\n   148→\n   149→def _on_reference_files_changed(self) -> None:\n   150→    if not self.reference_panel:\n   151→        return\n   152→    count = self.reference_panel.current_count()\n   153→    logger.info(f\"参考图更新，当前数量: {count}\")\n   154→\n   155→\n   156→def _on_reference_warning(self, message: str) -> None:\n   157→    if not message:\n   158→        return\n   159→    logger.warning(message)\n   160→    try:\n   161→        self.status_label.setText(message)\n   162→    except Exception:\n   163→        pass\n   164→\n   165→\n   166→def _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n   167→    panel = self.reference_panel\n   168→    assets: List[Dict[str, Any]] = []\n   169→\n   170→    # 处理4.0模式的参考图画廊\n   171→    if panel and panel.isVisible() and panel.isEnabled():\n   172→        validation = panel.validate(expected_outputs=expected_outputs)\n   173→        if not validation.get(\"valid\", True):\n   174→            errors = \"\\n\".join(validation.get(\"errors\", [])) or \"参考图数量超过限制\"\n   175→            if validation.get(\"can_trim\") and validation.get(\"trim_to\") is not None:\n   176→                trim_to = max(0, int(validation[\"trim_to\"]))\n   177→                msg = (f\"参考图数量超出限制，是否自动裁剪至 {trim_to} 张？\" + (\"\\n\\n\" + errors if errors else \"\"))\n   178→                choice = QMessageBox.question(\n   179→                    self,\n   180→                    \"参考图超限\",\n   181→                    msg,\n   182→                    QMessageBox.Yes | QMessageBox.No,\n   183→                    QMessageBox.Yes,\n   184→                )\n   185→                if choice == QMessageBox.Yes:\n   186→                    panel.trim_to(trim_to)\n   187→                    recheck = panel.validate(expected_outputs=expected_outputs)\n   188→                    if not recheck.get(\"valid\", True):\n   189→                        self.show_styled_message(\"参考图超限\", \"\\n\".join(recheck.get(\"errors\", [])), \"warning\")\n   190→                        return None\n   191→                    try:\n   192→                        self.status_label.setText(f\"已裁剪参考图至 {trim_to} 张\")\n   193→                    except Exception:\n   194→                        pass\n   195→                else:\n   196→                    try:\n   197→                        self.status_label.setText(\"已取消生成（参考图超限）\")\n   198→                    except Exception:\n   199→                        pass\n   200→                    return None\n   201→            else:\n   202→                self.show_styled_message(\"参考图超限\", errors, \"warning\")\n   203→                return None\n   204→\n   205→        panel_assets = panel.collect_assets()\n   206→        if panel_assets:\n   207→            assets.extend(panel_assets)\n   208→\n   209→    # 处理3.x模式的单独上传图片\n   210→    if hasattr(self, \"uploaded_image\") and self.uploaded_image:\n   211→        try:\n   212→            import uuid\n   213→\n   214→            # 生成唯一ID\n   215→            asset_id = str(uuid.uuid4())\n   216→\n   217→            # 获取文件信息\n   218→            image_path = Path(self.uploaded_image)\n   219→\n   220→            uploaded_asset = {\n   221→                \"id\": asset_id,\n   222→                \"path\": str(image_path),\n   223→                \"absolute_path\": str(image_path.resolve()),\n   224→                \"relative_path\": None,  # 3.x模式通常使用绝对路径\n   225→                \"kind\": \"uploaded_image\",  # 标记为3.x模式上传的图片\n   226→                \"order\": 0,  # 3.x模式只有一张图片，顺序为0\n   227→                \"file_size\": image_path.stat().st_size if image_path.exists() else 0,\n   228→                \"created_at\": datetime.now().isoformat(),\n   229→                \"source\": \"3x_mode_upload\",\n   230→            }\n   231→\n   232→            assets.append(uploaded_asset)\n   233→            logger.info(f\"[3.x模式] 成功将单独上传图片转换为参考图资产: {self.uploaded_image}\")\n   234→        except Exception as exc:\n   235→            logger.error(f\"处理3.x模式上传图片失败: {exc}\")\n   236→\n   237→    # 验证总资产数量（保留旧门禁：默认关闭）\n   238→    if False and len(assets) > expected_outputs:  # pragma: no cover - legacy guard\n   239→        QMessageBox.warning(\n   240→            self,\n   241→            \"参考图数量超限\",\n   242→            f\"参考图数量 ({len(assets)}) 超过了预期输出数量 ({expected_outputs})，请减少参考图数量。\",\n   243→        )\n   244→        return None\n   245→\n   246→    logger.debug(f\"[参考图收集] 总共收集到 {len(assets)} 个参考图资产\")\n   247→    return assets\n   248→\n   249→\n   250→def _on_reuse_parameters(self, record: dict) -> None:\n   251→    \"\"\"复用历史记录的生成参数到当前表单（完整版：模型+参数+参考图+提示词）\"\"\"\n   252→    logger.info(f\"[DEBUG] _on_reuse_parameters 被调用，record id={record.get('id') if record else 'None'}\")\n   253→    try:\n   254→        if not record:\n   255→            logger.warning(\"[DEBUG] record 为空，退出\")\n   256→            return\n   257→\n   258→        import json\n   259→\n   260→        # 获取仓库基础路径用于解析相对路径\n   261→        repo_base_path = \"\"\n   262→        try:\n   263→            repo = self.get_repository_manager()\n   264→            if repo:\n   265→                if hasattr(repo, \"storage_root\"):\n   266→                    repo_base_path = str(repo.storage_root)\n   267→                elif hasattr(repo, \"base_path\"):\n   268→                    repo_base_path = repo.base_path\n   269→        except Exception:\n   270→            pass\n   271→\n   272→        params = record.get(\"parameters\", {})\n   273→        if isinstance(params, str):\n   274→            try:\n   275→                params = json.loads(params)\n   276→            except Exception:\n   277→                params = {}\n   278→\n   279→        logger.info(f\"[DEBUG] params keys={list(params.keys()) if params else 'empty'}\")\n   280→\n   281→        model_variant = params.get(\"model_variant\") or params.get(\"model\") or record.get(\"model\") or \"\"\n   282→        model_lower = model_variant.lower()\n   283→        logger.info(f\"[DEBUG] 检测到 model_variant={model_variant}\")\n   284→\n   285→        # 定义匹配模式与目标变体的映射关系 (Regex Table)\n   286→        # 模式 (Regex)                                     Target Variant\n   287→        VARIANT_PATTERNS = [\n   288→            (r\"(seedream|seededit).*?(4\\.5|4[-_]5|v4_5)\", \"seedream_v4_5\"),\n   289→            (r\"(seedream|seededit).*?(4\\.0|4[-_]0|v4)\",   \"seedream_v4\"),\n   290→            (r\"(seedream|seededit).*?(3\\.0|3[-_]0|v3)\",   \"seedream_v3\"),\n   291→        ]\n   292→\n   293→        target_variant = None\n   294→        for pattern, variant in VARIANT_PATTERNS:\n   295→            if re.search(pattern, model_lower):\n   296→                target_variant = variant\n   297→                break\n   298→\n   299→        logger.info(f\"[DEBUG] 目标变体 target_variant={target_variant}\")\n   300→\n   301→        initial_values: Dict[str, Any] = {}\n   302→        if params.get(\"size\") and params[\"size\"] != \"adaptive\":\n   303→            initial_values[\"size\"] = params[\"size\"]\n   304→\n   305→        # 提取参数（兼容旧扁平 dict 与新三层结构）\n   306→        params_requested = params.get(\"params_requested\") if isinstance(params, dict) else None\n   307→        if not isinstance(params_requested, dict):\n   308→            params_requested = params if isinstance(params, dict) else {}\n   309→        params_actual = params.get(\"params_actual\") if isinstance(params, dict) else {}\n   310→        if not isinstance(params_actual, dict):\n   311→            params_actual = {}\n   312→\n   313→        # seed 仅 3.0 支持复用，4.0/4.5 不复用以免误导\n   314→        is_seedream_3 = target_variant == \"seedream_v3\" if target_variant else False\n   315→        if is_seedream_3:\n   316→            if not record.get('_skip_seed_reuse'):\n   317→                # 优先用 params_actual（API返回值），再用 params_requested，最后用顶层\n   318→                seed = params_actual.get(\"seed\")\n   319→                if seed is None:\n   320→                    seed = params_requested.get(\"seed\")\n   321→                if seed is None:\n   322→                    seed = params.get(\"seed\")\n   323→                if seed is not None:\n   324→                    initial_values[\"seed\"] = int(seed)\n   325→                    logger.info(f\"[DEBUG] 复用 seed 值: {seed}\")\n   326→            else:\n   327→                logger.info(\"[DEBUG] 跳过 seed 复用，显式设置为 -1（随机）\")\n   328→                initial_values[\"seed\"] = -1  # 显式设置为随机\n   329→\n   330→        if params.get(\"count\"):\n   331→            initial_values[\"count\"] = int(params[\"count\"])\n   332→        if target_variant:\n   333→            initial_values[\"model_variant\"] = target_variant\n   334→\n   335→        logger.info(f\"[DEBUG] initial_values={initial_values}\")\n   336→\n   337→        if target_variant:\n   338→            self._load_image_schema(variant=target_variant, keep_values=False, initial_values=initial_values)\n   339→        elif initial_values:\n   340→            if hasattr(self, \"image_schema_form\") and self.image_schema_form:\n   341→                for key, val in initial_values.items():\n   342→                    try:\n   343→                        self.image_schema_form.set_value(key, val)\n   344→                    except Exception:\n   345→                        pass\n   346→\n   347→        prompt = record.get(\"prompt\", \"\")\n   348→        if prompt and hasattr(self, \"prompt_input\"):\n   349→            self.prompt_input.setPlainText(prompt)\n   350→\n   351→        reference_assets = (\n   352→            record.get(\"_resolved_reference_assets_abs\")\n   353→            or record.get(\"_resolved_reference_assets\")\n   354→            or record.get(\"reference_assets\")\n   355→            or params.get(\"reference_assets\")\n   356→            or []\n   357→        )\n   358→        logger.info(f\"[DEBUG] reference_assets 数量={len(reference_assets)}, repo_base_path={repo_base_path}\")\n   359→\n   360→        def resolve_path(asset: Any) -> str:\n   361→            if isinstance(asset, dict):\n   362→                path = asset.get(\"absolute_path\") or asset.get(\"path\", \"\")\n   363→            elif isinstance(asset, str):\n   364→                path = asset\n   365→            else:\n   366→                return \"\"\n   367→\n   368→            if path and not os.path.isabs(path) and repo_base_path:\n   369→                abs_path = os.path.join(repo_base_path, path)\n   370→                if os.path.exists(abs_path):\n   371→                    return abs_path\n   372→            return path\n   373→\n   374→        if reference_assets:\n   375→            variant_str = str(self._image_schema_variant).lower() if self._image_schema_variant else \"\"\n   376→            is_seedream_4 = (\n   377→                \"seedream_4\" in variant_str\n   378→                or \"seedream_v4\" in variant_str\n   379→                or \"seedream4.0\" in variant_str\n   380→                or \"seedream_4.5\" in variant_str\n   381→            )\n   382→\n   383→            logger.info(f\"[DEBUG] is_seedream_4={is_seedream_4}, reference_panel存在={self.reference_panel is not None}\")\n   384→\n   385→            if is_seedream_4 and self.reference_panel:\n   386→                self.reference_panel.clear()\n   387→                for asset in reference_assets:\n   388→                    path = resolve_path(asset)\n   389→                    if path and os.path.exists(path):\n   390→                        logger.info(f\"[DEBUG] 添加参考图: {path}\")\n   391→                        self.reference_panel.add_image_path(path)\n   392→                    else:\n   393→                        logger.warning(f\"[DEBUG] 参考图不存在或路径为空: {path}\")\n   394→            else:\n   395→                if reference_assets:\n   396→                    first_ref = reference_assets[0]\n   397→                    path = resolve_path(first_ref)\n   398→                    logger.info(f\"[DEBUG] 3.0模式参考图路径: {path}, 存在={os.path.exists(path) if path else 'N/A'}\")\n   399→                    if path and os.path.exists(path):\n   400→                        self.load_image_to_upload(path)\n   401→\n   402→        self.status_label.setText(\"✅ 参数已填入，可直接生成\")\n   403→        logger.info(f\"[UI] 复用参数成功: model={target_variant}, prompt长度={len(prompt)}, 参考图数量={len(reference_assets)}\")\n   404→\n   405→    except Exception as exc:\n   406→        logger.error(f\"复用参数失败: {exc}\")\n   407→        import traceback\n   408→\n   409→        traceback.print_exc()\n   410→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"93347d89-301d-4ce9-836b-593a75b77009","timestamp":"2026-01-09T03:40:48.149Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/parameter_logic.py","content":"\"\"\"Image mode: parameter/schema related logic (Phase 4.3.a).\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom PySide6.QtWidgets import QMessageBox\nfrom loguru import logger\n\nfrom modules.provider import get_ui_schema\nfrom utils.reference_display import _evaluate_dependency_rules\n\n\ndef _load_image_schema(\n    self,\n    variant: Optional[str] = None,\n    *,\n    keep_values: bool = True,\n    initial_values: Optional[Dict[str, Any]] = None,\n) -> None:\n    if not self.image_schema_form:\n        return\n\n    preserved: Dict[str, Any] = {}\n    if keep_values and self.image_schema_form.schema():\n        try:\n            current_values, _errors = self.image_schema_form.collect_values()\n            preserved.update(current_values)\n        except Exception as exc:  # pragma: no cover - best effort cache\n            logger.debug(f\"采集旧参数失败: {exc}\")\n    if self._image_form_cache:\n        preserved.update(self._image_form_cache)\n    if initial_values:\n        preserved.update(initial_values)\n\n    try:\n        schema = get_ui_schema(\"seedream\", \"image\", variant)\n    except Exception as exc:\n        logger.error(f\"加载图片 Schema 失败: {exc}\")\n        return\n\n    self._image_schema = schema\n    self._image_schema_variant = schema.variant\n    self.image_schema_form.set_schema(schema, initial_values=preserved)\n    self._image_form_cache = preserved\n    self._handle_image_schema_extras(schema, preserved)\n    self._handle_image_schema_extras(schema, preserved)\n    self._refresh_image_reference_panel_state(preserved)\n\n    # Debug logs for schema loading\n    logger.debug(f\"加载图片 Schema 成功: variant={schema.variant}\")\n    logger.debug(f\"Schema Fields: {[f.name for f in schema.fields]}\")\n\n    # 根据当前模型变体设置上传按钮的初始可见性\n    current_variant = preserved.get(\"model_variant\") or schema.variant\n    self._update_upload_button_visibility(current_variant)\n\n    # 初始化组图模式联动逻辑（仅 Seedream 4.5）\n    self._on_sequential_mode_changed()\n\n\ndef _handle_image_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n    config = getattr(schema, \"reference_assets\", {}) or {}\n    self._image_reference_config = config\n    self._image_reference_visibility_rules = config.get(\"visible_if\") or []\n    self._image_reference_auto_field = config.get(\"auto_compress_field\")\n\n    panel = self.reference_panel\n    if not panel:\n        return\n\n    if not config.get(\"enabled\"):\n        panel.clear()\n        panel.set_panel_enabled(False)\n        self._image_reference_visibility_rules = []\n        self._image_reference_auto_field = None\n        return\n\n    panel.set_panel_enabled(True)\n    panel.set_limits(\n        max_count=config.get(\"max_count\"),\n        bundle_limit=config.get(\"bundle_limit\"),\n    )\n    if config.get(\"accept\"):\n        panel.set_accept_mime_types(config.get(\"accept\"))\n    panel.set_hint_text(config.get(\"help_text\"))\n\n\ndef _on_image_schema_reload(self, variant: str) -> None:\n    logger.info(f\"Schema 切换请求: {variant}\")\n    self._load_image_schema(variant=variant, keep_values=False)\n\n    # Plan P: 切换模型时强制重置布局状态\n    self._reset_input_layout()\n\n\ndef _on_image_field_changed(self, field_name: str, value: Any) -> None:\n    self._image_form_cache[field_name] = value\n    self._refresh_image_reference_panel_state()\n\n    # 当模型变体改变时，控制上传按钮的显示\n    if field_name == \"model_variant\":\n        self._update_upload_button_visibility(value)\n\n    # 组图模式联动逻辑（仅 Seedream 4.5）\n    if field_name in {\"sequential_mode\", \"count\", \"model_variant\"}:\n        self._on_sequential_mode_changed()\n\n\ndef _collect_image_form_values(self) -> Optional[Dict[str, Any]]:\n    if not self.image_schema_form:\n        return {}\n    values, errors = self.image_schema_form.collect_values()\n    if errors:\n        QMessageBox.warning(self, \"参数校验失败\", \"\\n\".join(errors))\n        return None\n    self._image_form_cache = dict(values)\n    return values\n\n\ndef _refresh_image_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n    panel = self.reference_panel\n    if not panel:\n        return\n\n    config = self._image_reference_config or {}\n    if not config.get(\"enabled\"):\n        panel.set_panel_enabled(False)\n        return\n\n    panel.set_panel_enabled(True)\n\n    data = dict(self._image_form_cache)\n    if values:\n        data.update(values)\n\n    visible = _evaluate_dependency_rules(self._image_reference_visibility_rules, data)\n    panel.setVisible(visible)\n\n    if self._image_reference_auto_field:\n        panel.set_auto_compress_enabled(bool(data.get(self._image_reference_auto_field, True)))\n\n\ndef _on_reference_files_changed(self) -> None:\n    if not self.reference_panel:\n        return\n    count = self.reference_panel.current_count()\n    logger.info(f\"参考图更新，当前数量: {count}\")\n\n\ndef _on_reference_warning(self, message: str) -> None:\n    if not message:\n        return\n    logger.warning(message)\n    try:\n        self.status_label.setText(message)\n    except Exception:\n        pass\n\n\ndef _collect_reference_assets_for_image(self, expected_outputs: int) -> Optional[List[Dict[str, Any]]]:\n    panel = self.reference_panel\n    assets: List[Dict[str, Any]] = []\n\n    # 处理4.0模式的参考图画廊\n    if panel and panel.isVisible() and panel.isEnabled():\n        validation = panel.validate(expected_outputs=expected_outputs)\n        if not validation.get(\"valid\", True):\n            errors = \"\\n\".join(validation.get(\"errors\", [])) or \"参考图数量超过限制\"\n            if validation.get(\"can_trim\") and validation.get(\"trim_to\") is not None:\n                trim_to = max(0, int(validation[\"trim_to\"]))\n                msg = (f\"参考图数量超出限制，是否自动裁剪至 {trim_to} 张？\" + (\"\\n\\n\" + errors if errors else \"\"))\n                choice = QMessageBox.question(\n                    self,\n                    \"参考图超限\",\n                    msg,\n                    QMessageBox.Yes | QMessageBox.No,\n                    QMessageBox.Yes,\n                )\n                if choice == QMessageBox.Yes:\n                    panel.trim_to(trim_to)\n                    recheck = panel.validate(expected_outputs=expected_outputs)\n                    if not recheck.get(\"valid\", True):\n                        self.show_styled_message(\"参考图超限\", \"\\n\".join(recheck.get(\"errors\", [])), \"warning\")\n                        return None\n                    try:\n                        self.status_label.setText(f\"已裁剪参考图至 {trim_to} 张\")\n                    except Exception:\n                        pass\n                else:\n                    try:\n                        self.status_label.setText(\"已取消生成（参考图超限）\")\n                    except Exception:\n                        pass\n                    return None\n            else:\n                self.show_styled_message(\"参考图超限\", errors, \"warning\")\n                return None\n\n        panel_assets = panel.collect_assets()\n        if panel_assets:\n            assets.extend(panel_assets)\n\n    # 处理3.x模式的单独上传图片\n    if hasattr(self, \"uploaded_image\") and self.uploaded_image:\n        try:\n            import uuid\n\n            # 生成唯一ID\n            asset_id = str(uuid.uuid4())\n\n            # 获取文件信息\n            image_path = Path(self.uploaded_image)\n\n            uploaded_asset = {\n                \"id\": asset_id,\n                \"path\": str(image_path),\n                \"absolute_path\": str(image_path.resolve()),\n                \"relative_path\": None,  # 3.x模式通常使用绝对路径\n                \"kind\": \"uploaded_image\",  # 标记为3.x模式上传的图片\n                \"order\": 0,  # 3.x模式只有一张图片，顺序为0\n                \"file_size\": image_path.stat().st_size if image_path.exists() else 0,\n                \"created_at\": datetime.now().isoformat(),\n                \"source\": \"3x_mode_upload\",\n            }\n\n            assets.append(uploaded_asset)\n            logger.info(f\"[3.x模式] 成功将单独上传图片转换为参考图资产: {self.uploaded_image}\")\n        except Exception as exc:\n            logger.error(f\"处理3.x模式上传图片失败: {exc}\")\n\n    # 验证总资产数量（保留旧门禁：默认关闭）\n    if False and len(assets) > expected_outputs:  # pragma: no cover - legacy guard\n        QMessageBox.warning(\n            self,\n            \"参考图数量超限\",\n            f\"参考图数量 ({len(assets)}) 超过了预期输出数量 ({expected_outputs})，请减少参考图数量。\",\n        )\n        return None\n\n    logger.debug(f\"[参考图收集] 总共收集到 {len(assets)} 个参考图资产\")\n    return assets\n\n\ndef _on_reuse_parameters(self, record: dict) -> None:\n    \"\"\"复用历史记录的生成参数到当前表单（完整版：模型+参数+参考图+提示词）\"\"\"\n    logger.info(f\"[DEBUG] _on_reuse_parameters 被调用，record id={record.get('id') if record else 'None'}\")\n    try:\n        if not record:\n            logger.warning(\"[DEBUG] record 为空，退出\")\n            return\n\n        import json\n\n        # 获取仓库基础路径用于解析相对路径\n        repo_base_path = \"\"\n        try:\n            repo = self.get_repository_manager()\n            if repo:\n                if hasattr(repo, \"storage_root\"):\n                    repo_base_path = str(repo.storage_root)\n                elif hasattr(repo, \"base_path\"):\n                    repo_base_path = repo.base_path\n        except Exception:\n            pass\n\n        params = record.get(\"parameters\", {})\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except Exception:\n                params = {}\n\n        logger.info(f\"[DEBUG] params keys={list(params.keys()) if params else 'empty'}\")\n\n        model_variant = params.get(\"model_variant\") or params.get(\"model\") or record.get(\"model\") or \"\"\n        model_lower = model_variant.lower()\n        logger.info(f\"[DEBUG] 检测到 model_variant={model_variant}\")\n\n        # 定义匹配模式与目标变体的映射关系 (Regex Table)\n        # 模式 (Regex)                                     Target Variant\n        VARIANT_PATTERNS = [\n            (r\"(seedream|seededit).*?(4\\.5|4[-_]5|v4_5)\", \"seedream_v4_5\"),\n            (r\"(seedream|seededit).*?(4\\.0|4[-_]0|v4)\",   \"seedream_v4\"),\n            (r\"(seedream|seededit).*?(3\\.0|3[-_]0|v3)\",   \"seedream_v3\"),\n        ]\n\n        target_variant = None\n        for pattern, variant in VARIANT_PATTERNS:\n            if re.search(pattern, model_lower):\n                target_variant = variant\n                break\n\n        logger.info(f\"[DEBUG] 目标变体 target_variant={target_variant}\")\n\n        initial_values: Dict[str, Any] = {}\n        if params.get(\"size\") and params[\"size\"] != \"adaptive\":\n            initial_values[\"size\"] = params[\"size\"]\n\n        # 提取参数（兼容旧扁平 dict 与新三层结构）\n        params_requested = params.get(\"params_requested\") if isinstance(params, dict) else None\n        if not isinstance(params_requested, dict):\n            params_requested = params if isinstance(params, dict) else {}\n        params_actual = params.get(\"params_actual\") if isinstance(params, dict) else {}\n        if not isinstance(params_actual, dict):\n            params_actual = {}\n\n        # seed 仅 3.0 支持复用，4.0/4.5 不复用以免误导\n        is_seedream_3 = target_variant == \"seedream_v3\" if target_variant else False\n        if is_seedream_3:\n            if not record.get('_skip_seed_reuse'):\n                # 优先用 params_actual（API返回值），再用 params_requested，最后用顶层\n                seed = params_actual.get(\"seed\")\n                if seed is None:\n                    seed = params_requested.get(\"seed\")\n                if seed is None:\n                    seed = params.get(\"seed\")\n                if seed is not None:\n                    initial_values[\"seed\"] = int(seed)\n                    logger.info(f\"[DEBUG] 复用 seed 值: {seed}\")\n            else:\n                logger.info(\"[DEBUG] 跳过 seed 复用，显式设置为 -1（随机）\")\n                initial_values[\"seed\"] = -1  # 显式设置为随机\n\n        if params.get(\"count\"):\n            initial_values[\"count\"] = int(params[\"count\"])\n        if target_variant:\n            initial_values[\"model_variant\"] = target_variant\n\n        logger.info(f\"[DEBUG] initial_values={initial_values}\")\n\n        if target_variant:\n            self._load_image_schema(variant=target_variant, keep_values=False, initial_values=initial_values)\n        elif initial_values:\n            if hasattr(self, \"image_schema_form\") and self.image_schema_form:\n                for key, val in initial_values.items():\n                    try:\n                        self.image_schema_form.set_value(key, val)\n                    except Exception:\n                        pass\n\n        prompt = record.get(\"prompt\", \"\")\n        if prompt and hasattr(self, \"prompt_input\"):\n            self.prompt_input.setPlainText(prompt)\n\n        reference_assets = (\n            record.get(\"_resolved_reference_assets_abs\")\n            or record.get(\"_resolved_reference_assets\")\n            or record.get(\"reference_assets\")\n            or params.get(\"reference_assets\")\n            or []\n        )\n        logger.info(f\"[DEBUG] reference_assets 数量={len(reference_assets)}, repo_base_path={repo_base_path}\")\n\n        def resolve_path(asset: Any) -> str:\n            if isinstance(asset, dict):\n                path = asset.get(\"absolute_path\") or asset.get(\"path\", \"\")\n            elif isinstance(asset, str):\n                path = asset\n            else:\n                return \"\"\n\n            if path and not os.path.isabs(path) and repo_base_path:\n                abs_path = os.path.join(repo_base_path, path)\n                if os.path.exists(abs_path):\n                    return abs_path\n            return path\n\n        if reference_assets:\n            variant_str = str(self._image_schema_variant).lower() if self._image_schema_variant else \"\"\n            is_seedream_4 = (\n                \"seedream_4\" in variant_str\n                or \"seedream_v4\" in variant_str\n                or \"seedream4.0\" in variant_str\n                or \"seedream_4.5\" in variant_str\n            )\n\n            logger.info(f\"[DEBUG] is_seedream_4={is_seedream_4}, reference_panel存在={self.reference_panel is not None}\")\n\n            if is_seedream_4 and self.reference_panel:\n                self.reference_panel.clear()\n                for asset in reference_assets:\n                    path = resolve_path(asset)\n                    if path and os.path.exists(path):\n                        logger.info(f\"[DEBUG] 添加参考图: {path}\")\n                        self.reference_panel.add_image_path(path)\n                    else:\n                        logger.warning(f\"[DEBUG] 参考图不存在或路径为空: {path}\")\n            else:\n                if reference_assets:\n                    first_ref = reference_assets[0]\n                    path = resolve_path(first_ref)\n                    logger.info(f\"[DEBUG] 3.0模式参考图路径: {path}, 存在={os.path.exists(path) if path else 'N/A'}\")\n                    if path and os.path.exists(path):\n                        self.load_image_to_upload(path)\n\n        self.status_label.setText(\"✅ 参数已填入，可直接生成\")\n        logger.info(f\"[UI] 复用参数成功: model={target_variant}, prompt长度={len(prompt)}, 参考图数量={len(reference_assets)}\")\n\n    except Exception as exc:\n        logger.error(f\"复用参数失败: {exc}\")\n        import traceback\n\n        traceback.print_exc()\n","numLines":410,"startLine":1,"totalLines":410}},"sourceToolAssistantUUID":"08084242-d354-4227-8bbe-acfa371bc33e"}
{"parentUuid":"3e7fb125-9034-411b-994b-3d4987e14213","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PagyucVW7kSZNwMD7CpxqU","type":"tool_result","content":"Found 14 files\ncomponents/modes/shared/image/parameter_logic.py\ncomponents/modes/shared/video/parameter_logic.py\nmodules/seedream/manager.py\ncomponents/creation_components.py\ncomponents/dialogs/image_detail_dialog.py\nservices/video_service.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/creation_components.py\nservices/image_service.py\ntools/fix_final_issues.py\n.style_backup/qt_app.py\n.style_backup/components/generation/video_mode_widget.py\n.style_backup/components/generation/image_mode_widget.py\n.style_backup/components/creation_components.py"}]},"uuid":"15cf2084-c00d-488d-966c-541dddd88d62","timestamp":"2026-01-09T03:40:48.170Z","toolUseResult":{"mode":"files_with_matches","filenames":["components/modes/shared/image/parameter_logic.py","components/modes/shared/video/parameter_logic.py","modules/seedream/manager.py","components/creation_components.py","components/dialogs/image_detail_dialog.py","services/video_service.py",".style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py",".style_backup/备份（界面正确版）/鸽梦 9.24/components/creation_components.py","services/image_service.py","tools/fix_final_issues.py",".style_backup/qt_app.py",".style_backup/components/generation/video_mode_widget.py",".style_backup/components/generation/image_mode_widget.py",".style_backup/components/creation_components.py"],"numFiles":14},"sourceToolAssistantUUID":"3e7fb125-9034-411b-994b-3d4987e14213"}
{"parentUuid":"15cf2084-c00d-488d-966c-541dddd88d62","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014jEdec7Z4tSFpFwCviKcMe","type":"message","role":"assistant","content":[{"type":"text","text":"Let me search for repository manager and schema information to get a complete picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6640,"cache_read_input_tokens":89542,"cache_creation":{"ephemeral_5m_input_tokens":6640,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"b746a9f7-da1d-46e2-ac01-5a47449b70c1","timestamp":"2026-01-09T03:40:51.939Z"}
{"parentUuid":"b746a9f7-da1d-46e2-ac01-5a47449b70c1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014jEdec7Z4tSFpFwCviKcMe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QExmxwAUvw7GgDUDWqRChe","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6640,"cache_read_input_tokens":89542,"cache_creation":{"ephemeral_5m_input_tokens":6640,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5a11d4aa-82ab-4476-a955-29369c013662","timestamp":"2026-01-09T03:40:52.522Z"}
{"parentUuid":"5a11d4aa-82ab-4476-a955-29369c013662","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014jEdec7Z4tSFpFwCviKcMe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AczN7q9rHv4deJ4fCxYaQg","name":"Bash","input":{"command":"find /Users/yunchang/Documents/GitHub/gemeng2 -name \"*schema*\" -type f | head -20","description":"Search for schema-related files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6640,"cache_read_input_tokens":89542,"cache_creation":{"ephemeral_5m_input_tokens":6640,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f1e50a71-64b3-4afa-98b4-a6dee859ed42","timestamp":"2026-01-09T03:40:52.894Z"}
{"parentUuid":"5a11d4aa-82ab-4476-a955-29369c013662","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QExmxwAUvw7GgDUDWqRChe","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→仓库管理器 - 统一管理所有内容仓库功能\n     5→\n     6→主要功能：\n     7→- 协调各个子模块的工作\n     8→- 提供统一的API接口\n     9→- 管理仓库配置和状态\n    10→- 处理跨模块的数据交互\n    11→\"\"\"\n    12→\n    13→import os\n    14→import json\n    15→from pathlib import Path\n    16→from typing import Dict, List, Optional, Any\n    17→from datetime import datetime\n    18→from typing import Tuple\n    19→\n    20→from .sqlite_handler import SQLiteHandler\n    21→from loguru import logger\n    22→from utils.path_resolver import get_path_resolver, reset_path_resolver\n    23→try:\n    24→    from utils.error_handler import global_error_handler as _global_error_handler\n    25→except Exception:\n    26→    _global_error_handler = None\n    27→\n    28→\n    29→class _RepoErrorHandler:\n    30→    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    31→    def log_error(self, message: str):\n    32→        try:\n    33→            if _global_error_handler:\n    34→                logger.error(message)\n    35→            else:\n    36→                print(f\"[RepositoryManager][ERROR] {message}\")\n    37→        except Exception:\n    38→            print(f\"[RepositoryManager][ERROR] {message}\")\n    39→\n    40→\n    41→class _NullTagManager:\n    42→    def get_content_tags(self, content_id: str):\n    43→        return []\n    44→    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n    45→        return False\n    46→    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n    47→        return False\n    48→    def get_all_tags(self, category: str = None):\n    49→        return []\n    50→    def get_statistics(self):\n    51→        return {}\n    52→    def export_data(self):\n    53→        return {}\n    54→\n    55→\n    56→class _NullSearchEngine:\n    57→    def get_total_count(self) -> int:\n    58→        return 0\n    59→    def export_data(self):\n    60→        return {}\n    61→\n    62→\n    63→class RepositoryManager:\n    64→    \"\"\"\n    65→    仓库管理器 - 内容仓库的核心控制器\n    66→    \n    67→    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    68→    为上层应用提供统一的仓库管理接口。\n    69→    \"\"\"\n    70→    \n    71→    def __init__(self, storage_root: str):\n    72→        \"\"\"\n    73→        初始化仓库管理器\n    74→        \n    75→        Args:\n    76→            storage_root: 用户指定的存储根目录\n    77→        \"\"\"\n    78→        self.storage_root = Path(storage_root)\n    79→        self.repository_root = self.storage_root / \"repository\"\n    80→        self.config_file = self.repository_root / \"config.json\"\n    81→        \n    82→        # 确保仓库目录存在\n    83→        self.repository_root.mkdir(parents=True, exist_ok=True)\n    84→        \n    85→        # 初始化子模块\n    86→        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n    87→        # 提供占位依赖，避免未实现接口导致崩溃\n    88→        self.error_handler = _RepoErrorHandler()\n    89→        self.tag_manager = _NullTagManager()\n    90→        self.search_engine = _NullSearchEngine()\n    91→\n    92→        # 初始化路径解析器（单例，用于带缓存的路径操作）\n    93→        self._path_resolver = get_path_resolver(self.storage_root)\n    94→        \n    95→        # 加载配置\n    96→        self.config = self._load_config()\n    97→        \n    98→        # 初始化仓库\n    99→        self._initialize_repository()\n   100→    \n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"6ad98cb4-0e13-458d-a3cc-2ad337181b9c","timestamp":"2026-01-09T03:40:52.974Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n仓库管理器 - 统一管理所有内容仓库功能\n\n主要功能：\n- 协调各个子模块的工作\n- 提供统一的API接口\n- 管理仓库配置和状态\n- 处理跨模块的数据交互\n\"\"\"\n\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nfrom typing import Tuple\n\nfrom .sqlite_handler import SQLiteHandler\nfrom loguru import logger\nfrom utils.path_resolver import get_path_resolver, reset_path_resolver\ntry:\n    from utils.error_handler import global_error_handler as _global_error_handler\nexcept Exception:\n    _global_error_handler = None\n\n\nclass _RepoErrorHandler:\n    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    def log_error(self, message: str):\n        try:\n            if _global_error_handler:\n                logger.error(message)\n            else:\n                print(f\"[RepositoryManager][ERROR] {message}\")\n        except Exception:\n            print(f\"[RepositoryManager][ERROR] {message}\")\n\n\nclass _NullTagManager:\n    def get_content_tags(self, content_id: str):\n        return []\n    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n        return False\n    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n        return False\n    def get_all_tags(self, category: str = None):\n        return []\n    def get_statistics(self):\n        return {}\n    def export_data(self):\n        return {}\n\n\nclass _NullSearchEngine:\n    def get_total_count(self) -> int:\n        return 0\n    def export_data(self):\n        return {}\n\n\nclass RepositoryManager:\n    \"\"\"\n    仓库管理器 - 内容仓库的核心控制器\n    \n    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    为上层应用提供统一的仓库管理接口。\n    \"\"\"\n    \n    def __init__(self, storage_root: str):\n        \"\"\"\n        初始化仓库管理器\n        \n        Args:\n            storage_root: 用户指定的存储根目录\n        \"\"\"\n        self.storage_root = Path(storage_root)\n        self.repository_root = self.storage_root / \"repository\"\n        self.config_file = self.repository_root / \"config.json\"\n        \n        # 确保仓库目录存在\n        self.repository_root.mkdir(parents=True, exist_ok=True)\n        \n        # 初始化子模块\n        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n        # 提供占位依赖，避免未实现接口导致崩溃\n        self.error_handler = _RepoErrorHandler()\n        self.tag_manager = _NullTagManager()\n        self.search_engine = _NullSearchEngine()\n\n        # 初始化路径解析器（单例，用于带缓存的路径操作）\n        self._path_resolver = get_path_resolver(self.storage_root)\n        \n        # 加载配置\n        self.config = self._load_config()\n        \n        # 初始化仓库\n        self._initialize_repository()\n    ","numLines":100,"startLine":1,"totalLines":1144}},"sourceToolAssistantUUID":"5a11d4aa-82ab-4476-a955-29369c013662"}
{"parentUuid":"f1e50a71-64b3-4afa-98b4-a6dee859ed42","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AczN7q9rHv4deJ4fCxYaQg","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/lxml/isoschematron/resources/xsl/iso-schematron-xslt1/iso_schematron_skeleton_for_xslt1.xsl\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/lxml/isoschematron/resources/xsl/iso-schematron-xslt1/iso_schematron_message.xsl\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/lxml/isoschematron/resources/rng/iso-schematron.rng\n/Users/yunchang/Documents/GitHub/gemeng2/components/forms/schema_form_renderer.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/forms/__pycache__/schema_form_renderer.cpython-312.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/components/forms/__pycache__/schema_form_renderer.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/schema.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/schema.cpython-312.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","is_error":false}]},"uuid":"0a0972e0-1541-40b4-9a5b-d3e795d41094","timestamp":"2026-01-09T03:40:53.141Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/lxml/isoschematron/resources/xsl/iso-schematron-xslt1/iso_schematron_skeleton_for_xslt1.xsl\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/lxml/isoschematron/resources/xsl/iso-schematron-xslt1/iso_schematron_message.xsl\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream/_internal/lxml/isoschematron/resources/rng/iso-schematron.rng\n/Users/yunchang/Documents/GitHub/gemeng2/components/forms/schema_form_renderer.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/forms/__pycache__/schema_form_renderer.cpython-312.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/components/forms/__pycache__/schema_form_renderer.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/schema.cpython-313.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__pycache__/schema.cpython-312.pyc\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"f1e50a71-64b3-4afa-98b4-a6dee859ed42"}
{"parentUuid":"0a0972e0-1541-40b4-9a5b-d3e795d41094","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011c1QubLEXTWFoSmGHoaFAH","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the schema provider file to understand the complete picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2244,"cache_read_input_tokens":96182,"cache_creation":{"ephemeral_5m_input_tokens":2244,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"458d6243-9dc8-4952-aef6-1c13b4748d89","timestamp":"2026-01-09T03:40:56.634Z"}
{"parentUuid":"458d6243-9dc8-4952-aef6-1c13b4748d89","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011c1QubLEXTWFoSmGHoaFAH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01273QwZY6N8MtHTeyPWCwjM","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2244,"cache_read_input_tokens":96182,"cache_creation":{"ephemeral_5m_input_tokens":2244,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a20d44dc-6f97-4511-844c-63d307342723","timestamp":"2026-01-09T03:40:56.942Z"}
{"parentUuid":"a20d44dc-6f97-4511-844c-63d307342723","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01273QwZY6N8MtHTeyPWCwjM","type":"tool_result","content":"     1→﻿#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 参数 Schema 与校验（最小落地）\n     5→\n     6→目标：\n     7→- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n     8→- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n     9→- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n    10→\"\"\"\n    11→\n    12→import copy\n    13→from dataclasses import dataclass, field\n    14→from typing import Any, Optional, Tuple, List, Dict\n    15→\n    16→# 参考图限制（见官方文档 lines 203-204）\n    17→MAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\n    18→MAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n    19→\n    20→\n    21→# 白名单与范围\n    22→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    23→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n    24→\n    25→\n    26→@dataclass\n    27→class TextToImageParams:\n    28→    prompt: str\n    29→    size: str = \"1024x1024\"\n    30→    guidance_scale: float = 2.5\n    31→    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    32→    reference_images: List[str] = field(default_factory=list)\n    33→    sequential_mode: bool = False\n    34→    count: int = 1\n    35→\n    36→\n    37→@dataclass\n    38→class ImageToImageParams:\n    39→    prompt: str\n    40→    image: str  # URL 或 data URL\n    41→    guidance_scale: float = 5.5\n    42→    seed: Optional[int] = None\n    43→    reference_images: List[str] = field(default_factory=list)\n    44→    sequential_mode: bool = False\n    45→    count: int = 1\n    46→\n    47→\n    48→@dataclass\n    49→class VideoParams:\n    50→    prompt: str\n    51→    image_path: Optional[str] = None\n    52→    first_frame_path: Optional[str] = None\n    53→    last_frame_path: Optional[str] = None\n    54→    duration: int = 8\n    55→    fps: int = 24\n    56→    seed: Optional[int] = None\n    57→    camera_fixed: bool = True\n    58→    watermark: bool = False\n    59→    resolution_grade: Optional[str] = None\n    60→    ratio: Optional[str] = None\n    61→    use_pro_model: bool = True\n    62→    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    63→    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    64→    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    65→    reference_images: List[str] = field(default_factory=list)\n    66→\n    67→\n    68→@dataclass(frozen=True)\n    69→class UIOption:\n    70→    value: Any\n    71→    label: str\n    72→    description: Optional[str] = None\n    73→    meta: Dict[str, Any] = field(default_factory=dict)\n    74→\n    75→\n    76→@dataclass(frozen=True)\n    77→class UIDependency:\n    78→    field: str\n    79→    equals: Any = None\n    80→    not_equals: Any = None\n    81→    exists: bool = False\n    82→\n    83→\n    84→@dataclass\n    85→class UISchemaField:\n    86→    name: str\n    87→    field_type: str\n    88→    label: str\n    89→    default: Any = None\n    90→    required: bool = False\n    91→    help_text: Optional[str] = None\n    92→    placeholder: Optional[str] = None\n    93→    options: List[UIOption] = field(default_factory=list)\n    94→    min_value: Optional[float] = None\n    95→    max_value: Optional[float] = None\n    96→    step: Optional[float] = None\n    97→    visible_if: List[UIDependency] = field(default_factory=list)\n    98→    enabled_if: List[UIDependency] = field(default_factory=list)\n    99→    extra: Dict[str, Any] = field(default_factory=dict)\n   100→\n   101→    def to_dict(self) -> Dict[str, Any]:\n   102→        return {\n   103→            \"name\": self.name,\n   104→            \"type\": self.field_type,\n   105→            \"label\": self.label,\n   106→            \"default\": self.default,\n   107→            \"required\": self.required,\n   108→            \"help_text\": self.help_text,\n   109→            \"placeholder\": self.placeholder,\n   110→            \"options\": [\n   111→                {\n   112→                    \"value\": opt.value,\n   113→                    \"label\": opt.label,\n   114→                    \"description\": opt.description,\n   115→                    \"meta\": opt.meta,\n   116→                }\n   117→                for opt in self.options\n   118→            ],\n   119→            \"min\": self.min_value,\n   120→            \"max\": self.max_value,\n   121→            \"step\": self.step,\n   122→            \"visible_if\": [\n   123→                {\n   124→                    \"field\": dep.field,\n   125→                    \"equals\": dep.equals,\n   126→                    \"not_equals\": dep.not_equals,\n   127→                    \"exists\": dep.exists,\n   128→                }\n   129→                for dep in self.visible_if\n   130→            ],\n   131→            \"enabled_if\": [\n   132→                {\n   133→                    \"field\": dep.field,\n   134→                    \"equals\": dep.equals,\n   135→                    \"not_equals\": dep.not_equals,\n   136→                    \"exists\": dep.exists,\n   137→                }\n   138→                for dep in self.enabled_if\n   139→            ],\n   140→            \"extra\": self.extra,\n   141→        }\n   142→\n   143→\n   144→@dataclass\n   145→class UISchema:\n   146→    provider: str\n   147→    mode: str\n   148→    variant: str\n   149→    fields: List[UISchemaField] = field(default_factory=list)\n   150→    primary_image: Dict[str, Any] = field(default_factory=dict)\n   151→    reference_assets: Dict[str, Any] = field(default_factory=dict)\n   152→    extra: Dict[str, Any] = field(default_factory=dict)\n   153→\n   154→    def to_dict(self) -> Dict[str, Any]:\n   155→        return {\n   156→            \"provider\": self.provider,\n   157→            \"mode\": self.mode,\n   158→            \"variant\": self.variant,\n   159→            \"fields\": [field.to_dict() for field in self.fields],\n   160→            \"primary_image\": self.primary_image,\n   161→            \"reference_assets\": self.reference_assets,\n   162→            \"extra\": self.extra,\n   163→        }\n   164→\n   165→\n   166→def _clip_seed(seed: Optional[int]) -> Optional[int]:\n   167→    if seed is None:\n   168→        return None\n   169→    try:\n   170→        iv = int(seed)\n   171→    except Exception:\n   172→        return None\n   173→    if iv < 0:\n   174→        return None\n   175→    if iv > 2147483647:\n   176→        iv = 2147483647\n   177→    return iv\n   178→\n   179→\n   180→def validate_and_normalize_t2i(p: TextToImageParams) -> Tuple[TextToImageParams, bool, str]:\n   181→    fb = False\n   182→    reasons: List[str] = []\n   183→    # size: 期望形如 WxH，范围 512..4096（兼容 Seedream 4.0 高分辨率）\n   184→    def _valid_size(s: str) -> bool:\n   185→        try:\n   186→            if 'x' not in s:\n   187→                return False\n   188→            w, h = s.split('x', 1)\n   189→            w, h = int(w), int(h)\n   190→            return 512 <= w <= 4096 and 512 <= h <= 4096\n   191→        except Exception:\n   192→            return False\n   193→\n   194→    size = p.size or \"1024x1024\"\n   195→    if not _valid_size(size):\n   196→        fb = True\n   197→        reasons.append(f\"无效尺寸: {p.size or '缺失'}\")\n   198→        size = \"1024x1024\"\n   199→\n   200→    gs = p.guidance_scale\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5a0b7052-b388-48b4-9ba5-238fc9c154a3","timestamp":"2026-01-09T03:40:57.026Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","content":"﻿#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 参数 Schema 与校验（最小落地）\n\n目标：\n- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n\"\"\"\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Any, Optional, Tuple, List, Dict\n\n# 参考图限制（见官方文档 lines 203-204）\nMAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\nMAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n\n\n# 白名单与范围\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n\n\n@dataclass\nclass TextToImageParams:\n    prompt: str\n    size: str = \"1024x1024\"\n    guidance_scale: float = 2.5\n    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass ImageToImageParams:\n    prompt: str\n    image: str  # URL 或 data URL\n    guidance_scale: float = 5.5\n    seed: Optional[int] = None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass VideoParams:\n    prompt: str\n    image_path: Optional[str] = None\n    first_frame_path: Optional[str] = None\n    last_frame_path: Optional[str] = None\n    duration: int = 8\n    fps: int = 24\n    seed: Optional[int] = None\n    camera_fixed: bool = True\n    watermark: bool = False\n    resolution_grade: Optional[str] = None\n    ratio: Optional[str] = None\n    use_pro_model: bool = True\n    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    reference_images: List[str] = field(default_factory=list)\n\n\n@dataclass(frozen=True)\nclass UIOption:\n    value: Any\n    label: str\n    description: Optional[str] = None\n    meta: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass(frozen=True)\nclass UIDependency:\n    field: str\n    equals: Any = None\n    not_equals: Any = None\n    exists: bool = False\n\n\n@dataclass\nclass UISchemaField:\n    name: str\n    field_type: str\n    label: str\n    default: Any = None\n    required: bool = False\n    help_text: Optional[str] = None\n    placeholder: Optional[str] = None\n    options: List[UIOption] = field(default_factory=list)\n    min_value: Optional[float] = None\n    max_value: Optional[float] = None\n    step: Optional[float] = None\n    visible_if: List[UIDependency] = field(default_factory=list)\n    enabled_if: List[UIDependency] = field(default_factory=list)\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"type\": self.field_type,\n            \"label\": self.label,\n            \"default\": self.default,\n            \"required\": self.required,\n            \"help_text\": self.help_text,\n            \"placeholder\": self.placeholder,\n            \"options\": [\n                {\n                    \"value\": opt.value,\n                    \"label\": opt.label,\n                    \"description\": opt.description,\n                    \"meta\": opt.meta,\n                }\n                for opt in self.options\n            ],\n            \"min\": self.min_value,\n            \"max\": self.max_value,\n            \"step\": self.step,\n            \"visible_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.visible_if\n            ],\n            \"enabled_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.enabled_if\n            ],\n            \"extra\": self.extra,\n        }\n\n\n@dataclass\nclass UISchema:\n    provider: str\n    mode: str\n    variant: str\n    fields: List[UISchemaField] = field(default_factory=list)\n    primary_image: Dict[str, Any] = field(default_factory=dict)\n    reference_assets: Dict[str, Any] = field(default_factory=dict)\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"provider\": self.provider,\n            \"mode\": self.mode,\n            \"variant\": self.variant,\n            \"fields\": [field.to_dict() for field in self.fields],\n            \"primary_image\": self.primary_image,\n            \"reference_assets\": self.reference_assets,\n            \"extra\": self.extra,\n        }\n\n\ndef _clip_seed(seed: Optional[int]) -> Optional[int]:\n    if seed is None:\n        return None\n    try:\n        iv = int(seed)\n    except Exception:\n        return None\n    if iv < 0:\n        return None\n    if iv > 2147483647:\n        iv = 2147483647\n    return iv\n\n\ndef validate_and_normalize_t2i(p: TextToImageParams) -> Tuple[TextToImageParams, bool, str]:\n    fb = False\n    reasons: List[str] = []\n    # size: 期望形如 WxH，范围 512..4096（兼容 Seedream 4.0 高分辨率）\n    def _valid_size(s: str) -> bool:\n        try:\n            if 'x' not in s:\n                return False\n            w, h = s.split('x', 1)\n            w, h = int(w), int(h)\n            return 512 <= w <= 4096 and 512 <= h <= 4096\n        except Exception:\n            return False\n\n    size = p.size or \"1024x1024\"\n    if not _valid_size(size):\n        fb = True\n        reasons.append(f\"无效尺寸: {p.size or '缺失'}\")\n        size = \"1024x1024\"\n\n    gs = p.guidance_scale","numLines":200,"startLine":1,"totalLines":887}},"sourceToolAssistantUUID":"a20d44dc-6f97-4511-844c-63d307342723"}
{"parentUuid":"5a0b7052-b388-48b4-9ba5-238fc9c154a3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MS44HJhZVTM12y19DhKBkx","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check for image service to see how the data flows to the database:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2821,"cache_read_input_tokens":98426,"cache_creation":{"ephemeral_5m_input_tokens":2821,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"edb9d484-f4fe-461a-b3b6-9d8b001179bb","timestamp":"2026-01-09T03:41:01.681Z"}
{"parentUuid":"edb9d484-f4fe-461a-b3b6-9d8b001179bb","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MS44HJhZVTM12y19DhKBkx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AamgGitaEXshEaP8YV9yWw","name":"Bash","input":{"command":"grep -n \"params_requested\\|params_actual\\|parameters.*seed\" /Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py | head -30","description":"Search for parameters handling in image service"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2821,"cache_read_input_tokens":98426,"cache_creation":{"ephemeral_5m_input_tokens":2821,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"02c4c294-1fec-47de-bf96-55113e24381d","timestamp":"2026-01-09T03:41:02.461Z"}
{"parentUuid":"02c4c294-1fec-47de-bf96-55113e24381d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AamgGitaEXshEaP8YV9yWw","type":"tool_result","content":"","is_error":false}]},"uuid":"6469ea48-1a6a-41b0-99f8-55ab6b9d43e2","timestamp":"2026-01-09T03:41:02.590Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"02c4c294-1fec-47de-bf96-55113e24381d"}
{"parentUuid":"6469ea48-1a6a-41b0-99f8-55ab6b9d43e2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017NSda4xhF5W7guMemkwx1H","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the image service file directly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":182,"cache_read_input_tokens":101247,"cache_creation":{"ephemeral_5m_input_tokens":182,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"855bcedf-8c52-46c8-b595-87dba90cb53e","timestamp":"2026-01-09T03:41:06.685Z"}
{"parentUuid":"855bcedf-8c52-46c8-b595-87dba90cb53e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017NSda4xhF5W7guMemkwx1H","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KCfEhyUVmLeWpTGTx3Rzmo","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":182,"cache_read_input_tokens":101247,"cache_creation":{"ephemeral_5m_input_tokens":182,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a654cf86-cf45-4d53-8ca7-c437f8970cb7","timestamp":"2026-01-09T03:41:07.010Z"}
{"parentUuid":"a654cf86-cf45-4d53-8ca7-c437f8970cb7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KCfEhyUVmLeWpTGTx3Rzmo","type":"tool_result","content":"     1→\"\"\"Seedream image generation service layer.\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import uuid\n     6→from typing import Any, Callable, Dict, List, Optional\n     7→\n     8→from config.unified_config import get_unified_config\n     9→from modules.repository.manager import RepositoryManager\n    10→from modules.seedream.manager import SeedreamManager\n    11→from modules.storage import get_v2_storage_manager\n    12→from utils.logger import logger\n    13→\n    14→ProgressCallback = Optional[Callable[[Optional[float], str], None]]\n    15→CancelCallback = Optional[Callable[[], bool]]\n    16→\n    17→\n    18→class ImageService:\n    19→    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n    20→\n    21→    def __init__(\n    22→        self,\n    23→        storage_manager=None,\n    24→        repository_manager: Optional[RepositoryManager] = None,\n    25→        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    26→    ) -> None:\n    27→        # Use unified config for storage path and API validation\n    28→        self.unified_config = get_unified_config()\n    29→\n    30→        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n    31→        self.repository_manager = repository_manager\n    32→        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n    33→\n    34→    # ------------------------------------------------------------------\n    35→    # Public API\n    36→    # ------------------------------------------------------------------\n    37→    def generate_image(\n    38→        self,\n    39→        params: Dict[str, Any],\n    40→        progress_callback: ProgressCallback = None,\n    41→        should_cancel: CancelCallback = None,\n    42→    ) -> Dict[str, Any]:\n    43→        prompt = (params.get(\"prompt\") or \"\").strip()\n    44→        if not prompt:\n    45→            return self._failure(\"Prompt cannot be empty\")\n    46→\n    47→        if self._is_cancelled(should_cancel):\n    48→            return self._cancelled()\n    49→\n    50→        self._emit_progress(progress_callback, \"Preparing...\")\n    51→\n    52→        try:\n    53→            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n    54→            if not is_valid:\n    55→                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n    56→                detail = message or \"API key not configured\"\n    57→                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n    58→        except Exception as cfg_err:\n    59→            return self._failure(f\"Config validation failed: {cfg_err}\")\n    60→\n    61→        try:\n    62→            api_key = self.unified_config.get_api_key(\"volcengine\")\n    63→        except Exception as key_err:\n    64→            return self._failure(f\"Failed to load API key: {key_err}\")\n    65→\n    66→        if self._is_cancelled(should_cancel):\n    67→            return self._cancelled()\n    68→\n    69→        try:\n    70→            seedream_manager = self._seedream_manager_factory(api_key)\n    71→            self._emit_progress(progress_callback, \"Seedream manager ready\")\n    72→        except Exception as init_err:\n    73→            logger.error(f\"Seedream manager init failed: {init_err}\")\n    74→            return self._failure(f\"Seedream manager init failed: {init_err}\")\n    75→\n    76→        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n    77→        reference_images = params.get(\"reference_images\") or []\n    78→        input_image_path = (\n    79→            params.get(\"input_image_path\")\n    80→            or params.get(\"input_image\")\n    81→            or params.get(\"image_path\")\n    82→            or params.get(\"image\")\n    83→        )\n    84→        base_size = params.get(\"size\", \"1024x1024\")\n    85→        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n    86→        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n    87→        model_variant = params.get(\"model_variant\")\n    88→        generation_id = params.get(\"generation_id\")\n    89→        derived_ids: List[str] = params.get(\"derived_ids\") or []\n    90→        sequential_mode = bool(params.get(\"sequential_mode\", False))\n    91→\n    92→        try:\n    93→            if generation_count == 1:\n    94→                result = self._generate_single(\n    95→                    seedream_manager=seedream_manager,\n    96→                    prompt=prompt,\n    97→                    size=base_size,\n    98→                    guidance_scale=guidance_scale,\n    99→                    seed=seed,\n   100→                    model_variant=model_variant,\n   101→                    input_image_path=input_image_path,\n   102→                    reference_images=reference_images,\n   103→                    generation_id=generation_id,\n   104→                    sequential_mode=sequential_mode,\n   105→                    progress_callback=progress_callback,\n   106→                    should_cancel=should_cancel,\n   107→                )\n   108→            else:\n   109→                result = self._generate_batch(\n   110→                    seedream_manager=seedream_manager,\n   111→                    prompt=prompt,\n   112→                    count=generation_count,\n   113→                    size=base_size,\n   114→                    guidance_scale=guidance_scale,\n   115→                    seed=seed,\n   116→                    input_image_path=input_image_path,\n   117→                    reference_images=reference_images,\n   118→                    model_variant=model_variant,\n   119→                    generation_id=generation_id,\n   120→                    derived_ids=derived_ids,\n   121→                    sequential_mode=sequential_mode,\n   122→                    progress_callback=progress_callback,\n   123→                    should_cancel=should_cancel,\n   124→                )\n   125→        except Exception as api_error:\n   126→            logger.error(f\"Seedream API error: {api_error}\")\n   127→            return self._failure(f\"API error: {api_error}\")\n   128→\n   129→        if self._is_cancelled(should_cancel):\n   130→            return self._cancelled()\n   131→\n   132→        if result.get(\"success\"):\n   133→            summary = \"Generation completed\"\n   134→            if generation_count > 1:\n   135→                success_count = result.get(\"success_count\", 0)\n   136→                summary = f\"Batch completed {success_count}/{result.get('total_count', generation_count)}\"\n   137→            self._emit_progress(progress_callback, summary, percentage=100.0)\n   138→            self._persist_metadata(result)\n   139→        else:\n   140→            error_msg = result.get(\"error\", \"unknown error\")\n   141→            self._emit_progress(progress_callback, f\"Generation failed: {error_msg}\")\n   142→\n   143→        return result\n   144→\n   145→    # ------------------------------------------------------------------\n   146→    # Internal helpers\n   147→    # ------------------------------------------------------------------\n   148→    def _generate_single(\n   149→        self,\n   150→        *,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"11cd6942-bcf0-4deb-a99a-9cf119780ccb","timestamp":"2026-01-09T03:41:07.061Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py","content":"\"\"\"Seedream image generation service layer.\"\"\"\n\nfrom __future__ import annotations\n\nimport uuid\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom config.unified_config import get_unified_config\nfrom modules.repository.manager import RepositoryManager\nfrom modules.seedream.manager import SeedreamManager\nfrom modules.storage import get_v2_storage_manager\nfrom utils.logger import logger\n\nProgressCallback = Optional[Callable[[Optional[float], str], None]]\nCancelCallback = Optional[Callable[[], bool]]\n\n\nclass ImageService:\n    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n\n    def __init__(\n        self,\n        storage_manager=None,\n        repository_manager: Optional[RepositoryManager] = None,\n        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    ) -> None:\n        # Use unified config for storage path and API validation\n        self.unified_config = get_unified_config()\n\n        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n        self.repository_manager = repository_manager\n        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n    def generate_image(\n        self,\n        params: Dict[str, Any],\n        progress_callback: ProgressCallback = None,\n        should_cancel: CancelCallback = None,\n    ) -> Dict[str, Any]:\n        prompt = (params.get(\"prompt\") or \"\").strip()\n        if not prompt:\n            return self._failure(\"Prompt cannot be empty\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        self._emit_progress(progress_callback, \"Preparing...\")\n\n        try:\n            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n            if not is_valid:\n                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n                detail = message or \"API key not configured\"\n                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n        except Exception as cfg_err:\n            return self._failure(f\"Config validation failed: {cfg_err}\")\n\n        try:\n            api_key = self.unified_config.get_api_key(\"volcengine\")\n        except Exception as key_err:\n            return self._failure(f\"Failed to load API key: {key_err}\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        try:\n            seedream_manager = self._seedream_manager_factory(api_key)\n            self._emit_progress(progress_callback, \"Seedream manager ready\")\n        except Exception as init_err:\n            logger.error(f\"Seedream manager init failed: {init_err}\")\n            return self._failure(f\"Seedream manager init failed: {init_err}\")\n\n        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n        reference_images = params.get(\"reference_images\") or []\n        input_image_path = (\n            params.get(\"input_image_path\")\n            or params.get(\"input_image\")\n            or params.get(\"image_path\")\n            or params.get(\"image\")\n        )\n        base_size = params.get(\"size\", \"1024x1024\")\n        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n        model_variant = params.get(\"model_variant\")\n        generation_id = params.get(\"generation_id\")\n        derived_ids: List[str] = params.get(\"derived_ids\") or []\n        sequential_mode = bool(params.get(\"sequential_mode\", False))\n\n        try:\n            if generation_count == 1:\n                result = self._generate_single(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    model_variant=model_variant,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    generation_id=generation_id,\n                    sequential_mode=sequential_mode,\n                    progress_callback=progress_callback,\n                    should_cancel=should_cancel,\n                )\n            else:\n                result = self._generate_batch(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    count=generation_count,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    model_variant=model_variant,\n                    generation_id=generation_id,\n                    derived_ids=derived_ids,\n                    sequential_mode=sequential_mode,\n                    progress_callback=progress_callback,\n                    should_cancel=should_cancel,\n                )\n        except Exception as api_error:\n            logger.error(f\"Seedream API error: {api_error}\")\n            return self._failure(f\"API error: {api_error}\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        if result.get(\"success\"):\n            summary = \"Generation completed\"\n            if generation_count > 1:\n                success_count = result.get(\"success_count\", 0)\n                summary = f\"Batch completed {success_count}/{result.get('total_count', generation_count)}\"\n            self._emit_progress(progress_callback, summary, percentage=100.0)\n            self._persist_metadata(result)\n        else:\n            error_msg = result.get(\"error\", \"unknown error\")\n            self._emit_progress(progress_callback, f\"Generation failed: {error_msg}\")\n\n        return result\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n    def _generate_single(\n        self,\n        *,","numLines":150,"startLine":1,"totalLines":398}},"sourceToolAssistantUUID":"a654cf86-cf45-4d53-8ca7-c437f8970cb7"}
{"parentUuid":"11cd6942-bcf0-4deb-a99a-9cf119780ccb","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"5e70f1d9-b4c5-4880-ae07-07d5d196691d","version":"2.1.1","gitBranch":"main","agentId":"a5490b6","slug":"jiggly-gliding-rose","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Xw3ebGaGnjqkAJV4yXpYAu","type":"message","role":"assistant","content":[{"type":"text","text":"Based on my comprehensive investigation, I now have a clear understanding of how seed values are stored in the Seedream 3.0 image generation system. Let me provide you with the detailed findings:\n\n## Seed Value Storage Investigation - Complete Report\n\n### 1. Seed Collection from Form (UI → SeedreamManager)\n\n**File**: `/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/generation_logic.py` (lines 30-34)\n\n```python\nseed_value = form_values.get(\"seed\", -1)\ntry:\n    seed_value = int(seed_value)\nexcept Exception:\n    seed_value = -1\n```\n\nThe seed value is collected from the image generation form with a default of **-1** (which means random).\n\n### 2. Seed Passed to SeedreamManager\n\n**File**: `/Users/yunchang/Documents/GitHub/gemeng2/components/modes/shared/image/mode_widget_impl.py` (line 79)\n\nThe seed is passed via params dict to `self._task_manager.submit_image_task(params)`.\n\n### 3. Seed Storage in parameters (Critical Finding)\n\n**File**: `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py`\n\nThere are **two key locations** where seed is stored:\n\n#### Location A: Single Image Mode (Lines 276-280)\n```python\n\"parameters\": {\n    \"size\": size,\n    \"guidance_scale\": guidance_scale,\n    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n    **(({\"seed\": seed} if seedream_provider is None else {})),\n    \"response_format\": \"url\",\n    \"watermark\": False,\n    ...\n}\n```\n\n#### Location B: Batch/Group Mode (Lines 219-235)\n```python\n\"parameters\": {\n    \"size\": size,\n    \"guidance_scale\": guidance_scale,\n    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n    **(({\"seed\": seed} if seedream_provider is None else {})),\n    ...\n}\n```\n\n### Key Observations:\n\n1. **Storage Level**: Seed is stored in the **top-level `parameters` dict** (NOT in `params_requested` or `params_actual`)\n\n2. **Conditional Storage** (Lines 223, 280):\n   - For **Seedream 3.0** (when `seedream_provider is None`): seed IS stored\n   - For **Seedream 4.0/4.5** (when `seedream_provider in {volc_v4, volc_v4_5}`): seed is NOT stored to avoid misleading users when reusing parameters\n\n3. **Database Storage**: The parameters dict is then serialized to JSON and stored in the SQLite database:\n   - **File**: `/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py` (line 228)\n   - **Field**: `parameters TEXT` column in `generations` table\n   - **Serialization**: `self._dump_json(data.get(\"parameters\"))` converts the dict to JSON string\n\n4. **Parameter Reuse** (from `parameter_logic.py` lines 313-328):\n   ```python\n   # seed 仅 3.0 支持复用，4.0/4.5 不复用以免误导\n   is_seedream_3 = target_variant == \"seedream_v3\" if target_variant else False\n   if is_seedream_3:\n       if not record.get('_skip_seed_reuse'):\n           # 优先用 params_actual，再用 params_requested，最后用顶层\n           seed = params_actual.get(\"seed\")\n           if seed is None:\n               seed = params_requested.get(\"seed\")\n           if seed is None:\n               seed = params.get(\"seed\")  # <- TOP-LEVEL FALLBACK\n   ```\n\n### Database Schema\n\n**File**: `/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py` (lines 111-124)\n\n```sql\nCREATE TABLE IF NOT EXISTS generations (\n    id TEXT PRIMARY KEY,\n    content_type TEXT NOT NULL,\n    prompt TEXT,\n    model TEXT,\n    status TEXT DEFAULT 'completed',\n    file_path TEXT,\n    relative_path TEXT,\n    thumbnail_path TEXT,\n    parameters TEXT,  -- <- SEED STORED HERE (JSON)\n    metadata TEXT,\n    created_at TEXT,\n    updated_at TEXT\n);\n```\n\n### Summary Table\n\n| Aspect | Location |\n|--------|----------|\n| **Form Collection** | Top-level form field \"seed\" with default -1 |\n| **Manager Processing** | `SeedreamManager.generate_text_to_image()` |\n| **Storage Level** | Top-level `parameters` dict (conditionally for 3.0 only) |\n| **Database Field** | `generations.parameters` (JSON serialized) |\n| **Actual Storage Key** | `parameters[\"seed\"]` for Seedream 3.0 |\n| **Support** | Seedream 3.0 only; NOT stored for 4.0/4.5 |\n| **Reuse Logic** | Checks top-level `params.get(\"seed\")` as fallback |\n\nThis design ensures backward compatibility while being explicit about which model versions support seed persistence and reuse."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2472,"cache_read_input_tokens":101429,"cache_creation":{"ephemeral_5m_input_tokens":2472,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"83d9c50a-7aaa-4f48-a660-313240b1e967","timestamp":"2026-01-09T03:41:23.771Z"}
