{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":"探索这个项目中图片模式和视频模式的数据库存储逻辑，特别关注模型名称是如何存储的：\n\n1. 找到图片生成后，模型名称存入数据库的代码（Seedream）\n2. 找到视频生成后，模型名称存入数据库的代码（Seedance）\n3. 对比两者存储的模型名称格式是否一致\n\n关注：\n- 存储的是完整模型ID（如 doubao-seedance-1-0-pro-250528）还是简短名称（如 pro）？\n- 图片和视频的存储格式是否一致？\n\n返回具体的代码位置和存储格式分析。"},"uuid":"41ad5117-9707-49db-9180-f353dcc2ccc4","timestamp":"2026-01-08T03:06:08.377Z"}
{"parentUuid":"41ad5117-9707-49db-9180-f353dcc2ccc4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01P7RUJyWMNpVki3LzhMwcZx","type":"message","role":"assistant","content":[{"type":"text","text":"I'll explore the project to understand how model names are stored in the database for both image and video generation modes. Let me start by examining the repository structure and key modules."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":19677,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":19677,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"588e9be9-f8f8-4c5f-8e94-f95b25b124ad","timestamp":"2026-01-08T03:06:11.809Z"}
{"parentUuid":"588e9be9-f8f8-4c5f-8e94-f95b25b124ad","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01P7RUJyWMNpVki3LzhMwcZx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GnXRFsf6YkjCfeaWNurfyw","name":"Bash","input":{"command":"find /Users/yunchang/Documents/GitHub/gemeng2 -type f -name \"*.py\" | grep -E \"(seedream|seedance|repository)\" | head -20","description":"Find Seedream and Seedance related files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":19677,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":19677,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"7d4f2d7c-fe60-42e6-8964-4c12099da289","timestamp":"2026-01-08T03:06:12.655Z"}
{"parentUuid":"7d4f2d7c-fe60-42e6-8964-4c12099da289","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01P7RUJyWMNpVki3LzhMwcZx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016aHD8siiRjvxdZTjAhJ5n6","name":"Glob","input":{"pattern":"**/*.py","path":"/Users/yunchang/Documents/GitHub/gemeng2"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":19677,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":19677,"ephemeral_1h_input_tokens":0},"output_tokens":222,"service_tier":"standard"}},"type":"assistant","uuid":"c444723c-0115-49a3-9a17-f2fca8489fea","timestamp":"2026-01-08T03:06:12.717Z"}
{"parentUuid":"c444723c-0115-49a3-9a17-f2fca8489fea","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016aHD8siiRjvxdZTjAhJ5n6","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_history_waterfall_update.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/verify_waterfall_changes.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/waterfall_loading_analysis.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/cards/image_card.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/cards/video_card.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/chat_components.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/common_components.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/creation_components.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/delegates/image_card_delegate.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/delegates/video_card_delegate.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/forms/parameter_form_standard.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/generation/image_mode_widget.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/generation/video_mode_widget.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/settings_page.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/views/history_view_optimized.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/widgets/mode_button.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/widgets/reference_assets_panel.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/qt_app.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/tools/debug_font_scaling.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/common_components.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/image_card_delegate.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/video_card_delegate.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py\n/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/tools/debug_font_scaling.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/adapters/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/forms/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/modes/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/app_config.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/project_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/settings.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/sources/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/config/sources/watermark_config.py\n/Users/yunchang/Documents/GitHub/gemeng2/edition/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/edition/constants.py\n/Users/yunchang/Documents/GitHub/gemeng2/edition/crypto_utils.py\n/Users/yunchang/Documents/GitHub/gemeng2/edition/resources.py\n/Users/yunchang/Documents/GitHub/gemeng2/edition/trial_license_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtCore.py\n/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtGui.py\n/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtMultimedia.py\n/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtNetwork.py\n/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtPrintSupport.py\n/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtWidgets.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/progress_tracker.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/safe_requests.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/runtime_env.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/setup_fixed.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/setup_with_zero_config.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/create_official_icon.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/create_ultra_hq_icon.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/prepare_icon.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/prepare_trial_icon.py\n/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/prepare_trial_icon_hq.py\n/Users/yunchang/Documents/GitHub/gemeng2/services/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/build_official_release.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/check_ffmpeg_filters.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/comprehensive_history_fix.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/convert_icon_to_ico.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/debug_font_scaling.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/deep_analysis_history_update.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_api_header_issue.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_detail_dialog_issue.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_font_scaling_issues.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_parameter_panel_spacing.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_reference_display.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_video_error.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_video_reference_panel.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_visibility_rules.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/final_fixes_summary.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_all_dependencies.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_all_string_errors.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_all_unterminated_strings.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_api_header_issue.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_component_dependencies.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_final_dependencies.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_final_issues.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_inline_docstrings.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_line_1099.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_line_1242.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_line_1465.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_remaining_issues.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/install_ffmpeg_windows.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/memory_leak_detector.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/performance_benchmark.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/repair_top.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/root_cause_analysis.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/sanitize_docstrings.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/setup_ffmpeg.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/strip_triple_blocks.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/style_migration_tool.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/system_diagnosis.py\n(Results are truncated. Consider using a more specific path or pattern.)"}]},"uuid":"6e8990cc-8853-48c0-858f-a6b6f9bb9e22","timestamp":"2026-01-08T03:06:12.929Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_history_waterfall_update.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/verify_waterfall_changes.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/waterfall_loading_analysis.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/cards/image_card.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/cards/video_card.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/chat_components.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/common_components.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/creation_components.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/delegates/image_card_delegate.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/delegates/video_card_delegate.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/forms/parameter_form_standard.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/generation/image_mode_widget.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/generation/video_mode_widget.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/settings_page.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/views/history_view_optimized.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/widgets/mode_button.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/components/widgets/reference_assets_panel.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/qt_app.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/tools/debug_font_scaling.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/common_components.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/image_card_delegate.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/delegates/video_card_delegate.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/components/widgets/reference_assets_panel.py","/Users/yunchang/Documents/GitHub/gemeng2/.style_backup/备份（界面正确版）/鸽梦 9.24/tools/debug_font_scaling.py","/Users/yunchang/Documents/GitHub/gemeng2/components/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/components/adapters/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/components/forms/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/components/modes/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/config/app_config.py","/Users/yunchang/Documents/GitHub/gemeng2/config/project_manager.py","/Users/yunchang/Documents/GitHub/gemeng2/config/settings.py","/Users/yunchang/Documents/GitHub/gemeng2/config/sources/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/config/sources/watermark_config.py","/Users/yunchang/Documents/GitHub/gemeng2/edition/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/edition/constants.py","/Users/yunchang/Documents/GitHub/gemeng2/edition/crypto_utils.py","/Users/yunchang/Documents/GitHub/gemeng2/edition/resources.py","/Users/yunchang/Documents/GitHub/gemeng2/edition/trial_license_manager.py","/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtCore.py","/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtGui.py","/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtMultimedia.py","/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtNetwork.py","/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtPrintSupport.py","/Users/yunchang/Documents/GitHub/gemeng2/hooks/hook-PyQt5.QtWidgets.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/progress_tracker.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/safe_requests.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/hooks/runtime_env.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/setup_fixed.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/macos/setup_with_zero_config.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/create_official_icon.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/create_ultra_hq_icon.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/prepare_icon.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/prepare_trial_icon.py","/Users/yunchang/Documents/GitHub/gemeng2/packaging/windows/prepare_trial_icon_hq.py","/Users/yunchang/Documents/GitHub/gemeng2/services/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/build_official_release.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/check_ffmpeg_filters.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/comprehensive_history_fix.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/convert_icon_to_ico.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/debug_font_scaling.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/deep_analysis_history_update.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_api_header_issue.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_detail_dialog_issue.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_font_scaling_issues.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_parameter_panel_spacing.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_reference_display.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_video_error.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_video_reference_panel.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_visibility_rules.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/final_fixes_summary.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_all_dependencies.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_all_string_errors.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_all_unterminated_strings.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_api_header_issue.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_component_dependencies.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_final_dependencies.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_final_issues.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_inline_docstrings.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_line_1099.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_line_1242.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_line_1465.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/fix_remaining_issues.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/install_ffmpeg_windows.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/memory_leak_detector.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/performance_benchmark.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/repair_top.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/root_cause_analysis.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/sanitize_docstrings.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/setup_ffmpeg.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/strip_triple_blocks.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/style_migration_tool.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/system_diagnosis.py"],"durationMs":119,"numFiles":100,"truncated":true},"sourceToolAssistantUUID":"c444723c-0115-49a3-9a17-f2fca8489fea"}
{"parentUuid":"7d4f2d7c-fe60-42e6-8964-4c12099da289","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GnXRFsf6YkjCfeaWNurfyw","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_direct.py\n/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test2.py\n/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","is_error":false}]},"uuid":"1c20c708-d393-4562-b918-3b21ea9e8f0d","timestamp":"2026-01-08T03:06:13.209Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_direct.py\n/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test2.py\n/Users/yunchang/Documents/GitHub/gemeng2/scripts/run_seedance_watermark_test.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"7d4f2d7c-fe60-42e6-8964-4c12099da289"}
{"parentUuid":"1c20c708-d393-4562-b918-3b21ea9e8f0d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ac8PUUm4ShKqSbky8AdQGx","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me examine the key repository and generation modules:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2769,"cache_creation_input_tokens":886,"cache_read_input_tokens":19677,"cache_creation":{"ephemeral_5m_input_tokens":886,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"35de58f4-958f-41b3-88bd-4f12e4d8b725","timestamp":"2026-01-08T03:06:15.859Z"}
{"parentUuid":"35de58f4-958f-41b3-88bd-4f12e4d8b725","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ac8PUUm4ShKqSbky8AdQGx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017UnjHepMJVwVy5UoaNL4cX","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2769,"cache_creation_input_tokens":886,"cache_read_input_tokens":19677,"cache_creation":{"ephemeral_5m_input_tokens":886,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"80a3f8cc-0028-43b7-a90e-5b2bf4940a57","timestamp":"2026-01-08T03:06:16.257Z"}
{"parentUuid":"80a3f8cc-0028-43b7-a90e-5b2bf4940a57","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ac8PUUm4ShKqSbky8AdQGx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fv3jVGZVqVPCZKQ5Ggn2Q1","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2769,"cache_creation_input_tokens":886,"cache_read_input_tokens":19677,"cache_creation":{"ephemeral_5m_input_tokens":886,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"82aa447b-0155-4268-8d9b-86ec41c8ff99","timestamp":"2026-01-08T03:06:16.524Z"}
{"parentUuid":"82aa447b-0155-4268-8d9b-86ec41c8ff99","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ac8PUUm4ShKqSbky8AdQGx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NtowVRuoYCMNSgfJWgj5rq","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2769,"cache_creation_input_tokens":886,"cache_read_input_tokens":19677,"cache_creation":{"ephemeral_5m_input_tokens":886,"ephemeral_1h_input_tokens":0},"output_tokens":204,"service_tier":"standard"}},"type":"assistant","uuid":"3fc7e3e1-4489-40b8-94d6-76a89bd02824","timestamp":"2026-01-08T03:06:16.734Z"}
{"parentUuid":"80a3f8cc-0028-43b7-a90e-5b2bf4940a57","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017UnjHepMJVwVy5UoaNL4cX","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import json\n     8→import sqlite3\n     9→import threading\n    10→from concurrent.futures import Future, TimeoutError\n    11→from queue import Queue\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Any, Callable, Dict, List, Optional\n    15→\n    16→from loguru import logger\n    17→\n    18→\n    19→class SQLiteHandler:\n    20→    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n    21→\n    22→    _DEFAULT_TIMEOUT_SECONDS = 30.0\n    23→\n    24→    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n    25→        \"\"\"初始化数据库连接并创建所需表结构.\n    26→\n    27→        Args:\n    28→            db_path: 数据库文件路径\n    29→            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n    30→        \"\"\"\n    31→\n    32→        self.db_path = Path(db_path)\n    33→        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n    34→        self.storage_root = storage_root\n    35→\n    36→        # 并发策略（Q002-方案B）：单线程 DB Worker + 队列串行执行\n    37→        self._closed = False\n    38→        self._queue: Queue[Optional[tuple[Future, Callable[[sqlite3.Connection], Any]]]] = Queue()\n    39→        self._init_future: Future[bool] = Future()\n    40→\n    41→        self._worker_thread = threading.Thread(\n    42→            target=self._run_worker,\n    43→            name=f\"SQLiteHandler[{self.db_path.name}]\",\n    44→            daemon=True,\n    45→        )\n    46→        self._worker_thread.start()\n    47→\n    48→        try:\n    49→            self._init_future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n    50→        except Exception as exc:\n    51→            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n    52→            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n    53→\n    54→    def _run_worker(self) -> None:\n    55→        connection: Optional[sqlite3.Connection] = None\n    56→        try:\n    57→            connection = sqlite3.connect(self.db_path)\n    58→            connection.row_factory = sqlite3.Row\n    59→            connection.execute(\"PRAGMA foreign_keys = ON;\")\n    60→            self._create_tables(connection)\n    61→        except Exception as exc:\n    62→            self._init_future.set_exception(exc)\n    63→            if connection:\n    64→                try:\n    65→                    connection.close()\n    66→                except Exception:\n    67→                    pass\n    68→            return\n    69→\n    70→        self._init_future.set_result(True)\n    71→\n    72→        while True:\n    73→            item = self._queue.get()\n    74→            try:\n    75→                if item is None:\n    76→                    break\n    77→                future, fn = item\n    78→                if not future.set_running_or_notify_cancel():\n    79→                    continue\n    80→                try:\n    81→                    future.set_result(fn(connection))\n    82→                except Exception as exc:\n    83→                    future.set_exception(exc)\n    84→            finally:\n    85→                self._queue.task_done()\n    86→\n    87→        if connection:\n    88→            try:\n    89→                connection.close()\n    90→            except sqlite3.Error as exc:\n    91→                logger.error(\"Failed to close SQLite connection: {}\", exc)\n    92→\n    93→    def _call(self, operation: str, fn: Callable[[sqlite3.Connection], Any], default: Any):\n    94→        if self._closed:\n    95→            return default\n    96→        future: Future = Future()\n    97→        self._queue.put((future, fn))\n    98→        try:\n    99→            return future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n   100→        except TimeoutError:\n   101→            logger.error(\"SQLite operation timed out: {}\", operation)\n   102→            return default\n   103→        except Exception as exc:\n   104→            logger.error(\"SQLite operation failed {}: {}\", operation, exc)\n   105→            return default\n   106→\n   107→    def _create_tables(self, connection: sqlite3.Connection) -> None:\n   108→        \"\"\"初始化数据库表结构.\"\"\"\n   109→\n   110→        schema = \"\"\"\n   111→        CREATE TABLE IF NOT EXISTS generations (\n   112→            id TEXT PRIMARY KEY,\n   113→            content_type TEXT NOT NULL,\n   114→            prompt TEXT,\n   115→            model TEXT,\n   116→            status TEXT DEFAULT 'completed',\n   117→            file_path TEXT,\n   118→            relative_path TEXT,\n   119→            thumbnail_path TEXT,\n   120→            parameters TEXT,\n   121→            metadata TEXT,\n   122→            created_at TEXT,\n   123→            updated_at TEXT\n   124→        );\n   125→\n   126→        CREATE TABLE IF NOT EXISTS reference_assets (\n   127→            id TEXT PRIMARY KEY,\n   128→            generation_id TEXT NOT NULL,\n   129→            asset_path TEXT,\n   130→            relative_path TEXT,\n   131→            asset_type TEXT,\n   132→            order_index INTEGER DEFAULT 0,\n   133→            metadata TEXT,\n   134→            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n   135→        );\n   136→\n   137→        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n   138→        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n   139→        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n   140→        \"\"\"\n   141→\n   142→        try:\n   143→            with connection:\n   144→                connection.executescript(schema)\n   145→        except sqlite3.Error as exc:\n   146→            logger.error(\"Failed to create initial tables: {}\", exc)\n   147→            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n   148→\n   149→    @staticmethod\n   150→    def _now() -> str:\n   151→        return datetime.utcnow().isoformat()\n   152→\n   153→    @staticmethod\n   154→    def _dump_json(data: Any) -> Optional[str]:\n   155→        if data is None:\n   156→            return None\n   157→\n   158→        try:\n   159→            return json.dumps(data)\n   160→        except (TypeError, ValueError) as exc:\n   161→            logger.error(\"Failed to serialize JSON field: {}\", exc)\n   162→            return None\n   163→\n   164→    @staticmethod\n   165→    def _load_json(payload: Optional[str]) -> Optional[Any]:\n   166→        if not payload:\n   167→            return None\n   168→\n   169→        try:\n   170→            return json.loads(payload)\n   171→        except json.JSONDecodeError as exc:\n   172→            logger.error(\"Failed to decode JSON payload: {}\", exc)\n   173→            return None\n   174→\n   175→    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n   176→        result = dict(row)\n   177→        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n   178→        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n   179→\n   180→        # 将相对路径转换为绝对路径\n   181→        if self.storage_root:\n   182→            import os\n   183→            # file_path / relative_path -> absolute_path\n   184→            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n   185→            if rel_path:\n   186→                # 统一路径分隔符\n   187→                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n   188→                abs_path = self.storage_root / rel_path\n   189→                result[\"absolute_path\"] = str(abs_path)\n   190→\n   191→            # thumbnail_path -> absolute thumbnail path\n   192→            thumb_path = result.get(\"thumbnail_path\")\n   193→            if thumb_path:\n   194→                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n   195→                abs_thumb = self.storage_root / thumb_path\n   196→                result[\"thumbnail_path\"] = str(abs_thumb)\n   197→\n   198→        return result\n   199→\n   200→    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n   201→        result = dict(row)\n   202→        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n   203→\n   204→        # 将相对路径转换为绝对路径\n   205→        if self.storage_root:\n   206→            import os\n   207→            rel_path = result.get(\"asset_path\") or result.get(\"relative_path\")\n   208→            if rel_path:\n   209→                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n   210→                abs_path = self.storage_root / rel_path\n   211→                result[\"absolute_path\"] = str(abs_path)\n   212→\n   213→        return result\n   214→\n   215→    def add_record(self, record_id: str, content_type: str, data: Dict) -> bool:\n   216→        \"\"\"添加或更新生成记录（UPSERT）.\"\"\"\n   217→\n   218→        timestamp = self._now()\n   219→        record = {\n   220→            \"id\": record_id,\n   221→            \"content_type\": content_type,\n   222→            \"prompt\": data.get(\"prompt\"),\n   223→            \"model\": data.get(\"model\"),\n   224→            \"status\": data.get(\"status\", \"completed\"),\n   225→            \"file_path\": data.get(\"file_path\"),\n   226→            \"relative_path\": data.get(\"relative_path\"),\n   227→            \"thumbnail_path\": data.get(\"thumbnail_path\"),\n   228→            \"parameters\": self._dump_json(data.get(\"parameters\")),\n   229→            \"metadata\": self._dump_json(data.get(\"metadata\")),\n   230→            \"created_at\": data.get(\"created_at\", timestamp),\n   231→            \"updated_at\": timestamp,\n   232→        }\n   233→\n   234→        sql = \"\"\"\n   235→        INSERT INTO generations (id, content_type, prompt, model, status, file_path,\n   236→            relative_path, thumbnail_path, parameters, metadata, created_at, updated_at)\n   237→        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n   238→        ON CONFLICT(id) DO UPDATE SET\n   239→            content_type = excluded.content_type,\n   240→            prompt = COALESCE(excluded.prompt, prompt),\n   241→            model = COALESCE(excluded.model, model),\n   242→            status = CASE\n   243→                WHEN excluded.status IS NULL OR excluded.status = '' THEN status\n   244→                ELSE excluded.status\n   245→            END,\n   246→            file_path = COALESCE(excluded.file_path, file_path),\n   247→            relative_path = COALESCE(excluded.relative_path, relative_path),\n   248→            thumbnail_path = COALESCE(excluded.thumbnail_path, thumbnail_path),\n   249→            parameters = COALESCE(excluded.parameters, parameters),\n   250→            metadata = COALESCE(excluded.metadata, metadata),\n   251→            updated_at = excluded.updated_at\n   252→        \"\"\"\n   253→\n   254→        def _op(connection: sqlite3.Connection) -> bool:\n   255→            try:\n   256→                with connection:\n   257→                    connection.execute(\n   258→                        sql,\n   259→                        (\n   260→                            record[\"id\"],\n   261→                            record[\"content_type\"],\n   262→                            record[\"prompt\"],\n   263→                            record[\"model\"],\n   264→                            record[\"status\"],\n   265→                            record[\"file_path\"],\n   266→                            record[\"relative_path\"],\n   267→                            record[\"thumbnail_path\"],\n   268→                            record[\"parameters\"],\n   269→                            record[\"metadata\"],\n   270→                            record[\"created_at\"],\n   271→                            record[\"updated_at\"],\n   272→                        ),\n   273→                    )\n   274→                return True\n   275→            except sqlite3.Error as exc:\n   276→                logger.error(\"Failed to upsert generation record {}: {}\", record_id, exc)\n   277→                return False\n   278→\n   279→        return self._call(\"add_record\", _op, False)\n   280→\n   281→    def get_records(self, content_type: str, limit: int, offset: int) -> List[Dict]:\n   282→        \"\"\"分页获取记录，按 created_at DESC 排序.\"\"\"\n   283→\n   284→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   285→            try:\n   286→                cursor = connection.execute(\n   287→                    \"\"\"\n   288→                    SELECT * FROM generations\n   289→                    WHERE content_type = ?\n   290→                    ORDER BY created_at DESC, updated_at DESC\n   291→                    LIMIT ? OFFSET ?\n   292→                    \"\"\",\n   293→                    (content_type, limit, offset),\n   294→                )\n   295→                return [self._row_to_dict(row) for row in cursor.fetchall()]\n   296→            except sqlite3.Error as exc:\n   297→                logger.error(\"Failed to fetch generation records: {}\", exc)\n   298→                return []\n   299→\n   300→        return self._call(\"get_records\", _op, [])\n   301→\n   302→    def get_records_by_status(self, content_type: str, statuses: List[str], limit: int = 50) -> List[Dict]:\n   303→        \"\"\"按状态获取记录（用于 pending 恢复等场景）.\"\"\"\n   304→\n   305→        statuses = [str(s) for s in (statuses or []) if s]\n   306→        if not statuses:\n   307→            return []\n   308→\n   309→        placeholders = \", \".join([\"?\"] * len(statuses))\n   310→        sql = (\n   311→            \"SELECT * FROM generations \"\n   312→            \"WHERE content_type = ? AND status IN (\" + placeholders + \") \"\n   313→            \"ORDER BY updated_at DESC, created_at DESC \"\n   314→            \"LIMIT ?\"\n   315→        )\n   316→\n   317→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   318→            try:\n   319→                cursor = connection.execute(sql, (content_type, *statuses, limit))\n   320→                return [self._row_to_dict(row) for row in cursor.fetchall()]\n   321→            except sqlite3.Error as exc:\n   322→                logger.error(\"Failed to fetch generation records by status: {}\", exc)\n   323→                return []\n   324→\n   325→        return self._call(\"get_records_by_status\", _op, [])\n   326→\n   327→    def get_record_by_id(self, record_id: str) -> Optional[Dict]:\n   328→        \"\"\"根据ID获取单条记录.\"\"\"\n   329→\n   330→        def _op(connection: sqlite3.Connection) -> Optional[Dict]:\n   331→            try:\n   332→                cursor = connection.execute(\n   333→                    \"SELECT * FROM generations WHERE id = ?\", (record_id,)\n   334→                )\n   335→                row = cursor.fetchone()\n   336→                return self._row_to_dict(row) if row else None\n   337→            except sqlite3.Error as exc:\n   338→                logger.error(\"Failed to fetch generation record {}: {}\", record_id, exc)\n   339→                return None\n   340→\n   341→        return self._call(\"get_record_by_id\", _op, None)\n   342→\n   343→    def update_record(self, record_id: str, data: Dict) -> bool:\n   344→        \"\"\"更新记录.\"\"\"\n   345→\n   346→        if not data:\n   347→            return False\n   348→\n   349→        allowed_columns = [\n   350→            \"content_type\",\n   351→            \"prompt\",\n   352→            \"model\",\n   353→            \"status\",\n   354→            \"file_path\",\n   355→            \"relative_path\",\n   356→            \"thumbnail_path\",\n   357→            \"parameters\",\n   358→            \"metadata\",\n   359→            \"created_at\",\n   360→        ]\n   361→\n   362→        set_clauses: List[str] = []\n   363→        values: List[Any] = []\n   364→\n   365→        for column in allowed_columns:\n   366→            if column in data:\n   367→                value = data[column]\n   368→                if column in {\"parameters\", \"metadata\"}:\n   369→                    value = self._dump_json(value)\n   370→                set_clauses.append(f\"{column} = ?\")\n   371→                values.append(value)\n   372→\n   373→        if not set_clauses:\n   374→            return False\n   375→\n   376→        set_clauses.append(\"updated_at = ?\")\n   377→        values.append(self._now())\n   378→\n   379→        values.append(record_id)\n   380→        sql = f\"UPDATE generations SET {', '.join(set_clauses)} WHERE id = ?\"\n   381→\n   382→        def _op(connection: sqlite3.Connection) -> bool:\n   383→            try:\n   384→                with connection:\n   385→                    cursor = connection.execute(sql, values)\n   386→                return cursor.rowcount > 0\n   387→            except sqlite3.Error as exc:\n   388→                logger.error(\"Failed to update generation record {}: {}\", record_id, exc)\n   389→                return False\n   390→\n   391→        return self._call(\"update_record\", _op, False)\n   392→\n   393→    def delete_record(self, record_id: str) -> bool:\n   394→        \"\"\"删除记录.\"\"\"\n   395→\n   396→        def _op(connection: sqlite3.Connection) -> bool:\n   397→            try:\n   398→                with connection:\n   399→                    cursor = connection.execute(\n   400→                        \"DELETE FROM generations WHERE id = ?\", (record_id,)\n   401→                    )\n   402→                return cursor.rowcount > 0\n   403→            except sqlite3.Error as exc:\n   404→                logger.error(\"Failed to delete generation record {}: {}\", record_id, exc)\n   405→                return False\n   406→\n   407→        return self._call(\"delete_record\", _op, False)\n   408→\n   409→    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n   410→        \"\"\"清理超时的 pending 记录（无文件路径的孤立占位符）\n   411→\n   412→        Args:\n   413→            timeout_hours: 超时时间（小时）\n   414→\n   415→        Returns:\n   416→            删除的记录数量\n   417→        \"\"\"\n   418→        from datetime import datetime, timedelta\n   419→\n   420→        cutoff = datetime.now() - timedelta(hours=timeout_hours)\n   421→        cutoff_str = cutoff.isoformat()\n   422→\n   423→        def _op(connection: sqlite3.Connection) -> int:\n   424→            try:\n   425→                with connection:\n   426→                    cursor = connection.execute(\n   427→                        \"\"\"\n   428→                        DELETE FROM generations\n   429→                        WHERE status = 'pending'\n   430→                          AND file_path IS NULL\n   431→                          AND created_at < ?\n   432→                        \"\"\",\n   433→                        (cutoff_str,),\n   434→                    )\n   435→                deleted = cursor.rowcount\n   436→                if deleted > 0:\n   437→                    logger.info(f\"已清理 {deleted} 条过期的 pending 记录\")\n   438→                return deleted\n   439→            except sqlite3.Error as exc:\n   440→                logger.error(\"Failed to cleanup stale pending records: {}\", exc)\n   441→                return 0\n   442→\n   443→        return self._call(\"cleanup_stale_pending_records\", _op, 0)\n   444→\n   445→    def get_total_count(self, content_type: str) -> int:\n   446→        \"\"\"获取某类型总数.\"\"\"\n   447→\n   448→        def _op(connection: sqlite3.Connection) -> int:\n   449→            try:\n   450→                cursor = connection.execute(\n   451→                    \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",\n   452→                    (content_type,),\n   453→                )\n   454→                row = cursor.fetchone()\n   455→                return int(row[0]) if row else 0\n   456→            except sqlite3.Error as exc:\n   457→                logger.error(\"Failed to count generation records: {}\", exc)\n   458→                return 0\n   459→\n   460→        return self._call(\"get_total_count\", _op, 0)\n   461→\n   462→    def search_records(\n   463→        self, keyword: str, content_type: Optional[str], limit: int\n   464→    ) -> List[Dict]:\n   465→        \"\"\"搜索记录（prompt、model、file_path）.\"\"\"\n   466→\n   467→        if not keyword:\n   468→            return []\n   469→\n   470→        pattern = f\"%{keyword}%\"\n   471→        where_clauses = [\n   472→            \"(prompt LIKE ? OR model LIKE ? OR file_path LIKE ?)\"\n   473→        ]\n   474→        params: List[Any] = [pattern, pattern, pattern]\n   475→\n   476→        if content_type:\n   477→            where_clauses.append(\"content_type = ?\")\n   478→            params.append(content_type)\n   479→\n   480→        params.append(limit)\n   481→\n   482→        query = (\n   483→            \"SELECT * FROM generations WHERE \"\n   484→            + \" AND \".join(where_clauses)\n   485→            + \" ORDER BY created_at DESC, updated_at DESC LIMIT ?\"\n   486→        )\n   487→\n   488→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   489→            try:\n   490→                cursor = connection.execute(query, params)\n   491→                return [self._row_to_dict(row) for row in cursor.fetchall()]\n   492→            except sqlite3.Error as exc:\n   493→                logger.error(\"Failed to search generation records: {}\", exc)\n   494→                return []\n   495→\n   496→        return self._call(\"search_records\", _op, [])\n   497→\n   498→    def add_reference_asset(self, generation_id: str, asset_data: Dict) -> bool:\n   499→        \"\"\"添加参考图资产.\"\"\"\n   500→\n   501→        asset_id = asset_data.get(\"id\") or asset_data.get(\"asset_id\")\n   502→        if not asset_id:\n   503→            logger.error(\"Reference asset requires an 'id' field\")\n   504→            return False\n   505→\n   506→        payload = {\n   507→            \"id\": asset_id,\n   508→            \"generation_id\": generation_id,\n   509→            \"asset_path\": asset_data.get(\"asset_path\"),\n   510→            \"relative_path\": asset_data.get(\"relative_path\"),\n   511→            \"asset_type\": asset_data.get(\"asset_type\"),\n   512→            \"order_index\": asset_data.get(\"order_index\", 0),\n   513→            \"metadata\": self._dump_json(asset_data.get(\"metadata\")),\n   514→        }\n   515→\n   516→        sql = (\n   517→            \"INSERT INTO reference_assets (id, generation_id, asset_path, relative_path, \"\n   518→            \"asset_type, order_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?)\"\n   519→        )\n   520→\n   521→        def _op(connection: sqlite3.Connection) -> bool:\n   522→            try:\n   523→                with connection:\n   524→                    connection.execute(\n   525→                        sql,\n   526→                        (\n   527→                            payload[\"id\"],\n   528→                            payload[\"generation_id\"],\n   529→                            payload[\"asset_path\"],\n   530→                            payload[\"relative_path\"],\n   531→                            payload[\"asset_type\"],\n   532→                            payload[\"order_index\"],\n   533→                            payload[\"metadata\"],\n   534→                        ),\n   535→                    )\n   536→                return True\n   537→            except sqlite3.Error as exc:\n   538→                logger.error(\n   539→                    \"Failed to insert reference asset {} for generation {}: {}\",\n   540→                    asset_id,\n   541→                    generation_id,\n   542→                    exc,\n   543→                )\n   544→                return False\n   545→\n   546→        return self._call(\"add_reference_asset\", _op, False)\n   547→\n   548→    def get_reference_assets(self, generation_id: str) -> List[Dict]:\n   549→        \"\"\"获取参考图资产.\"\"\"\n   550→\n   551→        def _op(connection: sqlite3.Connection) -> List[Dict]:\n   552→            try:\n   553→                cursor = connection.execute(\n   554→                    \"\"\"\n   555→                    SELECT * FROM reference_assets\n   556→                    WHERE generation_id = ?\n   557→                    ORDER BY order_index ASC\n   558→                    \"\"\",\n   559→                    (generation_id,),\n   560→                )\n   561→                return [self._reference_row_to_dict(row) for row in cursor.fetchall()]\n   562→            except sqlite3.Error as exc:\n   563→                logger.error(\n   564→                    \"Failed to fetch reference assets for generation {}: {}\",\n   565→                    generation_id,\n   566→                    exc,\n   567→                )\n   568→                return []\n   569→\n   570→        return self._call(\"get_reference_assets\", _op, [])\n   571→\n   572→    def close(self) -> None:\n   573→        \"\"\"关闭数据库连接.\"\"\"\n   574→\n   575→        if self._closed:\n   576→            return\n   577→        self._closed = True\n   578→\n   579→        try:\n   580→            self._queue.put(None)\n   581→        except Exception:\n   582→            return\n   583→\n   584→        try:\n   585→            self._worker_thread.join(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n   586→        except Exception:\n   587→            pass\n   588→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"710e7213-00cc-43b2-9d94-1b75e1071f88","timestamp":"2026-01-08T03:06:16.812Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sqlite3\nimport threading\nfrom concurrent.futures import Future, TimeoutError\nfrom queue import Queue\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom loguru import logger\n\n\nclass SQLiteHandler:\n    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n\n    _DEFAULT_TIMEOUT_SECONDS = 30.0\n\n    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n        \"\"\"初始化数据库连接并创建所需表结构.\n\n        Args:\n            db_path: 数据库文件路径\n            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n        \"\"\"\n\n        self.db_path = Path(db_path)\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n        self.storage_root = storage_root\n\n        # 并发策略（Q002-方案B）：单线程 DB Worker + 队列串行执行\n        self._closed = False\n        self._queue: Queue[Optional[tuple[Future, Callable[[sqlite3.Connection], Any]]]] = Queue()\n        self._init_future: Future[bool] = Future()\n\n        self._worker_thread = threading.Thread(\n            target=self._run_worker,\n            name=f\"SQLiteHandler[{self.db_path.name}]\",\n            daemon=True,\n        )\n        self._worker_thread.start()\n\n        try:\n            self._init_future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except Exception as exc:\n            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n\n    def _run_worker(self) -> None:\n        connection: Optional[sqlite3.Connection] = None\n        try:\n            connection = sqlite3.connect(self.db_path)\n            connection.row_factory = sqlite3.Row\n            connection.execute(\"PRAGMA foreign_keys = ON;\")\n            self._create_tables(connection)\n        except Exception as exc:\n            self._init_future.set_exception(exc)\n            if connection:\n                try:\n                    connection.close()\n                except Exception:\n                    pass\n            return\n\n        self._init_future.set_result(True)\n\n        while True:\n            item = self._queue.get()\n            try:\n                if item is None:\n                    break\n                future, fn = item\n                if not future.set_running_or_notify_cancel():\n                    continue\n                try:\n                    future.set_result(fn(connection))\n                except Exception as exc:\n                    future.set_exception(exc)\n            finally:\n                self._queue.task_done()\n\n        if connection:\n            try:\n                connection.close()\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to close SQLite connection: {}\", exc)\n\n    def _call(self, operation: str, fn: Callable[[sqlite3.Connection], Any], default: Any):\n        if self._closed:\n            return default\n        future: Future = Future()\n        self._queue.put((future, fn))\n        try:\n            return future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except TimeoutError:\n            logger.error(\"SQLite operation timed out: {}\", operation)\n            return default\n        except Exception as exc:\n            logger.error(\"SQLite operation failed {}: {}\", operation, exc)\n            return default\n\n    def _create_tables(self, connection: sqlite3.Connection) -> None:\n        \"\"\"初始化数据库表结构.\"\"\"\n\n        schema = \"\"\"\n        CREATE TABLE IF NOT EXISTS generations (\n            id TEXT PRIMARY KEY,\n            content_type TEXT NOT NULL,\n            prompt TEXT,\n            model TEXT,\n            status TEXT DEFAULT 'completed',\n            file_path TEXT,\n            relative_path TEXT,\n            thumbnail_path TEXT,\n            parameters TEXT,\n            metadata TEXT,\n            created_at TEXT,\n            updated_at TEXT\n        );\n\n        CREATE TABLE IF NOT EXISTS reference_assets (\n            id TEXT PRIMARY KEY,\n            generation_id TEXT NOT NULL,\n            asset_path TEXT,\n            relative_path TEXT,\n            asset_type TEXT,\n            order_index INTEGER DEFAULT 0,\n            metadata TEXT,\n            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n        \"\"\"\n\n        try:\n            with connection:\n                connection.executescript(schema)\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to create initial tables: {}\", exc)\n            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n\n    @staticmethod\n    def _now() -> str:\n        return datetime.utcnow().isoformat()\n\n    @staticmethod\n    def _dump_json(data: Any) -> Optional[str]:\n        if data is None:\n            return None\n\n        try:\n            return json.dumps(data)\n        except (TypeError, ValueError) as exc:\n            logger.error(\"Failed to serialize JSON field: {}\", exc)\n            return None\n\n    @staticmethod\n    def _load_json(payload: Optional[str]) -> Optional[Any]:\n        if not payload:\n            return None\n\n        try:\n            return json.loads(payload)\n        except json.JSONDecodeError as exc:\n            logger.error(\"Failed to decode JSON payload: {}\", exc)\n            return None\n\n    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n        result = dict(row)\n        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n\n        # 将相对路径转换为绝对路径\n        if self.storage_root:\n            import os\n            # file_path / relative_path -> absolute_path\n            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n            if rel_path:\n                # 统一路径分隔符\n                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_path = self.storage_root / rel_path\n                result[\"absolute_path\"] = str(abs_path)\n\n            # thumbnail_path -> absolute thumbnail path\n            thumb_path = result.get(\"thumbnail_path\")\n            if thumb_path:\n                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_thumb = self.storage_root / thumb_path\n                result[\"thumbnail_path\"] = str(abs_thumb)\n\n        return result\n\n    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n        result = dict(row)\n        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n\n        # 将相对路径转换为绝对路径\n        if self.storage_root:\n            import os\n            rel_path = result.get(\"asset_path\") or result.get(\"relative_path\")\n            if rel_path:\n                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_path = self.storage_root / rel_path\n                result[\"absolute_path\"] = str(abs_path)\n\n        return result\n\n    def add_record(self, record_id: str, content_type: str, data: Dict) -> bool:\n        \"\"\"添加或更新生成记录（UPSERT）.\"\"\"\n\n        timestamp = self._now()\n        record = {\n            \"id\": record_id,\n            \"content_type\": content_type,\n            \"prompt\": data.get(\"prompt\"),\n            \"model\": data.get(\"model\"),\n            \"status\": data.get(\"status\", \"completed\"),\n            \"file_path\": data.get(\"file_path\"),\n            \"relative_path\": data.get(\"relative_path\"),\n            \"thumbnail_path\": data.get(\"thumbnail_path\"),\n            \"parameters\": self._dump_json(data.get(\"parameters\")),\n            \"metadata\": self._dump_json(data.get(\"metadata\")),\n            \"created_at\": data.get(\"created_at\", timestamp),\n            \"updated_at\": timestamp,\n        }\n\n        sql = \"\"\"\n        INSERT INTO generations (id, content_type, prompt, model, status, file_path,\n            relative_path, thumbnail_path, parameters, metadata, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ON CONFLICT(id) DO UPDATE SET\n            content_type = excluded.content_type,\n            prompt = COALESCE(excluded.prompt, prompt),\n            model = COALESCE(excluded.model, model),\n            status = CASE\n                WHEN excluded.status IS NULL OR excluded.status = '' THEN status\n                ELSE excluded.status\n            END,\n            file_path = COALESCE(excluded.file_path, file_path),\n            relative_path = COALESCE(excluded.relative_path, relative_path),\n            thumbnail_path = COALESCE(excluded.thumbnail_path, thumbnail_path),\n            parameters = COALESCE(excluded.parameters, parameters),\n            metadata = COALESCE(excluded.metadata, metadata),\n            updated_at = excluded.updated_at\n        \"\"\"\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    connection.execute(\n                        sql,\n                        (\n                            record[\"id\"],\n                            record[\"content_type\"],\n                            record[\"prompt\"],\n                            record[\"model\"],\n                            record[\"status\"],\n                            record[\"file_path\"],\n                            record[\"relative_path\"],\n                            record[\"thumbnail_path\"],\n                            record[\"parameters\"],\n                            record[\"metadata\"],\n                            record[\"created_at\"],\n                            record[\"updated_at\"],\n                        ),\n                    )\n                return True\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to upsert generation record {}: {}\", record_id, exc)\n                return False\n\n        return self._call(\"add_record\", _op, False)\n\n    def get_records(self, content_type: str, limit: int, offset: int) -> List[Dict]:\n        \"\"\"分页获取记录，按 created_at DESC 排序.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(\n                    \"\"\"\n                    SELECT * FROM generations\n                    WHERE content_type = ?\n                    ORDER BY created_at DESC, updated_at DESC\n                    LIMIT ? OFFSET ?\n                    \"\"\",\n                    (content_type, limit, offset),\n                )\n                return [self._row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to fetch generation records: {}\", exc)\n                return []\n\n        return self._call(\"get_records\", _op, [])\n\n    def get_records_by_status(self, content_type: str, statuses: List[str], limit: int = 50) -> List[Dict]:\n        \"\"\"按状态获取记录（用于 pending 恢复等场景）.\"\"\"\n\n        statuses = [str(s) for s in (statuses or []) if s]\n        if not statuses:\n            return []\n\n        placeholders = \", \".join([\"?\"] * len(statuses))\n        sql = (\n            \"SELECT * FROM generations \"\n            \"WHERE content_type = ? AND status IN (\" + placeholders + \") \"\n            \"ORDER BY updated_at DESC, created_at DESC \"\n            \"LIMIT ?\"\n        )\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(sql, (content_type, *statuses, limit))\n                return [self._row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to fetch generation records by status: {}\", exc)\n                return []\n\n        return self._call(\"get_records_by_status\", _op, [])\n\n    def get_record_by_id(self, record_id: str) -> Optional[Dict]:\n        \"\"\"根据ID获取单条记录.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> Optional[Dict]:\n            try:\n                cursor = connection.execute(\n                    \"SELECT * FROM generations WHERE id = ?\", (record_id,)\n                )\n                row = cursor.fetchone()\n                return self._row_to_dict(row) if row else None\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to fetch generation record {}: {}\", record_id, exc)\n                return None\n\n        return self._call(\"get_record_by_id\", _op, None)\n\n    def update_record(self, record_id: str, data: Dict) -> bool:\n        \"\"\"更新记录.\"\"\"\n\n        if not data:\n            return False\n\n        allowed_columns = [\n            \"content_type\",\n            \"prompt\",\n            \"model\",\n            \"status\",\n            \"file_path\",\n            \"relative_path\",\n            \"thumbnail_path\",\n            \"parameters\",\n            \"metadata\",\n            \"created_at\",\n        ]\n\n        set_clauses: List[str] = []\n        values: List[Any] = []\n\n        for column in allowed_columns:\n            if column in data:\n                value = data[column]\n                if column in {\"parameters\", \"metadata\"}:\n                    value = self._dump_json(value)\n                set_clauses.append(f\"{column} = ?\")\n                values.append(value)\n\n        if not set_clauses:\n            return False\n\n        set_clauses.append(\"updated_at = ?\")\n        values.append(self._now())\n\n        values.append(record_id)\n        sql = f\"UPDATE generations SET {', '.join(set_clauses)} WHERE id = ?\"\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    cursor = connection.execute(sql, values)\n                return cursor.rowcount > 0\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to update generation record {}: {}\", record_id, exc)\n                return False\n\n        return self._call(\"update_record\", _op, False)\n\n    def delete_record(self, record_id: str) -> bool:\n        \"\"\"删除记录.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    cursor = connection.execute(\n                        \"DELETE FROM generations WHERE id = ?\", (record_id,)\n                    )\n                return cursor.rowcount > 0\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to delete generation record {}: {}\", record_id, exc)\n                return False\n\n        return self._call(\"delete_record\", _op, False)\n\n    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n        \"\"\"清理超时的 pending 记录（无文件路径的孤立占位符）\n\n        Args:\n            timeout_hours: 超时时间（小时）\n\n        Returns:\n            删除的记录数量\n        \"\"\"\n        from datetime import datetime, timedelta\n\n        cutoff = datetime.now() - timedelta(hours=timeout_hours)\n        cutoff_str = cutoff.isoformat()\n\n        def _op(connection: sqlite3.Connection) -> int:\n            try:\n                with connection:\n                    cursor = connection.execute(\n                        \"\"\"\n                        DELETE FROM generations\n                        WHERE status = 'pending'\n                          AND file_path IS NULL\n                          AND created_at < ?\n                        \"\"\",\n                        (cutoff_str,),\n                    )\n                deleted = cursor.rowcount\n                if deleted > 0:\n                    logger.info(f\"已清理 {deleted} 条过期的 pending 记录\")\n                return deleted\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to cleanup stale pending records: {}\", exc)\n                return 0\n\n        return self._call(\"cleanup_stale_pending_records\", _op, 0)\n\n    def get_total_count(self, content_type: str) -> int:\n        \"\"\"获取某类型总数.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> int:\n            try:\n                cursor = connection.execute(\n                    \"SELECT COUNT(*) FROM generations WHERE content_type = ?\",\n                    (content_type,),\n                )\n                row = cursor.fetchone()\n                return int(row[0]) if row else 0\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to count generation records: {}\", exc)\n                return 0\n\n        return self._call(\"get_total_count\", _op, 0)\n\n    def search_records(\n        self, keyword: str, content_type: Optional[str], limit: int\n    ) -> List[Dict]:\n        \"\"\"搜索记录（prompt、model、file_path）.\"\"\"\n\n        if not keyword:\n            return []\n\n        pattern = f\"%{keyword}%\"\n        where_clauses = [\n            \"(prompt LIKE ? OR model LIKE ? OR file_path LIKE ?)\"\n        ]\n        params: List[Any] = [pattern, pattern, pattern]\n\n        if content_type:\n            where_clauses.append(\"content_type = ?\")\n            params.append(content_type)\n\n        params.append(limit)\n\n        query = (\n            \"SELECT * FROM generations WHERE \"\n            + \" AND \".join(where_clauses)\n            + \" ORDER BY created_at DESC, updated_at DESC LIMIT ?\"\n        )\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(query, params)\n                return [self._row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to search generation records: {}\", exc)\n                return []\n\n        return self._call(\"search_records\", _op, [])\n\n    def add_reference_asset(self, generation_id: str, asset_data: Dict) -> bool:\n        \"\"\"添加参考图资产.\"\"\"\n\n        asset_id = asset_data.get(\"id\") or asset_data.get(\"asset_id\")\n        if not asset_id:\n            logger.error(\"Reference asset requires an 'id' field\")\n            return False\n\n        payload = {\n            \"id\": asset_id,\n            \"generation_id\": generation_id,\n            \"asset_path\": asset_data.get(\"asset_path\"),\n            \"relative_path\": asset_data.get(\"relative_path\"),\n            \"asset_type\": asset_data.get(\"asset_type\"),\n            \"order_index\": asset_data.get(\"order_index\", 0),\n            \"metadata\": self._dump_json(asset_data.get(\"metadata\")),\n        }\n\n        sql = (\n            \"INSERT INTO reference_assets (id, generation_id, asset_path, relative_path, \"\n            \"asset_type, order_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?)\"\n        )\n\n        def _op(connection: sqlite3.Connection) -> bool:\n            try:\n                with connection:\n                    connection.execute(\n                        sql,\n                        (\n                            payload[\"id\"],\n                            payload[\"generation_id\"],\n                            payload[\"asset_path\"],\n                            payload[\"relative_path\"],\n                            payload[\"asset_type\"],\n                            payload[\"order_index\"],\n                            payload[\"metadata\"],\n                        ),\n                    )\n                return True\n            except sqlite3.Error as exc:\n                logger.error(\n                    \"Failed to insert reference asset {} for generation {}: {}\",\n                    asset_id,\n                    generation_id,\n                    exc,\n                )\n                return False\n\n        return self._call(\"add_reference_asset\", _op, False)\n\n    def get_reference_assets(self, generation_id: str) -> List[Dict]:\n        \"\"\"获取参考图资产.\"\"\"\n\n        def _op(connection: sqlite3.Connection) -> List[Dict]:\n            try:\n                cursor = connection.execute(\n                    \"\"\"\n                    SELECT * FROM reference_assets\n                    WHERE generation_id = ?\n                    ORDER BY order_index ASC\n                    \"\"\",\n                    (generation_id,),\n                )\n                return [self._reference_row_to_dict(row) for row in cursor.fetchall()]\n            except sqlite3.Error as exc:\n                logger.error(\n                    \"Failed to fetch reference assets for generation {}: {}\",\n                    generation_id,\n                    exc,\n                )\n                return []\n\n        return self._call(\"get_reference_assets\", _op, [])\n\n    def close(self) -> None:\n        \"\"\"关闭数据库连接.\"\"\"\n\n        if self._closed:\n            return\n        self._closed = True\n\n        try:\n            self._queue.put(None)\n        except Exception:\n            return\n\n        try:\n            self._worker_thread.join(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except Exception:\n            pass\n","numLines":588,"startLine":1,"totalLines":588}},"sourceToolAssistantUUID":"80a3f8cc-0028-43b7-a90e-5b2bf4940a57"}
{"parentUuid":"3fc7e3e1-4489-40b8-94d6-76a89bd02824","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NtowVRuoYCMNSgfJWgj5rq","type":"tool_result","content":"     1→# Seedance视频生成管理器\n     2→# 负责视频生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→import base64\n    13→import pandas as pd\n    14→from datetime import datetime\n    15→from pathlib import Path\n    16→from typing import Dict, Any, List, Optional, Tuple\n    17→from urllib.parse import urlparse\n    18→from loguru import logger\n    19→from PIL import Image\n    20→\n    21→from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n    22→\n    23→from .client import SeedanceClient\n    24→from ..storage import get_v2_storage_manager\n    25→from ..provider.schema import (\n    26→    VideoParams,\n    27→    validate_and_normalize_video,\n    28→)\n    29→from config.unified_config import get_unified_config\n    30→from config.unified_config import get_storage_dir\n    31→# 使用统一水印服务（edition/watermark_service.py）\n    32→from edition.watermark_service import (\n    33→    should_add_watermark,\n    34→    get_watermark_text,\n    35→    get_watermark_opacity,\n    36→)\n    37→\n    38→# Q-006 固化策略：\n    39→# - 本地水印由 edition/watermark_service 控制（trial 强制开 / prod 关闭）\n    40→# - API 服务端水印固定关闭（不依赖 config_api）\n    41→\n    42→\n    43→class SeedanceManager:\n    44→    \"\"\"Seedance视频生成管理器\"\"\"\n    45→\n    46→    def __init__(self, api_key: str = None):\n    47→        \"\"\"\n    48→        初始化Seedance管理器\n    49→\n    50→        Args:\n    51→            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n    52→        \"\"\"\n    53→        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n    54→        if api_key is None:\n    55→            try:\n    56→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    57→            except Exception as exc:\n    58→                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n    59→        \n    60→        self.client = SeedanceClient(api_key)\n    61→\n    62→        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n    63→        storage_path = get_storage_dir()\n    64→        if not storage_path:\n    65→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    66→        Path(storage_path).mkdir(parents=True, exist_ok=True)\n    67→\n    68→        # 使用V2统一存储管理器（与单一真源对齐）\n    69→        self.storage_manager = get_v2_storage_manager(storage_path)\n    70→        \n    71→        # 保持兼容性别名\n    72→        self.file_manager = self.storage_manager\n    73→        self.metadata_manager = self.storage_manager\n    74→        self.video_storage_manager = self.storage_manager\n    75→        \n    76→        # 保留原有的目录属性以保持兼容性\n    77→        self.data_dir = Path(self.storage_manager.root_path)\n    78→        self.videos_dir = self.data_dir / \"videos\"\n    79→        self.metadata_dir = self.data_dir / \"metadata\"\n    80→\n    81→        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    82→\n    83→    def generate_video(\n    84→        self,\n    85→        prompt: str,\n    86→        image_path: Optional[str] = None,\n    87→        first_frame_path: Optional[str] = None,\n    88→        last_frame_path: Optional[str] = None,\n    89→        duration: float = 4.0,\n    90→        seed: int = -1,\n    91→        watermark: bool = False,\n    92→        save_local: bool = True,\n    93→        wait_for_completion: bool = True,\n    94→        # 新增参数（P0b）\n    95→        resolution_grade: Optional[str] = None,\n    96→        ratio: Optional[str] = None,\n    97→        fps: int = 24,\n    98→        camera_fixed: bool = True,\n    99→        use_pro_model: bool = True,\n   100→        model_type: Optional[str] = None,\n   101→        model_variant: Optional[str] = None,\n   102→        generate_audio: Optional[bool] = None,\n   103→        reference_images: Optional[List[Any]] = None,\n   104→        generation_id: Optional[str] = None,\n   105→    ) -> Dict[str, Any]:\n   106→        \"\"\"\n   107→        生成视频并保存到本地\n   108→\n   109→        Args:\n   110→            image_path: 输入图像路径\n   111→            duration: 视频时长（秒）\n   112→            motion_strength: 运动强度 (0.1-1.0)\n   113→            seed: 随机种子\n   114→            watermark: 保留参数（服务端水印由配置决定）\n   115→            save_local: 是否保存到本地\n   116→            wait_for_completion: 是否等待任务完成\n   117→\n   118→        Returns:\n   119→            Dict: 生成结果\n   120→        \"\"\"\n   121→        logger.info(\"开始视频生成任务(Manager)\")\n   122→\n   123→        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n   124→        task_id = generation_id or str(uuid.uuid4())\n   125→\n   126→        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n   127→        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n   128→            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n   129→\n   130→        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n   131→        # 构建待处理的图片列表\n   132→        all_input_images = []\n   133→\n   134→        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n   135→        frame_inputs = []\n   136→        if first_frame_path:\n   137→            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n   138→        if last_frame_path:\n   139→            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n   140→        elif image_path and not first_frame_path:\n   141→            frame_inputs.append({'path': image_path, 'type': 'image'})\n   142→\n   143→        all_input_images.extend(frame_inputs)\n   144→\n   145→        # 2. 添加参考图\n   146→        if reference_images:\n   147→            for ref in reference_images:\n   148→                if isinstance(ref, dict):\n   149→                    ref_copy = dict(ref)\n   150→                    ref_copy['type'] = ref_copy.get('type', 'reference')\n   151→                    all_input_images.append(ref_copy)\n   152→                else:\n   153→                    all_input_images.append({'path': ref, 'type': 'reference'})\n   154→\n   155→        # 3. 统一处理（复制到 references 目录）\n   156→        ref_summary = self._process_reference_assets(\n   157→            all_input_images if all_input_images else None,\n   158→            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n   159→            expected_outputs=1,\n   160→        )\n   161→        ref_assets = ref_summary.get('assets', [])\n   162→        ref_paths: List[str] = list(ref_summary.get('paths', []))\n   163→\n   164→        # 4. 分离帧图片和参考图\n   165→        frame_assets = {}\n   166→        pure_ref_assets = []\n   167→        for asset in ref_assets:\n   168→            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n   169→            if asset_type in ('first_frame', 'last_frame', 'image'):\n   170→                frame_assets[asset_type] = asset\n   171→            else:\n   172→                pure_ref_assets.append(asset)\n   173→\n   174→        # 5. 提取帧图片的相对路径（用于存储）\n   175→        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n   176→        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n   177→        stored_image_path = frame_assets.get('image', {}).get('path')\n   178→\n   179→        # 6. 提取参考图的 payload（用于 API 调用）\n   180→        ref_payloads: List[str] = []\n   181→        for asset in pure_ref_assets:\n   182→            payload = asset.get('_payload_b64')\n   183→            if payload:\n   184→                ref_payloads.append(payload)\n   185→\n   186→        if ref_summary.get('errors'):\n   187→            logger.warning(\n   188→                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   189→            )\n   190→        if ref_summary.get('warnings'):\n   191→            for warn in ref_summary['warnings']:\n   192→                logger.warning(f\"图片处理提示: {warn}\")\n   193→\n   194→        # Q-006：API 服务端水印固定关闭；体验版仅做本地水印（落盘后处理）\n   195→        watermark_enabled = False\n   196→\n   197→        create_kwargs = dict(\n   198→            prompt=prompt,\n   199→            duration=int(duration),\n   200→            seed=None if seed == -1 else seed,\n   201→            fps=fps,\n   202→            resolution_grade=resolution_grade,\n   203→            ratio=ratio,\n   204→            watermark=watermark_enabled,\n   205→            camera_fixed=bool(camera_fixed),\n   206→            use_pro_model=use_pro_model,\n   207→            model_type=model_type,\n   208→            model_variant=model_variant,\n   209→            generate_audio=generate_audio,\n   210→        )\n   211→        if ref_payloads:\n   212→            create_kwargs['reference_images'] = ref_payloads\n   213→        if first_frame_path and last_frame_path:\n   214→            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n   215→        elif image_path:\n   216→            create_kwargs.update(dict(image_path=image_path))\n   217→        # 文生视频：不追加图片参数\n   218→\n   219→        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n   220→        precheck_fb = False\n   221→        precheck_reason = \"\"\n   222→        try:\n   223→            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n   224→                VideoParams(\n   225→                    prompt=prompt,\n   226→                    image_path=None,  # 校验不依赖图像数据\n   227→                    first_frame_path=None,\n   228→                    last_frame_path=None,\n   229→                    duration=int(duration),\n   230→                    fps=int(fps),\n   231→                    seed=(None if seed == -1 else seed),\n   232→                    camera_fixed=bool(camera_fixed),\n   233→                    watermark=bool(watermark),\n   234→                    resolution_grade=resolution_grade,\n   235→                    ratio=ratio,\n   236→                    use_pro_model=bool(use_pro_model),\n   237→                    model_variant=model_variant,\n   238→                    generate_audio=generate_audio,\n   239→                )\n   240→            )\n   241→            logger.info(\n   242→                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   243→            )\n   244→            if fb:\n   245→                logger.warning(f\"前置参数回退建议: {reason}\")\n   246→            precheck_fb = fb\n   247→            precheck_reason = reason\n   248→        except Exception as _e:\n   249→            logger.debug(f\"前置参数校验跳过: {_e}\")\n   250→\n   251→        create_result = self.client.create_video_task(**create_kwargs)\n   252→        params_sent = create_result.get(\"params_sent\") if isinstance(create_result, dict) else None\n   253→\n   254→        # 用实际执行参数覆盖用户输入（如 Lite 参考图模式 1080p→720p 降级）\n   255→        if create_result.get(\"success\"):\n   256→            actual_rs = create_result.get('used_rs')\n   257→            actual_rt = create_result.get('used_rt')\n   258→            if actual_rs:\n   259→                logger.debug(f\"参数覆盖|resolution_grade: 用户输入={resolution_grade} -> 实际执行={actual_rs}\")\n   260→                resolution_grade = actual_rs\n   261→            if actual_rt:\n   262→                logger.debug(f\"参数覆盖|ratio: 用户输入={ratio} -> 实际执行={actual_rt}\")\n   263→                ratio = actual_rt\n   264→\n   265→        if not create_result[\"success\"]:\n   266→            self._cleanup_reference_paths(ref_paths)\n   267→            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n   268→            return create_result\n   269→\n   270→        api_task_id = create_result[\"task_id\"]\n   271→\n   272→        result = {\n   273→            \"task_id\": task_id,\n   274→            \"api_task_id\": api_task_id,\n   275→            \"params_sent\": params_sent,\n   276→            \"success\": True,\n   277→            \"type\": \"image_to_video\",\n   278→            \"input_image\": image_path,\n   279→            \"status\": \"pending\",\n   280→            \"parameters\": {\n   281→                \"prompt\": prompt,\n   282→                \"duration\": duration,\n   283→                \"seed\": (None if seed == -1 else seed),\n   284→                \"watermark\": watermark_enabled,\n   285→                \"resolution_grade\": resolution_grade,\n   286→                \"ratio\": ratio,\n   287→                \"fps\": fps,\n   288→                \"camera_fixed\": bool(camera_fixed),\n   289→                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n   290→                \"first_frame\": stored_first_frame,\n   291→                \"last_frame\": stored_last_frame,\n   292→                \"image_path\": stored_image_path,\n   293→            },\n   294→            \"created_at\": datetime.now().isoformat(),\n   295→        }\n   296→\n   297→        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   298→        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n   299→        result['reference_assets'] = sanitized_refs\n   300→        if ref_summary.get('errors'):\n   301→            result['reference_asset_errors'] = ref_summary['errors']\n   302→        if ref_summary.get('warnings'):\n   303→            result['reference_asset_warnings'] = ref_summary['warnings']\n   304→        if precheck_fb and precheck_reason:\n   305→            result.setdefault('fallback_applied', True)\n   306→            if result.get('fallback_reason'):\n   307→                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n   308→            else:\n   309→                result['fallback_reason'] = precheck_reason\n   310→\n   311→        masked_ids = self._summarize_reference_ids(sanitized_refs)\n   312→        logger.info(\n   313→            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n   314→            len(sanitized_refs),\n   315→            masked_ids or \"-\",\n   316→            self._provider_hint(),\n   317→        )\n   318→\n   319→        # 透传回退信息\n   320→        if create_result.get(\"fallback_applied\"):\n   321→            result[\"fallback_applied\"] = True\n   322→            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n   323→\n   324→        # 如果等待完成，轮询任务状态\n   325→        if wait_for_completion:\n   326→            completion_result = self.client.wait_for_completion(api_task_id)\n   327→\n   328→            if completion_result[\"success\"]:\n   329→                if completion_result[\"status\"] == \"success\":\n   330→                    result[\"status\"] = \"success\"\n   331→                    result[\"video_url\"] = completion_result[\"video_url\"]\n   332→                    result[\"duration\"] = completion_result.get(\"duration\")\n   333→                    result[\"file_size\"] = completion_result.get(\"file_size\")\n   334→                    result[\"completed_at\"] = datetime.now().isoformat()\n   335→\n   336→                    # 保存到本地\n   337→                    if save_local:\n   338→                        local_result = self._save_video_locally(result)\n   339→                        result.update(local_result)\n   340→                        # 注：file_size 已在 _save_video_locally 内部设置到 metadata['parameters'] 中\n   341→                        if local_result.get('local_save_error'):\n   342→                            self._cleanup_reference_paths(ref_paths)\n   343→                            result['parameters'][\"reference_assets\"] = []\n   344→                            result['reference_assets'] = []\n   345→                            warnings = result.setdefault('reference_asset_warnings', [])\n   346→                            warnings.append(\"视频保存失败，参考图已回滚\")\n   347→                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   348→\n   349→                    logger.success(f\"视频生成任务完成: {task_id}\")\n   350→                else:\n   351→                    result[\"status\"] = completion_result[\"status\"]\n   352→                    result[\"error\"] = completion_result.get(\"error\")\n   353→                    result[\"error_code\"] = completion_result.get(\"error_code\")\n   354→                    logger.error(f\"视频生成任务失败: {result['error']}\")\n   355→            else:\n   356→                result[\"status\"] = \"failed\"\n   357→                result[\"error\"] = completion_result[\"error\"]\n   358→                result[\"error_code\"] = completion_result[\"error_code\"]\n   359→                logger.error(f\"等待任务完成失败: {result['error']}\")\n   360→\n   361→        # 注：元数据已通过 save_content_file() 保存，无需重复调用\n   362→\n   363→        return result\n   364→\n   365→    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n   366→        \"\"\"\n   367→        检查任务状态\n   368→\n   369→        Args:\n   370→            task_id: 本地任务ID\n   371→\n   372→        Returns:\n   373→            Dict: 任务状态信息\n   374→        \"\"\"\n   375→        logger.info(f\"检查任务状态: {task_id}\")\n   376→\n   377→        # 从元数据中获取任务信息\n   378→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   379→\n   380→        if not task_record:\n   381→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   382→\n   383→        api_task_id = task_record.get(\"api_task_id\")\n   384→        if not api_task_id:\n   385→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   386→\n   387→        # 查询API任务状态\n   388→        status_result = self.client.get_task_status(api_task_id)\n   389→\n   390→        if status_result[\"success\"]:\n   391→            # 更新本地记录\n   392→            updates = {\n   393→                \"status\": status_result[\"status\"],\n   394→                \"progress\": status_result.get(\"progress\", 0),\n   395→                \"updated_at\": datetime.now().isoformat(),\n   396→            }\n   397→\n   398→            # 如果任务完成，添加结果信息\n   399→            if status_result[\"status\"] == \"success\":\n   400→                updates[\"video_url\"] = status_result[\"video_url\"]\n   401→                updates[\"duration\"] = status_result.get(\"duration\")\n   402→                updates[\"file_size\"] = status_result.get(\"file_size\")\n   403→                updates[\"completed_at\"] = datetime.now().isoformat()\n   404→\n   405→            # 如果任务失败，添加错误信息\n   406→            elif status_result[\"status\"] == \"failed\":\n   407→                updates[\"error\"] = status_result.get(\"error\")\n   408→                updates[\"error_code\"] = status_result.get(\"error_code\")\n   409→\n   410→            # 更新元数据\n   411→            self.metadata_manager.update_record(task_id, updates)\n   412→\n   413→            # 合并任务信息\n   414→            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n   415→\n   416→            return result\n   417→        else:\n   418→            return status_result\n   419→\n   420→    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n   421→        \"\"\"\n   422→        下载已完成的视频\n   423→\n   424→        Args:\n   425→            task_id: 本地任务ID\n   426→\n   427→        Returns:\n   428→            Dict: 下载结果\n   429→        \"\"\"\n   430→        logger.info(f\"下载视频: {task_id}\")\n   431→\n   432→        # 获取任务信息\n   433→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   434→\n   435→        if not task_record:\n   436→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   437→\n   438→        # 检查任务状态\n   439→        if task_record.get(\"status\") != \"success\":\n   440→            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n   441→\n   442→        video_url = task_record.get(\"video_url\")\n   443→        if not video_url:\n   444→            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n   445→\n   446→        # 检查是否已下载\n   447→        local_path = task_record.get(\"local_path\")\n   448→        if local_path and Path(local_path).exists():\n   449→            logger.info(\n   450→                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n   451→            )\n   452→            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n   453→\n   454→        # 下载视频\n   455→        try:\n   456→            response = safe_requests_get(video_url, timeout=300)\n   457→\n   458→            # 生成本地文件名\n   459→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n   460→            task_id_short = task_id[:8]\n   461→            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n   462→\n   463→            # 保存文件\n   464→            local_path = self.file_manager.save_file(filename, response.content)\n   465→\n   466→            # 获取视频信息\n   467→            video_info = self._get_video_info(local_path)\n   468→\n   469→            # 更新元数据\n   470→            updates = {\n   471→                \"filename\": filename,\n   472→                \"local_path\": str(local_path),\n   473→                \"local_file_size\": local_path.stat().st_size,\n   474→                \"downloaded_at\": datetime.now().isoformat(),\n   475→            }\n   476→\n   477→            if video_info:\n   478→                updates.update(video_info)\n   479→\n   480→            self.metadata_manager.update_record(task_id, updates)\n   481→\n   482→            logger.success(f\"视频下载成功: {filename}\")\n   483→\n   484→            summary = {\n   485→                \"success\": True,\n   486→                \"local_path\": str(local_path),\n   487→                \"filename\": filename,\n   488→                \"file_size\": local_path.stat().st_size,\n   489→                \"video_info\": video_info,\n   490→            }\n   491→            try:\n   492→                logger.info(\n   493→                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n   494→                )\n   495→            except Exception:\n   496→                pass\n   497→            return summary\n   498→\n   499→        except Exception as e:\n   500→            logger.error(f\"下载视频失败: {e}\")\n   501→            try:\n   502→                logger.info(\n   503→                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n   504→                )\n   505→            except Exception:\n   506→                pass\n   507→            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n   508→\n   509→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n   510→        \"\"\"\n   511→        取消任务\n   512→\n   513→        Args:\n   514→            task_id: 本地任务ID\n   515→\n   516→        Returns:\n   517→            Dict: 取消结果\n   518→        \"\"\"\n   519→        logger.info(f\"取消任务: {task_id}\")\n   520→\n   521→        # 获取任务信息\n   522→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   523→\n   524→        if not task_record:\n   525→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   526→\n   527→        api_task_id = task_record.get(\"api_task_id\")\n   528→        if not api_task_id:\n   529→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   530→\n   531→        # 调用API取消任务\n   532→        cancel_result = self.client.cancel_task(api_task_id)\n   533→\n   534→        if cancel_result[\"success\"]:\n   535→            # 更新本地记录\n   536→            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n   537→\n   538→            self.metadata_manager.update_record(task_id, updates)\n   539→\n   540→            logger.success(f\"任务取消成功: {task_id}\")\n   541→\n   542→        return cancel_result\n   543→\n   544→    def batch_generate_videos(\n   545→        self,\n   546→        image_paths: List[str],\n   547→        duration: float = 4.0,\n   548→        motion_strength: float = 0.8,\n   549→        watermark: bool = True,\n   550→        save_local: bool = True,\n   551→        wait_for_completion: bool = False,\n   552→    ) -> List[Dict[str, Any]]:\n   553→        \"\"\"\n   554→        批量生成视频\n   555→\n   556→        Args:\n   557→            image_paths: 图像路径列表\n   558→            duration: 视频时长\n   559→            motion_strength: 运动强度\n   560→            watermark: 保留参数（服务端水印由配置决定）\n   561→            save_local: 是否保存到本地\n   562→            wait_for_completion: 是否等待任务完成\n   563→\n   564→        Returns:\n   565→            List[Dict]: 生成结果列表\n   566→        \"\"\"\n   567→        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n   568→\n   569→        results = []\n   570→        for i, image_path in enumerate(image_paths, 1):\n   571→            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n   572→\n   573→            result = self.generate_video(\n   574→                image_path=image_path,\n   575→                duration=duration,\n   576→                motion_strength=motion_strength,\n   577→                watermark=watermark,\n   578→                save_local=save_local,\n   579→                wait_for_completion=wait_for_completion,\n   580→            )\n   581→\n   582→            results.append(result)\n   583→\n   584→        success_count = sum(1 for r in results if r[\"success\"])\n   585→        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n   586→\n   587→        return results\n   588→\n   589→    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   590→        \"\"\"\n   591→        保存视频到本地\n   592→\n   593→        Args:\n   594→            result: API生成结果\n   595→\n   596→        Returns:\n   597→            Dict: 包含本地文件信息的字典\n   598→        \"\"\"\n   599→        try:\n   600→            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n   601→\n   602→            # Validate inputs\n   603→            task_id = result.get(\"task_id\")\n   604→            video_url = result.get(\"video_url\")\n   605→            if not task_id:\n   606→                raise ValueError(\"Task ID is required\")\n   607→            if not video_url:\n   608→                raise ValueError(\"Video URL is required\")\n   609→            \n   610→            # 下载视频（带重试机制）\n   611→            logger.info(f\"Downloading video from {video_url}\")\n   612→            max_retries = 3\n   613→            retry_delay = 5  # 秒\n   614→            video_data = None\n   615→            last_error = None\n   616→\n   617→            for attempt in range(max_retries):\n   618→                try:\n   619→                    if attempt > 0:\n   620→                        logger.info(f\"重试下载视频 (第 {attempt + 1}/{max_retries} 次)...\")\n   621→\n   622→                    response = safe_requests_get(video_url, stream=True, timeout=300)\n   623→\n   624→                    # Check content type\n   625→                    content_type = response.headers.get('content-type', '')\n   626→                    if 'video' not in content_type:\n   627→                        logger.warning(f\"Unexpected content type: {content_type}\")\n   628→\n   629→                    # Get file size for progress tracking\n   630→                    total_size = int(response.headers.get('content-length', 0))\n   631→                    video_data = response.content\n   632→\n   633→                    logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n   634→                    break  # 下载成功，跳出重试循环\n   635→\n   636→                except requests.exceptions.RequestException as e:\n   637→                    last_error = e\n   638→                    logger.warning(f\"下载视频失败 (第 {attempt + 1}/{max_retries} 次): {e}\")\n   639→                    if attempt < max_retries - 1:\n   640→                        import time\n   641→                        time.sleep(retry_delay)\n   642→\n   643→            if video_data is None:\n   644→                logger.error(f\"Network error downloading video after {max_retries} attempts: {last_error}\")\n   645→                raise Exception(f\"Failed to download video after {max_retries} attempts: {str(last_error)}\")\n   646→            \n   647→            # 在保存前获取真实视频信息（写临时文件以便读取）\n   648→            actual_width = None\n   649→            actual_height = None\n   650→            actual_fps = None\n   651→            actual_duration = None\n   652→            try:\n   653→                import tempfile\n   654→                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   655→                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n   656→                    tf.write(video_data)\n   657→                    temp_path = Path(tf.name)\n   658→                # 使用缩略图工具的get_video_info\n   659→                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   660→                gen = VideoThumbnailGenerator(str(thumbs_dir))\n   661→                info = gen.get_video_info(str(temp_path))\n   662→                try:\n   663→                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n   664→                except Exception:\n   665→                    pass\n   666→                if info:\n   667→                    actual_width = info.get('width')\n   668→                    actual_height = info.get('height')\n   669→                    actual_fps = info.get('fps')\n   670→                    actual_duration = info.get('duration')\n   671→            except Exception as e:\n   672→                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n   673→\n   674→            # 准备元数据（适配UnifiedStorageManager的格式）\n   675→            metadata = {\n   676→                'generation_id': task_id,\n   677→                'task_id': task_id,\n   678→                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n   679→                'parameters': {\n   680→                    **result.get('parameters', {}),\n   681→                    # 设置文件大小（在保存前就设置，确保写入数据库）\n   682→                    'file_size': len(video_data),\n   683→                    # 回填真实视频信息\n   684→                    **({} if actual_width is None else {'width': actual_width}),\n   685→                    **({} if actual_height is None else {'height': actual_height}),\n   686→                    **({} if actual_fps is None else {'fps': actual_fps}),\n   687→                    **({} if actual_duration is None else {'duration': actual_duration}),\n   688→                    # 透传fallback信息\n   689→                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n   690→                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n   691→                },\n   692→                'model': self._get_display_model_name(result),\n   693→                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n   694→                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n   695→                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n   696→                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n   697→                'generation_time': result.get('generation_time', 0),\n   698→                'status': result.get('status', 'completed'),\n   699→                'batch_id': result.get('batch_id', '')\n   700→            }\n   701→\n   702→            # 使用统一存储管理器保存文件\n   703→            save_result = self.storage_manager.save_content_file(\n   704→                content_type='videos',\n   705→                file_data=video_data,\n   706→                url=video_url,\n   707→                metadata=metadata\n   708→            )\n   709→\n   710→            # 缩略图生成（已由UnifiedStorageManager处理）\n   711→            thumbnail_local_path = save_result.get('thumbnail_path')\n   712→            thumbnail_filename = None\n   713→            if thumbnail_local_path:\n   714→                thumbnail_filename = Path(thumbnail_local_path).name\n   715→                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n   716→            else:\n   717→                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n   718→\n   719→            # 下载并保存API返回的缩略图（如果有）作为备用\n   720→            api_thumbnail_local_path = None\n   721→            api_thumbnail_filename = None\n   722→            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n   723→                try:\n   724→                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n   725→                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n   726→                    \n   727→                    # 使用统一存储管理器保存备用缩略图\n   728→                    backup_metadata = {\n   729→                        'generation_id': task_id,\n   730→                        'prompt': 'API backup thumbnail for video',\n   731→                        'model': 'seedance',\n   732→                        'width': 320,\n   733→                        'height': 180,\n   734→                        'status': 'completed'\n   735→                    }\n   736→                    \n   737→                    backup_result = self.storage_manager.save_content_file(\n   738→                        content_type='images',  # 缩略图保存为图片\n   739→                        file_data=thumbnail_response.content,\n   740→                        url=result[\"thumbnail_url\"],\n   741→                        metadata=backup_metadata\n   742→                    )\n   743→                    \n   744→                    api_thumbnail_local_path = backup_result['local_path']\n   745→                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n   746→                    \n   747→                    # 如果本地缩略图生成失败，使用API缩略图\n   748→                    if not thumbnail_local_path:\n   749→                        thumbnail_local_path = api_thumbnail_local_path\n   750→                        thumbnail_filename = api_thumbnail_filename\n   751→                    \n   752→                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n   753→                        \n   754→                except Exception as e:\n   755→                    logger.warning(f\"下载API缩略图失败: {e}\")\n   756→                    api_thumbnail_local_path = None\n   757→                    api_thumbnail_filename = None\n   758→\n   759→            # 获取视频信息\n   760→            local_path = Path(save_result['local_path'])\n   761→            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n   762→            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n   763→                try:\n   764→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   765→                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   766→                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n   767→                    video_info = gen.get_video_info(str(local_path))\n   768→                except Exception:\n   769→                    video_info = {}\n   770→            else:\n   771→                video_info = {\n   772→                    'width': actual_width,\n   773→                    'height': actual_height,\n   774→                    'fps': actual_fps,\n   775→                    'duration': actual_duration,\n   776→                }\n   777→            file_size = local_path.stat().st_size if local_path.exists() else 0\n   778→            \n   779→            logger.success(f\"视频已保存到本地: {local_path.name}\")\n   780→            \n   781→            # 本地视频水印（使用统一水印服务控制）\n   782→            if should_add_watermark():\n   783→                try:\n   784→                    from edition.watermark_service import WatermarkService\n   785→\n   786→                    watermark_text = get_watermark_text() or \"PIGEON\"\n   787→                    try:\n   788→                        opacity = get_watermark_opacity()\n   789→                    except Exception:\n   790→                        opacity = 0.3\n   791→                    opacity = max(0.0, min(opacity, 1.0))\n   792→\n   793→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n   794→                    watermark_applied = watermark_service.apply_to_video(local_path)\n   795→                    if watermark_applied:\n   796→                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n   797→                    else:\n   798→                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n   799→                except Exception as e:\n   800→                    logger.warning(f\"添加视频水印时出错: {e}\")\n   801→\n   802→            result_obj = {\n   803→                \"local_path\": save_result['local_path'],\n   804→                \"filename\": local_path.name,\n   805→                \"file_path\": save_result['local_path'],  # 保持兼容性\n   806→                \"local_file_size\": file_size,\n   807→                \"video_info\": video_info,\n   808→                # 同步回填至顶层，便于上游使用\n   809→                **({} if not video_info else {\n   810→                    'width': video_info.get('width'),\n   811→                    'height': video_info.get('height'),\n   812→                    'fps': video_info.get('fps'),\n   813→                    'duration': video_info.get('duration'),\n   814→                }),\n   815→                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n   816→                \"thumbnail_filename\": thumbnail_filename,\n   817→                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n   818→                \"api_thumbnail_filename\": api_thumbnail_filename,\n   819→                \"task_id\": task_id,  # 添加task_id以供后续使用\n   820→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n   821→                \"file_id\": save_result.get('file_id'),\n   822→                \"relative_path\": save_result.get('relative_path'),\n   823→            }\n   824→            try:\n   825→                logger.info(\n   826→                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n   827→                )\n   828→            except Exception:\n   829→                pass\n   830→            return result_obj\n   831→\n   832→        except Exception as e:\n   833→            logger.error(f\"保存视频到本地失败: {e}\")\n   834→            logger.exception(\"Full traceback for video save error:\")\n   835→            try:\n   836→                logger.info(\n   837→                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n   838→                )\n   839→            except Exception:\n   840→                pass\n   841→            return {\"local_save_error\": str(e)}\n   842→\n   843→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n   844→        checksum = hashlib.sha1(file_data).hexdigest()\n   845→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n   846→        return f\"ref_{ts}_{checksum[:8]}\"\n   847→\n   848→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n   849→        source_meta: Dict[str, Any] = {}\n   850→        raw = ref\n   851→        if isinstance(ref, dict):\n   852→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n   853→                if ref.get(key) is not None:\n   854→                    source_meta[key] = ref.get(key)\n   855→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n   856→        if raw is None:\n   857→            return None\n   858→\n   859→        extension = source_meta.get('extension')\n   860→        data = None\n   861→        source_repr = source_meta.get('source')\n   862→\n   863→        try:\n   864→            if isinstance(raw, bytes):\n   865→                data = raw\n   866→            elif isinstance(raw, str):\n   867→                stripped = raw.strip()\n   868→                if stripped.startswith('data:') and ';base64,' in stripped:\n   869→                    header, payload = stripped.split(';base64,', 1)\n   870→                    mime_part = header[5:]\n   871→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n   872→                    data = base64.b64decode(payload)\n   873→                    source_repr = source_repr or mime_part\n   874→                    source_meta.setdefault('type', 'image')\n   875→                elif stripped.startswith(('http://', 'https://')):\n   876→                    resp = safe_requests_get(stripped, timeout=15)\n   877→                    data = resp.content\n   878→                    parsed = urlparse(stripped)\n   879→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n   880→                    source_repr = source_repr or stripped\n   881→                    source_meta.setdefault('source_url', stripped)\n   882→                else:\n   883→                    path = Path(stripped)\n   884→                    if not path.exists():\n   885→                        logger.warning(f\"参考图像不存在: {stripped}\")\n   886→                        return None\n   887→                    data = path.read_bytes()\n   888→                    extension = extension or path.suffix or '.png'\n   889→                    source_repr = source_repr or path.name\n   890→                    source_meta.setdefault('source_path', str(path))\n   891→            else:\n   892→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n   893→                return None\n   894→        except Exception as exc:\n   895→            logger.warning(f\"加载参考图失败: {exc}\")\n   896→            return None\n   897→\n   898→        if data is None:\n   899→            return None\n   900→\n   901→        width = source_meta.get('width')\n   902→        height = source_meta.get('height')\n   903→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n   904→            try:\n   905→                from io import BytesIO\n   906→\n   907→                with Image.open(BytesIO(data)) as img:\n   908→                    width = img.width\n   909→                    height = img.height\n   910→            except Exception:\n   911→                pass\n   912→\n   913→        source_meta['width'] = width\n   914→        source_meta['height'] = height\n   915→        source_meta.setdefault('type', 'image')\n   916→        source_meta['source'] = source_repr or source_meta.get('source')\n   917→\n   918→        return data, extension, source_meta\n   919→\n   920→    def _process_reference_assets(\n   921→        self,\n   922→        references: Optional[List[Any]],\n   923→        *,\n   924→        max_refs: int = MAX_REFERENCE_IMAGES,\n   925→        expected_outputs: int = 1,\n   926→    ) -> Dict[str, Any]:\n   927→        stored: List[Dict[str, Any]] = []\n   928→        absolute_paths: List[str] = []\n   929→        errors: List[str] = []\n   930→        warnings: List[str] = []\n   931→\n   932→        if not references:\n   933→            return {\n   934→                'assets': stored,\n   935→                'paths': absolute_paths,\n   936→                'errors': errors,\n   937→                'warnings': warnings,\n   938→            }\n   939→\n   940→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n   941→            warnings.append(\n   942→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n   943→            )\n   944→            references = references[:max_refs]\n   945→\n   946→        for order, item in enumerate(references):\n   947→            load_result = self._load_reference_source(item)\n   948→            if not load_result:\n   949→                errors.append(f\"ref[{order}] 加载失败\")\n   950→                continue\n   951→\n   952→            file_data, extension, meta = load_result\n   953→            meta.setdefault('order', order)\n   954→            meta.setdefault('kind', meta.get('type', 'image'))\n   955→\n   956→            try:\n   957→                asset_id = self._generate_reference_asset_id(file_data)\n   958→                record = self.storage_manager.save_reference_asset(\n   959→                    'images',\n   960→                    file_data,\n   961→                    asset_id=asset_id,\n   962→                    extension=extension,\n   963→                    metadata=meta,\n   964→                )\n   965→                try:\n   966→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n   967→                except Exception:\n   968→                    record['_payload_b64'] = None\n   969→                record['_source_meta'] = meta\n   970→                stored.append(record)\n   971→                if record.get('absolute_path'):\n   972→                    absolute_paths.append(record['absolute_path'])\n   973→            except Exception as exc:\n   974→                logger.warning(f\"保存参考图失败: {exc}\")\n   975→                errors.append(f\"ref[{order}] 保存失败\")\n   976→\n   977→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n   978→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n   979→            if len(stored) > allowed:\n   980→                warnings.append(\n   981→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n   982→                )\n   983→                stored = stored[:allowed]\n   984→                absolute_paths = absolute_paths[:allowed]\n   985→\n   986→        return {\n   987→            'assets': stored,\n   988→            'paths': absolute_paths,\n   989→            'errors': errors,\n   990→            'warnings': warnings,\n   991→        }\n   992→\n   993→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   994→        cleaned: List[Dict[str, Any]] = []\n   995→        for rec in assets or []:\n   996→            rec.pop('_payload_b64', None)\n   997→            rec.pop('_source_meta', None)\n   998→            rec.pop('absolute_path', None)\n   999→            cleaned.append({\n  1000→                'id': rec.get('id') or rec.get('reference_id'),\n  1001→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n  1002→                'type': rec.get('type'),\n  1003→                'kind': rec.get('kind'),\n  1004→                'source': rec.get('source'),\n  1005→                'order': rec.get('order'),\n  1006→                'checksum': rec.get('checksum'),\n  1007→                'size': rec.get('size'),\n  1008→                'width': rec.get('width'),\n  1009→                'height': rec.get('height'),\n  1010→                'created_at': rec.get('created_at'),\n  1011→            })\n  1012→        return cleaned\n  1013→\n  1014→    @staticmethod\n  1015→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1016→        masked: List[str] = []\n  1017→        for rec in assets or []:\n  1018→            rid = rec.get('id') or ''\n  1019→            if not rid:\n  1020→                continue\n  1021→            masked.append(f\"{rid[:6]}***\")\n  1022→        return \",\".join(masked)\n  1023→\n  1024→    @staticmethod\n  1025→    def _provider_hint() -> str:\n  1026→        try:\n  1027→            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n  1028→        except Exception:\n  1029→            return \"seedance\"\n  1030→\n  1031→    @staticmethod\n  1032→    def _cleanup_reference_paths(paths: List[str]):\n  1033→        for path in paths or []:\n  1034→            try:\n  1035→                if path and Path(path).exists():\n  1036→                    Path(path).unlink(missing_ok=True)\n  1037→            except Exception as exc:\n  1038→                logger.debug(f\"参考图清理失败: {exc}\")\n  1039→\n  1040→    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n  1041→        \"\"\"\n  1042→        将绝对路径转换为相对路径（相对于存储根目录）\n  1043→\n  1044→        如果路径已经是相对路径或无法转换，返回原路径。\n  1045→        这确保数据库中存储的是相对路径，支持跨平台迁移。\n  1046→\n  1047→        Args:\n  1048→            abs_path: 绝对路径或相对路径\n  1049→\n  1050→        Returns:\n  1051→            相对路径字符串，如 \"images/xxx.png\"\n  1052→        \"\"\"\n  1053→        if not abs_path:\n  1054→            return None\n  1055→\n  1056→        try:\n  1057→            path = Path(abs_path)\n  1058→\n  1059→            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n  1060→            if not path.is_absolute():\n  1061→                return str(path).replace('\\\\', '/')\n  1062→\n  1063→            # 尝试转换为相对于存储根目录的路径\n  1064→            storage_root = Path(self.storage_manager.root_path)\n  1065→            try:\n  1066→                relative = path.relative_to(storage_root)\n  1067→                return str(relative).replace('\\\\', '/')\n  1068→            except ValueError:\n  1069→                # 路径不在存储根目录下，尝试提取文件名部分\n  1070→                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n  1071→                parts = path.parts\n  1072→                for i, part in enumerate(parts):\n  1073→                    if part in ('images', 'videos', 'thumbnails', 'references'):\n  1074→                        relative = Path(*parts[i:])\n  1075→                        return str(relative).replace('\\\\', '/')\n  1076→\n  1077→                # 无法提取，返回原路径（记录警告）\n  1078→                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n  1079→                return str(path).replace('\\\\', '/')\n  1080→\n  1081→        except Exception as e:\n  1082→            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n  1083→            return abs_path\n  1084→\n  1085→    def _extract_width_from_resolution(self, resolution: str) -> int:\n  1086→        \"\"\"\n  1087→        从分辨率字符串中提取宽度\n  1088→        \n  1089→        Args:\n  1090→            resolution: 分辨率字符串，如 \"1280x720\"\n  1091→            \n  1092→        Returns:\n  1093→            int: 宽度值\n  1094→        \"\"\"\n  1095→        try:\n  1096→            return int(resolution.split('x')[0])\n  1097→        except (ValueError, IndexError):\n  1098→            return 1280  # 默认值\n  1099→    \n  1100→    def _extract_height_from_resolution(self, resolution: str) -> int:\n  1101→        \"\"\"\n  1102→        从分辨率字符串中提取高度\n  1103→        \n  1104→        Args:\n  1105→            resolution: 分辨率字符串，如 \"1280x720\"\n  1106→            \n  1107→        Returns:\n  1108→            int: 高度值\n  1109→        \"\"\"\n  1110→        try:\n  1111→            return int(resolution.split('x')[1])\n  1112→        except (ValueError, IndexError):\n  1113→            return 720  # 默认值\n  1114→\n  1115→    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n  1116→        \"\"\"\n  1117→        获取视频信息\n  1118→\n  1119→        Args:\n  1120→            video_path: 视频文件路径\n  1121→\n  1122→        Returns:\n  1123→            Dict: 视频信息\n  1124→        \"\"\"\n  1125→        try:\n  1126→            # 这里可以使用ffprobe或其他工具获取视频信息\n  1127→            # 暂时返回基本信息\n  1128→            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n  1129→        except Exception as e:\n  1130→            logger.error(f\"获取视频信息失败: {e}\")\n  1131→            return {}\n  1132→\n  1133→    def _save_task_metadata(self, result: Dict[str, Any]):\n  1134→        \"\"\"\n  1135→        保存任务元数据\n  1136→\n  1137→        Args:\n  1138→            result: 任务结果\n  1139→        \"\"\"\n  1140→        try:\n  1141→            # 构建视频元数据\n  1142→            metadata = {\n  1143→                \"generation_id\": result[\"task_id\"],\n  1144→                \"file_id\": result[\"task_id\"],\n  1145→                \"filename\": result.get(\"filename\", \"\"),\n  1146→                \"file_path\": result.get(\"local_path\", \"\"),\n  1147→                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n  1148→                \"parameters\": result.get(\"parameters\", {}),\n  1149→                \"created_at\": result[\"created_at\"],\n  1150→                \"file_size\": result.get(\"local_file_size\", 0),\n  1151→                \"source_url\": result.get(\"video_url\", \"\"),\n  1152→                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n  1153→                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n  1154→            }\n  1155→\n  1156→            # 调用视频元数据保存方法\n  1157→            self.metadata_manager.save_video_metadata(metadata)\n  1158→            \n  1159→            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n  1160→\n  1161→        except Exception as e:\n  1162→            logger.error(f\"保存任务元数据失败: {e}\")\n  1163→\n  1164→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1165→        \"\"\"\n  1166→        获取视频生成历史记录\n  1167→\n  1168→        Args:\n  1169→            limit: 返回记录数量限制\n  1170→\n  1171→        Returns:\n  1172→            List[Dict]: 历史记录列表\n  1173→        \"\"\"\n  1174→        return self.storage_manager.load_history('videos', limit=limit)\n  1175→\n  1176→    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n  1177→        \"\"\"\n  1178→        根据输入图像路径搜索历史记录\n  1179→\n  1180→        Args:\n  1181→            keyword: 搜索关键字\n  1182→\n  1183→        Returns:\n  1184→            List[Dict]: 匹配的记录列表\n  1185→        \"\"\"\n  1186→        return self.metadata_manager.search_records(\"input_image\", keyword)\n  1187→\n  1188→    def get_statistics(self) -> Dict[str, Any]:\n  1189→        \"\"\"\n  1190→        获取生成统计信息\n  1191→\n  1192→        Returns:\n  1193→            Dict: 统计信息\n  1194→        \"\"\"\n  1195→        try:\n  1196→            df = self.metadata_manager.get_dataframe()\n  1197→\n  1198→            if df.empty:\n  1199→                return {\n  1200→                    \"total_videos\": 0,\n  1201→                    \"success_count\": 0,\n  1202→                    \"failed_count\": 0,\n  1203→                    \"pending_count\": 0,\n  1204→                    \"total_file_size\": 0,\n  1205→                    \"average_file_size\": 0,\n  1206→                    \"total_duration\": 0,\n  1207→                    \"average_duration\": 0,\n  1208→                }\n  1209→\n  1210→            stats = {\n  1211→                \"total_videos\": len(df),\n  1212→                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n  1213→                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n  1214→                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n  1215→                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n  1216→                \"total_file_size\": df[\"local_file_size\"].sum(),\n  1217→                \"average_file_size\": df[\"local_file_size\"].mean(),\n  1218→                \"total_duration\": df[\"duration\"].sum(),\n  1219→                \"average_duration\": df[\"duration\"].mean(),\n  1220→                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n  1221→            }\n  1222→\n  1223→            return stats\n  1224→\n  1225→        except Exception as e:\n  1226→            logger.error(f\"获取统计信息失败: {e}\")\n  1227→            return {}\n  1228→\n  1229→    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n  1230→        \"\"\"\n  1231→        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n  1232→\n  1233→        注意：\n  1234→        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n  1235→          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n  1236→        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n  1237→        \"\"\"\n  1238→        params = result.get(\"parameters\", {}) or {}\n  1239→\n  1240→        # 新三层参数结构优先：actual > sent > requested\n  1241→        if isinstance(params, dict):\n  1242→            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n  1243→                layer_obj = params.get(layer)\n  1244→                if isinstance(layer_obj, dict):\n  1245→                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n  1246→                    if cand:\n  1247→                        return str(cand)\n  1248→                    if layer == \"params_requested\":\n  1249→                        mv = layer_obj.get(\"model_variant\")\n  1250→                        if mv:\n  1251→                            return str(mv)\n  1252→\n  1253→        # 顶层 model（VideoService 会尽量补齐）\n  1254→        top = result.get(\"model\")\n  1255→        if top:\n  1256→            return str(top)\n  1257→\n  1258→        # 旧结构兼容：从 parameters 推断\n  1259→        if isinstance(params, dict):\n  1260→            mv = params.get(\"model_variant\") or \"\"\n  1261→            mt = params.get(\"model_type\") or \"\"\n  1262→            use_pro_model = params.get(\"use_pro_model\", True)\n  1263→\n  1264→            if mv:\n  1265→                return str(mv)\n  1266→            if isinstance(mt, str) and mt.strip():\n  1267→                return mt.strip()\n  1268→            if bool(use_pro_model):\n  1269→                return \"pro\"\n  1270→            return \"lite\"\n  1271→\n  1272→        return \"seedance\"\n  1273→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"36f76147-e1ab-47f3-9353-1776210f10df","timestamp":"2026-01-08T03:06:17.651Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"# Seedance视频生成管理器\n# 负责视频生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nimport base64\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom urllib.parse import urlparse\nfrom loguru import logger\nfrom PIL import Image\n\nfrom ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n\nfrom .client import SeedanceClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    VideoParams,\n    validate_and_normalize_video,\n)\nfrom config.unified_config import get_unified_config\nfrom config.unified_config import get_storage_dir\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n# Q-006 固化策略：\n# - 本地水印由 edition/watermark_service 控制（trial 强制开 / prod 关闭）\n# - API 服务端水印固定关闭（不依赖 config_api）\n\n\nclass SeedanceManager:\n    \"\"\"Seedance视频生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedance管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n        \"\"\"\n        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n        \n        self.client = SeedanceClient(api_key)\n\n        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n        storage_path = get_storage_dir()\n        if not storage_path:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        Path(storage_path).mkdir(parents=True, exist_ok=True)\n\n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(storage_path)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.video_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.videos_dir = self.data_dir / \"videos\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_video(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: float = 4.0,\n        seed: int = -1,\n        watermark: bool = False,\n        save_local: bool = True,\n        wait_for_completion: bool = True,\n        # 新增参数（P0b）\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        fps: int = 24,\n        camera_fixed: bool = True,\n        use_pro_model: bool = True,\n        model_type: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        generate_audio: Optional[bool] = None,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成视频并保存到本地\n\n        Args:\n            image_path: 输入图像路径\n            duration: 视频时长（秒）\n            motion_strength: 运动强度 (0.1-1.0)\n            seed: 随机种子\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            Dict: 生成结果\n        \"\"\"\n        logger.info(\"开始视频生成任务(Manager)\")\n\n        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n        # 构建待处理的图片列表\n        all_input_images = []\n\n        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n        frame_inputs = []\n        if first_frame_path:\n            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n        if last_frame_path:\n            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n        elif image_path and not first_frame_path:\n            frame_inputs.append({'path': image_path, 'type': 'image'})\n\n        all_input_images.extend(frame_inputs)\n\n        # 2. 添加参考图\n        if reference_images:\n            for ref in reference_images:\n                if isinstance(ref, dict):\n                    ref_copy = dict(ref)\n                    ref_copy['type'] = ref_copy.get('type', 'reference')\n                    all_input_images.append(ref_copy)\n                else:\n                    all_input_images.append({'path': ref, 'type': 'reference'})\n\n        # 3. 统一处理（复制到 references 目录）\n        ref_summary = self._process_reference_assets(\n            all_input_images if all_input_images else None,\n            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n            expected_outputs=1,\n        )\n        ref_assets = ref_summary.get('assets', [])\n        ref_paths: List[str] = list(ref_summary.get('paths', []))\n\n        # 4. 分离帧图片和参考图\n        frame_assets = {}\n        pure_ref_assets = []\n        for asset in ref_assets:\n            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n            if asset_type in ('first_frame', 'last_frame', 'image'):\n                frame_assets[asset_type] = asset\n            else:\n                pure_ref_assets.append(asset)\n\n        # 5. 提取帧图片的相对路径（用于存储）\n        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n        stored_image_path = frame_assets.get('image', {}).get('path')\n\n        # 6. 提取参考图的 payload（用于 API 调用）\n        ref_payloads: List[str] = []\n        for asset in pure_ref_assets:\n            payload = asset.get('_payload_b64')\n            if payload:\n                ref_payloads.append(payload)\n\n        if ref_summary.get('errors'):\n            logger.warning(\n                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n            )\n        if ref_summary.get('warnings'):\n            for warn in ref_summary['warnings']:\n                logger.warning(f\"图片处理提示: {warn}\")\n\n        # Q-006：API 服务端水印固定关闭；体验版仅做本地水印（落盘后处理）\n        watermark_enabled = False\n\n        create_kwargs = dict(\n            prompt=prompt,\n            duration=int(duration),\n            seed=None if seed == -1 else seed,\n            fps=fps,\n            resolution_grade=resolution_grade,\n            ratio=ratio,\n            watermark=watermark_enabled,\n            camera_fixed=bool(camera_fixed),\n            use_pro_model=use_pro_model,\n            model_type=model_type,\n            model_variant=model_variant,\n            generate_audio=generate_audio,\n        )\n        if ref_payloads:\n            create_kwargs['reference_images'] = ref_payloads\n        if first_frame_path and last_frame_path:\n            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n        elif image_path:\n            create_kwargs.update(dict(image_path=image_path))\n        # 文生视频：不追加图片参数\n\n        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n        precheck_fb = False\n        precheck_reason = \"\"\n        try:\n            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n                VideoParams(\n                    prompt=prompt,\n                    image_path=None,  # 校验不依赖图像数据\n                    first_frame_path=None,\n                    last_frame_path=None,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if seed == -1 else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=bool(watermark),\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                    model_variant=model_variant,\n                    generate_audio=generate_audio,\n                )\n            )\n            logger.info(\n                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n            )\n            if fb:\n                logger.warning(f\"前置参数回退建议: {reason}\")\n            precheck_fb = fb\n            precheck_reason = reason\n        except Exception as _e:\n            logger.debug(f\"前置参数校验跳过: {_e}\")\n\n        create_result = self.client.create_video_task(**create_kwargs)\n        params_sent = create_result.get(\"params_sent\") if isinstance(create_result, dict) else None\n\n        # 用实际执行参数覆盖用户输入（如 Lite 参考图模式 1080p→720p 降级）\n        if create_result.get(\"success\"):\n            actual_rs = create_result.get('used_rs')\n            actual_rt = create_result.get('used_rt')\n            if actual_rs:\n                logger.debug(f\"参数覆盖|resolution_grade: 用户输入={resolution_grade} -> 实际执行={actual_rs}\")\n                resolution_grade = actual_rs\n            if actual_rt:\n                logger.debug(f\"参数覆盖|ratio: 用户输入={ratio} -> 实际执行={actual_rt}\")\n                ratio = actual_rt\n\n        if not create_result[\"success\"]:\n            self._cleanup_reference_paths(ref_paths)\n            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n            return create_result\n\n        api_task_id = create_result[\"task_id\"]\n\n        result = {\n            \"task_id\": task_id,\n            \"api_task_id\": api_task_id,\n            \"params_sent\": params_sent,\n            \"success\": True,\n            \"type\": \"image_to_video\",\n            \"input_image\": image_path,\n            \"status\": \"pending\",\n            \"parameters\": {\n                \"prompt\": prompt,\n                \"duration\": duration,\n                \"seed\": (None if seed == -1 else seed),\n                \"watermark\": watermark_enabled,\n                \"resolution_grade\": resolution_grade,\n                \"ratio\": ratio,\n                \"fps\": fps,\n                \"camera_fixed\": bool(camera_fixed),\n                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n                \"first_frame\": stored_first_frame,\n                \"last_frame\": stored_last_frame,\n                \"image_path\": stored_image_path,\n            },\n            \"created_at\": datetime.now().isoformat(),\n        }\n\n        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n        result['reference_assets'] = sanitized_refs\n        if ref_summary.get('errors'):\n            result['reference_asset_errors'] = ref_summary['errors']\n        if ref_summary.get('warnings'):\n            result['reference_asset_warnings'] = ref_summary['warnings']\n        if precheck_fb and precheck_reason:\n            result.setdefault('fallback_applied', True)\n            if result.get('fallback_reason'):\n                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n            else:\n                result['fallback_reason'] = precheck_reason\n\n        masked_ids = self._summarize_reference_ids(sanitized_refs)\n        logger.info(\n            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n            len(sanitized_refs),\n            masked_ids or \"-\",\n            self._provider_hint(),\n        )\n\n        # 透传回退信息\n        if create_result.get(\"fallback_applied\"):\n            result[\"fallback_applied\"] = True\n            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n\n        # 如果等待完成，轮询任务状态\n        if wait_for_completion:\n            completion_result = self.client.wait_for_completion(api_task_id)\n\n            if completion_result[\"success\"]:\n                if completion_result[\"status\"] == \"success\":\n                    result[\"status\"] = \"success\"\n                    result[\"video_url\"] = completion_result[\"video_url\"]\n                    result[\"duration\"] = completion_result.get(\"duration\")\n                    result[\"file_size\"] = completion_result.get(\"file_size\")\n                    result[\"completed_at\"] = datetime.now().isoformat()\n\n                    # 保存到本地\n                    if save_local:\n                        local_result = self._save_video_locally(result)\n                        result.update(local_result)\n                        # 注：file_size 已在 _save_video_locally 内部设置到 metadata['parameters'] 中\n                        if local_result.get('local_save_error'):\n                            self._cleanup_reference_paths(ref_paths)\n                            result['parameters'][\"reference_assets\"] = []\n                            result['reference_assets'] = []\n                            warnings = result.setdefault('reference_asset_warnings', [])\n                            warnings.append(\"视频保存失败，参考图已回滚\")\n                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n                    logger.success(f\"视频生成任务完成: {task_id}\")\n                else:\n                    result[\"status\"] = completion_result[\"status\"]\n                    result[\"error\"] = completion_result.get(\"error\")\n                    result[\"error_code\"] = completion_result.get(\"error_code\")\n                    logger.error(f\"视频生成任务失败: {result['error']}\")\n            else:\n                result[\"status\"] = \"failed\"\n                result[\"error\"] = completion_result[\"error\"]\n                result[\"error_code\"] = completion_result[\"error_code\"]\n                logger.error(f\"等待任务完成失败: {result['error']}\")\n\n        # 注：元数据已通过 save_content_file() 保存，无需重复调用\n\n        return result\n\n    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        检查任务状态\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        logger.info(f\"检查任务状态: {task_id}\")\n\n        # 从元数据中获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 查询API任务状态\n        status_result = self.client.get_task_status(api_task_id)\n\n        if status_result[\"success\"]:\n            # 更新本地记录\n            updates = {\n                \"status\": status_result[\"status\"],\n                \"progress\": status_result.get(\"progress\", 0),\n                \"updated_at\": datetime.now().isoformat(),\n            }\n\n            # 如果任务完成，添加结果信息\n            if status_result[\"status\"] == \"success\":\n                updates[\"video_url\"] = status_result[\"video_url\"]\n                updates[\"duration\"] = status_result.get(\"duration\")\n                updates[\"file_size\"] = status_result.get(\"file_size\")\n                updates[\"completed_at\"] = datetime.now().isoformat()\n\n            # 如果任务失败，添加错误信息\n            elif status_result[\"status\"] == \"failed\":\n                updates[\"error\"] = status_result.get(\"error\")\n                updates[\"error_code\"] = status_result.get(\"error_code\")\n\n            # 更新元数据\n            self.metadata_manager.update_record(task_id, updates)\n\n            # 合并任务信息\n            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n\n            return result\n        else:\n            return status_result\n\n    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        下载已完成的视频\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 下载结果\n        \"\"\"\n        logger.info(f\"下载视频: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        # 检查任务状态\n        if task_record.get(\"status\") != \"success\":\n            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n\n        video_url = task_record.get(\"video_url\")\n        if not video_url:\n            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n\n        # 检查是否已下载\n        local_path = task_record.get(\"local_path\")\n        if local_path and Path(local_path).exists():\n            logger.info(\n                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n            )\n            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n\n        # 下载视频\n        try:\n            response = safe_requests_get(video_url, timeout=300)\n\n            # 生成本地文件名\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            task_id_short = task_id[:8]\n            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n\n            # 保存文件\n            local_path = self.file_manager.save_file(filename, response.content)\n\n            # 获取视频信息\n            video_info = self._get_video_info(local_path)\n\n            # 更新元数据\n            updates = {\n                \"filename\": filename,\n                \"local_path\": str(local_path),\n                \"local_file_size\": local_path.stat().st_size,\n                \"downloaded_at\": datetime.now().isoformat(),\n            }\n\n            if video_info:\n                updates.update(video_info)\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"视频下载成功: {filename}\")\n\n            summary = {\n                \"success\": True,\n                \"local_path\": str(local_path),\n                \"filename\": filename,\n                \"file_size\": local_path.stat().st_size,\n                \"video_info\": video_info,\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n                )\n            except Exception:\n                pass\n            return summary\n\n        except Exception as e:\n            logger.error(f\"下载视频失败: {e}\")\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n                )\n            except Exception:\n                pass\n            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消任务\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 取消结果\n        \"\"\"\n        logger.info(f\"取消任务: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 调用API取消任务\n        cancel_result = self.client.cancel_task(api_task_id)\n\n        if cancel_result[\"success\"]:\n            # 更新本地记录\n            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"任务取消成功: {task_id}\")\n\n        return cancel_result\n\n    def batch_generate_videos(\n        self,\n        image_paths: List[str],\n        duration: float = 4.0,\n        motion_strength: float = 0.8,\n        watermark: bool = True,\n        save_local: bool = True,\n        wait_for_completion: bool = False,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成视频\n\n        Args:\n            image_paths: 图像路径列表\n            duration: 视频时长\n            motion_strength: 运动强度\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n\n        results = []\n        for i, image_path in enumerate(image_paths, 1):\n            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n\n            result = self.generate_video(\n                image_path=image_path,\n                duration=duration,\n                motion_strength=motion_strength,\n                watermark=watermark,\n                save_local=save_local,\n                wait_for_completion=wait_for_completion,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n\n        return results\n\n    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存视频到本地\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n\n            # Validate inputs\n            task_id = result.get(\"task_id\")\n            video_url = result.get(\"video_url\")\n            if not task_id:\n                raise ValueError(\"Task ID is required\")\n            if not video_url:\n                raise ValueError(\"Video URL is required\")\n            \n            # 下载视频（带重试机制）\n            logger.info(f\"Downloading video from {video_url}\")\n            max_retries = 3\n            retry_delay = 5  # 秒\n            video_data = None\n            last_error = None\n\n            for attempt in range(max_retries):\n                try:\n                    if attempt > 0:\n                        logger.info(f\"重试下载视频 (第 {attempt + 1}/{max_retries} 次)...\")\n\n                    response = safe_requests_get(video_url, stream=True, timeout=300)\n\n                    # Check content type\n                    content_type = response.headers.get('content-type', '')\n                    if 'video' not in content_type:\n                        logger.warning(f\"Unexpected content type: {content_type}\")\n\n                    # Get file size for progress tracking\n                    total_size = int(response.headers.get('content-length', 0))\n                    video_data = response.content\n\n                    logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n                    break  # 下载成功，跳出重试循环\n\n                except requests.exceptions.RequestException as e:\n                    last_error = e\n                    logger.warning(f\"下载视频失败 (第 {attempt + 1}/{max_retries} 次): {e}\")\n                    if attempt < max_retries - 1:\n                        import time\n                        time.sleep(retry_delay)\n\n            if video_data is None:\n                logger.error(f\"Network error downloading video after {max_retries} attempts: {last_error}\")\n                raise Exception(f\"Failed to download video after {max_retries} attempts: {str(last_error)}\")\n            \n            # 在保存前获取真实视频信息（写临时文件以便读取）\n            actual_width = None\n            actual_height = None\n            actual_fps = None\n            actual_duration = None\n            try:\n                import tempfile\n                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n                    tf.write(video_data)\n                    temp_path = Path(tf.name)\n                # 使用缩略图工具的get_video_info\n                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                gen = VideoThumbnailGenerator(str(thumbs_dir))\n                info = gen.get_video_info(str(temp_path))\n                try:\n                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n                except Exception:\n                    pass\n                if info:\n                    actual_width = info.get('width')\n                    actual_height = info.get('height')\n                    actual_fps = info.get('fps')\n                    actual_duration = info.get('duration')\n            except Exception as e:\n                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n\n            # 准备元数据（适配UnifiedStorageManager的格式）\n            metadata = {\n                'generation_id': task_id,\n                'task_id': task_id,\n                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n                'parameters': {\n                    **result.get('parameters', {}),\n                    # 设置文件大小（在保存前就设置，确保写入数据库）\n                    'file_size': len(video_data),\n                    # 回填真实视频信息\n                    **({} if actual_width is None else {'width': actual_width}),\n                    **({} if actual_height is None else {'height': actual_height}),\n                    **({} if actual_fps is None else {'fps': actual_fps}),\n                    **({} if actual_duration is None else {'duration': actual_duration}),\n                    # 透传fallback信息\n                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n                },\n                'model': self._get_display_model_name(result),\n                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n                'generation_time': result.get('generation_time', 0),\n                'status': result.get('status', 'completed'),\n                'batch_id': result.get('batch_id', '')\n            }\n\n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='videos',\n                file_data=video_data,\n                url=video_url,\n                metadata=metadata\n            )\n\n            # 缩略图生成（已由UnifiedStorageManager处理）\n            thumbnail_local_path = save_result.get('thumbnail_path')\n            thumbnail_filename = None\n            if thumbnail_local_path:\n                thumbnail_filename = Path(thumbnail_local_path).name\n                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n            else:\n                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n\n            # 下载并保存API返回的缩略图（如果有）作为备用\n            api_thumbnail_local_path = None\n            api_thumbnail_filename = None\n            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n                try:\n                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n                    \n                    # 使用统一存储管理器保存备用缩略图\n                    backup_metadata = {\n                        'generation_id': task_id,\n                        'prompt': 'API backup thumbnail for video',\n                        'model': 'seedance',\n                        'width': 320,\n                        'height': 180,\n                        'status': 'completed'\n                    }\n                    \n                    backup_result = self.storage_manager.save_content_file(\n                        content_type='images',  # 缩略图保存为图片\n                        file_data=thumbnail_response.content,\n                        url=result[\"thumbnail_url\"],\n                        metadata=backup_metadata\n                    )\n                    \n                    api_thumbnail_local_path = backup_result['local_path']\n                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n                    \n                    # 如果本地缩略图生成失败，使用API缩略图\n                    if not thumbnail_local_path:\n                        thumbnail_local_path = api_thumbnail_local_path\n                        thumbnail_filename = api_thumbnail_filename\n                    \n                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n                        \n                except Exception as e:\n                    logger.warning(f\"下载API缩略图失败: {e}\")\n                    api_thumbnail_local_path = None\n                    api_thumbnail_filename = None\n\n            # 获取视频信息\n            local_path = Path(save_result['local_path'])\n            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n                try:\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n                    video_info = gen.get_video_info(str(local_path))\n                except Exception:\n                    video_info = {}\n            else:\n                video_info = {\n                    'width': actual_width,\n                    'height': actual_height,\n                    'fps': actual_fps,\n                    'duration': actual_duration,\n                }\n            file_size = local_path.stat().st_size if local_path.exists() else 0\n            \n            logger.success(f\"视频已保存到本地: {local_path.name}\")\n            \n            # 本地视频水印（使用统一水印服务控制）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_video(local_path)\n                    if watermark_applied:\n                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n                    else:\n                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n                except Exception as e:\n                    logger.warning(f\"添加视频水印时出错: {e}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": local_path.name,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"local_file_size\": file_size,\n                \"video_info\": video_info,\n                # 同步回填至顶层，便于上游使用\n                **({} if not video_info else {\n                    'width': video_info.get('width'),\n                    'height': video_info.get('height'),\n                    'fps': video_info.get('fps'),\n                    'duration': video_info.get('duration'),\n                }),\n                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n                \"thumbnail_filename\": thumbnail_filename,\n                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n                \"api_thumbnail_filename\": api_thumbnail_filename,\n                \"task_id\": task_id,  # 添加task_id以供后续使用\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n                )\n            except Exception:\n                pass\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存视频到本地失败: {e}\")\n            logger.exception(\"Full traceback for video save error:\")\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n                )\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"参考图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('reference_id'),\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum'),\n                'size': rec.get('size'),\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n        except Exception:\n            return \"seedance\"\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n        \"\"\"\n        将绝对路径转换为相对路径（相对于存储根目录）\n\n        如果路径已经是相对路径或无法转换，返回原路径。\n        这确保数据库中存储的是相对路径，支持跨平台迁移。\n\n        Args:\n            abs_path: 绝对路径或相对路径\n\n        Returns:\n            相对路径字符串，如 \"images/xxx.png\"\n        \"\"\"\n        if not abs_path:\n            return None\n\n        try:\n            path = Path(abs_path)\n\n            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n            if not path.is_absolute():\n                return str(path).replace('\\\\', '/')\n\n            # 尝试转换为相对于存储根目录的路径\n            storage_root = Path(self.storage_manager.root_path)\n            try:\n                relative = path.relative_to(storage_root)\n                return str(relative).replace('\\\\', '/')\n            except ValueError:\n                # 路径不在存储根目录下，尝试提取文件名部分\n                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n                parts = path.parts\n                for i, part in enumerate(parts):\n                    if part in ('images', 'videos', 'thumbnails', 'references'):\n                        relative = Path(*parts[i:])\n                        return str(relative).replace('\\\\', '/')\n\n                # 无法提取，返回原路径（记录警告）\n                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n                return str(path).replace('\\\\', '/')\n\n        except Exception as e:\n            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n            return abs_path\n\n    def _extract_width_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取宽度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[0])\n        except (ValueError, IndexError):\n            return 1280  # 默认值\n    \n    def _extract_height_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取高度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[1])\n        except (ValueError, IndexError):\n            return 720  # 默认值\n\n    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取视频信息\n\n        Args:\n            video_path: 视频文件路径\n\n        Returns:\n            Dict: 视频信息\n        \"\"\"\n        try:\n            # 这里可以使用ffprobe或其他工具获取视频信息\n            # 暂时返回基本信息\n            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n        except Exception as e:\n            logger.error(f\"获取视频信息失败: {e}\")\n            return {}\n\n    def _save_task_metadata(self, result: Dict[str, Any]):\n        \"\"\"\n        保存任务元数据\n\n        Args:\n            result: 任务结果\n        \"\"\"\n        try:\n            # 构建视频元数据\n            metadata = {\n                \"generation_id\": result[\"task_id\"],\n                \"file_id\": result[\"task_id\"],\n                \"filename\": result.get(\"filename\", \"\"),\n                \"file_path\": result.get(\"local_path\", \"\"),\n                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n                \"parameters\": result.get(\"parameters\", {}),\n                \"created_at\": result[\"created_at\"],\n                \"file_size\": result.get(\"local_file_size\", 0),\n                \"source_url\": result.get(\"video_url\", \"\"),\n                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n            }\n\n            # 调用视频元数据保存方法\n            self.metadata_manager.save_video_metadata(metadata)\n            \n            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n\n        except Exception as e:\n            logger.error(f\"保存任务元数据失败: {e}\")\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取视频生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('videos', limit=limit)\n\n    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据输入图像路径搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        return self.metadata_manager.search_records(\"input_image\", keyword)\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            df = self.metadata_manager.get_dataframe()\n\n            if df.empty:\n                return {\n                    \"total_videos\": 0,\n                    \"success_count\": 0,\n                    \"failed_count\": 0,\n                    \"pending_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"total_duration\": 0,\n                    \"average_duration\": 0,\n                }\n\n            stats = {\n                \"total_videos\": len(df),\n                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n                \"total_file_size\": df[\"local_file_size\"].sum(),\n                \"average_file_size\": df[\"local_file_size\"].mean(),\n                \"total_duration\": df[\"duration\"].sum(),\n                \"average_duration\": df[\"duration\"].mean(),\n                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n            }\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {}\n\n    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n        \"\"\"\n        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n\n        注意：\n        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n        \"\"\"\n        params = result.get(\"parameters\", {}) or {}\n\n        # 新三层参数结构优先：actual > sent > requested\n        if isinstance(params, dict):\n            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n                layer_obj = params.get(layer)\n                if isinstance(layer_obj, dict):\n                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n                    if cand:\n                        return str(cand)\n                    if layer == \"params_requested\":\n                        mv = layer_obj.get(\"model_variant\")\n                        if mv:\n                            return str(mv)\n\n        # 顶层 model（VideoService 会尽量补齐）\n        top = result.get(\"model\")\n        if top:\n            return str(top)\n\n        # 旧结构兼容：从 parameters 推断\n        if isinstance(params, dict):\n            mv = params.get(\"model_variant\") or \"\"\n            mt = params.get(\"model_type\") or \"\"\n            use_pro_model = params.get(\"use_pro_model\", True)\n\n            if mv:\n                return str(mv)\n            if isinstance(mt, str) and mt.strip():\n                return mt.strip()\n            if bool(use_pro_model):\n                return \"pro\"\n            return \"lite\"\n\n        return \"seedance\"\n","numLines":1273,"startLine":1,"totalLines":1273}},"sourceToolAssistantUUID":"3fc7e3e1-4489-40b8-94d6-76a89bd02824"}
{"parentUuid":"82aa447b-0155-4268-8d9b-86ec41c8ff99","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fv3jVGZVqVPCZKQ5Ggn2Q1","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config.unified_config import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        storage_dir = get_storage_dir()\n    59→        if not storage_dir:\n    60→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    61→        self.storage_manager = get_v2_storage_manager(storage_dir)\n    62→        \n    63→        # 保持兼容性别名\n    64→        self.file_manager = self.storage_manager\n    65→        self.metadata_manager = self.storage_manager\n    66→        self.image_storage_manager = self.storage_manager\n    67→        \n    68→        # 保留原有的目录属性以保持兼容性\n    69→        self.data_dir = Path(self.storage_manager.root_path)\n    70→        self.images_dir = self.data_dir / \"images\"\n    71→        self.metadata_dir = self.data_dir / \"metadata\"\n    72→\n    73→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    74→\n    75→    def generate_text_to_image(\n    76→        self,\n    77→        prompt: str,\n    78→        size: str = \"1024x1024\",\n    79→        guidance_scale: float = 2.5,\n    80→        seed: int = -1,\n    81→        save_local: bool = True,\n    82→        reference_images: Optional[List[Any]] = None,\n    83→        model_variant: Optional[str] = None,\n    84→        generation_id: Optional[str] = None,\n    85→        count: int = 1,\n    86→        sequential_mode: bool = False,\n    87→        derived_ids: Optional[List[str]] = None,\n    88→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    89→    ) -> Dict[str, Any]:\n    90→        \"\"\"\n    91→        生成文生图并保存到本地\n    92→\n    93→        Args:\n    94→            prompt: 图像生成提示词\n    95→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    96→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    97→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    98→            response_format: 返回格式，\"url\"或\"b64_json\"\n    99→            save_local: 是否保存到本地\n   100→            reference_images: 参考图列表\n   101→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   102→            count: 生成图片数量（组图模式下生效）\n   103→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   104→            derived_ids: 组图生成的ID列表（用于关联）\n   105→\n   106→        Returns:\n   107→            Dict: 生成结果，包含本地文件路径\n   108→\n   109→        Note:\n   110→            model和watermark参数已固定，不再需要前端控制\n   111→        \"\"\"\n   112→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   113→\n   114→        # 根据 model_variant 选择 provider（并发安全：不写 env）\n   115→        seedream_provider: Optional[str] = None\n   116→        try:\n   117→            mv = (model_variant or \"\").strip().lower()\n   118→            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n   119→                seedream_provider = \"volc_v4\"\n   120→            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n   121→                seedream_provider = \"volc_v4_5\"\n   122→            elif mv.startswith(\"volc_\"):\n   123→                seedream_provider = mv\n   124→        except Exception:\n   125→            seedream_provider = None\n   126→\n   127→        # 生成唯一ID，优先使用外部传入的generation_id\n   128→        task_id = generation_id or str(uuid.uuid4())\n   129→\n   130→        ref_assets: List[Dict[str, Any]] = []\n   131→        ref_paths: List[str] = []\n   132→        ref_summary: Dict[str, Any] = {}\n   133→        ref_payloads: List[str] = []\n   134→\n   135→        try:\n   136→            if reference_images:\n   137→                ref_summary = self._process_reference_assets(\n   138→                    reference_images,\n   139→                    max_refs=MAX_REFERENCE_IMAGES,\n   140→                    expected_outputs=1,\n   141→                )\n   142→                ref_assets = list(ref_summary.get('assets', []))\n   143→                ref_paths = list(ref_summary.get('paths', []))\n   144→                ref_payloads = self._build_reference_payloads(ref_assets)\n   145→\n   146→                if ref_summary.get('errors'):\n   147→                    logger.warning(\n   148→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   149→                    )\n   150→                if ref_summary.get('warnings'):\n   151→                    for warn in ref_summary['warnings']:\n   152→                        logger.warning(f\"参考图提示: {warn}\")\n   153→\n   154→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   155→            try:\n   156→                norm, fb, reason = validate_and_normalize_t2i(\n   157→                    TextToImageParams(\n   158→                        prompt=prompt,\n   159→                        size=size,\n   160→                        guidance_scale=guidance_scale,\n   161→                        seed=(None if seed == -1 else seed),\n   162→                    )\n   163→                )\n   164→                logger.info(\n   165→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   166→                )\n   167→                if fb:\n   168→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   169→            except Exception as _e:\n   170→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   171→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   172→            actual_count = max(1, count)\n   173→            use_group_mode = bool(sequential_mode and actual_count > 1)\n   174→\n   175→            api_result = self.client.text_to_image(\n   176→                prompt=prompt,\n   177→                size=size,\n   178→                guidance_scale=guidance_scale,\n   179→                seed=seed,\n   180→                reference_images=ref_payloads or None,\n   181→                n=actual_count if use_group_mode else 1,\n   182→                sequential_mode=sequential_mode,\n   183→                seedream_provider=seedream_provider,\n   184→            )\n   185→\n   186→            # 组图模式：API 返回多张图，需要逐一保存\n   187→            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n   188→            images_count = len(images_list)\n   189→            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n   190→\n   191→            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n   192→            if use_group_mode and images_count < actual_count:\n   193→                logger.warning(\n   194→                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n   195→                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n   196→                )\n   197→\n   198→            if use_group_mode and images_count > 1:\n   199→                results_batch = []\n   200→                success_count = 0\n   201→                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n   202→                total_images = len(images_list)\n   203→\n   204→                for idx, img_data in enumerate(images_list):\n   205→                    # 发送下载进度（每张图开始下载时）\n   206→                    if progress_callback:\n   207→                        try:\n   208→                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n   209→                        except Exception:\n   210→                            pass\n   211→\n   212→                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n   213→                    per_result = {\n   214→                        \"task_id\": per_id,\n   215→                        \"success\": True,\n   216→                        \"type\": \"text_to_image\",\n   217→                        \"prompt\": prompt,\n   218→                        \"image_url\": img_data[\"url\"],\n   219→                        \"parameters\": {\n   220→                            \"size\": size,\n   221→                            \"guidance_scale\": guidance_scale,\n   222→                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   223→                            **(({\"seed\": seed} if seedream_provider is None else {})),\n   224→                            \"response_format\": \"url\",\n   225→                            \"watermark\": False,\n   226→                            \"model\": self._resolve_model_id(\n   227→                                \"doubao-seedream-3-0-t2i-250415\",\n   228→                                \"doubao-seedream-4-0-250828\",\n   229→                                \"doubao-seedream-4-5-251128\",\n   230→                            ),\n   231→                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   232→                            \"sequential_mode\": True,\n   233→                            \"group_index\": idx + 1,\n   234→                            \"group_total\": total_images,\n   235→                        },\n   236→                        \"created_at\": datetime.now().isoformat(),\n   237→                        \"usage\": api_result.get(\"usage\", {}),\n   238→                    }\n   239→\n   240→                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   241→                    if sanitized_refs:\n   242→                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   243→                        per_result[\"reference_assets\"] = sanitized_refs\n   244→\n   245→                    if save_local and per_result.get(\"image_url\"):\n   246→                        local_result = self._save_image_locally(per_result)\n   247→                        per_result.update(local_result)\n   248→                        if not local_result.get('local_save_error'):\n   249→                            success_count += 1\n   250→\n   251→                    results_batch.append(per_result)\n   252→\n   253→                    # 发送下载完成进度\n   254→                    if progress_callback:\n   255→                        try:\n   256→                            progress_callback(idx + 1, total_images, per_result)\n   257→                        except Exception:\n   258→                            pass\n   259→\n   260→                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n   261→                return {\n   262→                    \"batch\": True,\n   263→                    \"results\": results_batch,\n   264→                    \"success_count\": success_count,\n   265→                    \"total_count\": len(results_batch),\n   266→                    \"derived_ids\": group_ids,\n   267→                }\n   268→\n   269→            # 单图模式（默认）\n   270→            result = {\n   271→                \"task_id\": task_id,\n   272→                \"success\": True,\n   273→                \"type\": \"text_to_image\",\n   274→                \"prompt\": prompt,\n   275→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   276→                \"parameters\": {\n   277→                    \"size\": size,\n   278→                    \"guidance_scale\": guidance_scale,\n   279→                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   280→                    **(({\"seed\": seed} if seedream_provider is None else {})),\n   281→                    \"response_format\": \"url\",  # 固定值\n   282→                    \"watermark\": False,  # 固定值\n   283→                    \"model\": self._resolve_model_id(\n   284→                        \"doubao-seedream-3-0-t2i-250415\",\n   285→                        \"doubao-seedream-4-0-250828\",\n   286→                        \"doubao-seedream-4-5-251128\",\n   287→                    ),\n   288→                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   289→                },\n   290→                \"created_at\": datetime.now().isoformat(),\n   291→                \"usage\": api_result.get(\"usage\", {}),\n   292→            }\n   293→\n   294→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   295→            if sanitized_refs:\n   296→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   297→                result[\"reference_assets\"] = sanitized_refs\n   298→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   299→                logger.info(\n   300→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   301→                    len(sanitized_refs),\n   302→                    masked_ids or \"-\",\n   303→                    self._provider_used(),\n   304→                )\n   305→            else:\n   306→                result[\"parameters\"][\"reference_assets\"] = []\n   307→                result[\"reference_assets\"] = []\n   308→\n   309→            # 保存到本地\n   310→            if save_local and result.get(\"image_url\"):\n   311→                local_result = self._save_image_locally(result)\n   312→                result.update(local_result)\n   313→                if local_result.get('local_save_error') and sanitized_refs:\n   314→                    self._cleanup_reference_paths(ref_paths)\n   315→                    result[\"parameters\"][\"reference_assets\"] = []\n   316→                    result[\"reference_assets\"] = []\n   317→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   318→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   319→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   320→\n   321→            logger.success(f\"文生图任务完成: {task_id}\")\n   322→            return result\n   323→\n   324→        except Exception as e:\n   325→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   326→            self._cleanup_reference_paths(ref_paths)\n   327→            return {\n   328→                \"task_id\": task_id,\n   329→                \"success\": False,\n   330→                \"error\": str(e),\n   331→                \"type\": \"text_to_image\"\n   332→            }\n   333→\n   334→    def generate_image_to_image(\n   335→        self,\n   336→        prompt: str,\n   337→        image: str,\n   338→        guidance_scale: float = 5.5,\n   339→        seed: int = -1,\n   340→        save_local: bool = True,\n   341→        reference_images: Optional[List[Any]] = None,\n   342→        generation_id: Optional[str] = None,\n   343→    ) -> Dict[str, Any]:\n   344→        \"\"\"\n   345→        生成图生图并保存到本地\n   346→\n   347→        Args:\n   348→            prompt: 编辑提示词\n   349→            image_path: 原始图像路径（本地路径或URL）\n   350→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   351→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   352→            response_format: 返回格式，\"url\"或\"b64_json\"\n   353→            save_local: 是否保存到本地\n   354→\n   355→        Returns:\n   356→            Dict: 生成结果\n   357→        \n   358→        Note:\n   359→            model、size、watermark参数已固定，不再需要前端控制\n   360→        \"\"\"\n   361→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   362→\n   363→        # 生成唯一ID，优先使用外部传入的generation_id\n   364→        task_id = generation_id or str(uuid.uuid4())\n   365→\n   366→        ref_paths: List[str] = []\n   367→\n   368→        try:\n   369→            # 处理输入图像\n   370→            image_data = self._prepare_input_image(image)\n   371→            if not image_data:\n   372→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   373→\n   374→            # 处理参考图（复制到 references 并准备 API 载荷）\n   375→            ref_summary = self._process_reference_assets(\n   376→                reference_images,\n   377→                max_refs=MAX_REFERENCE_IMAGES,\n   378→                expected_outputs=1,\n   379→            )\n   380→            ref_assets = ref_summary.get('assets', [])\n   381→            ref_paths = list(ref_summary.get('paths', []))\n   382→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   383→            if ref_summary.get('errors'):\n   384→                logger.warning(\n   385→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   386→                )\n   387→            if ref_summary.get('warnings'):\n   388→                for warn in ref_summary['warnings']:\n   389→                    logger.warning(f\"参考图提示: {warn}\")\n   390→\n   391→            # 前置参数校验（不改变流程，仅记录摘要）\n   392→            fb = False\n   393→            reason = \"\"\n   394→            try:\n   395→                norm, fb, reason = validate_and_normalize_i2i(\n   396→                    ImageToImageParams(\n   397→                        prompt=prompt,\n   398→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   399→                        guidance_scale=guidance_scale,\n   400→                        seed=(None if seed == -1 else seed),\n   401→                        reference_images=ref_payloads,\n   402→                    )\n   403→                )\n   404→                logger.info(\n   405→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   406→                )\n   407→                if fb:\n   408→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   409→            except Exception as _e:\n   410→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   411→\n   412→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   413→            api_result = self.client.image_to_image(\n   414→                prompt=prompt,\n   415→                image=image_data,\n   416→                guidance_scale=guidance_scale,\n   417→                seed=seed,\n   418→                reference_images=(ref_payloads or None),\n   419→            )\n   420→\n   421→            # 处理input_image字段，避免在日志中输出大量base64数据\n   422→            input_image_info = \"[图像数据]\"\n   423→            if image:\n   424→                if image.startswith(\"data:image/\"):\n   425→                    # 如果是base64数据，只保留格式信息\n   426→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   427→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   428→                elif image.startswith((\"http://\", \"https://\")):\n   429→                    # 如果是URL，保留URL\n   430→                    input_image_info = image\n   431→                else:\n   432→                    # 如果是文件路径，只保留文件名\n   433→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   434→            \n   435→            result = {\n   436→                \"task_id\": task_id,\n   437→                \"success\": True,\n   438→                \"type\": \"image_to_image\",\n   439→                \"prompt\": prompt,\n   440→                \"input_image\": input_image_info,\n   441→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   442→                \"parameters\": {\n   443→                    \"guidance_scale\": guidance_scale,\n   444→                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   445→                    **({\"seed\": seed} if (self.client.last_provider() or \"\").lower() not in {\"volc_v4\", \"volc_v4_5\", \"volcengine_v4\", \"volcengine_v4_5\"} else {}),\n   446→                    \"response_format\": \"url\",  # 固定值\n   447→                    \"watermark\": False,  # 固定值\n   448→                    \"size\": \"adaptive\",  # 固定值\n   449→                    \"model\": self._resolve_model_id(\n   450→                        \"doubao-seededit-3-0-i2i-250628\",\n   451→                        \"doubao-seedream-4-0-250828\",\n   452→                        \"doubao-seedream-4-5-251128\",\n   453→                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n   454→                },\n   455→                \"created_at\": datetime.now().isoformat(),\n   456→                \"usage\": api_result.get(\"usage\", {}),\n   457→            }\n   458→\n   459→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   460→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   461→            result[\"reference_assets\"] = sanitized_refs\n   462→            if ref_summary.get('errors'):\n   463→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   464→            if ref_summary.get('warnings'):\n   465→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   466→            if fb and reason:\n   467→                result[\"fallback_applied\"] = True\n   468→                result[\"fallback_reason\"] = reason\n   469→\n   470→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   471→            logger.info(\n   472→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   473→                len(sanitized_refs),\n   474→                masked_ids or \"-\",\n   475→                self._provider_used(),\n   476→            )\n   477→\n   478→            # 保存到本地\n   479→            if save_local and result.get(\"image_url\"):\n   480→                local_result = self._save_image_locally(result)\n   481→                result.update(local_result)\n   482→                if local_result.get('local_save_error'):\n   483→                    self._cleanup_reference_paths(ref_paths)\n   484→                    result[\"parameters\"][\"reference_assets\"] = []\n   485→                    result[\"reference_assets\"] = []\n   486→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   487→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   488→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   489→\n   490→            logger.success(f\"图生图任务完成: {task_id}\")\n   491→            return result\n   492→\n   493→        except Exception as e:\n   494→            # 避免在日志中显示可能包含base64数据的异常信息\n   495→            error_msg = str(e)\n   496→            if len(error_msg) > 200:\n   497→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   498→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   499→            self._cleanup_reference_paths(ref_paths)\n   500→            return {\n   501→                \"task_id\": task_id,\n   502→                \"success\": False,\n   503→                \"error\": error_msg,\n   504→                \"type\": \"image_to_image\"\n   505→            }\n   506→\n   507→    def batch_generate_text_to_image(\n   508→        self,\n   509→        prompts: List[str],\n   510→        size: str = \"1024x1024\",\n   511→        guidance_scale: float = 2.5,\n   512→        save_local: bool = True,\n   513→    ) -> List[Dict[str, Any]]:\n   514→        \"\"\"\n   515→        批量生成文生图（顺序执行，保持向后兼容）\n   516→\n   517→        Args:\n   518→            prompts: 提示词列表\n   519→            size: 图像尺寸\n   520→            guidance_scale: 提示词一致性\n   521→            save_local: 是否保存到本地\n   522→\n   523→        Returns:\n   524→            List[Dict]: 生成结果列表\n   525→        \n   526→        Note:\n   527→            水印参数已固定为False，不再需要前端控制\n   528→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   529→        \"\"\"\n   530→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   531→\n   532→        results = []\n   533→        for i, prompt in enumerate(prompts, 1):\n   534→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   535→\n   536→            result = self.generate_text_to_image(\n   537→                prompt=prompt,\n   538→                size=size,\n   539→                guidance_scale=guidance_scale,\n   540→                save_local=save_local,\n   541→                generation_id=None,\n   542→            )\n   543→\n   544→            results.append(result)\n   545→\n   546→        success_count = sum(1 for r in results if r[\"success\"])\n   547→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   548→\n   549→        return results\n   550→\n   551→    def concurrent_generate_text_to_image(\n   552→        self,\n   553→        prompt: str,\n   554→        count: int = 4,\n   555→        size: str = \"1024x1024\",\n   556→        guidance_scale: float = 2.5,\n   557→        seed: int = -1,\n   558→        save_local: bool = True,\n   559→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   560→        max_workers: int = 5,\n   561→        derived_ids: Optional[List[str]] = None,\n   562→        generation_id: Optional[str] = None,\n   563→        model_variant: Optional[str] = None,\n   564→        sequential_mode: bool = False,\n   565→    ) -> Dict[str, Any]:\n   566→        \"\"\"\n   567→        并发生成多张文生图\n   568→\n   569→        Args:\n   570→            prompt: 图像生成提示词\n   571→            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n   572→            size: 图像尺寸\n   573→            guidance_scale: 引导强度\n   574→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   575→            save_local: 是否保存到本地\n   576→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   577→            max_workers: 最大并发数\n   578→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   579→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   580→\n   581→        Returns:\n   582→            Dict: 包含所有任务结果的字典\n   583→        \"\"\"\n   584→        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n   585→        max_allowed = 15 if sequential_mode else 10\n   586→        if count < 1 or count > max_allowed:\n   587→            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n   588→\n   589→        # 组图模式：单次 API 调用返回多张图\n   590→        if sequential_mode:\n   591→            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n   592→            return self.generate_text_to_image(\n   593→                prompt=prompt,\n   594→                size=size,\n   595→                guidance_scale=guidance_scale,\n   596→                seed=seed,\n   597→                save_local=save_local,\n   598→                model_variant=model_variant,\n   599→                generation_id=generation_id,\n   600→                count=count,\n   601→                sequential_mode=True,\n   602→                derived_ids=derived_ids,\n   603→                progress_callback=progress_callback,\n   604→            )\n   605→        \n   606→        if max_workers > count:\n   607→            max_workers = count\n   608→        \n   609→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   610→        \n   611→        # 生成批次ID\n   612→        batch_id = str(uuid.uuid4())\n   613→        start_time = time.time()\n   614→\n   615→        slots = max(1, count)\n   616→        per_ids: List[str] = list(derived_ids or [])\n   617→        if len(per_ids) < slots:\n   618→            base = generation_id or batch_id\n   619→            for idx in range(len(per_ids), slots):\n   620→                per_ids.append(f\"{base}_{idx + 1}\")\n   621→        \n   622→        # 准备任务参数\n   623→        tasks = []\n   624→        for i in range(count):\n   625→            # 为每个任务生成不同的种子（如果seed为-1）\n   626→            task_seed = seed if seed != -1 else None\n   627→            gen_id = per_ids[i] if i < len(per_ids) else None\n   628→            tasks.append({\n   629→                'prompt': prompt,\n   630→                'size': size,\n   631→                'guidance_scale': guidance_scale,\n   632→                'seed': task_seed,\n   633→                'save_local': save_local,\n   634→                'task_index': i + 1,\n   635→                'generation_id': gen_id,\n   636→                'model_variant': model_variant,\n   637→            })\n   638→        \n   639→        # 使用线程池并发执行\n   640→        results = []\n   641→        completed_count = 0\n   642→        \n   643→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   644→            # 提交所有任务\n   645→            future_to_task = {\n   646→                executor.submit(self._execute_single_text_to_image_task, task): task \n   647→                for task in tasks\n   648→            }\n   649→            \n   650→            # 收集结果\n   651→            for future in as_completed(future_to_task):\n   652→                task = future_to_task[future]\n   653→                try:\n   654→                    result = future.result()\n   655→                    result['task_index'] = task['task_index']\n   656→                    result['batch_id'] = batch_id\n   657→                    results.append(result)\n   658→                    \n   659→                    completed_count += 1\n   660→                    \n   661→                    # 调用进度回调\n   662→                    if progress_callback:\n   663→                        try:\n   664→                            progress_callback(completed_count, count, result)\n   665→                        except Exception as e:\n   666→                            logger.warning(f\"进度回调执行失败: {e}\")\n   667→                    \n   668→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   669→                    \n   670→                except Exception as e:\n   671→                    error_result = {\n   672→                        'task_index': task['task_index'],\n   673→                        'batch_id': batch_id,\n   674→                        'success': False,\n   675→                        'error': str(e),\n   676→                        'type': 'text_to_image'\n   677→                    }\n   678→                    results.append(error_result)\n   679→                    completed_count += 1\n   680→                    \n   681→                    if progress_callback:\n   682→                        try:\n   683→                            progress_callback(completed_count, count, error_result)\n   684→                        except Exception as e:\n   685→                            logger.warning(f\"进度回调执行失败: {e}\")\n   686→                    \n   687→                    # 避免在日志中显示可能包含base64数据的异常信息\n   688→                    error_msg = str(e)\n   689→                    if len(error_msg) > 200:\n   690→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   691→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   692→        \n   693→        # 按task_index排序\n   694→        results.sort(key=lambda x: x.get('task_index', 0))\n   695→        \n   696→        # 统计结果\n   697→        success_count = sum(1 for r in results if r.get('success', False))\n   698→        total_time = time.time() - start_time\n   699→        \n   700→        batch_result = {\n   701→            'batch_id': batch_id,\n   702→            'success': True,\n   703→            'prompt': prompt,\n   704→            'total_count': count,\n   705→            'success_count': success_count,\n   706→            'failed_count': count - success_count,\n   707→            'total_time': round(total_time, 2),\n   708→            'average_time': round(total_time / count, 2),\n   709→            'results': results,\n   710→            'parameters': {\n   711→                'size': size,\n   712→                'guidance_scale': guidance_scale,\n   713→                'seed': seed,\n   714→                'max_workers': max_workers\n   715→            },\n   716→            'derived_ids': per_ids,\n   717→            'created_at': datetime.now().isoformat()\n   718→        }\n   719→        \n   720→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   721→        return batch_result\n   722→\n   723→    def concurrent_generate_image_to_image(\n   724→        self,\n   725→        prompt: str,\n   726→        image: str,\n   727→        count: int = 4,\n   728→        guidance_scale: float = 5.5,\n   729→        seed: int = -1,\n   730→        save_local: bool = True,\n   731→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   732→        max_workers: int = 5,\n   733→        derived_ids: Optional[List[str]] = None,\n   734→        generation_id: Optional[str] = None,\n   735→    ) -> Dict[str, Any]:\n   736→        \"\"\"\n   737→        并发生成多张图生图\n   738→\n   739→        Args:\n   740→            prompt: 编辑提示词\n   741→            image: 输入图像路径或URL\n   742→            count: 生成图片数量，默认4张，最多10张\n   743→            guidance_scale: 引导强度\n   744→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   745→            save_local: 是否保存到本地\n   746→            progress_callback: 进度回调函数\n   747→            max_workers: 最大并发数\n   748→\n   749→        Returns:\n   750→            Dict: 包含所有任务结果的字典\n   751→        \"\"\"\n   752→        # 验证参数\n   753→        if count < 1 or count > 10:\n   754→            raise ValueError(\"生成数量必须在1-10之间\")\n   755→        \n   756→        if max_workers > count:\n   757→            max_workers = count\n   758→        \n   759→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   760→        \n   761→        # 生成批次ID\n   762→        batch_id = str(uuid.uuid4())\n   763→        start_time = time.time()\n   764→        \n   765→        slots = max(1, count)\n   766→        per_ids: List[str] = list(derived_ids or [])\n   767→        if len(per_ids) < slots:\n   768→            base = generation_id or batch_id\n   769→            for idx in range(len(per_ids), slots):\n   770→                per_ids.append(f\"{base}_{idx + 1}\")\n   771→        \n   772→        # 准备输入图像\n   773→        image_data = self._prepare_input_image(image)\n   774→        if not image_data:\n   775→            return {\n   776→                'batch_id': batch_id,\n   777→                'success': False,\n   778→                'error': '无法处理输入图像',\n   779→                'type': 'image_to_image'\n   780→            }\n   781→        \n   782→        # 准备任务参数\n   783→        tasks = []\n   784→        for i in range(count):\n   785→            task_seed = seed if seed != -1 else None\n   786→            gen_id = per_ids[i] if i < len(per_ids) else None\n   787→            tasks.append({\n   788→                'prompt': prompt,\n   789→                'image': image_data,\n   790→                'guidance_scale': guidance_scale,\n   791→                'seed': task_seed,\n   792→                'save_local': save_local,\n   793→                'task_index': i + 1,\n   794→                'generation_id': gen_id\n   795→            })\n   796→        \n   797→        # 使用线程池并发执行\n   798→        results = []\n   799→        completed_count = 0\n   800→        \n   801→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   802→            # 提交所有任务\n   803→            future_to_task = {\n   804→                executor.submit(self._execute_single_image_to_image_task, task): task \n   805→                for task in tasks\n   806→            }\n   807→            \n   808→            # 收集结果\n   809→            for future in as_completed(future_to_task):\n   810→                task = future_to_task[future]\n   811→                try:\n   812→                    result = future.result()\n   813→                    result['task_index'] = task['task_index']\n   814→                    result['batch_id'] = batch_id\n   815→                    results.append(result)\n   816→                    \n   817→                    completed_count += 1\n   818→                    \n   819→                    # 调用进度回调\n   820→                    if progress_callback:\n   821→                        try:\n   822→                            progress_callback(completed_count, count, result)\n   823→                        except Exception as e:\n   824→                            logger.warning(f\"进度回调执行失败: {e}\")\n   825→                    \n   826→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   827→                    \n   828→                except Exception as e:\n   829→                    error_result = {\n   830→                        'task_index': task['task_index'],\n   831→                        'batch_id': batch_id,\n   832→                        'success': False,\n   833→                        'error': str(e),\n   834→                        'type': 'image_to_image'\n   835→                    }\n   836→                    results.append(error_result)\n   837→                    completed_count += 1\n   838→                    \n   839→                    if progress_callback:\n   840→                        try:\n   841→                            progress_callback(completed_count, count, error_result)\n   842→                        except Exception as e:\n   843→                            logger.warning(f\"进度回调执行失败: {e}\")\n   844→                    \n   845→                    # 避免在日志中显示可能包含base64数据的异常信息\n   846→                    error_msg = str(e)\n   847→                    if len(error_msg) > 200:\n   848→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   849→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   850→        \n   851→        # 按task_index排序\n   852→        results.sort(key=lambda x: x.get('task_index', 0))\n   853→        \n   854→        # 统计结果\n   855→        success_count = sum(1 for r in results if r.get('success', False))\n   856→        total_time = time.time() - start_time\n   857→        \n   858→        # 处理input_image字段，避免在日志中输出大量base64数据\n   859→        input_image_info = \"[图像数据]\"\n   860→        if image:\n   861→            if image.startswith(\"data:image/\"):\n   862→                # 如果是base64数据，只保留格式信息\n   863→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   864→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   865→            elif image.startswith((\"http://\", \"https://\")):\n   866→                # 如果是URL，保留URL\n   867→                input_image_info = image\n   868→            else:\n   869→                # 如果是文件路径，只保留文件名\n   870→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   871→        \n   872→        batch_result = {\n   873→            'batch_id': batch_id,\n   874→            'success': True,\n   875→            'prompt': prompt,\n   876→            'input_image': input_image_info,\n   877→            'total_count': count,\n   878→            'success_count': success_count,\n   879→            'failed_count': count - success_count,\n   880→            'total_time': round(total_time, 2),\n   881→            'average_time': round(total_time / count, 2),\n   882→            'results': results,\n   883→            'parameters': {\n   884→                'guidance_scale': guidance_scale,\n   885→                'seed': seed,\n   886→                'max_workers': max_workers\n   887→            },\n   888→            'derived_ids': per_ids,\n   889→            'created_at': datetime.now().isoformat()\n   890→        }\n   891→        \n   892→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   893→        return batch_result\n   894→\n   895→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   896→        \"\"\"\n   897→        执行单个文生图任务\n   898→        \n   899→        Args:\n   900→            task: 任务参数字典\n   901→            \n   902→        Returns:\n   903→            Dict: 任务执行结果\n   904→        \"\"\"\n   905→        return self.generate_text_to_image(\n   906→            prompt=task['prompt'],\n   907→            size=task['size'],\n   908→            guidance_scale=task['guidance_scale'],\n   909→            seed=task['seed'],\n   910→            save_local=task['save_local'],\n   911→            generation_id=task.get('generation_id'),\n   912→            model_variant=task.get('model_variant'),\n   913→        )\n   914→    \n   915→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   916→        \"\"\"\n   917→        执行单个图生图任务\n   918→        \n   919→        Args:\n   920→            task: 任务参数字典\n   921→            \n   922→        Returns:\n   923→            Dict: 任务执行结果\n   924→        \"\"\"\n   925→        # 生成唯一ID，优先使用外部传入的generation_id\n   926→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   927→        \n   928→        try:\n   929→            # 直接使用已经处理好的图片数据，避免重复处理\n   930→            image_data = task['image']\n   931→            \n   932→            # 调用API生成图像\n   933→            api_result = self.client.image_to_image(\n   934→                prompt=task['prompt'], \n   935→                image=image_data, \n   936→                guidance_scale=task['guidance_scale'], \n   937→                seed=task['seed']\n   938→            )\n   939→            \n   940→            result = {\n   941→                \"task_id\": task_id,\n   942→                \"success\": True,\n   943→                \"type\": \"image_to_image\",\n   944→                \"prompt\": task['prompt'],\n   945→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   946→                \"parameters\": {\n   947→                    \"guidance_scale\": task['guidance_scale'], \n   948→                    \"seed\": task['seed'], \n   949→                    \"response_format\": \"url\",\n   950→                    \"watermark\": False,\n   951→                    \"size\": \"adaptive\",\n   952→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   953→                },\n   954→                \"created_at\": datetime.now().isoformat(),\n   955→                \"usage\": api_result.get(\"usage\", {}),\n   956→            }\n   957→            \n   958→            # 保存到本地\n   959→            if task['save_local'] and result.get(\"image_url\"):\n   960→                local_result = self._save_image_locally(result)\n   961→                result.update(local_result)\n   962→            \n   963→            return result\n   964→            \n   965→        except Exception as e:\n   966→            # 避免在日志中显示可能包含base64数据的异常信息\n   967→            error_msg = str(e)\n   968→            if len(error_msg) > 200:\n   969→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   970→            return {\n   971→                \"task_id\": task_id,\n   972→                \"success\": False,\n   973→                \"error\": error_msg,\n   974→                \"type\": \"image_to_image\"\n   975→            }\n   976→\n   977→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   978→        \"\"\"\n   979→        保存图像到本地并记录元数据\n   980→\n   981→        Args:\n   982→            result: API生成结果\n   983→\n   984→        Returns:\n   985→            Dict: 包含本地文件信息的字典\n   986→        \"\"\"\n   987→        try:\n   988→            # 下载图像\n   989→            image_url = result[\"image_url\"]\n   990→            response = safe_requests_get(image_url, timeout=30)\n   991→\n   992→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   993→            from io import BytesIO\n   994→            real_w, real_h = None, None\n   995→            try:\n   996→                with Image.open(BytesIO(response.content)) as img:\n   997→                    real_w, real_h = int(img.width), int(img.height)\n   998→            except Exception as _e:\n   999→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n  1000→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n  1001→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n  1002→\n  1003→            # 组装元数据（适配UnifiedStorageManager的格式）\n  1004→            params = result.get(\"parameters\", {}) or {}\n  1005→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n  1006→            try:\n  1007→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n  1008→                    from math import gcd\n  1009→                    g = gcd(real_w, real_h)\n  1010→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n  1011→            except Exception:\n  1012→                pass\n  1013→\n  1014→            metadata = {\n  1015→                'generation_id': result.get(\"task_id\", \"\"),\n  1016→                'prompt': result.get(\"prompt\", \"\"),\n  1017→                'parameters': params,\n  1018→                'model': params.get(\"model\", \"seedream\"),\n  1019→                'width': real_w,\n  1020→                'height': real_h,\n  1021→                'generation_time': result.get(\"generation_time\", 0),\n  1022→                'batch_id': result.get(\"batch_id\", \"\"),\n  1023→                'status': 'completed'\n  1024→            }\n  1025→            \n  1026→            # 使用统一存储管理器保存文件\n  1027→            save_result = self.storage_manager.save_content_file(\n  1028→                content_type='images',\n  1029→                file_data=response.content,\n  1030→                url=image_url,\n  1031→                metadata=metadata\n  1032→            )\n  1033→\n  1034→            # 获取图像信息（再次确认像素尺寸）\n  1035→            image_info = self._get_image_info(Path(save_result['local_path']))\n  1036→            file_size = Path(save_result['local_path']).stat().st_size\n  1037→\n  1038→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n  1039→\n  1040→            result_obj = {\n  1041→                \"local_path\": save_result['local_path'],\n  1042→                \"filename\": Path(save_result['local_path']).name,\n  1043→                \"file_size\": file_size,\n  1044→                \"image_info\": image_info,\n  1045→                \"file_path\": save_result['local_path'],  # 保持兼容性\n  1046→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n  1047→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n  1048→                \"file_id\": save_result.get('file_id'),\n  1049→                \"relative_path\": save_result.get('relative_path'),\n  1050→            }\n  1051→            try:\n  1052→                w = image_info.get('width') if isinstance(image_info, dict) else None\n  1053→                h = image_info.get('height') if isinstance(image_info, dict) else None\n  1054→                logger.info(\n  1055→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n  1056→                )\n  1057→            except Exception:\n  1058→                pass\n  1059→\n  1060→            # 体验版本地图片水印（使用统一水印服务）\n  1061→            if should_add_watermark():\n  1062→                try:\n  1063→                    from edition.watermark_service import WatermarkService\n  1064→\n  1065→                    watermark_text = get_watermark_text() or \"PIGEON\"\n  1066→                    try:\n  1067→                        opacity = get_watermark_opacity()\n  1068→                    except Exception:\n  1069→                        opacity = 0.3\n  1070→                    opacity = max(0.0, min(opacity, 1.0))\n  1071→\n  1072→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n  1073→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n  1074→                    if watermark_applied:\n  1075→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n  1076→                        result_obj[\"watermark_applied\"] = True\n  1077→                    else:\n  1078→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n  1079→                        result_obj[\"watermark_applied\"] = False\n  1080→                except Exception as e:\n  1081→                    logger.warning(f\"添加图片水印时出错: {e}\")\n  1082→                    result_obj[\"watermark_applied\"] = False\n  1083→\n  1084→            return result_obj\n  1085→\n  1086→        except Exception as e:\n  1087→            logger.error(f\"保存图像到本地失败: {e}\")\n  1088→            try:\n  1089→                logger.info(\"摘要|operation=save_image status=failed\")\n  1090→            except Exception:\n  1091→                pass\n  1092→            return {\"local_save_error\": str(e)}\n  1093→\n  1094→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1095→        checksum = hashlib.sha1(file_data).hexdigest()\n  1096→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1097→        return f\"ref_{ts}_{checksum[:8]}\"\n  1098→\n  1099→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1100→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1101→        source_meta: Dict[str, Any] = {}\n  1102→        raw = ref\n  1103→        if isinstance(ref, dict):\n  1104→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1105→                if ref.get(key) is not None:\n  1106→                    source_meta[key] = ref.get(key)\n  1107→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1108→        if raw is None:\n  1109→            return None\n  1110→\n  1111→        extension = source_meta.get('extension')\n  1112→        data = None\n  1113→        source_repr = source_meta.get('source')\n  1114→\n  1115→        try:\n  1116→            if isinstance(raw, bytes):\n  1117→                data = raw\n  1118→            elif isinstance(raw, str):\n  1119→                stripped = raw.strip()\n  1120→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1121→                    header, payload = stripped.split(';base64,', 1)\n  1122→                    mime_part = header[5:]\n  1123→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n  1124→                    data = base64.b64decode(payload)\n  1125→                    source_repr = source_repr or mime_part\n  1126→                    source_meta.setdefault('type', 'image')\n  1127→                elif stripped.startswith(('http://', 'https://')):\n  1128→                    resp = safe_requests_get(stripped, timeout=15)\n  1129→                    data = resp.content\n  1130→                    parsed = urlparse(stripped)\n  1131→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1132→                    source_repr = source_repr or stripped\n  1133→                    source_meta.setdefault('source_url', stripped)\n  1134→                else:\n  1135→                    path = Path(stripped)\n  1136→                    if not path.exists():\n  1137→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1138→                        return None\n  1139→                    data = path.read_bytes()\n  1140→                    extension = extension or path.suffix or '.png'\n  1141→                    source_repr = source_repr or path.name\n  1142→                    source_meta.setdefault('source_path', str(path))\n  1143→            else:\n  1144→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1145→                return None\n  1146→        except Exception as exc:\n  1147→            logger.warning(f\"加载参考图失败: {exc}\")\n  1148→            return None\n  1149→\n  1150→        if data is None:\n  1151→            return None\n  1152→\n  1153→        width = source_meta.get('width')\n  1154→        height = source_meta.get('height')\n  1155→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1156→            try:\n  1157→                from io import BytesIO\n  1158→\n  1159→                with Image.open(BytesIO(data)) as img:\n  1160→                    width = img.width\n  1161→                    height = img.height\n  1162→            except Exception:\n  1163→                pass\n  1164→\n  1165→        source_meta['width'] = width\n  1166→        source_meta['height'] = height\n  1167→        source_meta.setdefault('type', 'image')\n  1168→        source_meta['source'] = source_repr or source_meta.get('source')\n  1169→\n  1170→        return data, extension, source_meta\n  1171→\n  1172→    def _process_reference_assets(\n  1173→        self,\n  1174→        references: Optional[List[Any]],\n  1175→        *,\n  1176→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1177→        expected_outputs: int = 1,\n  1178→    ) -> Dict[str, Any]:\n  1179→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1180→        stored: List[Dict[str, Any]] = []\n  1181→        absolute_paths: List[str] = []\n  1182→        errors: List[str] = []\n  1183→        warnings: List[str] = []\n  1184→\n  1185→        if not references:\n  1186→            return {\n  1187→                'assets': stored,\n  1188→                'paths': absolute_paths,\n  1189→                'errors': errors,\n  1190→                'warnings': warnings,\n  1191→            }\n  1192→\n  1193→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1194→            warnings.append(\n  1195→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1196→            )\n  1197→            references = references[:max_refs]\n  1198→\n  1199→        for order, item in enumerate(references):\n  1200→            load_result = self._load_reference_source(item)\n  1201→            if not load_result:\n  1202→                errors.append(f\"ref[{order}] 加载失败\")\n  1203→                continue\n  1204→\n  1205→            file_data, extension, meta = load_result\n  1206→            meta.setdefault('order', order)\n  1207→            meta.setdefault('kind', meta.get('type', 'image'))\n  1208→\n  1209→            try:\n  1210→                asset_id = self._generate_reference_asset_id(file_data)\n  1211→                record = self.storage_manager.save_reference_asset(\n  1212→                    'images',\n  1213→                    file_data,\n  1214→                    asset_id=asset_id,\n  1215→                    extension=extension,\n  1216→                    metadata=meta,\n  1217→                )\n  1218→                try:\n  1219→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1220→                except Exception:\n  1221→                    record['_payload_b64'] = None\n  1222→                record['_source_meta'] = meta\n  1223→                stored.append(record)\n  1224→                if record.get('absolute_path'):\n  1225→                    absolute_paths.append(record['absolute_path'])\n  1226→            except Exception as exc:\n  1227→                logger.warning(f\"保存参考图失败: {exc}\")\n  1228→                errors.append(f\"ref[{order}] 保存失败\")\n  1229→\n  1230→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1231→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1232→            if len(stored) > allowed:\n  1233→                warnings.append(\n  1234→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1235→                )\n  1236→                stored = stored[:allowed]\n  1237→                absolute_paths = absolute_paths[:allowed]\n  1238→\n  1239→        return {\n  1240→            'assets': stored,\n  1241→            'paths': absolute_paths,\n  1242→            'errors': errors,\n  1243→            'warnings': warnings,\n  1244→        }\n  1245→\n  1246→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1247→        payloads: List[str] = []\n  1248→        for asset in assets or []:\n  1249→            payload = asset.get('_payload_b64')\n  1250→            if not payload:\n  1251→                continue\n  1252→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1253→            mime = 'image/png'\n  1254→            try:\n  1255→                if path_hint:\n  1256→                    suffix = Path(path_hint).suffix.lower()\n  1257→                    if suffix in {'.jpg', '.jpeg'}:\n  1258→                        mime = 'image/jpeg'\n  1259→                    elif suffix == '.webp':\n  1260→                        mime = 'image/webp'\n  1261→                    elif suffix == '.bmp':\n  1262→                        mime = 'image/bmp'\n  1263→                    elif suffix == '.gif':\n  1264→                        mime = 'image/gif'\n  1265→            except Exception:\n  1266→                pass\n  1267→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1268→        return payloads\n  1269→\n  1270→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1271→        provider = (self.client.last_provider() or \"\").lower()\n  1272→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1273→            return v4_5_model or v4_model\n  1274→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1275→            return v4_model\n  1276→        return default_model\n  1277→\n  1278→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1279→        cleaned: List[Dict[str, Any]] = []\n  1280→        for rec in assets or []:\n  1281→            rec.pop('_payload_b64', None)\n  1282→            rec.pop('_source_meta', None)\n  1283→            rec.pop('absolute_path', None)\n  1284→            cleaned.append({\n  1285→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1286→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1287→                'type': rec.get('type'),\n  1288→                'kind': rec.get('kind'),\n  1289→                'source': rec.get('source'),\n  1290→                'order': rec.get('order'),\n  1291→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1292→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1293→                'width': rec.get('width'),\n  1294→                'height': rec.get('height'),\n  1295→                'created_at': rec.get('created_at'),\n  1296→            })\n  1297→        return cleaned\n  1298→\n  1299→    @staticmethod\n  1300→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1301→        masked: List[str] = []\n  1302→        for rec in assets or []:\n  1303→            rid = rec.get('id') or ''\n  1304→            if not rid:\n  1305→                continue\n  1306→            masked.append(f\"{rid[:6]}***\")\n  1307→        return \",\".join(masked)\n  1308→\n  1309→    @staticmethod\n  1310→    def _provider_hint() -> str:\n  1311→        try:\n  1312→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1313→        except Exception:\n  1314→            return \"unknown\"\n  1315→\n  1316→    def _provider_used(self) -> str:\n  1317→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1318→        if provider:\n  1319→            return provider\n  1320→        return self._provider_hint()\n  1321→\n  1322→    @staticmethod\n  1323→    def _cleanup_reference_paths(paths: List[str]):\n  1324→        for path in paths or []:\n  1325→            try:\n  1326→                if path and Path(path).exists():\n  1327→                    Path(path).unlink(missing_ok=True)\n  1328→            except Exception as exc:\n  1329→                logger.debug(f\"参考图清理失败: {exc}\")\n  1330→\n  1331→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1332→        \"\"\"\n  1333→        准备输入图像，支持本地文件和URL\n  1334→        \n  1335→        Args:\n  1336→            image_path: 图像路径（本地路径或URL）\n  1337→            \n  1338→        Returns:\n  1339→            str: 图像URL、base64数据或None\n  1340→        \"\"\"\n  1341→        try:\n  1342→            # 如果是URL，直接返回\n  1343→            if image_path.startswith((\"http://\", \"https://\")):\n  1344→                return image_path\n  1345→\n  1346→            # 如果是本地文件，转换为Base64\n  1347→            local_path = Path(image_path)\n  1348→            if local_path.exists():\n  1349→                with open(local_path, \"rb\") as f:\n  1350→                    image_data = f.read()\n  1351→\n  1352→                # 检测图像格式\n  1353→                image = Image.open(local_path)\n  1354→                format_name = image.format.lower()\n  1355→\n  1356→                # 转换为Base64\n  1357→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1358→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1359→\n  1360→            logger.error(f\"图像文件不存在: {image_path}\")\n  1361→            return None\n  1362→\n  1363→        except Exception as e:\n  1364→            logger.error(f\"处理输入图像失败: {e}\")\n  1365→            return None\n  1366→\n  1367→    def _extract_width_from_size(self, size: str) -> int:\n  1368→        \"\"\"\n  1369→        从尺寸字符串中提取宽度\n  1370→        \n  1371→        Args:\n  1372→            size: 尺寸字符串，如 \"1024x1024\"\n  1373→            \n  1374→        Returns:\n  1375→            int: 宽度值\n  1376→        \"\"\"\n  1377→        try:\n  1378→            return int(size.split('x')[0])\n  1379→        except (ValueError, IndexError):\n  1380→            return 1024  # 默认值\n  1381→    \n  1382→    def _extract_height_from_size(self, size: str) -> int:\n  1383→        \"\"\"\n  1384→        从尺寸字符串中提取高度\n  1385→        \n  1386→        Args:\n  1387→            size: 尺寸字符串，如 \"1024x1024\"\n  1388→            \n  1389→        Returns:\n  1390→            int: 高度值\n  1391→        \"\"\"\n  1392→        try:\n  1393→            return int(size.split('x')[1])\n  1394→        except (ValueError, IndexError):\n  1395→            return 1024  # 默认值\n  1396→\n  1397→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1398→        \"\"\"\n  1399→        获取图像信息\n  1400→\n  1401→        Args:\n  1402→            image_path: 图像文件路径\n  1403→\n  1404→        Returns:\n  1405→            Dict: 图像信息\n  1406→        \"\"\"\n  1407→        try:\n  1408→            with Image.open(image_path) as img:\n  1409→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1410→        except Exception as e:\n  1411→            logger.error(f\"获取图像信息失败: {e}\")\n  1412→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1413→\n  1414→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1415→        \"\"\"\n  1416→        获取图像生成历史记录\n  1417→\n  1418→        Args:\n  1419→            limit: 返回记录数量限制\n  1420→\n  1421→        Returns:\n  1422→            List[Dict]: 历史记录列表\n  1423→        \"\"\"\n  1424→        return self.storage_manager.load_history('images', limit=limit)\n  1425→\n  1426→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1427→        \"\"\"\n  1428→        根据提示词关键字搜索历史记录\n  1429→\n  1430→        Args:\n  1431→            keyword: 搜索关键字\n  1432→\n  1433→        Returns:\n  1434→            List[Dict]: 匹配的记录列表\n  1435→        \"\"\"\n  1436→        # 获取所有历史记录并在内存中过滤\n  1437→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1438→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1439→\n  1440→    def get_statistics(self) -> Dict[str, Any]:\n  1441→        \"\"\"\n  1442→        获取生成统计信息\n  1443→\n  1444→        Returns:\n  1445→            Dict: 统计信息\n  1446→        \"\"\"\n  1447→        try:\n  1448→            # 使用统一存储管理器获取存储统计\n  1449→            storage_stats = self.storage_manager.get_storage_stats()\n  1450→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1451→            \n  1452→            # 获取历史记录进行详细统计\n  1453→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1454→            \n  1455→            if not all_records:\n  1456→                return {\n  1457→                    \"total_images\": 0,\n  1458→                    \"text_to_image_count\": 0,\n  1459→                    \"image_to_image_count\": 0,\n  1460→                    \"total_file_size\": 0,\n  1461→                    \"average_file_size\": 0,\n  1462→                    \"most_common_size\": \"unknown\"\n  1463→                }\n  1464→\n  1465→            # 统计不同类型的图片数量\n  1466→            text_to_image_count = 0\n  1467→            image_to_image_count = 0\n  1468→            total_file_size = 0\n  1469→            sizes = []\n  1470→            \n  1471→            for record in all_records:\n  1472→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1473→                if 'input_image' in record.get('parameters', {}):\n  1474→                    image_to_image_count += 1\n  1475→                else:\n  1476→                    text_to_image_count += 1\n  1477→                \n  1478→                # 计算文件大小\n  1479→                file_size = record.get('file_size', 0)\n  1480→                if isinstance(file_size, str) and file_size.isdigit():\n  1481→                    file_size = int(file_size)\n  1482→                elif not isinstance(file_size, (int, float)):\n  1483→                    file_size = 0\n  1484→                total_file_size += file_size\n  1485→                \n  1486→                # 收集尺寸信息\n  1487→                width = record.get('width', 0)\n  1488→                height = record.get('height', 0)\n  1489→                if width and height:\n  1490→                    sizes.append(f\"{width}x{height}\")\n  1491→\n  1492→            stats = {\n  1493→                \"total_images\": len(all_records),\n  1494→                \"text_to_image_count\": text_to_image_count,\n  1495→                \"image_to_image_count\": image_to_image_count,\n  1496→                \"total_file_size\": total_file_size,\n  1497→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1498→                \"most_common_size\": \"unknown\",\n  1499→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1500→            }\n  1501→\n  1502→            # 最常用的尺寸\n  1503→            if sizes:\n  1504→                from collections import Counter\n  1505→                size_counts = Counter(sizes)\n  1506→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1507→\n  1508→            return stats\n  1509→\n  1510→        except Exception as e:\n  1511→            logger.error(f\"获取统计信息失败: {e}\")\n  1512→            return {\n  1513→                \"total_images\": 0,\n  1514→                \"text_to_image_count\": 0,\n  1515→                \"image_to_image_count\": 0,\n  1516→                \"total_file_size\": 0,\n  1517→                \"average_file_size\": 0,\n  1518→                \"most_common_size\": \"unknown\"\n  1519→            }\n  1520→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"53ff5670-1dfa-4ed2-ab28-02d0934526e8","timestamp":"2026-01-08T03:06:17.698Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config.unified_config import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        storage_dir = get_storage_dir()\n        if not storage_dir:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        self.storage_manager = get_v2_storage_manager(storage_dir)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n        count: int = 1,\n        sequential_mode: bool = False,\n        derived_ids: Optional[List[str]] = None,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            count: 生成图片数量（组图模式下生效）\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n            derived_ids: 组图生成的ID列表（用于关联）\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n\n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n\n        # 根据 model_variant 选择 provider（并发安全：不写 env）\n        seedream_provider: Optional[str] = None\n        try:\n            mv = (model_variant or \"\").strip().lower()\n            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n                seedream_provider = \"volc_v4\"\n            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n                seedream_provider = \"volc_v4_5\"\n            elif mv.startswith(\"volc_\"):\n                seedream_provider = mv\n        except Exception:\n            seedream_provider = None\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            actual_count = max(1, count)\n            use_group_mode = bool(sequential_mode and actual_count > 1)\n\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n                n=actual_count if use_group_mode else 1,\n                sequential_mode=sequential_mode,\n                seedream_provider=seedream_provider,\n            )\n\n            # 组图模式：API 返回多张图，需要逐一保存\n            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n            images_count = len(images_list)\n            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n\n            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n            if use_group_mode and images_count < actual_count:\n                logger.warning(\n                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n                )\n\n            if use_group_mode and images_count > 1:\n                results_batch = []\n                success_count = 0\n                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n                total_images = len(images_list)\n\n                for idx, img_data in enumerate(images_list):\n                    # 发送下载进度（每张图开始下载时）\n                    if progress_callback:\n                        try:\n                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n                        except Exception:\n                            pass\n\n                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n                    per_result = {\n                        \"task_id\": per_id,\n                        \"success\": True,\n                        \"type\": \"text_to_image\",\n                        \"prompt\": prompt,\n                        \"image_url\": img_data[\"url\"],\n                        \"parameters\": {\n                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                            **(({\"seed\": seed} if seedream_provider is None else {})),\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,\n                        },\n                        \"created_at\": datetime.now().isoformat(),\n                        \"usage\": api_result.get(\"usage\", {}),\n                    }\n\n                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n                    if sanitized_refs:\n                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                        per_result[\"reference_assets\"] = sanitized_refs\n\n                    if save_local and per_result.get(\"image_url\"):\n                        local_result = self._save_image_locally(per_result)\n                        per_result.update(local_result)\n                        if not local_result.get('local_save_error'):\n                            success_count += 1\n\n                    results_batch.append(per_result)\n\n                    # 发送下载完成进度\n                    if progress_callback:\n                        try:\n                            progress_callback(idx + 1, total_images, per_result)\n                        except Exception:\n                            pass\n\n                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n                return {\n                    \"batch\": True,\n                    \"results\": results_batch,\n                    \"success_count\": success_count,\n                    \"total_count\": len(results_batch),\n                    \"derived_ids\": group_ids,\n                }\n\n            # 单图模式（默认）\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                    **(({\"seed\": seed} if seedream_provider is None else {})),\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    ),\n                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale,\n                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                    **({\"seed\": seed} if (self.client.last_provider() or \"\").lower() not in {\"volc_v4\", \"volc_v4_5\", \"volcengine_v4\", \"volcengine_v4_5\"} else {}),\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        sequential_mode: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n        max_allowed = 15 if sequential_mode else 10\n        if count < 1 or count > max_allowed:\n            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n\n        # 组图模式：单次 API 调用返回多张图\n        if sequential_mode:\n            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n            return self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=save_local,\n                model_variant=model_variant,\n                generation_id=generation_id,\n                count=count,\n                sequential_mode=True,\n                derived_ids=derived_ids,\n                progress_callback=progress_callback,\n            )\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1520,"startLine":1,"totalLines":1520}},"sourceToolAssistantUUID":"82aa447b-0155-4268-8d9b-86ec41c8ff99"}
{"parentUuid":"53ff5670-1dfa-4ed2-ab28-02d0934526e8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0193MBV4xhSB7CTroJQogYuQ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me search for where the model names are actually saved to the database by looking at how the storage manager saves records:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":18904,"cache_creation_input_tokens":32873,"cache_read_input_tokens":20563,"cache_creation":{"ephemeral_5m_input_tokens":32873,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a2698537-0c8f-4a33-9009-53efef3c0ef9","timestamp":"2026-01-08T03:06:21.483Z"}
{"parentUuid":"a2698537-0c8f-4a33-9009-53efef3c0ef9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0193MBV4xhSB7CTroJQogYuQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q3DhMTcZPFhbJBjctRNJAZ","name":"Grep","input":{"pattern":"def add_record|def save_content_file","type":"py","path":"/Users/yunchang/Documents/GitHub/gemeng2/modules"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":18904,"cache_creation_input_tokens":32873,"cache_read_input_tokens":20563,"cache_creation":{"ephemeral_5m_input_tokens":32873,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"0c513307-6cd7-4580-8858-725e752e1d2f","timestamp":"2026-01-08T03:06:22.248Z"}
{"parentUuid":"0c513307-6cd7-4580-8858-725e752e1d2f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0193MBV4xhSB7CTroJQogYuQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TS41V6KMU6Jre1pvKqYJL9","name":"Bash","input":{"command":"find /Users/yunchang/Documents/GitHub/gemeng2/modules/storage -name \"*.py\" -type f","description":"Find storage related files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":18904,"cache_creation_input_tokens":32873,"cache_read_input_tokens":20563,"cache_creation":{"ephemeral_5m_input_tokens":32873,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2417c8dd-7b89-4ae4-93d0-2c6820e2c6d8","timestamp":"2026-01-08T03:06:22.507Z"}
{"parentUuid":"0c513307-6cd7-4580-8858-725e752e1d2f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q3DhMTcZPFhbJBjctRNJAZ","type":"tool_result","content":"Found 2 files\nmodules/storage/unified_storage_manager_v2.py\nmodules/repository/sqlite_handler.py"}]},"uuid":"e1c6f750-d9cd-4e44-a38b-01562751bec5","timestamp":"2026-01-08T03:06:22.595Z","toolUseResult":{"mode":"files_with_matches","filenames":["modules/storage/unified_storage_manager_v2.py","modules/repository/sqlite_handler.py"],"numFiles":2},"sourceToolAssistantUUID":"0c513307-6cd7-4580-8858-725e752e1d2f"}
{"parentUuid":"2417c8dd-7b89-4ae4-93d0-2c6820e2c6d8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TS41V6KMU6Jre1pvKqYJL9","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/storage_manager_factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","is_error":false}]},"uuid":"e134c75a-914c-45dd-9393-454d62fdc3ab","timestamp":"2026-01-08T03:06:22.669Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/storage_manager_factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"2417c8dd-7b89-4ae4-93d0-2c6820e2c6d8"}
{"parentUuid":"e134c75a-914c-45dd-9393-454d62fdc3ab","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BNd3N9hE5Mu5rihd4JTep1","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the unified storage manager to see how it saves records with model names:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":19670,"cache_read_input_tokens":53436,"cache_creation":{"ephemeral_5m_input_tokens":19670,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"426f4e2e-e8f9-4915-a253-8649452c01bc","timestamp":"2026-01-08T03:06:29.146Z"}
{"parentUuid":"426f4e2e-e8f9-4915-a253-8649452c01bc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BNd3N9hE5Mu5rihd4JTep1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019J3bvWVXURGKcVqE8Jh31S","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":19670,"cache_read_input_tokens":53436,"cache_creation":{"ephemeral_5m_input_tokens":19670,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"5fd7bf65-9277-4549-a51b-1659d544fc5d","timestamp":"2026-01-08T03:06:29.441Z"}
{"parentUuid":"5fd7bf65-9277-4549-a51b-1659d544fc5d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019J3bvWVXURGKcVqE8Jh31S","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Unified storage manager (V2) - SQLite-backed implementation.\n     5→\n     6→Responsibilities:\n     7→- Manage root_path and subdirectories (images, videos, references, thumbnails, metadata, repository).\n     8→- Persist generation records into SQLite (repository/gemeng.db) for history views.\n     9→- Save content files and reference assets; generate image thumbnails (up to 1080p, no upscale).\n    10→- Provide history loading and basic storage stats.\n    11→\n    12→Notes:\n    13→- Video thumbnail generation is skipped (ffmpeg unavailable by default); placeholder None is returned.\n    14→- Interfaces kept compatible with existing callers (save_content_file, save_reference_asset, load_history, get_storage_stats).\n    15→\"\"\"\n    16→\n    17→from __future__ import annotations\n    18→\n    19→import io\n    20→import uuid\n    21→from datetime import datetime\n    22→from pathlib import Path\n    23→from typing import Any, Dict, List, Optional\n    24→\n    25→from loguru import logger\n    26→from PIL import Image\n    27→\n    28→\n    29→def _now_iso() -> str:\n    30→    return datetime.utcnow().isoformat()\n    31→\n    32→\n    33→class UnifiedStorageManagerV2:\n    34→    def __init__(self, base_path: str):\n    35→        from modules.repository.manager import RepositoryManager  # lazy import to avoid circular init in frozen mode\n    36→        self.root_path = Path(base_path).expanduser().resolve()\n    37→        self.root_path.mkdir(parents=True, exist_ok=True)\n    38→\n    39→        # Directory layout\n    40→        self.images_dir = self.root_path / \"images\"\n    41→        self.videos_dir = self.root_path / \"videos\"\n    42→        self.references_images_dir = self.root_path / \"references\" / \"images\"\n    43→        self.references_videos_dir = self.root_path / \"references\" / \"videos\"\n    44→        self.thumbnails_images_dir = self.root_path / \"thumbnails\" / \"images\"\n    45→        self.thumbnails_videos_dir = self.root_path / \"thumbnails\" / \"videos\"\n    46→        self.metadata_dir = self.root_path / \"metadata\"\n    47→        self.repository_dir = self.root_path / \"repository\"\n    48→\n    49→        for d in [\n    50→            self.images_dir,\n    51→            self.videos_dir,\n    52→            self.references_images_dir,\n    53→            self.references_videos_dir,\n    54→            self.thumbnails_images_dir,\n    55→            self.thumbnails_videos_dir,\n    56→            self.metadata_dir,\n    57→            self.repository_dir,\n    58→        ]:\n    59→            d.mkdir(parents=True, exist_ok=True)\n    60→\n    61→        # SQLite-backed repository manager\n    62→        self._repository_manager = RepositoryManager(self.root_path)\n    63→\n    64→    # ------------------------------------------------------------------ helpers\n    65→    @staticmethod\n    66→    def _guess_ext(url: Optional[str], default: str) -> str:\n    67→        if not url:\n    68→            return default\n    69→        lowered = url.lower()\n    70→        for ext in (\".png\", \".jpg\", \".jpeg\", \".webp\", \".mp4\", \".mov\", \".avi\"):\n    71→            if lowered.endswith(ext):\n    72→                return ext\n    73→        return default\n    74→\n    75→    def _save_file(self, target_path: Path, data: bytes) -> None:\n    76→        target_path.parent.mkdir(parents=True, exist_ok=True)\n    77→\n    78→        # 对于图片文件，使用 PIL 重新保存以确保格式正确和 macOS 缩略图兼容性\n    79→        ext = target_path.suffix.lower()\n    80→        if ext in {'.png', '.jpg', '.jpeg', '.webp'}:\n    81→            try:\n    82→                with Image.open(io.BytesIO(data)) as img:\n    83→                    # 转换 RGBA -> RGB（如果目标格式不支持透明度）\n    84→                    if ext in {'.jpg', '.jpeg'} and img.mode in ('RGBA', 'LA', 'P'):\n    85→                        rgb_img = Image.new('RGB', img.size, (255, 255, 255))\n    86→                        if img.mode == 'P':\n    87→                            img = img.convert('RGBA')\n    88→                        rgb_img.paste(img, mask=img.split()[-1] if img.mode in ('RGBA', 'LA') else None)\n    89→                        img = rgb_img\n    90→\n    91→                    # 使用 PIL 保存，确保格式规范\n    92→                    save_kwargs = {}\n    93→                    if ext == '.png':\n    94→                        save_kwargs = {'optimize': True}\n    95→                    elif ext in {'.jpg', '.jpeg'}:\n    96→                        save_kwargs = {'quality': 95, 'optimize': True}\n    97→                    elif ext == '.webp':\n    98→                        save_kwargs = {'quality': 95}\n    99→\n   100→                    img.save(target_path, **save_kwargs)\n   101→                    logger.debug(f\"图片已通过 PIL 保存: {target_path.name}\")\n   102→                    return\n   103→            except Exception as e:\n   104→                logger.warning(f\"PIL 保存失败，回退到直接写入: {e}\")\n   105→\n   106→        # 回退：直接写入字节（视频或其他文件）\n   107→        target_path.write_bytes(data)\n   108→\n   109→    def _make_image_thumbnail(self, src_bytes: bytes, file_id: str, ext: str) -> Optional[Path]:\n   110→        try:\n   111→            with Image.open(io.BytesIO(src_bytes)) as img:\n   112→                img = img.convert(\"RGB\")\n   113→                # Maintain clarity: cap longest side at 1080px, do not upscale if smaller\n   114→                max_side = 1080\n   115→                w, h = img.size\n   116→                if max(w, h) > max_side:\n   117→                    img.thumbnail((max_side, max_side), Image.LANCZOS)\n   118→                thumb_name = f\"{file_id}_thumb.jpg\"\n   119→                thumb_path = self.thumbnails_images_dir / thumb_name\n   120→                thumb_path.parent.mkdir(parents=True, exist_ok=True)\n   121→                img.save(thumb_path, format=\"JPEG\", quality=92)\n   122→                return thumb_path\n   123→        except Exception as exc:\n   124→            logger.warning(f\"Failed to generate image thumbnail: {exc}\")\n   125→            return None\n   126→        return None\n   127→\n   128→    def _persist_record(\n   129→        self,\n   130→        record_id: str,\n   131→        content_type: str,\n   132→        file_path: Path,\n   133→        relative_path: str,\n   134→        thumbnail_path: Optional[Path],\n   135→        prompt: Optional[str],\n   136→        model: Optional[str],\n   137→        parameters: Dict[str, Any],\n   138→        metadata: Dict[str, Any],\n   139→        status: str = \"completed\",\n   140→    ) -> None:\n   141→        # 计算缩略图的相对路径\n   142→        rel_thumb = None\n   143→        if thumbnail_path:\n   144→            try:\n   145→                rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace('\\\\', '/')\n   146→            except ValueError:\n   147→                # 如果无法计算相对路径，使用文件名\n   148→                rel_thumb = f\"thumbnails/{thumbnail_path.name}\"\n   149→\n   150→        # 统一使用正斜杠，确保跨平台兼容\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cbeaeb9b-1f64-4561-baa4-a9060d504c69","timestamp":"2026-01-08T03:06:29.570Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nUnified storage manager (V2) - SQLite-backed implementation.\n\nResponsibilities:\n- Manage root_path and subdirectories (images, videos, references, thumbnails, metadata, repository).\n- Persist generation records into SQLite (repository/gemeng.db) for history views.\n- Save content files and reference assets; generate image thumbnails (up to 1080p, no upscale).\n- Provide history loading and basic storage stats.\n\nNotes:\n- Video thumbnail generation is skipped (ffmpeg unavailable by default); placeholder None is returned.\n- Interfaces kept compatible with existing callers (save_content_file, save_reference_asset, load_history, get_storage_stats).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport uuid\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom loguru import logger\nfrom PIL import Image\n\n\ndef _now_iso() -> str:\n    return datetime.utcnow().isoformat()\n\n\nclass UnifiedStorageManagerV2:\n    def __init__(self, base_path: str):\n        from modules.repository.manager import RepositoryManager  # lazy import to avoid circular init in frozen mode\n        self.root_path = Path(base_path).expanduser().resolve()\n        self.root_path.mkdir(parents=True, exist_ok=True)\n\n        # Directory layout\n        self.images_dir = self.root_path / \"images\"\n        self.videos_dir = self.root_path / \"videos\"\n        self.references_images_dir = self.root_path / \"references\" / \"images\"\n        self.references_videos_dir = self.root_path / \"references\" / \"videos\"\n        self.thumbnails_images_dir = self.root_path / \"thumbnails\" / \"images\"\n        self.thumbnails_videos_dir = self.root_path / \"thumbnails\" / \"videos\"\n        self.metadata_dir = self.root_path / \"metadata\"\n        self.repository_dir = self.root_path / \"repository\"\n\n        for d in [\n            self.images_dir,\n            self.videos_dir,\n            self.references_images_dir,\n            self.references_videos_dir,\n            self.thumbnails_images_dir,\n            self.thumbnails_videos_dir,\n            self.metadata_dir,\n            self.repository_dir,\n        ]:\n            d.mkdir(parents=True, exist_ok=True)\n\n        # SQLite-backed repository manager\n        self._repository_manager = RepositoryManager(self.root_path)\n\n    # ------------------------------------------------------------------ helpers\n    @staticmethod\n    def _guess_ext(url: Optional[str], default: str) -> str:\n        if not url:\n            return default\n        lowered = url.lower()\n        for ext in (\".png\", \".jpg\", \".jpeg\", \".webp\", \".mp4\", \".mov\", \".avi\"):\n            if lowered.endswith(ext):\n                return ext\n        return default\n\n    def _save_file(self, target_path: Path, data: bytes) -> None:\n        target_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # 对于图片文件，使用 PIL 重新保存以确保格式正确和 macOS 缩略图兼容性\n        ext = target_path.suffix.lower()\n        if ext in {'.png', '.jpg', '.jpeg', '.webp'}:\n            try:\n                with Image.open(io.BytesIO(data)) as img:\n                    # 转换 RGBA -> RGB（如果目标格式不支持透明度）\n                    if ext in {'.jpg', '.jpeg'} and img.mode in ('RGBA', 'LA', 'P'):\n                        rgb_img = Image.new('RGB', img.size, (255, 255, 255))\n                        if img.mode == 'P':\n                            img = img.convert('RGBA')\n                        rgb_img.paste(img, mask=img.split()[-1] if img.mode in ('RGBA', 'LA') else None)\n                        img = rgb_img\n\n                    # 使用 PIL 保存，确保格式规范\n                    save_kwargs = {}\n                    if ext == '.png':\n                        save_kwargs = {'optimize': True}\n                    elif ext in {'.jpg', '.jpeg'}:\n                        save_kwargs = {'quality': 95, 'optimize': True}\n                    elif ext == '.webp':\n                        save_kwargs = {'quality': 95}\n\n                    img.save(target_path, **save_kwargs)\n                    logger.debug(f\"图片已通过 PIL 保存: {target_path.name}\")\n                    return\n            except Exception as e:\n                logger.warning(f\"PIL 保存失败，回退到直接写入: {e}\")\n\n        # 回退：直接写入字节（视频或其他文件）\n        target_path.write_bytes(data)\n\n    def _make_image_thumbnail(self, src_bytes: bytes, file_id: str, ext: str) -> Optional[Path]:\n        try:\n            with Image.open(io.BytesIO(src_bytes)) as img:\n                img = img.convert(\"RGB\")\n                # Maintain clarity: cap longest side at 1080px, do not upscale if smaller\n                max_side = 1080\n                w, h = img.size\n                if max(w, h) > max_side:\n                    img.thumbnail((max_side, max_side), Image.LANCZOS)\n                thumb_name = f\"{file_id}_thumb.jpg\"\n                thumb_path = self.thumbnails_images_dir / thumb_name\n                thumb_path.parent.mkdir(parents=True, exist_ok=True)\n                img.save(thumb_path, format=\"JPEG\", quality=92)\n                return thumb_path\n        except Exception as exc:\n            logger.warning(f\"Failed to generate image thumbnail: {exc}\")\n            return None\n        return None\n\n    def _persist_record(\n        self,\n        record_id: str,\n        content_type: str,\n        file_path: Path,\n        relative_path: str,\n        thumbnail_path: Optional[Path],\n        prompt: Optional[str],\n        model: Optional[str],\n        parameters: Dict[str, Any],\n        metadata: Dict[str, Any],\n        status: str = \"completed\",\n    ) -> None:\n        # 计算缩略图的相对路径\n        rel_thumb = None\n        if thumbnail_path:\n            try:\n                rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace('\\\\', '/')\n            except ValueError:\n                # 如果无法计算相对路径，使用文件名\n                rel_thumb = f\"thumbnails/{thumbnail_path.name}\"\n\n        # 统一使用正斜杠，确保跨平台兼容","numLines":150,"startLine":1,"totalLines":377}},"sourceToolAssistantUUID":"5fd7bf65-9277-4549-a51b-1659d544fc5d"}
{"parentUuid":"cbeaeb9b-1f64-4561-baa4-a9060d504c69","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016Q1ZFr4g7M97NRQ2LZP9W3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016rBC3XP97ERyMtRPPWKe5C","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","offset":150,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":2443,"cache_read_input_tokens":73106,"cache_creation":{"ephemeral_5m_input_tokens":2443,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"type":"assistant","uuid":"fc9fefc8-198f-42c3-988d-aac0906a1c5c","timestamp":"2026-01-08T03:06:35.157Z"}
{"parentUuid":"fc9fefc8-198f-42c3-988d-aac0906a1c5c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016rBC3XP97ERyMtRPPWKe5C","type":"tool_result","content":"   150→        # 统一使用正斜杠，确保跨平台兼容\n   151→        rel_path_normalized = relative_path.replace('\\\\', '/') if relative_path else None\n   152→\n   153→        repo_data = {\n   154→            \"file_id\": record_id,\n   155→            \"generation_id\": parameters.get(\"generation_id\") or metadata.get(\"generation_id\") or record_id,\n   156→            \"prompt\": prompt,\n   157→            \"model\": model,\n   158→            \"status\": status,\n   159→            \"file_path\": rel_path_normalized,  # 存储相对路径（跨平台兼容）\n   160→            \"relative_path\": rel_path_normalized,\n   161→            \"thumbnail_path\": rel_thumb,  # 存储相对路径（跨平台兼容）\n   162→            \"parameters\": parameters,\n   163→            \"metadata\": metadata,\n   164→            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n   165→        }\n   166→        try:\n   167→            self._repository_manager.add_content(record_id, content_type, repo_data)\n   168→        except Exception as exc:\n   169→            logger.error(f\"Failed to persist record to repository: {exc}\")\n   170→\n   171→    # ------------------------------------------------------------------ public\n   172→    def save_content_file(\n   173→        self,\n   174→        content_type: str,\n   175→        file_data: bytes,\n   176→        url: Optional[str] = None,\n   177→        metadata: Optional[Dict[str, Any]] = None,\n   178→    ) -> Dict[str, Any]:\n   179→        \"\"\"\n   180→        Save a generated content file (image/video) and persist metadata to SQLite.\n   181→        Returns a record dict containing local paths and identifiers.\n   182→        \"\"\"\n   183→        metadata = metadata or {}\n   184→        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n   185→\n   186→        file_id = str(metadata.get(\"generation_id\") or metadata.get(\"file_id\") or uuid.uuid4().hex)\n   187→        ext = self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n   188→        filename = f\"{file_id}{ext}\"\n   189→        target_dir = self.images_dir if ctype == \"images\" else self.videos_dir\n   190→        target_path = target_dir / filename\n   191→\n   192→        self._save_file(target_path, file_data)\n   193→\n   194→        thumbnail_path: Optional[Path] = None\n   195→        if ctype == \"images\":\n   196→            thumbnail_path = self._make_image_thumbnail(file_data, file_id, ext)\n   197→            try:\n   198→                with Image.open(io.BytesIO(file_data)) as img:\n   199→                    metadata.setdefault(\"width\", img.width)\n   200→                    metadata.setdefault(\"height\", img.height)\n   201→            except Exception as exc:\n   202→                logger.debug(f\"Failed to inspect image size: {exc}\")\n   203→\n   204→        rel_path = str(target_path.relative_to(self.root_path))\n   205→        rel_thumb = str(thumbnail_path.relative_to(self.root_path)) if thumbnail_path else None\n   206→\n   207→        parameters = metadata.get(\"parameters\") or {}\n   208→        # ensure prompt/model at top-level for repository\n   209→        prompt = metadata.get(\"prompt\") or parameters.get(\"prompt\")\n   210→        model = metadata.get(\"model\") or parameters.get(\"model\")\n   211→\n   212→        self._persist_record(\n   213→            record_id=file_id,\n   214→            content_type=ctype,\n   215→            file_path=target_path,\n   216→            relative_path=rel_path,\n   217→            thumbnail_path=thumbnail_path,\n   218→            prompt=prompt,\n   219→            model=model,\n   220→            parameters=parameters if isinstance(parameters, dict) else {},\n   221→            metadata=metadata if isinstance(metadata, dict) else {},\n   222→            status=str(metadata.get(\"status\") or \"completed\"),\n   223→        )\n   224→\n   225→        return {\n   226→            \"file_id\": file_id,\n   227→            \"local_path\": str(target_path),\n   228→            \"relative_path\": rel_path,\n   229→            \"thumbnail_path\": str(thumbnail_path) if thumbnail_path else None,\n   230→            \"content_type\": ctype,\n   231→            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n   232→            \"status\": metadata.get(\"status\") or \"completed\",\n   233→        }\n   234→\n   235→    def save_reference_asset(\n   236→        self,\n   237→        content_type: str,\n   238→        file_data: bytes,\n   239→        url: Optional[str] = None,\n   240→        metadata: Optional[Dict[str, Any]] = None,\n   241→        *,\n   242→        asset_id: Optional[str] = None,\n   243→        extension: Optional[str] = None,\n   244→    ) -> Dict[str, Any]:\n   245→        \"\"\"\n   246→        Save a reference asset (image/video). Does not persist to repository table by default.\n   247→        Accepts optional asset_id/extension for callers that pre-generate IDs.\n   248→        \"\"\"\n   249→        metadata = metadata or {}\n   250→        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n   251→\n   252→        ref_id = str(asset_id or metadata.get(\"reference_id\") or uuid.uuid4().hex)\n   253→        ext = extension or self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n   254→        filename = f\"{ref_id}{ext}\"\n   255→        target_dir = self.references_images_dir if ctype == \"images\" else self.references_videos_dir\n   256→        target_path = target_dir / filename\n   257→\n   258→        self._save_file(target_path, file_data)\n   259→\n   260→        width: Optional[int] = metadata.get(\"width\")\n   261→        height: Optional[int] = metadata.get(\"height\")\n   262→        thumbnail_path: Optional[Path] = None\n   263→        if ctype == \"images\":\n   264→            try:\n   265→                with Image.open(io.BytesIO(file_data)) as img:\n   266→                    width = width or img.width\n   267→                    height = height or img.height\n   268→            except Exception as exc:\n   269→                logger.warning(f\"Failed to inspect reference image size: {exc}\")\n   270→            thumbnail_path = self._make_image_thumbnail(file_data, ref_id, ext)\n   271→\n   272→        rel_path = str(target_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\")\n   273→        rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\") if thumbnail_path else None\n   274→        record = {\n   275→            \"id\": ref_id,\n   276→            \"reference_id\": ref_id,\n   277→            \"path\": rel_path,\n   278→            \"relative_path\": rel_path,\n   279→            \"absolute_path\": str(target_path),\n   280→            \"content_type\": ctype,\n   281→            \"type\": metadata.get(\"type\") or metadata.get(\"kind\") or (\"image\" if ctype == \"images\" else \"video\"),\n   282→            \"kind\": metadata.get(\"kind\") or metadata.get(\"type\") or (\"image\" if ctype == \"images\" else \"video\"),\n   283→            \"source\": metadata.get(\"source\") or metadata.get(\"source_path\") or metadata.get(\"source_url\"),\n   284→            \"order\": metadata.get(\"order\"),\n   285→            \"size\": len(file_data),\n   286→            \"checksum\": metadata.get(\"checksum\"),\n   287→            \"width\": width,\n   288→            \"height\": height,\n   289→            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n   290→            \"thumbnail_path\": rel_thumb,\n   291→            \"thumbnail_local_path\": str(thumbnail_path) if thumbnail_path else None,\n   292→        }\n   293→        return record\n   294→\n   295→    def load_history(self, content_type: str, limit: int = 100) -> List[Dict[str, Any]]:\n   296→        ctype = \"image\" if content_type in (\"image\", \"images\") else \"video\"\n   297→        try:\n   298→            records = self._repository_manager.get_records_batch(\n   299→                start_index=0,\n   300→                batch_size=limit,\n   301→                record_type=ctype,\n   302→            )\n   303→            return records or []\n   304→        except Exception as exc:\n   305→            logger.error(f\"Failed to load history: {exc}\")\n   306→            return []\n   307→\n   308→    def get_storage_stats(self) -> Dict[str, Any]:\n   309→        try:\n   310→            images = self._repository_manager.get_total_count('image')\n   311→            videos = self._repository_manager.get_total_count('video')\n   312→        except Exception:\n   313→            images = videos = 0\n   314→        return {\n   315→            \"images\": images,\n   316→            \"videos\": videos,\n   317→            \"total\": images + videos,\n   318→            \"root_path\": str(self.root_path),\n   319→        }\n   320→\n   321→    def resolve_reference_path(self, relative_path: str) -> Path:\n   322→        \"\"\"Resolve a storage-relative path to an absolute path.\"\"\"\n   323→        if not relative_path:\n   324→            raise ValueError(\"Empty relative path\")\n   325→        # Ensure we don't traverse up via ..\n   326→        safe_rel = relative_path.lstrip(\"/\").replace(\"\\\\\", \"/\")\n   327→        abs_path = (self.root_path / safe_rel).resolve()\n   328→        if not str(abs_path).startswith(str(self.root_path)):\n   329→             # Optional: Security check to prevent jailbreak, though usually internal use\n   330→            pass \n   331→        return abs_path\n   332→\n   333→    def resolve_reference_records(self, assets: List[Dict[str, Any]], absolute: bool = False) -> List[Dict[str, Any]]:\n   334→        \"\"\"\n   335→        Batch resolve reference assets, populating absolute paths if requested.\n   336→        Checks if files actually exist.\n   337→        \"\"\"\n   338→        resolved: List[Dict[str, Any]] = []\n   339→        for asset in assets:\n   340→            if not isinstance(asset, dict):\n   341→                continue\n   342→            clone = dict(asset)\n   343→            rel_path = clone.get(\"path\") or clone.get(\"relative_path\")\n   344→            \n   345→            # Try to populate absolute path if missing or requested\n   346→            if rel_path:\n   347→                try:\n   348→                    abs_path = self.resolve_reference_path(rel_path)\n   349→                    if abs_path.exists():\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f16833cb-d911-4aff-b1e8-c262d6b629f2","timestamp":"2026-01-08T03:06:35.232Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py","content":"        # 统一使用正斜杠，确保跨平台兼容\n        rel_path_normalized = relative_path.replace('\\\\', '/') if relative_path else None\n\n        repo_data = {\n            \"file_id\": record_id,\n            \"generation_id\": parameters.get(\"generation_id\") or metadata.get(\"generation_id\") or record_id,\n            \"prompt\": prompt,\n            \"model\": model,\n            \"status\": status,\n            \"file_path\": rel_path_normalized,  # 存储相对路径（跨平台兼容）\n            \"relative_path\": rel_path_normalized,\n            \"thumbnail_path\": rel_thumb,  # 存储相对路径（跨平台兼容）\n            \"parameters\": parameters,\n            \"metadata\": metadata,\n            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n        }\n        try:\n            self._repository_manager.add_content(record_id, content_type, repo_data)\n        except Exception as exc:\n            logger.error(f\"Failed to persist record to repository: {exc}\")\n\n    # ------------------------------------------------------------------ public\n    def save_content_file(\n        self,\n        content_type: str,\n        file_data: bytes,\n        url: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Save a generated content file (image/video) and persist metadata to SQLite.\n        Returns a record dict containing local paths and identifiers.\n        \"\"\"\n        metadata = metadata or {}\n        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n\n        file_id = str(metadata.get(\"generation_id\") or metadata.get(\"file_id\") or uuid.uuid4().hex)\n        ext = self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n        filename = f\"{file_id}{ext}\"\n        target_dir = self.images_dir if ctype == \"images\" else self.videos_dir\n        target_path = target_dir / filename\n\n        self._save_file(target_path, file_data)\n\n        thumbnail_path: Optional[Path] = None\n        if ctype == \"images\":\n            thumbnail_path = self._make_image_thumbnail(file_data, file_id, ext)\n            try:\n                with Image.open(io.BytesIO(file_data)) as img:\n                    metadata.setdefault(\"width\", img.width)\n                    metadata.setdefault(\"height\", img.height)\n            except Exception as exc:\n                logger.debug(f\"Failed to inspect image size: {exc}\")\n\n        rel_path = str(target_path.relative_to(self.root_path))\n        rel_thumb = str(thumbnail_path.relative_to(self.root_path)) if thumbnail_path else None\n\n        parameters = metadata.get(\"parameters\") or {}\n        # ensure prompt/model at top-level for repository\n        prompt = metadata.get(\"prompt\") or parameters.get(\"prompt\")\n        model = metadata.get(\"model\") or parameters.get(\"model\")\n\n        self._persist_record(\n            record_id=file_id,\n            content_type=ctype,\n            file_path=target_path,\n            relative_path=rel_path,\n            thumbnail_path=thumbnail_path,\n            prompt=prompt,\n            model=model,\n            parameters=parameters if isinstance(parameters, dict) else {},\n            metadata=metadata if isinstance(metadata, dict) else {},\n            status=str(metadata.get(\"status\") or \"completed\"),\n        )\n\n        return {\n            \"file_id\": file_id,\n            \"local_path\": str(target_path),\n            \"relative_path\": rel_path,\n            \"thumbnail_path\": str(thumbnail_path) if thumbnail_path else None,\n            \"content_type\": ctype,\n            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n            \"status\": metadata.get(\"status\") or \"completed\",\n        }\n\n    def save_reference_asset(\n        self,\n        content_type: str,\n        file_data: bytes,\n        url: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        *,\n        asset_id: Optional[str] = None,\n        extension: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Save a reference asset (image/video). Does not persist to repository table by default.\n        Accepts optional asset_id/extension for callers that pre-generate IDs.\n        \"\"\"\n        metadata = metadata or {}\n        ctype = \"images\" if content_type in (\"image\", \"images\") else \"videos\"\n\n        ref_id = str(asset_id or metadata.get(\"reference_id\") or uuid.uuid4().hex)\n        ext = extension or self._guess_ext(url, default=\".png\" if ctype == \"images\" else \".mp4\")\n        filename = f\"{ref_id}{ext}\"\n        target_dir = self.references_images_dir if ctype == \"images\" else self.references_videos_dir\n        target_path = target_dir / filename\n\n        self._save_file(target_path, file_data)\n\n        width: Optional[int] = metadata.get(\"width\")\n        height: Optional[int] = metadata.get(\"height\")\n        thumbnail_path: Optional[Path] = None\n        if ctype == \"images\":\n            try:\n                with Image.open(io.BytesIO(file_data)) as img:\n                    width = width or img.width\n                    height = height or img.height\n            except Exception as exc:\n                logger.warning(f\"Failed to inspect reference image size: {exc}\")\n            thumbnail_path = self._make_image_thumbnail(file_data, ref_id, ext)\n\n        rel_path = str(target_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\")\n        rel_thumb = str(thumbnail_path.relative_to(self.root_path)).replace(\"\\\\\", \"/\") if thumbnail_path else None\n        record = {\n            \"id\": ref_id,\n            \"reference_id\": ref_id,\n            \"path\": rel_path,\n            \"relative_path\": rel_path,\n            \"absolute_path\": str(target_path),\n            \"content_type\": ctype,\n            \"type\": metadata.get(\"type\") or metadata.get(\"kind\") or (\"image\" if ctype == \"images\" else \"video\"),\n            \"kind\": metadata.get(\"kind\") or metadata.get(\"type\") or (\"image\" if ctype == \"images\" else \"video\"),\n            \"source\": metadata.get(\"source\") or metadata.get(\"source_path\") or metadata.get(\"source_url\"),\n            \"order\": metadata.get(\"order\"),\n            \"size\": len(file_data),\n            \"checksum\": metadata.get(\"checksum\"),\n            \"width\": width,\n            \"height\": height,\n            \"created_at\": metadata.get(\"created_at\") or _now_iso(),\n            \"thumbnail_path\": rel_thumb,\n            \"thumbnail_local_path\": str(thumbnail_path) if thumbnail_path else None,\n        }\n        return record\n\n    def load_history(self, content_type: str, limit: int = 100) -> List[Dict[str, Any]]:\n        ctype = \"image\" if content_type in (\"image\", \"images\") else \"video\"\n        try:\n            records = self._repository_manager.get_records_batch(\n                start_index=0,\n                batch_size=limit,\n                record_type=ctype,\n            )\n            return records or []\n        except Exception as exc:\n            logger.error(f\"Failed to load history: {exc}\")\n            return []\n\n    def get_storage_stats(self) -> Dict[str, Any]:\n        try:\n            images = self._repository_manager.get_total_count('image')\n            videos = self._repository_manager.get_total_count('video')\n        except Exception:\n            images = videos = 0\n        return {\n            \"images\": images,\n            \"videos\": videos,\n            \"total\": images + videos,\n            \"root_path\": str(self.root_path),\n        }\n\n    def resolve_reference_path(self, relative_path: str) -> Path:\n        \"\"\"Resolve a storage-relative path to an absolute path.\"\"\"\n        if not relative_path:\n            raise ValueError(\"Empty relative path\")\n        # Ensure we don't traverse up via ..\n        safe_rel = relative_path.lstrip(\"/\").replace(\"\\\\\", \"/\")\n        abs_path = (self.root_path / safe_rel).resolve()\n        if not str(abs_path).startswith(str(self.root_path)):\n             # Optional: Security check to prevent jailbreak, though usually internal use\n            pass \n        return abs_path\n\n    def resolve_reference_records(self, assets: List[Dict[str, Any]], absolute: bool = False) -> List[Dict[str, Any]]:\n        \"\"\"\n        Batch resolve reference assets, populating absolute paths if requested.\n        Checks if files actually exist.\n        \"\"\"\n        resolved: List[Dict[str, Any]] = []\n        for asset in assets:\n            if not isinstance(asset, dict):\n                continue\n            clone = dict(asset)\n            rel_path = clone.get(\"path\") or clone.get(\"relative_path\")\n            \n            # Try to populate absolute path if missing or requested\n            if rel_path:\n                try:\n                    abs_path = self.resolve_reference_path(rel_path)\n                    if abs_path.exists():","numLines":200,"startLine":150,"totalLines":377}},"sourceToolAssistantUUID":"fc9fefc8-198f-42c3-988d-aac0906a1c5c"}
{"parentUuid":"f16833cb-d911-4aff-b1e8-c262d6b629f2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01L2cgHiXVywi7vgUTrjKgJL","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check where the model name is extracted and stored in both seedream and seedance managers. Let me look at specific lines where models are set:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3219,"cache_read_input_tokens":75549,"cache_creation":{"ephemeral_5m_input_tokens":3219,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"558b1222-a926-4cf3-b8c2-2b8ce1ae9b84","timestamp":"2026-01-08T03:06:40.314Z"}
{"parentUuid":"558b1222-a926-4cf3-b8c2-2b8ce1ae9b84","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01L2cgHiXVywi7vgUTrjKgJL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017XP7nZb6tJxu3PH5gZD25h","name":"Grep","input":{"path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream","pattern":"\"model\":\\s*|_resolve_model_id|model_variant","type":"py","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3219,"cache_read_input_tokens":75549,"cache_creation":{"ephemeral_5m_input_tokens":3219,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"6bd554ad-0d98-4305-9054-4dfe936ddcd5","timestamp":"2026-01-08T03:06:41.186Z"}
{"parentUuid":"6bd554ad-0d98-4305-9054-4dfe936ddcd5","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017XP7nZb6tJxu3PH5gZD25h","type":"tool_result","content":"modules/seedream/manager.py:83:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:101:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:112:        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\nmodules/seedream/manager.py:114:        # 根据 model_variant 选择 provider（并发安全：不写 env）\nmodules/seedream/manager.py:117:            mv = (model_variant or \"\").strip().lower()\nmodules/seedream/manager.py:226:                            \"model\": self._resolve_model_id(\nmodules/seedream/manager.py:231:                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\nmodules/seedream/manager.py:283:                    \"model\": self._resolve_model_id(\nmodules/seedream/manager.py:288:                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\nmodules/seedream/manager.py:449:                    \"model\": self._resolve_model_id(\nmodules/seedream/manager.py:563:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:578:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:598:                model_variant=model_variant,\nmodules/seedream/manager.py:636:                'model_variant': model_variant,\nmodules/seedream/manager.py:912:            model_variant=task.get('model_variant'),\nmodules/seedream/manager.py:952:                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\nmodules/seedream/manager.py:1270:    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\nmodules/seedream/__init__.py:15:        \"model\": \"doubao-seedream-3-0-t2i-250415\",\nmodules/seedream/__init__.py:31:        \"model\": \"doubao-seededit-3-0-i2i-250628\",\nmodules/seedream/client.py:547:            \"model\": self.model_id,\r\nmodules/seedream/client.py:642:                \"model\": \"doubao-seedream-3-0-t2i-250415\",\r\nmodules/seedream/client.py:793:                \"model\": \"doubao-seededit-3-0-i2i-250628\","}]},"uuid":"25f914fb-862e-442c-b8dd-e7a7d4db3c2e","timestamp":"2026-01-08T03:06:41.329Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"modules/seedream/manager.py:83:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:101:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:112:        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\nmodules/seedream/manager.py:114:        # 根据 model_variant 选择 provider（并发安全：不写 env）\nmodules/seedream/manager.py:117:            mv = (model_variant or \"\").strip().lower()\nmodules/seedream/manager.py:226:                            \"model\": self._resolve_model_id(\nmodules/seedream/manager.py:231:                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\nmodules/seedream/manager.py:283:                    \"model\": self._resolve_model_id(\nmodules/seedream/manager.py:288:                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\nmodules/seedream/manager.py:449:                    \"model\": self._resolve_model_id(\nmodules/seedream/manager.py:563:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:578:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:598:                model_variant=model_variant,\nmodules/seedream/manager.py:636:                'model_variant': model_variant,\nmodules/seedream/manager.py:912:            model_variant=task.get('model_variant'),\nmodules/seedream/manager.py:952:                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\nmodules/seedream/manager.py:1270:    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\nmodules/seedream/__init__.py:15:        \"model\": \"doubao-seedream-3-0-t2i-250415\",\nmodules/seedream/__init__.py:31:        \"model\": \"doubao-seededit-3-0-i2i-250628\",\nmodules/seedream/client.py:547:            \"model\": self.model_id,\r\nmodules/seedream/client.py:642:                \"model\": \"doubao-seedream-3-0-t2i-250415\",\r\nmodules/seedream/client.py:793:                \"model\": \"doubao-seededit-3-0-i2i-250628\",","numLines":22},"sourceToolAssistantUUID":"6bd554ad-0d98-4305-9054-4dfe936ddcd5"}
{"parentUuid":"25f914fb-862e-442c-b8dd-e7a7d4db3c2e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PzCWdrh33fuY93xzvCqrxH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013Vok5SiGFEtzEP4Y2CA8go","name":"Grep","input":{"output_mode":"content","path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance","pattern":"\"model\":\\s*|_get_display_model_name|model_variant","type":"py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1178,"cache_read_input_tokens":78768,"cache_creation":{"ephemeral_5m_input_tokens":1178,"ephemeral_1h_input_tokens":0},"output_tokens":141,"service_tier":"standard"}},"type":"assistant","uuid":"c93656c7-be9f-4c0b-bb57-1008f1b9c5f7","timestamp":"2026-01-08T03:06:47.750Z"}
{"parentUuid":"c93656c7-be9f-4c0b-bb57-1008f1b9c5f7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013Vok5SiGFEtzEP4Y2CA8go","type":"tool_result","content":"modules/seedance/manager.py:101:        model_variant: Optional[str] = None,\r\nmodules/seedance/manager.py:127:        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\r\nmodules/seedance/manager.py:208:            model_variant=model_variant,\r\nmodules/seedance/manager.py:237:                    model_variant=model_variant,\r\nmodules/seedance/manager.py:692:                'model': self._get_display_model_name(result),\r\nmodules/seedance/manager.py:1229:    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\r\nmodules/seedance/manager.py:1236:        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\r\nmodules/seedance/manager.py:1249:                        mv = layer_obj.get(\"model_variant\")\r\nmodules/seedance/manager.py:1260:            mv = params.get(\"model_variant\") or \"\"\r\nmodules/seedance/client.py:71:            \"model\": data.get(\"model\"),\nmodules/seedance/client.py:93:            \"model\": data.get(\"model\") if isinstance(data, dict) else None,\nmodules/seedance/client.py:505:        model_variant: Optional[str] = None,\nmodules/seedance/client.py:527:            model_variant: UI 侧模型变体（如 seedance_1_5_pro）\nmodules/seedance/client.py:539:        is_seedance_1_5_variant = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\nmodules/seedance/client.py:571:                    model_variant=model_variant,\nmodules/seedance/client.py:575:                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\nmodules/seedance/client.py:595:            is_seedance_1_5 = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\nmodules/seedance/client.py:697:            data = {\"model\": model, \"content\": content}\nmodules/seedance/client.py:747:                \"model\": data.get(\"model\"),\nmodules/seedance/client.py:772:                    \"model\": model,\nmodules/seedance/client.py:816:                        \"model\": model,\nmodules/seedance/client.py:930:                \"model\": result.get(\"model\"),"}]},"uuid":"c6cca72e-d0f3-43cb-9921-7a06dc580156","timestamp":"2026-01-08T03:06:47.904Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"modules/seedance/manager.py:101:        model_variant: Optional[str] = None,\r\nmodules/seedance/manager.py:127:        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\r\nmodules/seedance/manager.py:208:            model_variant=model_variant,\r\nmodules/seedance/manager.py:237:                    model_variant=model_variant,\r\nmodules/seedance/manager.py:692:                'model': self._get_display_model_name(result),\r\nmodules/seedance/manager.py:1229:    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\r\nmodules/seedance/manager.py:1236:        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\r\nmodules/seedance/manager.py:1249:                        mv = layer_obj.get(\"model_variant\")\r\nmodules/seedance/manager.py:1260:            mv = params.get(\"model_variant\") or \"\"\r\nmodules/seedance/client.py:71:            \"model\": data.get(\"model\"),\nmodules/seedance/client.py:93:            \"model\": data.get(\"model\") if isinstance(data, dict) else None,\nmodules/seedance/client.py:505:        model_variant: Optional[str] = None,\nmodules/seedance/client.py:527:            model_variant: UI 侧模型变体（如 seedance_1_5_pro）\nmodules/seedance/client.py:539:        is_seedance_1_5_variant = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\nmodules/seedance/client.py:571:                    model_variant=model_variant,\nmodules/seedance/client.py:575:                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\nmodules/seedance/client.py:595:            is_seedance_1_5 = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\nmodules/seedance/client.py:697:            data = {\"model\": model, \"content\": content}\nmodules/seedance/client.py:747:                \"model\": data.get(\"model\"),\nmodules/seedance/client.py:772:                    \"model\": model,\nmodules/seedance/client.py:816:                        \"model\": model,\nmodules/seedance/client.py:930:                \"model\": result.get(\"model\"),","numLines":22},"sourceToolAssistantUUID":"c93656c7-be9f-4c0b-bb57-1008f1b9c5f7"}
{"parentUuid":"c6cca72e-d0f3-43cb-9921-7a06dc580156","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AirZtMRTnMRyd9UFCJTi3W","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me look at the specific code that shows how model names are saved. Let me check the exact lines in seedream manager around line 226 and in seedance manager:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":824,"cache_read_input_tokens":79946,"cache_creation":{"ephemeral_5m_input_tokens":824,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c981c8de-0ade-4833-a6a3-282c2d317331","timestamp":"2026-01-08T03:06:52.272Z"}
{"parentUuid":"c981c8de-0ade-4833-a6a3-282c2d317331","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AirZtMRTnMRyd9UFCJTi3W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MUjvfGNs6xNUuCnouLpFkf","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","limit":20,"offset":1268}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":824,"cache_read_input_tokens":79946,"cache_creation":{"ephemeral_5m_input_tokens":824,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"db55ff98-0031-419e-a46f-9d3cd8515ff0","timestamp":"2026-01-08T03:06:52.631Z"}
{"parentUuid":"db55ff98-0031-419e-a46f-9d3cd8515ff0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AirZtMRTnMRyd9UFCJTi3W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012A258v69BxDHkZNz9W916x","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","limit":45,"offset":1228}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":824,"cache_read_input_tokens":79946,"cache_creation":{"ephemeral_5m_input_tokens":824,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"6b6159f5-9605-487c-91ba-1a4504169c1f","timestamp":"2026-01-08T03:06:52.961Z"}
{"parentUuid":"db55ff98-0031-419e-a46f-9d3cd8515ff0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MUjvfGNs6xNUuCnouLpFkf","type":"tool_result","content":"  1268→        return payloads\n  1269→\n  1270→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1271→        provider = (self.client.last_provider() or \"\").lower()\n  1272→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1273→            return v4_5_model or v4_model\n  1274→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1275→            return v4_model\n  1276→        return default_model\n  1277→\n  1278→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1279→        cleaned: List[Dict[str, Any]] = []\n  1280→        for rec in assets or []:\n  1281→            rec.pop('_payload_b64', None)\n  1282→            rec.pop('_source_meta', None)\n  1283→            rec.pop('absolute_path', None)\n  1284→            cleaned.append({\n  1285→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1286→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1287→                'type': rec.get('type'),\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4e90daac-12ad-4834-a571-f2bd18bf4252","timestamp":"2026-01-08T03:06:53.119Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),","numLines":20,"startLine":1268,"totalLines":1520}},"sourceToolAssistantUUID":"db55ff98-0031-419e-a46f-9d3cd8515ff0"}
{"parentUuid":"6b6159f5-9605-487c-91ba-1a4504169c1f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012A258v69BxDHkZNz9W916x","type":"tool_result","content":"  1228→\n  1229→    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n  1230→        \"\"\"\n  1231→        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n  1232→\n  1233→        注意：\n  1234→        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n  1235→          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n  1236→        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n  1237→        \"\"\"\n  1238→        params = result.get(\"parameters\", {}) or {}\n  1239→\n  1240→        # 新三层参数结构优先：actual > sent > requested\n  1241→        if isinstance(params, dict):\n  1242→            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n  1243→                layer_obj = params.get(layer)\n  1244→                if isinstance(layer_obj, dict):\n  1245→                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n  1246→                    if cand:\n  1247→                        return str(cand)\n  1248→                    if layer == \"params_requested\":\n  1249→                        mv = layer_obj.get(\"model_variant\")\n  1250→                        if mv:\n  1251→                            return str(mv)\n  1252→\n  1253→        # 顶层 model（VideoService 会尽量补齐）\n  1254→        top = result.get(\"model\")\n  1255→        if top:\n  1256→            return str(top)\n  1257→\n  1258→        # 旧结构兼容：从 parameters 推断\n  1259→        if isinstance(params, dict):\n  1260→            mv = params.get(\"model_variant\") or \"\"\n  1261→            mt = params.get(\"model_type\") or \"\"\n  1262→            use_pro_model = params.get(\"use_pro_model\", True)\n  1263→\n  1264→            if mv:\n  1265→                return str(mv)\n  1266→            if isinstance(mt, str) and mt.strip():\n  1267→                return mt.strip()\n  1268→            if bool(use_pro_model):\n  1269→                return \"pro\"\n  1270→            return \"lite\"\n  1271→\n  1272→        return \"seedance\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7984b702-e4c2-46ee-9a92-8633e4dbdf8f","timestamp":"2026-01-08T03:06:53.119Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"\n    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n        \"\"\"\n        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n\n        注意：\n        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n        \"\"\"\n        params = result.get(\"parameters\", {}) or {}\n\n        # 新三层参数结构优先：actual > sent > requested\n        if isinstance(params, dict):\n            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n                layer_obj = params.get(layer)\n                if isinstance(layer_obj, dict):\n                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n                    if cand:\n                        return str(cand)\n                    if layer == \"params_requested\":\n                        mv = layer_obj.get(\"model_variant\")\n                        if mv:\n                            return str(mv)\n\n        # 顶层 model（VideoService 会尽量补齐）\n        top = result.get(\"model\")\n        if top:\n            return str(top)\n\n        # 旧结构兼容：从 parameters 推断\n        if isinstance(params, dict):\n            mv = params.get(\"model_variant\") or \"\"\n            mt = params.get(\"model_type\") or \"\"\n            use_pro_model = params.get(\"use_pro_model\", True)\n\n            if mv:\n                return str(mv)\n            if isinstance(mt, str) and mt.strip():\n                return mt.strip()\n            if bool(use_pro_model):\n                return \"pro\"\n            return \"lite\"\n\n        return \"seedance\"","numLines":45,"startLine":1228,"totalLines":1273}},"sourceToolAssistantUUID":"6b6159f5-9605-487c-91ba-1a4504169c1f"}
{"parentUuid":"7984b702-e4c2-46ee-9a92-8633e4dbdf8f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01B7yjC4XQbHadCF9gm8yjAC","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at the exact code where the models are stored in the parameters for both seedream and seedance. Let me check the lines around where parameters dict is created:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1606,"cache_read_input_tokens":80770,"cache_creation":{"ephemeral_5m_input_tokens":1606,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"c44fdddf-aa23-48b9-93d4-92f9ab703414","timestamp":"2026-01-08T03:06:58.809Z"}
{"parentUuid":"c44fdddf-aa23-48b9-93d4-92f9ab703414","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01B7yjC4XQbHadCF9gm8yjAC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FbBB5PWvPGs2ZNfZoCqMxu","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","limit":15,"offset":220}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1606,"cache_read_input_tokens":80770,"cache_creation":{"ephemeral_5m_input_tokens":1606,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"e0c94e57-7754-4499-871b-823d3ec07299","timestamp":"2026-01-08T03:06:59.410Z"}
{"parentUuid":"e0c94e57-7754-4499-871b-823d3ec07299","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01B7yjC4XQbHadCF9gm8yjAC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Tbv8wqxJgoCRZud57sUZJ6","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","limit":15,"offset":275}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1606,"cache_read_input_tokens":80770,"cache_creation":{"ephemeral_5m_input_tokens":1606,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"bda1ae78-f9f7-4b89-a932-4d13ebea6808","timestamp":"2026-01-08T03:06:59.696Z"}
{"parentUuid":"bda1ae78-f9f7-4b89-a932-4d13ebea6808","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01B7yjC4XQbHadCF9gm8yjAC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01169P3cF4inEDqDoWbw3LHt","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","limit":25,"offset":275}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1606,"cache_read_input_tokens":80770,"cache_creation":{"ephemeral_5m_input_tokens":1606,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"type":"assistant","uuid":"b5a860cf-c3be-4d96-abf4-4fc37b2966ec","timestamp":"2026-01-08T03:07:00.022Z"}
{"parentUuid":"e0c94e57-7754-4499-871b-823d3ec07299","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FbBB5PWvPGs2ZNfZoCqMxu","type":"tool_result","content":"   220→                            \"size\": size,\n   221→                            \"guidance_scale\": guidance_scale,\n   222→                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   223→                            **(({\"seed\": seed} if seedream_provider is None else {})),\n   224→                            \"response_format\": \"url\",\n   225→                            \"watermark\": False,\n   226→                            \"model\": self._resolve_model_id(\n   227→                                \"doubao-seedream-3-0-t2i-250415\",\n   228→                                \"doubao-seedream-4-0-250828\",\n   229→                                \"doubao-seedream-4-5-251128\",\n   230→                            ),\n   231→                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   232→                            \"sequential_mode\": True,\n   233→                            \"group_index\": idx + 1,\n   234→                            \"group_total\": total_images,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"82f0b982-264c-4350-8ff8-63a3ca9bf10e","timestamp":"2026-01-08T03:07:00.124Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                            **(({\"seed\": seed} if seedream_provider is None else {})),\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,","numLines":15,"startLine":220,"totalLines":1520}},"sourceToolAssistantUUID":"e0c94e57-7754-4499-871b-823d3ec07299"}
{"parentUuid":"bda1ae78-f9f7-4b89-a932-4d13ebea6808","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Tbv8wqxJgoCRZud57sUZJ6","type":"tool_result","content":"   275→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   276→                \"parameters\": {\n   277→                    \"size\": size,\n   278→                    \"guidance_scale\": guidance_scale,\n   279→                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n   280→                    **(({\"seed\": seed} if seedream_provider is None else {})),\n   281→                    \"response_format\": \"url\",  # 固定值\n   282→                    \"watermark\": False,  # 固定值\n   283→                    \"model\": self._resolve_model_id(\n   284→                        \"doubao-seedream-3-0-t2i-250415\",\n   285→                        \"doubao-seedream-4-0-250828\",\n   286→                        \"doubao-seedream-4-5-251128\",\n   287→                    ),\n   288→                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   289→                },\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e5008a42-95d2-41a4-bdde-384363571206","timestamp":"2026-01-08T03:07:00.125Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    # seed 仅 3.0 支持，4.0/4.5 不保存以免复用时误导\n                    **(({\"seed\": seed} if seedream_provider is None else {})),\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    ),\n                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                },","numLines":15,"startLine":275,"totalLines":1520}},"sourceToolAssistantUUID":"bda1ae78-f9f7-4b89-a932-4d13ebea6808"}
{"parentUuid":"b5a860cf-c3be-4d96-abf4-4fc37b2966ec","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01169P3cF4inEDqDoWbw3LHt","type":"tool_result","content":"   275→            \"params_sent\": params_sent,\n   276→            \"success\": True,\n   277→            \"type\": \"image_to_video\",\n   278→            \"input_image\": image_path,\n   279→            \"status\": \"pending\",\n   280→            \"parameters\": {\n   281→                \"prompt\": prompt,\n   282→                \"duration\": duration,\n   283→                \"seed\": (None if seed == -1 else seed),\n   284→                \"watermark\": watermark_enabled,\n   285→                \"resolution_grade\": resolution_grade,\n   286→                \"ratio\": ratio,\n   287→                \"fps\": fps,\n   288→                \"camera_fixed\": bool(camera_fixed),\n   289→                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n   290→                \"first_frame\": stored_first_frame,\n   291→                \"last_frame\": stored_last_frame,\n   292→                \"image_path\": stored_image_path,\n   293→            },\n   294→            \"created_at\": datetime.now().isoformat(),\n   295→        }\n   296→\n   297→        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   298→        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n   299→        result['reference_assets'] = sanitized_refs\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"02102a49-405f-4e52-be5c-a3ac3f8f0ebb","timestamp":"2026-01-08T03:07:00.125Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"            \"params_sent\": params_sent,\n            \"success\": True,\n            \"type\": \"image_to_video\",\n            \"input_image\": image_path,\n            \"status\": \"pending\",\n            \"parameters\": {\n                \"prompt\": prompt,\n                \"duration\": duration,\n                \"seed\": (None if seed == -1 else seed),\n                \"watermark\": watermark_enabled,\n                \"resolution_grade\": resolution_grade,\n                \"ratio\": ratio,\n                \"fps\": fps,\n                \"camera_fixed\": bool(camera_fixed),\n                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n                \"first_frame\": stored_first_frame,\n                \"last_frame\": stored_last_frame,\n                \"image_path\": stored_image_path,\n            },\n            \"created_at\": datetime.now().isoformat(),\n        }\n\n        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n        result['reference_assets'] = sanitized_refs","numLines":25,"startLine":275,"totalLines":1273}},"sourceToolAssistantUUID":"b5a860cf-c3be-4d96-abf4-4fc37b2966ec"}
{"parentUuid":"02102a49-405f-4e52-be5c-a3ac3f8f0ebb","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FDa8jzkGTNQSPp4rwDks13","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check where the model is saved in the database for video generation. Let me look at the _save_video_locally method in seedance:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1946,"cache_read_input_tokens":82376,"cache_creation":{"ephemeral_5m_input_tokens":1946,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"b82c51a4-7109-4904-a024-2537e53028be","timestamp":"2026-01-08T03:07:05.581Z"}
{"parentUuid":"b82c51a4-7109-4904-a024-2537e53028be","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FDa8jzkGTNQSPp4rwDks13","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0139xvK27RnXDnoVE7W8WYSw","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","limit":30,"offset":674}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1946,"cache_read_input_tokens":82376,"cache_creation":{"ephemeral_5m_input_tokens":1946,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"df91cf35-06cd-43ce-af4b-461435667196","timestamp":"2026-01-08T03:07:06.039Z"}
{"parentUuid":"df91cf35-06cd-43ce-af4b-461435667196","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0139xvK27RnXDnoVE7W8WYSw","type":"tool_result","content":"   674→            # 准备元数据（适配UnifiedStorageManager的格式）\n   675→            metadata = {\n   676→                'generation_id': task_id,\n   677→                'task_id': task_id,\n   678→                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n   679→                'parameters': {\n   680→                    **result.get('parameters', {}),\n   681→                    # 设置文件大小（在保存前就设置，确保写入数据库）\n   682→                    'file_size': len(video_data),\n   683→                    # 回填真实视频信息\n   684→                    **({} if actual_width is None else {'width': actual_width}),\n   685→                    **({} if actual_height is None else {'height': actual_height}),\n   686→                    **({} if actual_fps is None else {'fps': actual_fps}),\n   687→                    **({} if actual_duration is None else {'duration': actual_duration}),\n   688→                    # 透传fallback信息\n   689→                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n   690→                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n   691→                },\n   692→                'model': self._get_display_model_name(result),\n   693→                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n   694→                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n   695→                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n   696→                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n   697→                'generation_time': result.get('generation_time', 0),\n   698→                'status': result.get('status', 'completed'),\n   699→                'batch_id': result.get('batch_id', '')\n   700→            }\n   701→\n   702→            # 使用统一存储管理器保存文件\n   703→            save_result = self.storage_manager.save_content_file(\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a82af786-6f80-432c-b2bd-965797f7bf94","timestamp":"2026-01-08T03:07:06.292Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"            # 准备元数据（适配UnifiedStorageManager的格式）\n            metadata = {\n                'generation_id': task_id,\n                'task_id': task_id,\n                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n                'parameters': {\n                    **result.get('parameters', {}),\n                    # 设置文件大小（在保存前就设置，确保写入数据库）\n                    'file_size': len(video_data),\n                    # 回填真实视频信息\n                    **({} if actual_width is None else {'width': actual_width}),\n                    **({} if actual_height is None else {'height': actual_height}),\n                    **({} if actual_fps is None else {'fps': actual_fps}),\n                    **({} if actual_duration is None else {'duration': actual_duration}),\n                    # 透传fallback信息\n                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n                },\n                'model': self._get_display_model_name(result),\n                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n                'generation_time': result.get('generation_time', 0),\n                'status': result.get('status', 'completed'),\n                'batch_id': result.get('batch_id', '')\n            }\n\n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(","numLines":30,"startLine":674,"totalLines":1273}},"sourceToolAssistantUUID":"df91cf35-06cd-43ce-af4b-461435667196"}
{"parentUuid":"a82af786-6f80-432c-b2bd-965797f7bf94","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0139rC7ZrKHR4ht16jjk3CZB","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now I have a comprehensive understanding. Let me also verify the flow by examining the repository manager to understand how the model field is actually persisted:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":917,"cache_read_input_tokens":84322,"cache_creation":{"ephemeral_5m_input_tokens":917,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e2c80223-cb7e-40f2-9768-2f3b5931a8a4","timestamp":"2026-01-08T03:07:11.760Z"}
{"parentUuid":"e2c80223-cb7e-40f2-9768-2f3b5931a8a4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0139rC7ZrKHR4ht16jjk3CZB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017GfTafVaWfAR5gKadCFTmf","name":"Bash","input":{"command":"grep -n \"def add_content\\|content_type\\|model\" /Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py | head -40","description":"Check repository manager content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":917,"cache_read_input_tokens":84322,"cache_creation":{"ephemeral_5m_input_tokens":917,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"bfb28545-35da-426c-94c6-22bd12b4b31b","timestamp":"2026-01-08T03:07:12.319Z"}
{"parentUuid":"bfb28545-35da-426c-94c6-22bd12b4b31b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017GfTafVaWfAR5gKadCFTmf","type":"tool_result","content":"181:    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n187:            normalized_record = self._normalize_record(record, content_type)\n200:    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n214:        ctype = item.get('content_type') or content_type or ''\n219:        item['content_type'] = ctype\n392:    def add_content(self, content_id: str, content_type: str, \n399:            content_type: 内容类型 (image/video/audio/chat)\n407:            normalized_type = (content_type or '').lower()\n520:            content_type = raw.get('content_type') or 'image'\n521:            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n546:        content_type = 'videos' if normalized_type == 'video' else 'images'\n548:            raw = self.sqlite_handler.get_records_by_status(content_type, statuses, limit=limit) or []\n584:                content_type = 'images' if normalized_type == 'image' else 'videos'\n585:                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n631:                content_type = 'images' if normalized_type == 'image' else 'videos'\n632:                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n735:                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n755:                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n933:                if not resolved and record.get('content_type') == 'videos':\n961:    def search_content(self, query: str, content_type: Optional[str] = None,\n969:            content_type: 内容类型过滤\n986:            if content_type:\n987:                ct = content_type.lower()","is_error":false}]},"uuid":"656ce7ea-0b5e-4c72-88e2-44377894fe44","timestamp":"2026-01-08T03:07:12.494Z","toolUseResult":{"stdout":"181:    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n187:            normalized_record = self._normalize_record(record, content_type)\n200:    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n214:        ctype = item.get('content_type') or content_type or ''\n219:        item['content_type'] = ctype\n392:    def add_content(self, content_id: str, content_type: str, \n399:            content_type: 内容类型 (image/video/audio/chat)\n407:            normalized_type = (content_type or '').lower()\n520:            content_type = raw.get('content_type') or 'image'\n521:            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n546:        content_type = 'videos' if normalized_type == 'video' else 'images'\n548:            raw = self.sqlite_handler.get_records_by_status(content_type, statuses, limit=limit) or []\n584:                content_type = 'images' if normalized_type == 'image' else 'videos'\n585:                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n631:                content_type = 'images' if normalized_type == 'image' else 'videos'\n632:                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n735:                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n755:                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n933:                if not resolved and record.get('content_type') == 'videos':\n961:    def search_content(self, query: str, content_type: Optional[str] = None,\n969:            content_type: 内容类型过滤\n986:            if content_type:\n987:                ct = content_type.lower()","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"bfb28545-35da-426c-94c6-22bd12b4b31b"}
{"parentUuid":"656ce7ea-0b5e-4c72-88e2-44377894fe44","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014GKsf9Yun7PdnmFu1nRupK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Uqg8tA9xj7QzecZCFUjqyt","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","limit":30,"offset":390}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":797,"cache_read_input_tokens":85239,"cache_creation":{"ephemeral_5m_input_tokens":797,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"type":"assistant","uuid":"dfcc572e-1567-446d-8581-4c022a3c6413","timestamp":"2026-01-08T03:07:16.817Z"}
{"parentUuid":"dfcc572e-1567-446d-8581-4c022a3c6413","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Uqg8tA9xj7QzecZCFUjqyt","type":"tool_result","content":"   390→        return (created_dt, file_id)\n   391→\n   392→    def add_content(self, content_id: str, content_type: str, \n   393→                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n   394→        \"\"\"\n   395→        添加内容到仓库\n   396→        \n   397→        Args:\n   398→            content_id: 内容唯一标识\n   399→            content_type: 内容类型 (image/video/audio/chat)\n   400→            metadata: 内容元数据\n   401→            auto_tag: 是否自动生成标签\n   402→        \n   403→        Returns:\n   404→            是否添加成功\n   405→        \"\"\"\n   406→        try:\n   407→            normalized_type = (content_type or '').lower()\n   408→            if normalized_type in {'image', 'images'}:\n   409→                storage_type = 'images'\n   410→            elif normalized_type in {'video', 'videos'}:\n   411→                storage_type = 'videos'\n   412→            else:\n   413→                storage_type = normalized_type or 'unknown'\n   414→            status = metadata.get('status', 'unknown')\n   415→            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n   416→            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n   417→            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n   418→            return result\n   419→        except Exception as e:\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"846a9cf9-afea-452f-99b2-04be0df112dc","timestamp":"2026-01-08T03:07:16.909Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","content":"        return (created_dt, file_id)\n\n    def add_content(self, content_id: str, content_type: str, \n                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n        \"\"\"\n        添加内容到仓库\n        \n        Args:\n            content_id: 内容唯一标识\n            content_type: 内容类型 (image/video/audio/chat)\n            metadata: 内容元数据\n            auto_tag: 是否自动生成标签\n        \n        Returns:\n            是否添加成功\n        \"\"\"\n        try:\n            normalized_type = (content_type or '').lower()\n            if normalized_type in {'image', 'images'}:\n                storage_type = 'images'\n            elif normalized_type in {'video', 'videos'}:\n                storage_type = 'videos'\n            else:\n                storage_type = normalized_type or 'unknown'\n            status = metadata.get('status', 'unknown')\n            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n            return result\n        except Exception as e:","numLines":30,"startLine":390,"totalLines":1145}},"sourceToolAssistantUUID":"dfcc572e-1567-446d-8581-4c022a3c6413"}
{"parentUuid":"846a9cf9-afea-452f-99b2-04be0df112dc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"e5cd2248-a4a1-4a43-bdad-e4cd37a2a649","version":"2.1.1","gitBranch":"main","agentId":"a28e04c","slug":"immutable-weaving-horizon","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QM2qNoT6mJ5g1ZDdTqK5yy","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now I have all the information I need. Let me create a comprehensive report on the findings.\n\n## 分析报告：图片与视频模式的数据库存储逻辑\n\n### 存储路径概览\n\n两者都使用 **SQLite 数据库**（`repository/gemeng.db`）来存储生成记录，通过统一的 `UnifiedStorageManagerV2` 和 `RepositoryManager` 处理持久化。\n\n---\n\n## 1. **图片模式（Seedream）模型名称存储**\n\n### 存储位置\n- **文件**: `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py`\n- **方法**: `generate_text_to_image()` 和 `generate_image_to_image()`\n\n### 存储格式\n\n#### 文生图 (Text-to-Image)\n**行号 226-231（单图模式）：**\n```python\n\"parameters\": {\n    \"size\": size,\n    \"guidance_scale\": guidance_scale,\n    \"response_format\": \"url\",\n    \"watermark\": False,\n    \"model\": self._resolve_model_id(\n        \"doubao-seedream-3-0-t2i-250415\",      # 默认 3.0 版本\n        \"doubao-seedream-4-0-250828\",          # v4 版本\n        \"doubao-seedream-4-5-251128\",          # v4.5 版本\n    ),\n    \"model_variant\": model_variant,             # 保存 UI 变体名称（如 'seedream_v4'）\n    ...\n}\n```\n\n**关键发现：**\n- 存储的是 **完整模型 ID**（如 `doubao-seedream-3-0-t2i-250415`）\n- 同时在 `model_variant` 字段存储简短名称（如 `seedream_v4`），用于复用参数\n\n### Model ID 解析逻辑\n\n**行号 1270-1276（_resolve_model_id 方法）：**\n```python\ndef _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n    provider = (self.client.last_provider() or \"\").lower()\n    if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n        return v4_5_model or v4_model\n    if provider in {\"volc_v4\", \"volcengine_v4\"}:\n        return v4_model\n    return default_model\n```\n\n**规则：**\n1. 根据最后使用的 provider 判断\n2. `volc_v4_5` → 返回 `doubao-seedream-4-5-251128`\n3. `volc_v4` → 返回 `doubao-seedream-4-0-250828`\n4. 其他（默认 v3）→ 返回 `doubao-seedream-3-0-t2i-250415`\n\n---\n\n## 2. **视频模式（Seedance）模型名称存储**\n\n### 存储位置\n- **文件**: `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py`\n- **方法**: `_save_video_locally()` → 行号 692\n\n### 存储格式\n\n**行号 674-700（元数据构建）：**\n```python\nmetadata = {\n    'generation_id': task_id,\n    'task_id': task_id,\n    'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n    'parameters': {\n        **result.get('parameters', {}),\n        # ... 其他参数 ...\n    },\n    'model': self._get_display_model_name(result),  # <- 关键：调用此方法获取模型名\n    'duration': ...,\n    'fps': ...,\n    'status': 'completed'\n}\n```\n\n### Model Name 提取逻辑\n\n**行号 1229-1272（_get_display_model_name 方法）：**\n\n```python\ndef _get_display_model_name(self, result: Dict[str, Any]) -> str:\n    \"\"\"获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）\"\"\"\n    params = result.get(\"parameters\", {}) or {}\n    \n    # 1. 新三层参数结构优先：actual > sent > requested\n    if isinstance(params, dict):\n        for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n            layer_obj = params.get(layer)\n            if isinstance(layer_obj, dict):\n                cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n                if cand:\n                    return str(cand)\n                if layer == \"params_requested\":\n                    mv = layer_obj.get(\"model_variant\")\n                    if mv:\n                        return str(mv)\n    \n    # 2. 顶层 model（VideoService 会尽量补齐）\n    top = result.get(\"model\")\n    if top:\n        return str(top)\n    \n    # 3. 旧结构兼容：从 parameters 推断\n    if isinstance(params, dict):\n        mv = params.get(\"model_variant\") or \"\"\n        mt = params.get(\"model_type\") or \"\"\n        use_pro_model = params.get(\"use_pro_model\", True)\n        \n        if mv:\n            return str(mv)\n        if isinstance(mt, str) and mt.strip():\n            return mt.strip()\n        if bool(use_pro_model):\n            return \"pro\"\n        return \"lite\"\n    \n    return \"seedance\"\n```\n\n**关键发现：**\n- 优先顺序：`params_actual/sent/requested` > 顶层 `model` > `model_variant` > `model_type` > 回退\n- 可能存储 **完整模型 ID**（如 `doubao-seedance-1-5-pro-251215`）\n- 也可能存储 **简短名称**（如 `seedance_1_5_pro`、`pro`、`lite`）\n- **灵活性更强**，但存储格式不一致\n\n---\n\n## 3. **数据库持久化流程对比**\n\n### Seedream（图片）\n```\ngenerate_text_to_image()\n    ↓\nresult[\"parameters\"][\"model\"] = self._resolve_model_id(...)  // 完整 ID\n    ↓\n_save_image_locally(result)\n    ↓\nstorage_manager.save_content_file(metadata)\n    ↓\nUnifiedStorageManagerV2._persist_record(model=..., parameters=...)\n    ↓\nSQLiteHandler.add_record()\n    ↓\n✅ 数据库存储：model 字段 = \"doubao-seedream-3-0-t2i-250415\"（等）\n```\n\n### Seedance（视频）\n```\ngenerate_video()\n    ↓\n_save_video_locally(result)\n    ↓\nmetadata['model'] = self._get_display_model_name(result)  // 智能提取（可变）\n    ↓\nstorage_manager.save_content_file(metadata)\n    ↓\nUnifiedStorageManagerV2._persist_record(model=..., parameters=...)\n    ↓\nSQLiteHandler.add_record()\n    ↓\n✅ 数据库存储：model 字段 = \"pro\" 或 \"seedance_1_5_pro\" 或完整 ID（取决于提取逻辑）\n```\n\n---\n\n## 4. **存储格式一致性对比**\n\n### 图片模式（Seedream）\n\n| 字段 | 存储值 | 格式 |\n|------|------|------|\n| `parameters.model` | `doubao-seedream-3-0-t2i-250415` | **完整模型 ID** |\n| `parameters.model_variant` | `seedream_v4` 或 `seedream_v4_5` | 简短名称 |\n| 数据库 `model` 字段 | `doubao-seedream-3-0-t2i-250415` | **完整模型 ID** |\n\n**特点：** ✅ 一致、规范、完整\n\n### 视频模式（Seedance）\n\n| 字段 | 存储值 | 格式 |\n|------|------|------|\n| `parameters.model_variant` | `seedance_1_5_pro` | 简短名称 |\n| 数据库 `model` 字段 | 可能是以下任何一个：<br>- `doubao-seedance-1-5-pro-251215`（完整 ID）<br>- `seedance_1_5_pro`（UI 变体）<br>- `pro` 或 `lite`（回退值）| **不一致** |\n\n**特点：** ⚠️ 不一致、灵活但容易产生歧义\n\n---\n\n## 5. **关键差异分析**\n\n### 差异 1：模型标识格式\n- **Seedream**: 统一使用完整模型 ID（如 `doubao-seedream-4-5-251128`）\n- **Seedance**: 使用多种格式（完整 ID、UI 变体、简短名称）\n\n### 差异 2：存储位置\n- **Seedream**: 完整 ID 存储在 `parameters.model`，同时备份 `model_variant`\n- **Seedance**: 完整 ID 可能在 `parameters.model` 中，但数据库存储取决于 `_get_display_model_name()` 的提取逻辑\n\n### 差异 3：回溯成本\n- **Seedream**: 数据库存储完整 ID，可直接溯源到具体模型版本\n- **Seedance**: 数据库存储可能的简短名称（如 `pro`），需反向映射到完整 ID，回溯成本高\n\n---\n\n## 6. **建议修复方案**\n\n为了使两者格式一致，建议对 Seedance 做如下调整：\n\n1. **统一数据库存储格式**：确保 `model` 字段始终存储完整模型 ID\n2. **增加备用字段**：在 `parameters` 中明确存储 `model_variant`（类似 Seedream）\n3. **简化提取逻辑**：`_get_display_model_name()` 优先返回完整 ID，仅在无法获取时回退\n\n---\n\n## 总结\n\n| 维度 | Seedream（图片） | Seedance（视频） |\n|------|-----------------|-----------------|\n| **数据库模型 ID** | 完整 ID | 可变（ID/变体/简称） |\n| **参数冗余度** | 高（同时存储 ID + variant） | 低（主要依赖 variant） |\n| **一致性** | ✅ 强 | ⚠️ 弱 |\n| **可维护性** | ✅ 高 | ⚠️ 中等 |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":925,"cache_read_input_tokens":86036,"cache_creation":{"ephemeral_5m_input_tokens":925,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"124d85e5-e1b0-4b6a-99e0-41b9b0135ff0","timestamp":"2026-01-08T03:07:43.821Z"}
