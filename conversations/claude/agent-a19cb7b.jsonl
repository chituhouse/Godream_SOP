{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":"探索 modules/seedream 和 modules/seedance 的实现结构：\n1. 找到这两个模块的主要文件\n2. 了解它们如何封装 API 调用\n3. 查看接口设计（初始化、参数传递、响应处理）\n4. 识别哪些代码是火山引擎特定的，哪些是通用的\n5. 看看是否有抽象层或接口定义\n\n重点关注代码的耦合程度和可扩展性。"},"uuid":"7bdbbda4-1ce8-4a06-aa0d-3c31eff8bb2c","timestamp":"2026-01-05T11:50:53.878Z"}
{"parentUuid":"7bdbbda4-1ce8-4a06-aa0d-3c31eff8bb2c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RfV6u2ksXFUUTs7cpkWoNs","type":"message","role":"assistant","content":[{"type":"text","text":"I'll explore the seedream and seedance modules to understand their implementation structure, API encapsulation, and extensibility. Let me start by finding and analyzing these modules."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21321,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21321,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"ae123f9b-51c5-4af0-9c53-bafe25e4f4ff","timestamp":"2026-01-05T11:50:56.392Z"}
{"parentUuid":"ae123f9b-51c5-4af0-9c53-bafe25e4f4ff","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RfV6u2ksXFUUTs7cpkWoNs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PH7aEdFmEihjrKPpkSvYf5","name":"Glob","input":{"pattern":"modules/seedream/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21321,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21321,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"264ac1a3-ee5e-43b3-81c2-4f5e6a879069","timestamp":"2026-01-05T11:50:56.740Z"}
{"parentUuid":"264ac1a3-ee5e-43b3-81c2-4f5e6a879069","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RfV6u2ksXFUUTs7cpkWoNs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017vRBUzpknPu95P9tu9iQXU","name":"Glob","input":{"pattern":"modules/seedance/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21321,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21321,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"6d0e7192-ec7f-4c31-aaff-401ae4bc0e2b","timestamp":"2026-01-05T11:50:56.821Z"}
{"parentUuid":"6d0e7192-ec7f-4c31-aaff-401ae4bc0e2b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RfV6u2ksXFUUTs7cpkWoNs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016KPxw8z1VfY3BYq16DYimZ","name":"Bash","input":{"command":"find /Users/yunchang/Documents/GitHub/gemeng2/modules -type f -name \"*.py\" | head -20","description":"List all Python files in modules directory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21321,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21321,"ephemeral_1h_input_tokens":0},"output_tokens":222,"service_tier":"standard"}},"type":"assistant","uuid":"39537a7e-e467-448e-989f-e22e2f6245a4","timestamp":"2026-01-05T11:50:57.285Z"}
{"parentUuid":"39537a7e-e467-448e-989f-e22e2f6245a4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PH7aEdFmEihjrKPpkSvYf5","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}]},"uuid":"b2211a03-3b5f-47fd-a271-4402781136e0","timestamp":"2026-01-05T11:50:57.352Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"],"durationMs":34,"numFiles":3,"truncated":false}}
{"parentUuid":"b2211a03-3b5f-47fd-a271-4402781136e0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017vRBUzpknPu95P9tu9iQXU","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}]},"uuid":"499fc367-3a57-4bd1-a2d1-745246b2ccda","timestamp":"2026-01-05T11:50:57.353Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"],"durationMs":35,"numFiles":4,"truncated":false}}
{"parentUuid":"499fc367-3a57-4bd1-a2d1-745246b2ccda","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016KPxw8z1VfY3BYq16DYimZ","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4_5.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/safe_requests.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/progress_tracker.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/storage_manager_factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py","is_error":false}]},"uuid":"2a785012-72cd-4044-9e7b-993747ec19b4","timestamp":"2026-01-05T11:50:57.405Z","toolUseResult":{"stdout":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/csv_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4_5.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/safe_requests.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/utils/progress_tracker.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/storage_manager_factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/storage/unified_storage_manager_v2.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"2a785012-72cd-4044-9e7b-993747ec19b4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"text","text":"Good! Now let me read the main files from both modules to understand their structure:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9ed5ece3-4bf8-48e8-b289-d2d2b75ee326","timestamp":"2026-01-05T11:51:00.378Z"}
{"parentUuid":"9ed5ece3-4bf8-48e8-b289-d2d2b75ee326","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015ggYzH8urLRkBAWtcJc6Zi","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"50f72173-21f8-4435-b911-20ae080c82d9","timestamp":"2026-01-05T11:51:00.538Z"}
{"parentUuid":"50f72173-21f8-4435-b911-20ae080c82d9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GJJ8s7FCQmdkuDVfLT2bqC","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"bd56264d-a5ad-48a0-b533-7af02a6c3c5e","timestamp":"2026-01-05T11:51:00.736Z"}
{"parentUuid":"bd56264d-a5ad-48a0-b533-7af02a6c3c5e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JHYqJWzKUfJBcFjkXtE6Jk","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"56b0ea21-5326-49ef-a6ac-d06081307b29","timestamp":"2026-01-05T11:51:00.915Z"}
{"parentUuid":"56b0ea21-5326-49ef-a6ac-d06081307b29","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015iVSoTu1QAokyFxiEJhwry","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"0fe100ab-fb9b-4552-bd14-3ea670bff4e1","timestamp":"2026-01-05T11:51:01.152Z"}
{"parentUuid":"0fe100ab-fb9b-4552-bd14-3ea670bff4e1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BeJgFubTKxFPX2YC3NoN2b","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"8dad2eee-0e91-4000-8199-7a26e42fdb5c","timestamp":"2026-01-05T11:51:01.429Z"}
{"parentUuid":"8dad2eee-0e91-4000-8199-7a26e42fdb5c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F4vGA5CWbMWJfw9GsfVYpo","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"4e63b3ed-d2bf-4453-bb94-e84e12569d94","timestamp":"2026-01-05T11:51:01.537Z"}
{"parentUuid":"4e63b3ed-d2bf-4453-bb94-e84e12569d94","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013Rwinc7ZjaA1oHqPHyTBtD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RMm6CUbuxeeRSfwknFgyMK","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1238,"cache_read_input_tokens":21321,"cache_creation":{"ephemeral_5m_input_tokens":1238,"ephemeral_1h_input_tokens":0},"output_tokens":441,"service_tier":"standard"}},"type":"assistant","uuid":"b9ec9887-82bc-4a5d-8bc6-fd0f4610adfc","timestamp":"2026-01-05T11:51:01.773Z"}
{"parentUuid":"b9ec9887-82bc-4a5d-8bc6-fd0f4610adfc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015ggYzH8urLRkBAWtcJc6Zi","type":"tool_result","content":"     1→# Seedream图像生成模块\n     2→# 基于火山引擎Seedream3.0的图像生成功能\n     3→\n     4→from .client import SeedreamClient\n     5→from .manager import SeedreamManager\n     6→\n     7→__version__ = \"0.1.4\"\n     8→__description__ = \"火山引擎Seedream3.0图像生成模块\"\n     9→\n    10→# 支持的功能\n    11→FEATURES = {\n    12→    \"text_to_image\": {\n    13→        \"name\": \"文生图\",\n    14→        \"description\": \"根据文字描述生成图像\",\n    15→        \"model\": \"doubao-seedream-3-0-t2i-250415\",\n    16→        \"supported_sizes\": [\n    17→            # 按常见比例的最大像素组合（范围 512–2048）\n    18→            \"2048x2048\",   # 1:1\n    19→            \"2048x1536\",   # 4:3\n    20→            \"1536x2048\",   # 3:4\n    21→            \"2048x1152\",   # 16:9\n    22→            \"1152x2048\",   # 9:16\n    23→            \"1920x1280\",   # 3:2（最大常用）\n    24→            \"1280x1920\",   # 2:3（最大常用）\n    25→            \"1792x768\",    # 21:9（最大常用，64 对齐）\n    26→        ],\n    27→    },\n    28→    \"image_to_image\": {\n    29→        \"name\": \"图生图\",\n    30→        \"description\": \"基于现有图像进行编辑和变换\",\n    31→        \"model\": \"doubao-seededit-3-0-i2i-250628\",\n    32→        \"supported_formats\": [\"jpeg\", \"png\"],\n    33→        \"max_size_mb\": 10,\n    34→    },\n    35→}\n    36→\n    37→# 默认参数\n    38→DEFAULT_PARAMS = {\n    39→    \"text_to_image\": {\n    40→        \"size\": \"1024x1024\",\n    41→        \"guidance_scale\": 2.5,\n    42→        \"seed\": -1,\n    43→        \"watermark\": False,  # 正式版固定禁用水印\n    44→        \"response_format\": \"url\",\n    45→    },\n    46→    \"image_to_image\": {\n    47→        \"guidance_scale\": 5.5,\n    48→        \"seed\": -1,\n    49→        \"size\": \"adaptive\",\n    50→        \"watermark\": False,  # 正式版固定禁用水印\n    51→        \"response_format\": \"url\",\n    52→    },\n    53→}\n    54→\n    55→__all__ = [\"SeedreamClient\", \"SeedreamManager\", \"FEATURES\", \"DEFAULT_PARAMS\"]\n    56→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b56eb80f-389d-4a49-8523-34f88b86684f","timestamp":"2026-01-05T11:51:01.820Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/__init__.py","content":"# Seedream图像生成模块\n# 基于火山引擎Seedream3.0的图像生成功能\n\nfrom .client import SeedreamClient\nfrom .manager import SeedreamManager\n\n__version__ = \"0.1.4\"\n__description__ = \"火山引擎Seedream3.0图像生成模块\"\n\n# 支持的功能\nFEATURES = {\n    \"text_to_image\": {\n        \"name\": \"文生图\",\n        \"description\": \"根据文字描述生成图像\",\n        \"model\": \"doubao-seedream-3-0-t2i-250415\",\n        \"supported_sizes\": [\n            # 按常见比例的最大像素组合（范围 512–2048）\n            \"2048x2048\",   # 1:1\n            \"2048x1536\",   # 4:3\n            \"1536x2048\",   # 3:4\n            \"2048x1152\",   # 16:9\n            \"1152x2048\",   # 9:16\n            \"1920x1280\",   # 3:2（最大常用）\n            \"1280x1920\",   # 2:3（最大常用）\n            \"1792x768\",    # 21:9（最大常用，64 对齐）\n        ],\n    },\n    \"image_to_image\": {\n        \"name\": \"图生图\",\n        \"description\": \"基于现有图像进行编辑和变换\",\n        \"model\": \"doubao-seededit-3-0-i2i-250628\",\n        \"supported_formats\": [\"jpeg\", \"png\"],\n        \"max_size_mb\": 10,\n    },\n}\n\n# 默认参数\nDEFAULT_PARAMS = {\n    \"text_to_image\": {\n        \"size\": \"1024x1024\",\n        \"guidance_scale\": 2.5,\n        \"seed\": -1,\n        \"watermark\": False,  # 正式版固定禁用水印\n        \"response_format\": \"url\",\n    },\n    \"image_to_image\": {\n        \"guidance_scale\": 5.5,\n        \"seed\": -1,\n        \"size\": \"adaptive\",\n        \"watermark\": False,  # 正式版固定禁用水印\n        \"response_format\": \"url\",\n    },\n}\n\n__all__ = [\"SeedreamClient\", \"SeedreamManager\", \"FEATURES\", \"DEFAULT_PARAMS\"]\n","numLines":56,"startLine":1,"totalLines":56}}}
{"parentUuid":"b56eb80f-389d-4a49-8523-34f88b86684f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015iVSoTu1QAokyFxiEJhwry","type":"tool_result","content":"     1→﻿from .client import SeedanceClient\n     2→from .manager import SeedanceManager\n     3→\n     4→__all__ = [\n     5→    'SeedanceClient',\n     6→    'SeedanceManager',\n     7→]\n     8→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"01287052-522b-4555-aced-2fb0cda75f57","timestamp":"2026-01-05T11:51:01.821Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py","content":"﻿from .client import SeedanceClient\nfrom .manager import SeedanceManager\n\n__all__ = [\n    'SeedanceClient',\n    'SeedanceManager',\n]\n","numLines":8,"startLine":1,"totalLines":8}}}
{"parentUuid":"01287052-522b-4555-aced-2fb0cda75f57","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RMm6CUbuxeeRSfwknFgyMK","type":"tool_result","content":"     1→# Seedance配置管理\n     2→# 定义模型、状态和配置常量\n     3→\n     4→from enum import Enum\n     5→from typing import Dict, List\n     6→\n     7→\n     8→class SeedanceModels(Enum):\n     9→    \"\"\"Seedance模型枚举\"\"\"\n    10→    PRO_1_5 = \"doubao-seedance-1-5-pro-251215\"\n    11→    PRO = \"doubao-seedance-1-0-pro-250528\"\n    12→    PRO_FAST = \"doubao-seedance-1-0-pro-fast-251015\"\n    13→    LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    14→    LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n    15→\n    16→\n    17→class TaskStatus(Enum):\n    18→    \"\"\"任务状态枚举\"\"\"\n    19→    PENDING = \"pending\"\n    20→    QUEUED = \"queued\"\n    21→    PROCESSING = \"processing\"\n    22→    RUNNING = \"running\"\n    23→    SUCCEEDED = \"succeeded\"\n    24→    FAILED = \"failed\"\n    25→    CANCELLED = \"cancelled\"\n    26→    EXPIRED = \"expired\"\n    27→    \n    28→    @classmethod\n    29→    def is_terminal(cls, status: str) -> bool:\n    30→        \"\"\"判断是否为终态\"\"\"\n    31→        return status in [\n    32→            cls.SUCCEEDED.value,\n    33→            cls.FAILED.value,\n    34→            cls.CANCELLED.value,\n    35→            cls.EXPIRED.value,\n    36→        ]\n    37→    \n    38→    @classmethod\n    39→    def is_active(cls, status: str) -> bool:\n    40→        \"\"\"判断是否为活跃状态\"\"\"\n    41→        return status in [\n    42→            cls.PENDING.value,\n    43→            cls.QUEUED.value,\n    44→            cls.PROCESSING.value,\n    45→            cls.RUNNING.value,\n    46→        ]\n    47→\n    48→\n    49→class SeedanceConfig:\n    50→    \"\"\"Seedance配置管理\"\"\"\n    51→    \n    52→    # API端点\n    53→    ENDPOINTS = {\n    54→        \"create_task\": \"/contents/generations/tasks\",\n    55→        \"query_task\": \"/contents/generations/tasks/{task_id}\",\n    56→        # 根据实测，取消为对任务资源本身执行DELETE，而非 /cancel 动作\n    57→        \"cancel_task\": \"/contents/generations/tasks/{task_id}\",\n    58→        \"list_tasks\": \"/contents/generations/tasks\"\n    59→    }\n    60→    \n    61→    # 轮询配置\n    62→    POLLING = {\n    63→        \"max_wait_time\": 600,  # 10分钟\n    64→        \"intervals\": [2, 3, 5, 8, 10],  # 递增间隔\n    65→        \"max_retries\": 3\n    66→    }\n    67→    \n    68→    # 模型价格（元/百万token）\n    69→    MODEL_PRICING = {\n    70→        SeedanceModels.PRO.value: 15,\n    71→        SeedanceModels.LITE_T2V.value: 10,\n    72→        SeedanceModels.LITE_I2V.value: 10\n    73→    }\n    74→    \n    75→    # 默认参数\n    76→    DEFAULTS = {\n    77→        \"duration\": 8,\n    78→        \"fps\": 24,\n    79→        \"width\": 1920,\n    80→        \"height\": 1080,\n    81→        \"model_type\": \"pro\"\n    82→    }\n    83→    \n    84→    # 支持的分辨率\n    85→    RESOLUTIONS = {\n    86→        \"480p\": {\"width\": 854, \"height\": 480},\n    87→        \"720p\": {\"width\": 1280, \"height\": 720},\n    88→        \"1080p\": {\"width\": 1920, \"height\": 1080}\n    89→    }\n    90→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4cbe714f-c66f-44c3-8e93-3d9c0c467e01","timestamp":"2026-01-05T11:51:01.821Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py","content":"# Seedance配置管理\n# 定义模型、状态和配置常量\n\nfrom enum import Enum\nfrom typing import Dict, List\n\n\nclass SeedanceModels(Enum):\n    \"\"\"Seedance模型枚举\"\"\"\n    PRO_1_5 = \"doubao-seedance-1-5-pro-251215\"\n    PRO = \"doubao-seedance-1-0-pro-250528\"\n    PRO_FAST = \"doubao-seedance-1-0-pro-fast-251015\"\n    LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n\n\nclass TaskStatus(Enum):\n    \"\"\"任务状态枚举\"\"\"\n    PENDING = \"pending\"\n    QUEUED = \"queued\"\n    PROCESSING = \"processing\"\n    RUNNING = \"running\"\n    SUCCEEDED = \"succeeded\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    EXPIRED = \"expired\"\n    \n    @classmethod\n    def is_terminal(cls, status: str) -> bool:\n        \"\"\"判断是否为终态\"\"\"\n        return status in [\n            cls.SUCCEEDED.value,\n            cls.FAILED.value,\n            cls.CANCELLED.value,\n            cls.EXPIRED.value,\n        ]\n    \n    @classmethod\n    def is_active(cls, status: str) -> bool:\n        \"\"\"判断是否为活跃状态\"\"\"\n        return status in [\n            cls.PENDING.value,\n            cls.QUEUED.value,\n            cls.PROCESSING.value,\n            cls.RUNNING.value,\n        ]\n\n\nclass SeedanceConfig:\n    \"\"\"Seedance配置管理\"\"\"\n    \n    # API端点\n    ENDPOINTS = {\n        \"create_task\": \"/contents/generations/tasks\",\n        \"query_task\": \"/contents/generations/tasks/{task_id}\",\n        # 根据实测，取消为对任务资源本身执行DELETE，而非 /cancel 动作\n        \"cancel_task\": \"/contents/generations/tasks/{task_id}\",\n        \"list_tasks\": \"/contents/generations/tasks\"\n    }\n    \n    # 轮询配置\n    POLLING = {\n        \"max_wait_time\": 600,  # 10分钟\n        \"intervals\": [2, 3, 5, 8, 10],  # 递增间隔\n        \"max_retries\": 3\n    }\n    \n    # 模型价格（元/百万token）\n    MODEL_PRICING = {\n        SeedanceModels.PRO.value: 15,\n        SeedanceModels.LITE_T2V.value: 10,\n        SeedanceModels.LITE_I2V.value: 10\n    }\n    \n    # 默认参数\n    DEFAULTS = {\n        \"duration\": 8,\n        \"fps\": 24,\n        \"width\": 1920,\n        \"height\": 1080,\n        \"model_type\": \"pro\"\n    }\n    \n    # 支持的分辨率\n    RESOLUTIONS = {\n        \"480p\": {\"width\": 854, \"height\": 480},\n        \"720p\": {\"width\": 1280, \"height\": 720},\n        \"1080p\": {\"width\": 1920, \"height\": 1080}\n    }\n","numLines":90,"startLine":1,"totalLines":90}}}
{"parentUuid":"4cbe714f-c66f-44c3-8e93-3d9c0c467e01","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GJJ8s7FCQmdkuDVfLT2bqC","type":"tool_result","content":"     1→# Seedream图像生成客户端\n     2→# 封装火山引擎Seedream3.0 API调用\n     3→\n     4→import json\n     5→import os\n     6→import requests\n     7→from requests.exceptions import Timeout, ReadTimeout, ConnectTimeout\n     8→import time\n     9→import random\n    10→from typing import Dict, Any, Optional, List\n    11→from pathlib import Path\n    12→from loguru import logger\n    13→from urllib3.util.retry import Retry\n    14→from requests.adapters import HTTPAdapter\n    15→\n    16→# 导入配置管理器和错误处理\n    17→from config.unified_config import get_unified_config\n    18→from utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n    19→\n    20→\n    21→class SeedreamClient:\n    22→    \"\"\"火山引擎Seedream图片生成客户端\n    23→\n    24→    提供文生图和图生图功能\n    25→    \"\"\"\n    26→\n    27→    def __init__(\n    28→        self,\n    29→        api_key: Optional[str] = None,\n    30→        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n    31→        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n    32→        timeout: int = 60,\n    33→        max_retries: int = 3,\n    34→    ):\n    35→        \"\"\"初始化Seedream客户端\n    36→\n    37→        Args:\n    38→            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n    39→            base_url: API基础URL\n    40→            timeout: 请求超时时间（秒）\n    41→            max_retries: 最大重试次数\n    42→        \"\"\"\n    43→        # 获取API密钥\n    44→        if api_key is None:\n    45→            try:\n    46→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    47→            except Exception as exc:\n    48→                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n    49→\n    50→        self.api_key = api_key\n    51→        self.base_url = base_url.rstrip(\"/\")\n    52→        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n    53→        self.timeout = timeout\n    54→        self.max_retries = max_retries\n    55→\n    56→        # 配置会话\n    57→        self.session = requests.Session()\n    58→\n    59→        # 配置重试策略\n    60→        retry_strategy = Retry(\n    61→            total=max_retries,\n    62→            status_forcelist=[429, 500, 502, 503, 504],\n    63→            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n    64→            backoff_factor=1\n    65→        )\n    66→\n    67→        adapter = HTTPAdapter(max_retries=retry_strategy)\n    68→        self.session.mount(\"http://\", adapter)\n    69→        self.session.mount(\"https://\", adapter)\n    70→\n    71→        logger.info(\"Seedream客户端初始化完成\")\n    72→\n    73→        # 初始化性能监控与错误缓存（统一结构）\n    74→        self._performance_stats = {\n    75→            \"total_requests\": 0,\n    76→            \"successful_requests\": 0,\n    77→            \"failed_requests\": 0,\n    78→            \"total_response_time\": 0.0,\n    79→            \"last_request_time\": None,\n    80→        }\n    81→        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n    82→        self._last_provider: Optional[str] = None\n    83→        self._last_endpoint: Optional[str] = None\n    84→\n    85→    def _encode_image(self, image_path: str) -> str:\n    86→        \"\"\"将图像文件编码为base64字符串\n    87→        \n    88→        Args:\n    89→            image_path: 图像文件路径\n    90→            \n    91→        Returns:\n    92→            base64编码的图像字符串\n    93→        \"\"\"\n    94→        import base64\n    95→        \n    96→        try:\n    97→            with open(image_path, 'rb') as image_file:\n    98→                image_data = image_file.read()\n    99→                base64_string = base64.b64encode(image_data).decode('utf-8')\n   100→                return base64_string\n   101→        except Exception as e:\n   102→            # 避免在日志中显示可能包含base64数据的异常信息\n   103→            error_msg = str(e)\n   104→            if len(error_msg) > 200:\n   105→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   106→            logger.error(f\"图像编码失败: {error_msg}\")\n   107→            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n   108→\n   109→    def _get_headers(self) -> Dict[str, str]:\n   110→        \"\"\"获取请求头\"\"\"\n   111→        # 验证API密钥，防止尺寸配置被错误使用\n   112→        api_key = str(self.api_key).strip()\n   113→\n   114→        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n   115→        try:\n   116→            api_key.encode('ascii')\n   117→        except UnicodeEncodeError:\n   118→            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n   119→\n   120→        # 检查是否包含尺寸信息或换行符\n   121→        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n   122→            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n   123→\n   124→        # 检查API密钥长度\n   125→        if len(api_key) < 10 or len(api_key) > 200:\n   126→            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n   127→        \n   128→        return {\n   129→            \"Authorization\": f\"Bearer {api_key}\",\n   130→            \"Content-Type\": \"application/json; charset=utf-8\",\n   131→            \"User-Agent\": \"Seedream-Client/1.0.0\",\n   132→        }\n   133→\n   134→    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n   135→        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\n   136→\n   137→        注意：当 timeout > 120 时，使用独立的 requests.post() 而不是 session.post()。\n   138→        这是因为 Session 配置了 Retry 策略，会在超时后自动重试，导致：\n   139→        1. 实际等待时间 = timeout × (1 + retry_count)，可能长达数十分钟\n   140→        2. 重试期间没有日志输出，用户看起来像\"卡住\"\n   141→\n   142→        对于组图等长时间请求，我们需要精确控制超时，不希望自动重试。\n   143→        \"\"\"\n   144→        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   145→        start = time.time()\n   146→\n   147→        # 长超时请求（组图模式）：绕过 Session 重试机制\n   148→        if timeout > 120:\n   149→            logger.info(f\"[HTTP POST] 长时间请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s (无重试)\")\n   150→            try:\n   151→                # 直接使用 requests.post，不经过 session 的重试策略\n   152→                resp = requests.post(url, headers=headers, data=body, timeout=(30, timeout))\n   153→                elapsed = time.time() - start\n   154→                logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n   155→                return resp\n   156→            except Exception as e:\n   157→                elapsed = time.time() - start\n   158→                logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n   159→                raise\n   160→\n   161→        # 普通请求：使用 session（带重试机制）\n   162→        logger.info(f\"[HTTP POST] 开始请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s\")\n   163→        try:\n   164→            resp = self.session.post(url, headers=headers, data=body, timeout=(30, timeout))\n   165→            elapsed = time.time() - start\n   166→            logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n   167→            return resp\n   168→        except Exception as e:\n   169→            elapsed = time.time() - start\n   170→            logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n   171→            raise\n   172→\n   173→    def _is_large_size(self, size: str) -> bool:\n   174→        \"\"\"判断是否是 v4.5 大尺寸（超过 v3 的 2048 限制）\"\"\"\n   175→        if not size:\n   176→            return False\n   177→        try:\n   178→            if \"x\" in size.lower():\n   179→                w, h = size.lower().split(\"x\")\n   180→                return int(w) > 2048 or int(h) > 2048\n   181→            # 处理 2K/4K 格式\n   182→            if size.upper() in (\"2K\", \"4K\"):\n   183→                return True\n   184→        except Exception:\n   185→            pass\n   186→        return False\n   187→\n   188→    def _provider_enabled(self) -> bool:\n   189→        try:\n   190→            import os\n   191→            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n   192→            return v not in {\"0\", \"false\", \"no\"}\n   193→        except Exception:\n   194→            return True\n   195→\n   196→    def _get_seedream_provider_order(self, preferred_provider: Optional[str] = None) -> List[str]:\n   197→        \"\"\"计算 Seedream provider 调用顺序。\n   198→\n   199→        规则：\n   200→        - 优先使用调用方传入的 preferred_provider（并发安全）\n   201→        - 其次允许通过环境变量 GEMENG_SEEDREAM_PROVIDER 启动覆盖（只读）\n   202→        - 最后兜底 volc_v3\n   203→        \"\"\"\n   204→        order: List[str] = []\n   205→\n   206→        candidates: List[Optional[str]] = []\n   207→        if preferred_provider:\n   208→            candidates.append(preferred_provider)\n   209→        try:\n   210→            candidates.append(os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\"))\n   211→        except Exception:\n   212→            candidates.append(None)\n   213→\n   214→        for candidate in candidates:\n   215→            if not candidate:\n   216→                continue\n   217→            name = candidate.strip().lower()\n   218→            if not name:\n   219→                continue\n   220→            if name not in order:\n   221→                order.append(name)\n   222→\n   223→        if \"volc_v3\" not in order:\n   224→            order.append(\"volc_v3\")\n   225→        return order\n   226→\n   227→    def _call_seedream_provider(\n   228→        self,\n   229→        headers: Dict[str, str],\n   230→        mapper,\n   231→        operation: str,\n   232→        preferred_provider: Optional[str] = None,\n   233→    ):\n   234→        from modules.provider.factory import get_default_provider\n   235→        default_endpoint = \"/images/generations\"\n   236→        base_url = self.base_url.rstrip(\"/\")\n   237→        first_choice = None\n   238→        last_error: Optional[BaseException] = None\n   239→        order = self._get_seedream_provider_order(preferred_provider)\n   240→        if order:\n   241→            first_choice = order[0]\n   242→        for idx, name in enumerate(order):\n   243→            try:\n   244→                provider = get_default_provider(name)\n   245→            except Exception as e:\n   246→                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n   247→                last_error = e\n   248→                continue\n   249→            try:\n   250→                mapped = mapper(provider)\n   251→                if not isinstance(mapped, tuple):\n   252→                    raise ValueError(\"provider mapper 返回值异常\")\n   253→                if len(mapped) == 4:\n   254→                    payload, fb, reason, endpoint = mapped\n   255→                elif len(mapped) == 3:\n   256→                    payload, fb, reason = mapped\n   257→                    endpoint = default_endpoint\n   258→                else:\n   259→                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n   260→            except Exception as e:\n   261→                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n   262→                last_error = e\n   263→                continue\n   264→            start_time = time.time()\n   265→            try:\n   266→                endpoint_path = endpoint or default_endpoint\n   267→                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n   268→                    request_url = endpoint_path\n   269→                else:\n   270→                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   271→                    if not normalized.startswith(\"/\"):\n   272→                        normalized = f\"/{normalized}\"\n   273→                    request_url = f\"{base_url}{normalized}\"\n   274→\n   275→                # 动态超时：组图模式需要更长时间\n   276→                # 实测：5 张 4096x4096 约需 8 分钟（458 秒）\n   277→                timeout = 120\n   278→                seq_options = payload.get(\"sequential_image_generation_options\")\n   279→                max_images = seq_options.get(\"max_images\", 1) if seq_options else 1\n   280→                if max_images > 1:\n   281→                    # 组图模式：基础 120 秒 + 每张图 60 秒，最大 20 分钟\n   282→                    # 实测：15 张 4096x4096 约需 14.5 分钟（869 秒）\n   283→                    timeout = min(120 + max_images * 60, 1200)\n   284→                    logger.info(f\"组图模式: {max_images} 张图，超时设置为 {timeout} 秒\")\n   285→\n   286→                response = self._safe_json_post(request_url, headers, payload, timeout=timeout)\n   287→                result = self._handle_response(response)\n   288→                elapsed = time.time() - start_time\n   289→                if idx > 0 and first_choice:\n   290→                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n   291→                if fb and reason:\n   292→                    logger.warning(f\"参数回退: {reason}\")\n   293→                logger.info(\n   294→                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n   295→                )\n   296→                self._last_provider = name\n   297→                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   298→                return result, payload, endpoint_path, name, fb, reason, elapsed\n   299→            except AppError as e:\n   300→                last_error = e\n   301→                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n   302→                # v4.5 特有功能失败时不回退到 v3（参数不兼容）\n   303→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   304→                    is_v45_feature = (\n   305→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   306→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   307→                    )\n   308→                    if is_v45_feature:\n   309→                        logger.error(f\"v4.5 特有功能失败，不回退: {e.message}\")\n   310→                        raise\n   311→                continue\n   312→            except (Timeout, ReadTimeout, ConnectTimeout) as e:\n   313→                elapsed = time.time() - start_time\n   314→                last_error = e\n   315→                logger.error(f\"Seedream provider {name} 请求超时 ({elapsed:.1f}s): {e}\")\n   316→                # v4.5 特有功能超时时直接报错，不回退\n   317→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   318→                    is_v45_feature = (\n   319→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   320→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   321→                    )\n   322→                    if is_v45_feature:\n   323→                        raise AppError(\n   324→                            f\"组图生成超时 ({elapsed:.0f}秒)，请减少生成数量或稍后重试\",\n   325→                            ErrorType.NETWORK_ERROR\n   326→                        )\n   327→                continue\n   328→            except Exception as e:\n   329→                last_error = e\n   330→                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n   331→                # v4.5 特有功能异常时也不回退\n   332→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   333→                    is_v45_feature = (\n   334→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   335→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   336→                    )\n   337→                    if is_v45_feature:\n   338→                        logger.error(f\"v4.5 特有功能异常，不回退: {e}\")\n   339→                        raise\n   340→                continue\n   341→        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n   342→\n   343→    def _log_seedream_event(\n   344→        self,\n   345→        operation: str,\n   346→        status: str,\n   347→        provider: Optional[str],\n   348→        endpoint: Optional[str],\n   349→        elapsed: float,\n   350→        fallback_applied: bool,\n   351→        fallback_reason: Optional[str] = None,\n   352→        extra: Optional[Dict[str, Any]] = None,\n   353→    ) -> None:\n   354→        try:\n   355→            provider_name = provider or \"unknown\"\n   356→            endpoint_text = endpoint or \"/images/generations\"\n   357→            parts = [\n   358→                f\"operation={operation}\",\n   359→                f\"status={status}\",\n   360→                f\"provider={provider_name}\",\n   361→                f\"endpoint={endpoint_text}\",\n   362→                f\"elapsed={elapsed:.2f}s\",\n   363→                f\"fallback={'yes' if fallback_applied else 'no'}\",\n   364→            ]\n   365→            if fallback_applied and fallback_reason:\n   366→                safe_reason = str(fallback_reason)\n   367→                if len(safe_reason) > 120:\n   368→                    safe_reason = safe_reason[:120] + \"...\"\n   369→                parts.append(f\"fallback_reason={safe_reason}\")\n   370→            if extra:\n   371→                for key, value in extra.items():\n   372→                    if value is None:\n   373→                        continue\n   374→                    parts.append(f\"{key}={value}\")\n   375→            logger.info(\"摘要|\" + \" \".join(parts))\n   376→        except Exception:\n   377→            # 保证日志逻辑不会影响主流程\n   378→            pass\n   379→\n   380→    @staticmethod\n   381→    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n   382→        mime = \"image/png\"\n   383→        try:\n   384→            if path_hint:\n   385→                suffix = Path(path_hint).suffix.lower()\n   386→                if suffix in {\".jpg\", \".jpeg\"}:\n   387→                    mime = \"image/jpeg\"\n   388→                elif suffix == \".webp\":\n   389→                    mime = \"image/webp\"\n   390→                elif suffix == \".bmp\":\n   391→                    mime = \"image/bmp\"\n   392→                elif suffix == \".gif\":\n   393→                    mime = \"image/gif\"\n   394→        except Exception:\n   395→            pass\n   396→        return f\"data:{mime};base64,{b64_data}\"\n   397→\n   398→    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n   399→        \"\"\"处理API响应\n   400→\n   401→        Args:\n   402→            response: HTTP响应对象\n   403→\n   404→        Returns:\n   405→            解析后的响应数据\n   406→\n   407→        Raises:\n   408→            AppError: 当API返回错误时\n   409→        \"\"\"\n   410→        try:\n   411→            if not response.ok:\n   412→                try:\n   413→                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n   414→                except Exception:\n   415→                    error_text = str(response.content[:500])\n   416→                # 避免在日志中显示可能包含base64数据的完整响应\n   417→                if len(error_text) > 500:\n   418→                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n   419→                else:\n   420→                    error_summary = error_text\n   421→                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n   422→                raise AppError(\n   423→                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n   424→                    ErrorType.API_ERROR,\n   425→                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n   426→                )\n   427→\n   428→            # 解析响应（增强容错：包括编码问题回退）\n   429→            try:\n   430→                result = response.json()\n   431→            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n   432→                raw = response.content or b\"\"\n   433→                tried = set()\n   434→                result = None\n   435→                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n   436→                    if not enc or enc in tried:\n   437→                        continue\n   438→                    tried.add(enc)\n   439→                    try:\n   440→                        text = raw.decode(enc, errors=\"strict\")\n   441→                        result = json.loads(text)\n   442→                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n   443→                        break\n   444→                    except Exception:\n   445→                        continue\n   446→                if result is None:\n   447→                    try:\n   448→                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n   449→                    except Exception:\n   450→                        preview = str(raw[:200])\n   451→                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n   452→                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n   453→\n   454→            # OpenAI格式的响应检查\n   455→            if \"data\" not in result:\n   456→                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n   457→                logger.error(f\"Seedream API错误: {error_msg}\")\n   458→                raise AppError(\n   459→                    f\"API错误: {error_msg}\",\n   460→                    ErrorType.API_ERROR,\n   461→                    {\"response_data\": result},\n   462→                )\n   463→\n   464→            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n   465→            images = []\n   466→            for item in result[\"data\"]:\n   467→                if \"url\" in item:\n   468→                    images.append({\n   469→                        \"url\": item[\"url\"]\n   470→                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n   471→                    })\n   472→\n   473→            # 调试日志：输出组图返回的图片数量\n   474→            logger.debug(f\"API 返回 {len(images)} 张图片\")\n   475→\n   476→            return {\n   477→                \"code\": 200,\n   478→                \"message\": \"success\",\n   479→                \"data\": {\n   480→                    \"images\": images\n   481→                },\n   482→                \"created\": result.get(\"created\"),\n   483→                \"usage\": result.get(\"usage\", {})\n   484→            }\n   485→\n   486→        except requests.exceptions.RequestException as e:\n   487→            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n   488→        except json.JSONDecodeError as e:\n   489→            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n   490→\n   491→    def _record_request_stats(\n   492→        self,\n   493→        operation: str,\n   494→        success: bool,\n   495→        response_time: float,\n   496→        error_code: Optional[str] = None,\n   497→        error_message: Optional[str] = None,\n   498→    ) -> None:\n   499→        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n   500→        try:\n   501→            self._performance_stats[\"total_requests\"] += 1\n   502→            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n   503→            self._performance_stats[\"last_request_time\"] = time.time()\n   504→            if success:\n   505→                self._performance_stats[\"successful_requests\"] += 1\n   506→            else:\n   507→                self._performance_stats[\"failed_requests\"] += 1\n   508→                if error_code or error_message:\n   509→                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n   510→\n   511→            # 调试日志（安全版）\n   512→            total = max(1, self._performance_stats[\"total_requests\"])\n   513→            avg = self._performance_stats[\"total_response_time\"] / total\n   514→            succ = self._performance_stats[\"successful_requests\"]\n   515→            success_rate = (succ / total) * 100.0\n   516→            logger.debug(\n   517→                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n   518→            )\n   519→        except Exception:\n   520→            # 统计不应影响业务流程\n   521→            pass\n   522→\n   523→    def get_performance_stats(self) -> Dict[str, Any]:\n   524→        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n   525→        stats = dict(self._performance_stats)\n   526→        total = stats.get(\"total_requests\", 0) or 0\n   527→        if total > 0:\n   528→            avg = stats.get(\"total_response_time\", 0.0) / total\n   529→            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n   530→        else:\n   531→            avg = 0.0\n   532→            success_rate = 0.0\n   533→        return {\n   534→            \"total_requests\": total,\n   535→            \"successful_requests\": stats.get(\"successful_requests\", 0),\n   536→            \"failed_requests\": stats.get(\"failed_requests\", 0),\n   537→            \"avg_response_time\": avg,\n   538→            \"success_rate\": success_rate,\n   539→            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n   540→        }\n   541→\n   542→    def dump_metrics(self) -> Dict[str, Any]:\n   543→        \"\"\"导出诊断可读的统一指标。\"\"\"\n   544→        m = self.get_performance_stats()\n   545→        m.update({\n   546→            \"client\": \"Seedream\",\n   547→            \"model\": self.model_id,\n   548→            \"base_url\": self.base_url,\n   549→        })\n   550→        return m\n   551→\n   552→    def last_provider(self) -> Optional[str]:\n   553→        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n   554→        return self._last_provider\n   555→\n   556→    def last_endpoint(self) -> Optional[str]:\n   557→        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n   558→        return self._last_endpoint\n   559→\n   560→    @error_handler(\"Seedream文生图\")\n   561→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   562→    def text_to_image(\n   563→        self,\n   564→        prompt: str,\n   565→        size: str = \"1024x1024\",\n   566→        guidance_scale: float = 2.5,\n   567→        seed: Optional[int] = None,\n   568→        reference_images: Optional[List[Any]] = None,\n   569→        n: int = 1,\n   570→        sequential_mode: bool = False,\n   571→        seedream_provider: Optional[str] = None,\n   572→    ) -> Dict[str, Any]:\n   573→        \"\"\"\n   574→        文生图API调用\n   575→\n   576→        Args:\n   577→            prompt: 图片描述提示词\n   578→            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n   579→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   580→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   581→            reference_images: 参考图列表（路径或URL），最多10张\n   582→            n: 生成图片数量，组图模式下生效（1-15）\n   583→            sequential_mode: 是否启用组图模式\n   584→            response_format: 返回格式，\"url\"或\"b64_json\"\n   585→\n   586→        Returns:\n   587→            API响应结果\n   588→\n   589→        Raises:\n   590→            AppError: 当API调用失败时\n   591→        \"\"\"\n   592→        headers = self._get_headers()\n   593→\n   594→        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n   595→\n   596→        if self._provider_enabled():\n   597→            try:\n   598→                from modules.provider.schema import TextToImageParams\n   599→\n   600→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   601→                    headers,\n   602→                    lambda provider: provider.map_t2i(TextToImageParams(\n   603→                        prompt=prompt,\n   604→                        size=size,\n   605→                        guidance_scale=guidance_scale,\n   606→                        seed=(None if (seed is None or seed == -1) else seed),\n   607→                        reference_images=reference_images or [],\n   608→                        sequential_mode=sequential_mode,\n   609→                        count=n\n   610→                    )),\n   611→                    \"text_to_image\",\n   612→                    preferred_provider=seedream_provider,\n   613→                )\n   614→                self._log_seedream_event(\n   615→                    \"text_to_image\",\n   616→                    \"success\",\n   617→                    provider_used,\n   618→                    endpoint_used,\n   619→                    response_time,\n   620→                    fallback_applied,\n   621→                    fallback_reason,\n   622→                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   623→                )\n   624→                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n   625→                return result\n   626→            except Exception as provider_exc:\n   627→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   628→\n   629→        success = False\n   630→        err_code: Optional[str] = None\n   631→        err_msg: Optional[str] = None\n   632→        start_time = time.time()\n   633→        try:\n   634→            if not self.validate_image_size(size):\n   635→                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n   636→            if not (1.0 <= guidance_scale <= 10.0):\n   637→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   638→            if seed is not None and not (-1 <= seed <= 2147483647):\n   639→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   640→\n   641→            data = {\n   642→                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n   643→                \"prompt\": prompt,\n   644→                \"size\": size,\n   645→                \"response_format\": \"url\",\n   646→                \"watermark\": False,  # 正式版固定禁用水印\n   647→                \"guidance_scale\": guidance_scale,\n   648→            }\n   649→            if seed is not None:\n   650→                data[\"seed\"] = seed\n   651→\n   652→            if reference_images:\n   653→                images_payload = []\n   654→                for item in reference_images:\n   655→                    try:\n   656→                        if isinstance(item, str):\n   657→                            if item.startswith(\"data:image/\"):\n   658→                                images_payload.append(item)\n   659→                                continue\n   660→                            p = Path(item)\n   661→                            if p.exists():\n   662→                                encoded = self._encode_image(str(p))\n   663→                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   664→                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n   665→                                images_payload.append(item)\n   666→                        elif isinstance(item, dict):\n   667→                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n   668→                            path_hint = item.get('path') or item.get('source')\n   669→                            if payload:\n   670→                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n   671→                            else:\n   672→                                path_val = item.get('path')\n   673→                                if path_val:\n   674→                                    p = Path(path_val)\n   675→                                    if p.exists():\n   676→                                        encoded = self._encode_image(str(p))\n   677→                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   678→                    except Exception as exc:\n   679→                        logger.warning(f\"参考图处理失败: {exc}\")\n   680→                if images_payload:\n   681→                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n   682→                    data[\"sequential_image_generation\"] = \"disabled\"\n   683→\n   684→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   685→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   686→            result = self._handle_response(response)\n   687→            success = True\n   688→            elapsed = time.time() - start_time\n   689→            self._last_provider = \"legacy_v3\"\n   690→            self._last_endpoint = \"/images/generations\"\n   691→            self._log_seedream_event(\n   692→                \"text_to_image\",\n   693→                \"success\",\n   694→                \"legacy_v3\",\n   695→                \"/images/generations\",\n   696→                elapsed,\n   697→                False,\n   698→                None,\n   699→                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   700→            )\n   701→            return result\n   702→        except AppError as e:\n   703→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   704→            err_msg = e.message\n   705→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   706→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   707→            raise\n   708→        except Exception as e:\n   709→            err_code = \"UNKNOWN_ERROR\"\n   710→            err_msg = str(e)\n   711→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   712→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   713→            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n   714→        finally:\n   715→            elapsed = time.time() - start_time\n   716→            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n   717→\n   718→    @error_handler(\"Seedream图生图\")\n   719→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   720→    def image_to_image(\n   721→        self,\n   722→        prompt: str,\n   723→        image: str,\n   724→        guidance_scale: float = 5.5,\n   725→        seed: Optional[int] = None,\n   726→        reference_images: Optional[List[str]] = None,\n   727→        seedream_provider: Optional[str] = None,\n   728→    ) -> Dict[str, Any]:\n   729→        \"\"\"\n   730→        图生图API调用\n   731→\n   732→        Args:\n   733→            prompt: 图片编辑提示词\n   734→            image: 输入图像URL或Base64编码\n   735→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   736→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   737→            reference_images: 参考图列表（路径或URL），最多10张\n   738→            response_format: 返回格式，\"url\"或\"b64_json\"\n   739→            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n   740→\n   741→        Returns:\n   742→            API响应结果\n   743→\n   744→        Raises:\n   745→            AppError: 当API调用失败时\n   746→        \"\"\"\n   747→        headers = self._get_headers()\n   748→\n   749→        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n   750→\n   751→        if self._provider_enabled():\n   752→            try:\n   753→                from modules.provider.schema import ImageToImageParams\n   754→\n   755→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   756→                    headers,\n   757→                    lambda provider: provider.map_i2i(ImageToImageParams(\n   758→                        prompt=prompt,\n   759→                        image=image,\n   760→                        guidance_scale=guidance_scale,\n   761→                        seed=(None if (seed is None or seed == -1) else seed),\n   762→                        reference_images=(reference_images or []),\n   763→                    )),\n   764→                    \"image_to_image\",\n   765→                    preferred_provider=seedream_provider,\n   766→                )\n   767→                self._log_seedream_event(\n   768→                    \"image_to_image\",\n   769→                    \"success\",\n   770→                    provider_used,\n   771→                    endpoint_used,\n   772→                    response_time,\n   773→                    fallback_applied,\n   774→                    fallback_reason,\n   775→                    {\"seed\": data.get(\"seed\")},\n   776→                )\n   777→                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n   778→                return result\n   779→            except Exception as provider_exc:\n   780→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   781→\n   782→        success = False\n   783→        err_code: Optional[str] = None\n   784→        err_msg: Optional[str] = None\n   785→        start_time = time.time()\n   786→        try:\n   787→            if not (1.0 <= guidance_scale <= 10.0):\n   788→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   789→            if seed is not None and not (-1 <= seed <= 2147483647):\n   790→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   791→\n   792→            data = {\n   793→                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n   794→                \"prompt\": prompt,\n   795→                \"image\": image,\n   796→                \"size\": \"adaptive\",\n   797→                \"response_format\": \"url\",\n   798→                \"watermark\": False,  # 正式版固定禁用水印\n   799→                \"guidance_scale\": guidance_scale,\n   800→            }\n   801→            if seed is not None:\n   802→                data[\"seed\"] = seed\n   803→            if reference_images:\n   804→                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n   805→\n   806→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   807→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   808→            result = self._handle_response(response)\n   809→            success = True\n   810→            elapsed = time.time() - start_time\n   811→            self._last_provider = \"legacy_v3\"\n   812→            self._last_endpoint = \"/images/generations\"\n   813→            self._log_seedream_event(\n   814→                \"image_to_image\",\n   815→                \"success\",\n   816→                \"legacy_v3\",\n   817→                \"/images/generations\",\n   818→                elapsed,\n   819→                False,\n   820→                None,\n   821→                {\"seed\": data.get(\"seed\")},\n   822→            )\n   823→            return result\n   824→        except AppError as e:\n   825→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   826→            err_msg = e.message\n   827→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   828→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   829→            raise\n   830→        except Exception as e:\n   831→            err_code = \"UNKNOWN_ERROR\"\n   832→            err_msg = str(e)\n   833→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   834→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   835→            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n   836→        finally:\n   837→            elapsed = time.time() - start_time\n   838→            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n   839→\n   840→    def batch_text_to_image(\n   841→        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n   842→    ) -> List[Dict[str, Any]]:\n   843→        \"\"\"\n   844→        批量文生图：同时生成多张图片\n   845→\n   846→        Args:\n   847→            prompts: 提示词列表\n   848→            width: 图像宽度\n   849→            height: 图像高度\n   850→            guidance_scale: 提示词一致性\n   851→\n   852→        Returns:\n   853→            List[Dict]: 生成结果列表\n   854→        \"\"\"\n   855→        results = []\n   856→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   857→\n   858→        for i, prompt in enumerate(prompts, 1):\n   859→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   860→\n   861→            try:\n   862→                # 为每个任务生成不同的随机种子\n   863→                seed = random.randint(1, 2147483647)\n   864→\n   865→                result = self.text_to_image(\n   866→                    prompt=prompt, \n   867→                    width=width, \n   868→                    height=height, \n   869→                    guidance_scale=guidance_scale, \n   870→                    seed=seed\n   871→                )\n   872→\n   873→                results.append({\n   874→                    \"success\": True,\n   875→                    \"result\": result,\n   876→                    \"prompt\": prompt\n   877→                })\n   878→\n   879→            except Exception as e:\n   880→                # 避免在日志中显示过长的异常信息\n   881→                error_msg = str(e)\n   882→                if len(error_msg) > 200:\n   883→                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   884→                logger.error(f\"第{i}个任务失败: {error_msg}\")\n   885→                results.append({\n   886→                    \"success\": False,\n   887→                    \"error\": error_msg,\n   888→                    \"prompt\": prompt\n   889→                })\n   890→\n   891→            # 避免请求过于频繁\n   892→            if i < len(prompts):\n   893→                time.sleep(0.5)\n   894→\n   895→        success_count = sum(1 for r in results if r[\"success\"])\n   896→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   897→        return results\n   898→\n   899→    def validate_image_size(self, size: str) -> bool:\n   900→        \"\"\"\n   901→        验证图像尺寸是否支持\n   902→\n   903→        Args:\n   904→            size: 图像尺寸字符串，如 \"1024x1024\"\n   905→\n   906→        Returns:\n   907→            bool: 是否支持该尺寸\n   908→        \"\"\"\n   909→        try:\n   910→            # 解析尺寸字符串\n   911→            if 'x' not in size:\n   912→                return False\n   913→                \n   914→            width_str, height_str = size.split('x', 1)\n   915→            width = int(width_str)\n   916→            height = int(height_str)\n   917→            \n   918→            # 验证范围：Seedream 4.0 支持 512-4096像素\n   919→            return (512 <= width <= 4096) and (512 <= height <= 4096)\n   920→            \n   921→        except (ValueError, AttributeError):\n   922→            return False\n   923→\n   924→    def get_supported_sizes(self) -> List[str]:\n   925→        \"\"\"\n   926→        获取常用的图像尺寸列表\n   927→        \n   928→        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n   929→\n   930→        Returns:\n   931→            List[str]: 常用尺寸列表，包含官方推荐尺寸\n   932→        \"\"\"\n   933→        return [\n   934→            # 官方推荐尺寸 (Seedream 4.0)\n   935→            \"2048x2048\",   # 1:1 官方推荐\n   936→            \"2304x1728\",   # 4:3 官方推荐\n   937→            \"1728x2304\",   # 3:4 官方推荐\n   938→            \"2560x1440\",   # 16:9 官方推荐\n   939→            \"1440x2560\",   # 9:16 官方推荐\n   940→            \"2496x1664\",   # 3:2 官方推荐\n   941→            \"1664x2496\",   # 2:3 官方推荐\n   942→            \"3024x1296\",   # 21:9 官方推荐\n   943→            \n   944→            # 兼容性尺寸\n   945→            \"1920x1080\",   # 16:9 兼容\n   946→            \"1080x1920\",   # 9:16 兼容\n   947→            \"1536x1024\",   # 3:2 兼容\n   948→            \"1024x1536\",   # 2:3 兼容\n   949→            \"1512x648\",    # 21:9 兼容\n   950→            \"1280x720\",    # 16:9 小尺寸\n   951→            \"720x1280\",    # 9:16 小尺寸\n   952→            \"1024x1024\",   # 1:1 兼容\n   953→            \"768x768\",     # 1:1 小尺寸\n   954→            \"512x512\",     # 1:1 最小尺寸\n   955→        ]\n   956→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b64b4f9c-8e19-47c9-8633-286841e42564","timestamp":"2026-01-05T11:51:02.779Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py","content":"# Seedream图像生成客户端\n# 封装火山引擎Seedream3.0 API调用\n\nimport json\nimport os\nimport requests\nfrom requests.exceptions import Timeout, ReadTimeout, ConnectTimeout\nimport time\nimport random\nfrom typing import Dict, Any, Optional, List\nfrom pathlib import Path\nfrom loguru import logger\nfrom urllib3.util.retry import Retry\nfrom requests.adapters import HTTPAdapter\n\n# 导入配置管理器和错误处理\nfrom config.unified_config import get_unified_config\nfrom utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n\n\nclass SeedreamClient:\n    \"\"\"火山引擎Seedream图片生成客户端\n\n    提供文生图和图生图功能\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n        timeout: int = 60,\n        max_retries: int = 3,\n    ):\n        \"\"\"初始化Seedream客户端\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n            base_url: API基础URL\n            timeout: 请求超时时间（秒）\n            max_retries: 最大重试次数\n        \"\"\"\n        # 获取API密钥\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n\n        self.api_key = api_key\n        self.base_url = base_url.rstrip(\"/\")\n        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n        # 配置会话\n        self.session = requests.Session()\n\n        # 配置重试策略\n        retry_strategy = Retry(\n            total=max_retries,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n            backoff_factor=1\n        )\n\n        adapter = HTTPAdapter(max_retries=retry_strategy)\n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        logger.info(\"Seedream客户端初始化完成\")\n\n        # 初始化性能监控与错误缓存（统一结构）\n        self._performance_stats = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"total_response_time\": 0.0,\n            \"last_request_time\": None,\n        }\n        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n        self._last_provider: Optional[str] = None\n        self._last_endpoint: Optional[str] = None\n\n    def _encode_image(self, image_path: str) -> str:\n        \"\"\"将图像文件编码为base64字符串\n        \n        Args:\n            image_path: 图像文件路径\n            \n        Returns:\n            base64编码的图像字符串\n        \"\"\"\n        import base64\n        \n        try:\n            with open(image_path, 'rb') as image_file:\n                image_data = image_file.read()\n                base64_string = base64.b64encode(image_data).decode('utf-8')\n                return base64_string\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图像编码失败: {error_msg}\")\n            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n\n    def _get_headers(self) -> Dict[str, str]:\n        \"\"\"获取请求头\"\"\"\n        # 验证API密钥，防止尺寸配置被错误使用\n        api_key = str(self.api_key).strip()\n\n        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n        try:\n            api_key.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n\n        # 检查是否包含尺寸信息或换行符\n        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n\n        # 检查API密钥长度\n        if len(api_key) < 10 or len(api_key) > 200:\n            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n        \n        return {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"User-Agent\": \"Seedream-Client/1.0.0\",\n        }\n\n    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\n\n        注意：当 timeout > 120 时，使用独立的 requests.post() 而不是 session.post()。\n        这是因为 Session 配置了 Retry 策略，会在超时后自动重试，导致：\n        1. 实际等待时间 = timeout × (1 + retry_count)，可能长达数十分钟\n        2. 重试期间没有日志输出，用户看起来像\"卡住\"\n\n        对于组图等长时间请求，我们需要精确控制超时，不希望自动重试。\n        \"\"\"\n        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n        start = time.time()\n\n        # 长超时请求（组图模式）：绕过 Session 重试机制\n        if timeout > 120:\n            logger.info(f\"[HTTP POST] 长时间请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s (无重试)\")\n            try:\n                # 直接使用 requests.post，不经过 session 的重试策略\n                resp = requests.post(url, headers=headers, data=body, timeout=(30, timeout))\n                elapsed = time.time() - start\n                logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n                return resp\n            except Exception as e:\n                elapsed = time.time() - start\n                logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n                raise\n\n        # 普通请求：使用 session（带重试机制）\n        logger.info(f\"[HTTP POST] 开始请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s\")\n        try:\n            resp = self.session.post(url, headers=headers, data=body, timeout=(30, timeout))\n            elapsed = time.time() - start\n            logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n            return resp\n        except Exception as e:\n            elapsed = time.time() - start\n            logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n            raise\n\n    def _is_large_size(self, size: str) -> bool:\n        \"\"\"判断是否是 v4.5 大尺寸（超过 v3 的 2048 限制）\"\"\"\n        if not size:\n            return False\n        try:\n            if \"x\" in size.lower():\n                w, h = size.lower().split(\"x\")\n                return int(w) > 2048 or int(h) > 2048\n            # 处理 2K/4K 格式\n            if size.upper() in (\"2K\", \"4K\"):\n                return True\n        except Exception:\n            pass\n        return False\n\n    def _provider_enabled(self) -> bool:\n        try:\n            import os\n            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n            return v not in {\"0\", \"false\", \"no\"}\n        except Exception:\n            return True\n\n    def _get_seedream_provider_order(self, preferred_provider: Optional[str] = None) -> List[str]:\n        \"\"\"计算 Seedream provider 调用顺序。\n\n        规则：\n        - 优先使用调用方传入的 preferred_provider（并发安全）\n        - 其次允许通过环境变量 GEMENG_SEEDREAM_PROVIDER 启动覆盖（只读）\n        - 最后兜底 volc_v3\n        \"\"\"\n        order: List[str] = []\n\n        candidates: List[Optional[str]] = []\n        if preferred_provider:\n            candidates.append(preferred_provider)\n        try:\n            candidates.append(os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\"))\n        except Exception:\n            candidates.append(None)\n\n        for candidate in candidates:\n            if not candidate:\n                continue\n            name = candidate.strip().lower()\n            if not name:\n                continue\n            if name not in order:\n                order.append(name)\n\n        if \"volc_v3\" not in order:\n            order.append(\"volc_v3\")\n        return order\n\n    def _call_seedream_provider(\n        self,\n        headers: Dict[str, str],\n        mapper,\n        operation: str,\n        preferred_provider: Optional[str] = None,\n    ):\n        from modules.provider.factory import get_default_provider\n        default_endpoint = \"/images/generations\"\n        base_url = self.base_url.rstrip(\"/\")\n        first_choice = None\n        last_error: Optional[BaseException] = None\n        order = self._get_seedream_provider_order(preferred_provider)\n        if order:\n            first_choice = order[0]\n        for idx, name in enumerate(order):\n            try:\n                provider = get_default_provider(name)\n            except Exception as e:\n                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n                last_error = e\n                continue\n            try:\n                mapped = mapper(provider)\n                if not isinstance(mapped, tuple):\n                    raise ValueError(\"provider mapper 返回值异常\")\n                if len(mapped) == 4:\n                    payload, fb, reason, endpoint = mapped\n                elif len(mapped) == 3:\n                    payload, fb, reason = mapped\n                    endpoint = default_endpoint\n                else:\n                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n            except Exception as e:\n                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n                last_error = e\n                continue\n            start_time = time.time()\n            try:\n                endpoint_path = endpoint or default_endpoint\n                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n                    request_url = endpoint_path\n                else:\n                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                    if not normalized.startswith(\"/\"):\n                        normalized = f\"/{normalized}\"\n                    request_url = f\"{base_url}{normalized}\"\n\n                # 动态超时：组图模式需要更长时间\n                # 实测：5 张 4096x4096 约需 8 分钟（458 秒）\n                timeout = 120\n                seq_options = payload.get(\"sequential_image_generation_options\")\n                max_images = seq_options.get(\"max_images\", 1) if seq_options else 1\n                if max_images > 1:\n                    # 组图模式：基础 120 秒 + 每张图 60 秒，最大 20 分钟\n                    # 实测：15 张 4096x4096 约需 14.5 分钟（869 秒）\n                    timeout = min(120 + max_images * 60, 1200)\n                    logger.info(f\"组图模式: {max_images} 张图，超时设置为 {timeout} 秒\")\n\n                response = self._safe_json_post(request_url, headers, payload, timeout=timeout)\n                result = self._handle_response(response)\n                elapsed = time.time() - start_time\n                if idx > 0 and first_choice:\n                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n                if fb and reason:\n                    logger.warning(f\"参数回退: {reason}\")\n                logger.info(\n                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n                )\n                self._last_provider = name\n                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                return result, payload, endpoint_path, name, fb, reason, elapsed\n            except AppError as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n                # v4.5 特有功能失败时不回退到 v3（参数不兼容）\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        logger.error(f\"v4.5 特有功能失败，不回退: {e.message}\")\n                        raise\n                continue\n            except (Timeout, ReadTimeout, ConnectTimeout) as e:\n                elapsed = time.time() - start_time\n                last_error = e\n                logger.error(f\"Seedream provider {name} 请求超时 ({elapsed:.1f}s): {e}\")\n                # v4.5 特有功能超时时直接报错，不回退\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        raise AppError(\n                            f\"组图生成超时 ({elapsed:.0f}秒)，请减少生成数量或稍后重试\",\n                            ErrorType.NETWORK_ERROR\n                        )\n                continue\n            except Exception as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n                # v4.5 特有功能异常时也不回退\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        logger.error(f\"v4.5 特有功能异常，不回退: {e}\")\n                        raise\n                continue\n        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n\n    def _log_seedream_event(\n        self,\n        operation: str,\n        status: str,\n        provider: Optional[str],\n        endpoint: Optional[str],\n        elapsed: float,\n        fallback_applied: bool,\n        fallback_reason: Optional[str] = None,\n        extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        try:\n            provider_name = provider or \"unknown\"\n            endpoint_text = endpoint or \"/images/generations\"\n            parts = [\n                f\"operation={operation}\",\n                f\"status={status}\",\n                f\"provider={provider_name}\",\n                f\"endpoint={endpoint_text}\",\n                f\"elapsed={elapsed:.2f}s\",\n                f\"fallback={'yes' if fallback_applied else 'no'}\",\n            ]\n            if fallback_applied and fallback_reason:\n                safe_reason = str(fallback_reason)\n                if len(safe_reason) > 120:\n                    safe_reason = safe_reason[:120] + \"...\"\n                parts.append(f\"fallback_reason={safe_reason}\")\n            if extra:\n                for key, value in extra.items():\n                    if value is None:\n                        continue\n                    parts.append(f\"{key}={value}\")\n            logger.info(\"摘要|\" + \" \".join(parts))\n        except Exception:\n            # 保证日志逻辑不会影响主流程\n            pass\n\n    @staticmethod\n    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n        mime = \"image/png\"\n        try:\n            if path_hint:\n                suffix = Path(path_hint).suffix.lower()\n                if suffix in {\".jpg\", \".jpeg\"}:\n                    mime = \"image/jpeg\"\n                elif suffix == \".webp\":\n                    mime = \"image/webp\"\n                elif suffix == \".bmp\":\n                    mime = \"image/bmp\"\n                elif suffix == \".gif\":\n                    mime = \"image/gif\"\n        except Exception:\n            pass\n        return f\"data:{mime};base64,{b64_data}\"\n\n    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n        \"\"\"处理API响应\n\n        Args:\n            response: HTTP响应对象\n\n        Returns:\n            解析后的响应数据\n\n        Raises:\n            AppError: 当API返回错误时\n        \"\"\"\n        try:\n            if not response.ok:\n                try:\n                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n                except Exception:\n                    error_text = str(response.content[:500])\n                # 避免在日志中显示可能包含base64数据的完整响应\n                if len(error_text) > 500:\n                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n                else:\n                    error_summary = error_text\n                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n                raise AppError(\n                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n                    ErrorType.API_ERROR,\n                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n                )\n\n            # 解析响应（增强容错：包括编码问题回退）\n            try:\n                result = response.json()\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                raw = response.content or b\"\"\n                tried = set()\n                result = None\n                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                    if not enc or enc in tried:\n                        continue\n                    tried.add(enc)\n                    try:\n                        text = raw.decode(enc, errors=\"strict\")\n                        result = json.loads(text)\n                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n                        break\n                    except Exception:\n                        continue\n                if result is None:\n                    try:\n                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                    except Exception:\n                        preview = str(raw[:200])\n                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n\n            # OpenAI格式的响应检查\n            if \"data\" not in result:\n                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n                logger.error(f\"Seedream API错误: {error_msg}\")\n                raise AppError(\n                    f\"API错误: {error_msg}\",\n                    ErrorType.API_ERROR,\n                    {\"response_data\": result},\n                )\n\n            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n            images = []\n            for item in result[\"data\"]:\n                if \"url\" in item:\n                    images.append({\n                        \"url\": item[\"url\"]\n                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n                    })\n\n            # 调试日志：输出组图返回的图片数量\n            logger.debug(f\"API 返回 {len(images)} 张图片\")\n\n            return {\n                \"code\": 200,\n                \"message\": \"success\",\n                \"data\": {\n                    \"images\": images\n                },\n                \"created\": result.get(\"created\"),\n                \"usage\": result.get(\"usage\", {})\n            }\n\n        except requests.exceptions.RequestException as e:\n            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n        except json.JSONDecodeError as e:\n            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n\n    def _record_request_stats(\n        self,\n        operation: str,\n        success: bool,\n        response_time: float,\n        error_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n    ) -> None:\n        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n        try:\n            self._performance_stats[\"total_requests\"] += 1\n            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n            self._performance_stats[\"last_request_time\"] = time.time()\n            if success:\n                self._performance_stats[\"successful_requests\"] += 1\n            else:\n                self._performance_stats[\"failed_requests\"] += 1\n                if error_code or error_message:\n                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n\n            # 调试日志（安全版）\n            total = max(1, self._performance_stats[\"total_requests\"])\n            avg = self._performance_stats[\"total_response_time\"] / total\n            succ = self._performance_stats[\"successful_requests\"]\n            success_rate = (succ / total) * 100.0\n            logger.debug(\n                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n            )\n        except Exception:\n            # 统计不应影响业务流程\n            pass\n\n    def get_performance_stats(self) -> Dict[str, Any]:\n        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n        stats = dict(self._performance_stats)\n        total = stats.get(\"total_requests\", 0) or 0\n        if total > 0:\n            avg = stats.get(\"total_response_time\", 0.0) / total\n            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n        else:\n            avg = 0.0\n            success_rate = 0.0\n        return {\n            \"total_requests\": total,\n            \"successful_requests\": stats.get(\"successful_requests\", 0),\n            \"failed_requests\": stats.get(\"failed_requests\", 0),\n            \"avg_response_time\": avg,\n            \"success_rate\": success_rate,\n            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n        }\n\n    def dump_metrics(self) -> Dict[str, Any]:\n        \"\"\"导出诊断可读的统一指标。\"\"\"\n        m = self.get_performance_stats()\n        m.update({\n            \"client\": \"Seedream\",\n            \"model\": self.model_id,\n            \"base_url\": self.base_url,\n        })\n        return m\n\n    def last_provider(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n        return self._last_provider\n\n    def last_endpoint(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n        return self._last_endpoint\n\n    @error_handler(\"Seedream文生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[Any]] = None,\n        n: int = 1,\n        sequential_mode: bool = False,\n        seedream_provider: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        文生图API调用\n\n        Args:\n            prompt: 图片描述提示词\n            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            n: 生成图片数量，组图模式下生效（1-15）\n            sequential_mode: 是否启用组图模式\n            response_format: 返回格式，\"url\"或\"b64_json\"\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import TextToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_t2i(TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=reference_images or [],\n                        sequential_mode=sequential_mode,\n                        count=n\n                    )),\n                    \"text_to_image\",\n                    preferred_provider=seedream_provider,\n                )\n                self._log_seedream_event(\n                    \"text_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not self.validate_image_size(size):\n                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n                \"prompt\": prompt,\n                \"size\": size,\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n\n            if reference_images:\n                images_payload = []\n                for item in reference_images:\n                    try:\n                        if isinstance(item, str):\n                            if item.startswith(\"data:image/\"):\n                                images_payload.append(item)\n                                continue\n                            p = Path(item)\n                            if p.exists():\n                                encoded = self._encode_image(str(p))\n                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n                                images_payload.append(item)\n                        elif isinstance(item, dict):\n                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n                            path_hint = item.get('path') or item.get('source')\n                            if payload:\n                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n                            else:\n                                path_val = item.get('path')\n                                if path_val:\n                                    p = Path(path_val)\n                                    if p.exists():\n                                        encoded = self._encode_image(str(p))\n                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                    except Exception as exc:\n                        logger.warning(f\"参考图处理失败: {exc}\")\n                if images_payload:\n                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n                    data[\"sequential_image_generation\"] = \"disabled\"\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"text_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n\n    @error_handler(\"Seedream图生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n        seedream_provider: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        图生图API调用\n\n        Args:\n            prompt: 图片编辑提示词\n            image: 输入图像URL或Base64编码\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import ImageToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_i2i(ImageToImageParams(\n                        prompt=prompt,\n                        image=image,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=(reference_images or []),\n                    )),\n                    \"image_to_image\",\n                    preferred_provider=seedream_provider,\n                )\n                self._log_seedream_event(\n                    \"image_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n                \"prompt\": prompt,\n                \"image\": image,\n                \"size\": \"adaptive\",\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n            if reference_images:\n                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"image_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n\n    def batch_text_to_image(\n        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量文生图：同时生成多张图片\n\n        Args:\n            prompts: 提示词列表\n            width: 图像宽度\n            height: 图像高度\n            guidance_scale: 提示词一致性\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        results = []\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            try:\n                # 为每个任务生成不同的随机种子\n                seed = random.randint(1, 2147483647)\n\n                result = self.text_to_image(\n                    prompt=prompt, \n                    width=width, \n                    height=height, \n                    guidance_scale=guidance_scale, \n                    seed=seed\n                )\n\n                results.append({\n                    \"success\": True,\n                    \"result\": result,\n                    \"prompt\": prompt\n                })\n\n            except Exception as e:\n                # 避免在日志中显示过长的异常信息\n                error_msg = str(e)\n                if len(error_msg) > 200:\n                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                logger.error(f\"第{i}个任务失败: {error_msg}\")\n                results.append({\n                    \"success\": False,\n                    \"error\": error_msg,\n                    \"prompt\": prompt\n                })\n\n            # 避免请求过于频繁\n            if i < len(prompts):\n                time.sleep(0.5)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n        return results\n\n    def validate_image_size(self, size: str) -> bool:\n        \"\"\"\n        验证图像尺寸是否支持\n\n        Args:\n            size: 图像尺寸字符串，如 \"1024x1024\"\n\n        Returns:\n            bool: 是否支持该尺寸\n        \"\"\"\n        try:\n            # 解析尺寸字符串\n            if 'x' not in size:\n                return False\n                \n            width_str, height_str = size.split('x', 1)\n            width = int(width_str)\n            height = int(height_str)\n            \n            # 验证范围：Seedream 4.0 支持 512-4096像素\n            return (512 <= width <= 4096) and (512 <= height <= 4096)\n            \n        except (ValueError, AttributeError):\n            return False\n\n    def get_supported_sizes(self) -> List[str]:\n        \"\"\"\n        获取常用的图像尺寸列表\n        \n        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n\n        Returns:\n            List[str]: 常用尺寸列表，包含官方推荐尺寸\n        \"\"\"\n        return [\n            # 官方推荐尺寸 (Seedream 4.0)\n            \"2048x2048\",   # 1:1 官方推荐\n            \"2304x1728\",   # 4:3 官方推荐\n            \"1728x2304\",   # 3:4 官方推荐\n            \"2560x1440\",   # 16:9 官方推荐\n            \"1440x2560\",   # 9:16 官方推荐\n            \"2496x1664\",   # 3:2 官方推荐\n            \"1664x2496\",   # 2:3 官方推荐\n            \"3024x1296\",   # 21:9 官方推荐\n            \n            # 兼容性尺寸\n            \"1920x1080\",   # 16:9 兼容\n            \"1080x1920\",   # 9:16 兼容\n            \"1536x1024\",   # 3:2 兼容\n            \"1024x1536\",   # 2:3 兼容\n            \"1512x648\",    # 21:9 兼容\n            \"1280x720\",    # 16:9 小尺寸\n            \"720x1280\",    # 9:16 小尺寸\n            \"1024x1024\",   # 1:1 兼容\n            \"768x768\",     # 1:1 小尺寸\n            \"512x512\",     # 1:1 最小尺寸\n        ]\n","numLines":956,"startLine":1,"totalLines":956}}}
{"parentUuid":"b64b4f9c-8e19-47c9-8633-286841e42564","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JHYqJWzKUfJBcFjkXtE6Jk","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config.unified_config import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        storage_dir = get_storage_dir()\n    59→        if not storage_dir:\n    60→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    61→        self.storage_manager = get_v2_storage_manager(storage_dir)\n    62→        \n    63→        # 保持兼容性别名\n    64→        self.file_manager = self.storage_manager\n    65→        self.metadata_manager = self.storage_manager\n    66→        self.image_storage_manager = self.storage_manager\n    67→        \n    68→        # 保留原有的目录属性以保持兼容性\n    69→        self.data_dir = Path(self.storage_manager.root_path)\n    70→        self.images_dir = self.data_dir / \"images\"\n    71→        self.metadata_dir = self.data_dir / \"metadata\"\n    72→\n    73→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    74→\n    75→    def generate_text_to_image(\n    76→        self,\n    77→        prompt: str,\n    78→        size: str = \"1024x1024\",\n    79→        guidance_scale: float = 2.5,\n    80→        seed: int = -1,\n    81→        save_local: bool = True,\n    82→        reference_images: Optional[List[Any]] = None,\n    83→        model_variant: Optional[str] = None,\n    84→        generation_id: Optional[str] = None,\n    85→        count: int = 1,\n    86→        sequential_mode: bool = False,\n    87→        derived_ids: Optional[List[str]] = None,\n    88→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    89→    ) -> Dict[str, Any]:\n    90→        \"\"\"\n    91→        生成文生图并保存到本地\n    92→\n    93→        Args:\n    94→            prompt: 图像生成提示词\n    95→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    96→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    97→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    98→            response_format: 返回格式，\"url\"或\"b64_json\"\n    99→            save_local: 是否保存到本地\n   100→            reference_images: 参考图列表\n   101→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   102→            count: 生成图片数量（组图模式下生效）\n   103→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   104→            derived_ids: 组图生成的ID列表（用于关联）\n   105→\n   106→        Returns:\n   107→            Dict: 生成结果，包含本地文件路径\n   108→\n   109→        Note:\n   110→            model和watermark参数已固定，不再需要前端控制\n   111→        \"\"\"\n   112→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   113→\n   114→        # 根据 model_variant 选择 provider（并发安全：不写 env）\n   115→        seedream_provider: Optional[str] = None\n   116→        try:\n   117→            mv = (model_variant or \"\").strip().lower()\n   118→            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n   119→                seedream_provider = \"volc_v4\"\n   120→            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n   121→                seedream_provider = \"volc_v4_5\"\n   122→            elif mv.startswith(\"volc_\"):\n   123→                seedream_provider = mv\n   124→        except Exception:\n   125→            seedream_provider = None\n   126→\n   127→        # 生成唯一ID，优先使用外部传入的generation_id\n   128→        task_id = generation_id or str(uuid.uuid4())\n   129→\n   130→        ref_assets: List[Dict[str, Any]] = []\n   131→        ref_paths: List[str] = []\n   132→        ref_summary: Dict[str, Any] = {}\n   133→        ref_payloads: List[str] = []\n   134→\n   135→        try:\n   136→            if reference_images:\n   137→                ref_summary = self._process_reference_assets(\n   138→                    reference_images,\n   139→                    max_refs=MAX_REFERENCE_IMAGES,\n   140→                    expected_outputs=1,\n   141→                )\n   142→                ref_assets = list(ref_summary.get('assets', []))\n   143→                ref_paths = list(ref_summary.get('paths', []))\n   144→                ref_payloads = self._build_reference_payloads(ref_assets)\n   145→\n   146→                if ref_summary.get('errors'):\n   147→                    logger.warning(\n   148→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   149→                    )\n   150→                if ref_summary.get('warnings'):\n   151→                    for warn in ref_summary['warnings']:\n   152→                        logger.warning(f\"参考图提示: {warn}\")\n   153→\n   154→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   155→            try:\n   156→                norm, fb, reason = validate_and_normalize_t2i(\n   157→                    TextToImageParams(\n   158→                        prompt=prompt,\n   159→                        size=size,\n   160→                        guidance_scale=guidance_scale,\n   161→                        seed=(None if seed == -1 else seed),\n   162→                    )\n   163→                )\n   164→                logger.info(\n   165→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   166→                )\n   167→                if fb:\n   168→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   169→            except Exception as _e:\n   170→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   171→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   172→            actual_count = max(1, count)\n   173→            use_group_mode = bool(sequential_mode and actual_count > 1)\n   174→\n   175→            api_result = self.client.text_to_image(\n   176→                prompt=prompt,\n   177→                size=size,\n   178→                guidance_scale=guidance_scale,\n   179→                seed=seed,\n   180→                reference_images=ref_payloads or None,\n   181→                n=actual_count if use_group_mode else 1,\n   182→                sequential_mode=sequential_mode,\n   183→                seedream_provider=seedream_provider,\n   184→            )\n   185→\n   186→            # 组图模式：API 返回多张图，需要逐一保存\n   187→            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n   188→            images_count = len(images_list)\n   189→            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n   190→\n   191→            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n   192→            if use_group_mode and images_count < actual_count:\n   193→                logger.warning(\n   194→                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n   195→                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n   196→                )\n   197→\n   198→            if use_group_mode and images_count > 1:\n   199→                results_batch = []\n   200→                success_count = 0\n   201→                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n   202→                total_images = len(images_list)\n   203→\n   204→                for idx, img_data in enumerate(images_list):\n   205→                    # 发送下载进度（每张图开始下载时）\n   206→                    if progress_callback:\n   207→                        try:\n   208→                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n   209→                        except Exception:\n   210→                            pass\n   211→\n   212→                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n   213→                    per_result = {\n   214→                        \"task_id\": per_id,\n   215→                        \"success\": True,\n   216→                        \"type\": \"text_to_image\",\n   217→                        \"prompt\": prompt,\n   218→                        \"image_url\": img_data[\"url\"],\n   219→                        \"parameters\": {\n   220→                            \"size\": size,\n   221→                            \"guidance_scale\": guidance_scale,\n   222→                            \"seed\": seed,\n   223→                            \"response_format\": \"url\",\n   224→                            \"watermark\": False,\n   225→                            \"model\": self._resolve_model_id(\n   226→                                \"doubao-seedream-3-0-t2i-250415\",\n   227→                                \"doubao-seedream-4-0-250828\",\n   228→                                \"doubao-seedream-4-5-251128\",\n   229→                            ),\n   230→                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   231→                            \"sequential_mode\": True,\n   232→                            \"group_index\": idx + 1,\n   233→                            \"group_total\": total_images,\n   234→                        },\n   235→                        \"created_at\": datetime.now().isoformat(),\n   236→                        \"usage\": api_result.get(\"usage\", {}),\n   237→                    }\n   238→\n   239→                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   240→                    if sanitized_refs:\n   241→                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   242→                        per_result[\"reference_assets\"] = sanitized_refs\n   243→\n   244→                    if save_local and per_result.get(\"image_url\"):\n   245→                        local_result = self._save_image_locally(per_result)\n   246→                        per_result.update(local_result)\n   247→                        if not local_result.get('local_save_error'):\n   248→                            success_count += 1\n   249→\n   250→                    results_batch.append(per_result)\n   251→\n   252→                    # 发送下载完成进度\n   253→                    if progress_callback:\n   254→                        try:\n   255→                            progress_callback(idx + 1, total_images, per_result)\n   256→                        except Exception:\n   257→                            pass\n   258→\n   259→                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n   260→                return {\n   261→                    \"batch\": True,\n   262→                    \"results\": results_batch,\n   263→                    \"success_count\": success_count,\n   264→                    \"total_count\": len(results_batch),\n   265→                    \"derived_ids\": group_ids,\n   266→                }\n   267→\n   268→            # 单图模式（默认）\n   269→            result = {\n   270→                \"task_id\": task_id,\n   271→                \"success\": True,\n   272→                \"type\": \"text_to_image\",\n   273→                \"prompt\": prompt,\n   274→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   275→                \"parameters\": {\n   276→                    \"size\": size,\n   277→                    \"guidance_scale\": guidance_scale,\n   278→                    \"seed\": seed,\n   279→                    \"response_format\": \"url\",  # 固定值\n   280→                    \"watermark\": False,  # 固定值\n   281→                    \"model\": self._resolve_model_id(\n   282→                        \"doubao-seedream-3-0-t2i-250415\",\n   283→                        \"doubao-seedream-4-0-250828\",\n   284→                        \"doubao-seedream-4-5-251128\",\n   285→                    ),\n   286→                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   287→                },\n   288→                \"created_at\": datetime.now().isoformat(),\n   289→                \"usage\": api_result.get(\"usage\", {}),\n   290→            }\n   291→\n   292→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   293→            if sanitized_refs:\n   294→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   295→                result[\"reference_assets\"] = sanitized_refs\n   296→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   297→                logger.info(\n   298→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   299→                    len(sanitized_refs),\n   300→                    masked_ids or \"-\",\n   301→                    self._provider_used(),\n   302→                )\n   303→            else:\n   304→                result[\"parameters\"][\"reference_assets\"] = []\n   305→                result[\"reference_assets\"] = []\n   306→\n   307→            # 保存到本地\n   308→            if save_local and result.get(\"image_url\"):\n   309→                local_result = self._save_image_locally(result)\n   310→                result.update(local_result)\n   311→                if local_result.get('local_save_error') and sanitized_refs:\n   312→                    self._cleanup_reference_paths(ref_paths)\n   313→                    result[\"parameters\"][\"reference_assets\"] = []\n   314→                    result[\"reference_assets\"] = []\n   315→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   316→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   317→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   318→\n   319→            logger.success(f\"文生图任务完成: {task_id}\")\n   320→            return result\n   321→\n   322→        except Exception as e:\n   323→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   324→            self._cleanup_reference_paths(ref_paths)\n   325→            return {\n   326→                \"task_id\": task_id,\n   327→                \"success\": False,\n   328→                \"error\": str(e),\n   329→                \"type\": \"text_to_image\"\n   330→            }\n   331→\n   332→    def generate_image_to_image(\n   333→        self,\n   334→        prompt: str,\n   335→        image: str,\n   336→        guidance_scale: float = 5.5,\n   337→        seed: int = -1,\n   338→        save_local: bool = True,\n   339→        reference_images: Optional[List[Any]] = None,\n   340→        generation_id: Optional[str] = None,\n   341→    ) -> Dict[str, Any]:\n   342→        \"\"\"\n   343→        生成图生图并保存到本地\n   344→\n   345→        Args:\n   346→            prompt: 编辑提示词\n   347→            image_path: 原始图像路径（本地路径或URL）\n   348→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   349→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   350→            response_format: 返回格式，\"url\"或\"b64_json\"\n   351→            save_local: 是否保存到本地\n   352→\n   353→        Returns:\n   354→            Dict: 生成结果\n   355→        \n   356→        Note:\n   357→            model、size、watermark参数已固定，不再需要前端控制\n   358→        \"\"\"\n   359→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   360→\n   361→        # 生成唯一ID，优先使用外部传入的generation_id\n   362→        task_id = generation_id or str(uuid.uuid4())\n   363→\n   364→        ref_paths: List[str] = []\n   365→\n   366→        try:\n   367→            # 处理输入图像\n   368→            image_data = self._prepare_input_image(image)\n   369→            if not image_data:\n   370→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   371→\n   372→            # 处理参考图（复制到 references 并准备 API 载荷）\n   373→            ref_summary = self._process_reference_assets(\n   374→                reference_images,\n   375→                max_refs=MAX_REFERENCE_IMAGES,\n   376→                expected_outputs=1,\n   377→            )\n   378→            ref_assets = ref_summary.get('assets', [])\n   379→            ref_paths = list(ref_summary.get('paths', []))\n   380→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   381→            if ref_summary.get('errors'):\n   382→                logger.warning(\n   383→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   384→                )\n   385→            if ref_summary.get('warnings'):\n   386→                for warn in ref_summary['warnings']:\n   387→                    logger.warning(f\"参考图提示: {warn}\")\n   388→\n   389→            # 前置参数校验（不改变流程，仅记录摘要）\n   390→            fb = False\n   391→            reason = \"\"\n   392→            try:\n   393→                norm, fb, reason = validate_and_normalize_i2i(\n   394→                    ImageToImageParams(\n   395→                        prompt=prompt,\n   396→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   397→                        guidance_scale=guidance_scale,\n   398→                        seed=(None if seed == -1 else seed),\n   399→                        reference_images=ref_payloads,\n   400→                    )\n   401→                )\n   402→                logger.info(\n   403→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   404→                )\n   405→                if fb:\n   406→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   407→            except Exception as _e:\n   408→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   409→\n   410→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   411→            api_result = self.client.image_to_image(\n   412→                prompt=prompt,\n   413→                image=image_data,\n   414→                guidance_scale=guidance_scale,\n   415→                seed=seed,\n   416→                reference_images=(ref_payloads or None),\n   417→            )\n   418→\n   419→            # 处理input_image字段，避免在日志中输出大量base64数据\n   420→            input_image_info = \"[图像数据]\"\n   421→            if image:\n   422→                if image.startswith(\"data:image/\"):\n   423→                    # 如果是base64数据，只保留格式信息\n   424→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   425→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   426→                elif image.startswith((\"http://\", \"https://\")):\n   427→                    # 如果是URL，保留URL\n   428→                    input_image_info = image\n   429→                else:\n   430→                    # 如果是文件路径，只保留文件名\n   431→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   432→            \n   433→            result = {\n   434→                \"task_id\": task_id,\n   435→                \"success\": True,\n   436→                \"type\": \"image_to_image\",\n   437→                \"prompt\": prompt,\n   438→                \"input_image\": input_image_info,\n   439→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   440→                \"parameters\": {\n   441→                    \"guidance_scale\": guidance_scale, \n   442→                    \"seed\": seed, \n   443→                    \"response_format\": \"url\",  # 固定值\n   444→                    \"watermark\": False,  # 固定值\n   445→                    \"size\": \"adaptive\",  # 固定值\n   446→                    \"model\": self._resolve_model_id(\n   447→                        \"doubao-seededit-3-0-i2i-250628\",\n   448→                        \"doubao-seedream-4-0-250828\",\n   449→                        \"doubao-seedream-4-5-251128\",\n   450→                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n   451→                },\n   452→                \"created_at\": datetime.now().isoformat(),\n   453→                \"usage\": api_result.get(\"usage\", {}),\n   454→            }\n   455→\n   456→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   457→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   458→            result[\"reference_assets\"] = sanitized_refs\n   459→            if ref_summary.get('errors'):\n   460→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   461→            if ref_summary.get('warnings'):\n   462→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   463→            if fb and reason:\n   464→                result[\"fallback_applied\"] = True\n   465→                result[\"fallback_reason\"] = reason\n   466→\n   467→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   468→            logger.info(\n   469→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   470→                len(sanitized_refs),\n   471→                masked_ids or \"-\",\n   472→                self._provider_used(),\n   473→            )\n   474→\n   475→            # 保存到本地\n   476→            if save_local and result.get(\"image_url\"):\n   477→                local_result = self._save_image_locally(result)\n   478→                result.update(local_result)\n   479→                if local_result.get('local_save_error'):\n   480→                    self._cleanup_reference_paths(ref_paths)\n   481→                    result[\"parameters\"][\"reference_assets\"] = []\n   482→                    result[\"reference_assets\"] = []\n   483→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   484→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   485→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   486→\n   487→            logger.success(f\"图生图任务完成: {task_id}\")\n   488→            return result\n   489→\n   490→        except Exception as e:\n   491→            # 避免在日志中显示可能包含base64数据的异常信息\n   492→            error_msg = str(e)\n   493→            if len(error_msg) > 200:\n   494→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   495→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   496→            self._cleanup_reference_paths(ref_paths)\n   497→            return {\n   498→                \"task_id\": task_id,\n   499→                \"success\": False,\n   500→                \"error\": error_msg,\n   501→                \"type\": \"image_to_image\"\n   502→            }\n   503→\n   504→    def batch_generate_text_to_image(\n   505→        self,\n   506→        prompts: List[str],\n   507→        size: str = \"1024x1024\",\n   508→        guidance_scale: float = 2.5,\n   509→        save_local: bool = True,\n   510→    ) -> List[Dict[str, Any]]:\n   511→        \"\"\"\n   512→        批量生成文生图（顺序执行，保持向后兼容）\n   513→\n   514→        Args:\n   515→            prompts: 提示词列表\n   516→            size: 图像尺寸\n   517→            guidance_scale: 提示词一致性\n   518→            save_local: 是否保存到本地\n   519→\n   520→        Returns:\n   521→            List[Dict]: 生成结果列表\n   522→        \n   523→        Note:\n   524→            水印参数已固定为False，不再需要前端控制\n   525→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   526→        \"\"\"\n   527→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   528→\n   529→        results = []\n   530→        for i, prompt in enumerate(prompts, 1):\n   531→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   532→\n   533→            result = self.generate_text_to_image(\n   534→                prompt=prompt,\n   535→                size=size,\n   536→                guidance_scale=guidance_scale,\n   537→                save_local=save_local,\n   538→                generation_id=None,\n   539→            )\n   540→\n   541→            results.append(result)\n   542→\n   543→        success_count = sum(1 for r in results if r[\"success\"])\n   544→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   545→\n   546→        return results\n   547→\n   548→    def concurrent_generate_text_to_image(\n   549→        self,\n   550→        prompt: str,\n   551→        count: int = 4,\n   552→        size: str = \"1024x1024\",\n   553→        guidance_scale: float = 2.5,\n   554→        seed: int = -1,\n   555→        save_local: bool = True,\n   556→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   557→        max_workers: int = 5,\n   558→        derived_ids: Optional[List[str]] = None,\n   559→        generation_id: Optional[str] = None,\n   560→        model_variant: Optional[str] = None,\n   561→        sequential_mode: bool = False,\n   562→    ) -> Dict[str, Any]:\n   563→        \"\"\"\n   564→        并发生成多张文生图\n   565→\n   566→        Args:\n   567→            prompt: 图像生成提示词\n   568→            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n   569→            size: 图像尺寸\n   570→            guidance_scale: 引导强度\n   571→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   572→            save_local: 是否保存到本地\n   573→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   574→            max_workers: 最大并发数\n   575→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   576→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   577→\n   578→        Returns:\n   579→            Dict: 包含所有任务结果的字典\n   580→        \"\"\"\n   581→        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n   582→        max_allowed = 15 if sequential_mode else 10\n   583→        if count < 1 or count > max_allowed:\n   584→            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n   585→\n   586→        # 组图模式：单次 API 调用返回多张图\n   587→        if sequential_mode:\n   588→            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n   589→            return self.generate_text_to_image(\n   590→                prompt=prompt,\n   591→                size=size,\n   592→                guidance_scale=guidance_scale,\n   593→                seed=seed,\n   594→                save_local=save_local,\n   595→                model_variant=model_variant,\n   596→                generation_id=generation_id,\n   597→                count=count,\n   598→                sequential_mode=True,\n   599→                derived_ids=derived_ids,\n   600→                progress_callback=progress_callback,\n   601→            )\n   602→        \n   603→        if max_workers > count:\n   604→            max_workers = count\n   605→        \n   606→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   607→        \n   608→        # 生成批次ID\n   609→        batch_id = str(uuid.uuid4())\n   610→        start_time = time.time()\n   611→\n   612→        slots = max(1, count)\n   613→        per_ids: List[str] = list(derived_ids or [])\n   614→        if len(per_ids) < slots:\n   615→            base = generation_id or batch_id\n   616→            for idx in range(len(per_ids), slots):\n   617→                per_ids.append(f\"{base}_{idx + 1}\")\n   618→        \n   619→        # 准备任务参数\n   620→        tasks = []\n   621→        for i in range(count):\n   622→            # 为每个任务生成不同的种子（如果seed为-1）\n   623→            task_seed = seed if seed != -1 else None\n   624→            gen_id = per_ids[i] if i < len(per_ids) else None\n   625→            tasks.append({\n   626→                'prompt': prompt,\n   627→                'size': size,\n   628→                'guidance_scale': guidance_scale,\n   629→                'seed': task_seed,\n   630→                'save_local': save_local,\n   631→                'task_index': i + 1,\n   632→                'generation_id': gen_id,\n   633→                'model_variant': model_variant,\n   634→            })\n   635→        \n   636→        # 使用线程池并发执行\n   637→        results = []\n   638→        completed_count = 0\n   639→        \n   640→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   641→            # 提交所有任务\n   642→            future_to_task = {\n   643→                executor.submit(self._execute_single_text_to_image_task, task): task \n   644→                for task in tasks\n   645→            }\n   646→            \n   647→            # 收集结果\n   648→            for future in as_completed(future_to_task):\n   649→                task = future_to_task[future]\n   650→                try:\n   651→                    result = future.result()\n   652→                    result['task_index'] = task['task_index']\n   653→                    result['batch_id'] = batch_id\n   654→                    results.append(result)\n   655→                    \n   656→                    completed_count += 1\n   657→                    \n   658→                    # 调用进度回调\n   659→                    if progress_callback:\n   660→                        try:\n   661→                            progress_callback(completed_count, count, result)\n   662→                        except Exception as e:\n   663→                            logger.warning(f\"进度回调执行失败: {e}\")\n   664→                    \n   665→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   666→                    \n   667→                except Exception as e:\n   668→                    error_result = {\n   669→                        'task_index': task['task_index'],\n   670→                        'batch_id': batch_id,\n   671→                        'success': False,\n   672→                        'error': str(e),\n   673→                        'type': 'text_to_image'\n   674→                    }\n   675→                    results.append(error_result)\n   676→                    completed_count += 1\n   677→                    \n   678→                    if progress_callback:\n   679→                        try:\n   680→                            progress_callback(completed_count, count, error_result)\n   681→                        except Exception as e:\n   682→                            logger.warning(f\"进度回调执行失败: {e}\")\n   683→                    \n   684→                    # 避免在日志中显示可能包含base64数据的异常信息\n   685→                    error_msg = str(e)\n   686→                    if len(error_msg) > 200:\n   687→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   688→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   689→        \n   690→        # 按task_index排序\n   691→        results.sort(key=lambda x: x.get('task_index', 0))\n   692→        \n   693→        # 统计结果\n   694→        success_count = sum(1 for r in results if r.get('success', False))\n   695→        total_time = time.time() - start_time\n   696→        \n   697→        batch_result = {\n   698→            'batch_id': batch_id,\n   699→            'success': True,\n   700→            'prompt': prompt,\n   701→            'total_count': count,\n   702→            'success_count': success_count,\n   703→            'failed_count': count - success_count,\n   704→            'total_time': round(total_time, 2),\n   705→            'average_time': round(total_time / count, 2),\n   706→            'results': results,\n   707→            'parameters': {\n   708→                'size': size,\n   709→                'guidance_scale': guidance_scale,\n   710→                'seed': seed,\n   711→                'max_workers': max_workers\n   712→            },\n   713→            'derived_ids': per_ids,\n   714→            'created_at': datetime.now().isoformat()\n   715→        }\n   716→        \n   717→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   718→        return batch_result\n   719→\n   720→    def concurrent_generate_image_to_image(\n   721→        self,\n   722→        prompt: str,\n   723→        image: str,\n   724→        count: int = 4,\n   725→        guidance_scale: float = 5.5,\n   726→        seed: int = -1,\n   727→        save_local: bool = True,\n   728→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   729→        max_workers: int = 5,\n   730→        derived_ids: Optional[List[str]] = None,\n   731→        generation_id: Optional[str] = None,\n   732→    ) -> Dict[str, Any]:\n   733→        \"\"\"\n   734→        并发生成多张图生图\n   735→\n   736→        Args:\n   737→            prompt: 编辑提示词\n   738→            image: 输入图像路径或URL\n   739→            count: 生成图片数量，默认4张，最多10张\n   740→            guidance_scale: 引导强度\n   741→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   742→            save_local: 是否保存到本地\n   743→            progress_callback: 进度回调函数\n   744→            max_workers: 最大并发数\n   745→\n   746→        Returns:\n   747→            Dict: 包含所有任务结果的字典\n   748→        \"\"\"\n   749→        # 验证参数\n   750→        if count < 1 or count > 10:\n   751→            raise ValueError(\"生成数量必须在1-10之间\")\n   752→        \n   753→        if max_workers > count:\n   754→            max_workers = count\n   755→        \n   756→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   757→        \n   758→        # 生成批次ID\n   759→        batch_id = str(uuid.uuid4())\n   760→        start_time = time.time()\n   761→        \n   762→        slots = max(1, count)\n   763→        per_ids: List[str] = list(derived_ids or [])\n   764→        if len(per_ids) < slots:\n   765→            base = generation_id or batch_id\n   766→            for idx in range(len(per_ids), slots):\n   767→                per_ids.append(f\"{base}_{idx + 1}\")\n   768→        \n   769→        # 准备输入图像\n   770→        image_data = self._prepare_input_image(image)\n   771→        if not image_data:\n   772→            return {\n   773→                'batch_id': batch_id,\n   774→                'success': False,\n   775→                'error': '无法处理输入图像',\n   776→                'type': 'image_to_image'\n   777→            }\n   778→        \n   779→        # 准备任务参数\n   780→        tasks = []\n   781→        for i in range(count):\n   782→            task_seed = seed if seed != -1 else None\n   783→            gen_id = per_ids[i] if i < len(per_ids) else None\n   784→            tasks.append({\n   785→                'prompt': prompt,\n   786→                'image': image_data,\n   787→                'guidance_scale': guidance_scale,\n   788→                'seed': task_seed,\n   789→                'save_local': save_local,\n   790→                'task_index': i + 1,\n   791→                'generation_id': gen_id\n   792→            })\n   793→        \n   794→        # 使用线程池并发执行\n   795→        results = []\n   796→        completed_count = 0\n   797→        \n   798→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   799→            # 提交所有任务\n   800→            future_to_task = {\n   801→                executor.submit(self._execute_single_image_to_image_task, task): task \n   802→                for task in tasks\n   803→            }\n   804→            \n   805→            # 收集结果\n   806→            for future in as_completed(future_to_task):\n   807→                task = future_to_task[future]\n   808→                try:\n   809→                    result = future.result()\n   810→                    result['task_index'] = task['task_index']\n   811→                    result['batch_id'] = batch_id\n   812→                    results.append(result)\n   813→                    \n   814→                    completed_count += 1\n   815→                    \n   816→                    # 调用进度回调\n   817→                    if progress_callback:\n   818→                        try:\n   819→                            progress_callback(completed_count, count, result)\n   820→                        except Exception as e:\n   821→                            logger.warning(f\"进度回调执行失败: {e}\")\n   822→                    \n   823→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   824→                    \n   825→                except Exception as e:\n   826→                    error_result = {\n   827→                        'task_index': task['task_index'],\n   828→                        'batch_id': batch_id,\n   829→                        'success': False,\n   830→                        'error': str(e),\n   831→                        'type': 'image_to_image'\n   832→                    }\n   833→                    results.append(error_result)\n   834→                    completed_count += 1\n   835→                    \n   836→                    if progress_callback:\n   837→                        try:\n   838→                            progress_callback(completed_count, count, error_result)\n   839→                        except Exception as e:\n   840→                            logger.warning(f\"进度回调执行失败: {e}\")\n   841→                    \n   842→                    # 避免在日志中显示可能包含base64数据的异常信息\n   843→                    error_msg = str(e)\n   844→                    if len(error_msg) > 200:\n   845→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   846→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   847→        \n   848→        # 按task_index排序\n   849→        results.sort(key=lambda x: x.get('task_index', 0))\n   850→        \n   851→        # 统计结果\n   852→        success_count = sum(1 for r in results if r.get('success', False))\n   853→        total_time = time.time() - start_time\n   854→        \n   855→        # 处理input_image字段，避免在日志中输出大量base64数据\n   856→        input_image_info = \"[图像数据]\"\n   857→        if image:\n   858→            if image.startswith(\"data:image/\"):\n   859→                # 如果是base64数据，只保留格式信息\n   860→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   861→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   862→            elif image.startswith((\"http://\", \"https://\")):\n   863→                # 如果是URL，保留URL\n   864→                input_image_info = image\n   865→            else:\n   866→                # 如果是文件路径，只保留文件名\n   867→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   868→        \n   869→        batch_result = {\n   870→            'batch_id': batch_id,\n   871→            'success': True,\n   872→            'prompt': prompt,\n   873→            'input_image': input_image_info,\n   874→            'total_count': count,\n   875→            'success_count': success_count,\n   876→            'failed_count': count - success_count,\n   877→            'total_time': round(total_time, 2),\n   878→            'average_time': round(total_time / count, 2),\n   879→            'results': results,\n   880→            'parameters': {\n   881→                'guidance_scale': guidance_scale,\n   882→                'seed': seed,\n   883→                'max_workers': max_workers\n   884→            },\n   885→            'derived_ids': per_ids,\n   886→            'created_at': datetime.now().isoformat()\n   887→        }\n   888→        \n   889→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   890→        return batch_result\n   891→\n   892→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   893→        \"\"\"\n   894→        执行单个文生图任务\n   895→        \n   896→        Args:\n   897→            task: 任务参数字典\n   898→            \n   899→        Returns:\n   900→            Dict: 任务执行结果\n   901→        \"\"\"\n   902→        return self.generate_text_to_image(\n   903→            prompt=task['prompt'],\n   904→            size=task['size'],\n   905→            guidance_scale=task['guidance_scale'],\n   906→            seed=task['seed'],\n   907→            save_local=task['save_local'],\n   908→            generation_id=task.get('generation_id'),\n   909→            model_variant=task.get('model_variant'),\n   910→        )\n   911→    \n   912→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   913→        \"\"\"\n   914→        执行单个图生图任务\n   915→        \n   916→        Args:\n   917→            task: 任务参数字典\n   918→            \n   919→        Returns:\n   920→            Dict: 任务执行结果\n   921→        \"\"\"\n   922→        # 生成唯一ID，优先使用外部传入的generation_id\n   923→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   924→        \n   925→        try:\n   926→            # 直接使用已经处理好的图片数据，避免重复处理\n   927→            image_data = task['image']\n   928→            \n   929→            # 调用API生成图像\n   930→            api_result = self.client.image_to_image(\n   931→                prompt=task['prompt'], \n   932→                image=image_data, \n   933→                guidance_scale=task['guidance_scale'], \n   934→                seed=task['seed']\n   935→            )\n   936→            \n   937→            result = {\n   938→                \"task_id\": task_id,\n   939→                \"success\": True,\n   940→                \"type\": \"image_to_image\",\n   941→                \"prompt\": task['prompt'],\n   942→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   943→                \"parameters\": {\n   944→                    \"guidance_scale\": task['guidance_scale'], \n   945→                    \"seed\": task['seed'], \n   946→                    \"response_format\": \"url\",\n   947→                    \"watermark\": False,\n   948→                    \"size\": \"adaptive\",\n   949→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   950→                },\n   951→                \"created_at\": datetime.now().isoformat(),\n   952→                \"usage\": api_result.get(\"usage\", {}),\n   953→            }\n   954→            \n   955→            # 保存到本地\n   956→            if task['save_local'] and result.get(\"image_url\"):\n   957→                local_result = self._save_image_locally(result)\n   958→                result.update(local_result)\n   959→            \n   960→            return result\n   961→            \n   962→        except Exception as e:\n   963→            # 避免在日志中显示可能包含base64数据的异常信息\n   964→            error_msg = str(e)\n   965→            if len(error_msg) > 200:\n   966→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   967→            return {\n   968→                \"task_id\": task_id,\n   969→                \"success\": False,\n   970→                \"error\": error_msg,\n   971→                \"type\": \"image_to_image\"\n   972→            }\n   973→\n   974→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   975→        \"\"\"\n   976→        保存图像到本地并记录元数据\n   977→\n   978→        Args:\n   979→            result: API生成结果\n   980→\n   981→        Returns:\n   982→            Dict: 包含本地文件信息的字典\n   983→        \"\"\"\n   984→        try:\n   985→            # 下载图像\n   986→            image_url = result[\"image_url\"]\n   987→            response = safe_requests_get(image_url, timeout=30)\n   988→\n   989→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   990→            from io import BytesIO\n   991→            real_w, real_h = None, None\n   992→            try:\n   993→                with Image.open(BytesIO(response.content)) as img:\n   994→                    real_w, real_h = int(img.width), int(img.height)\n   995→            except Exception as _e:\n   996→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n   997→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   998→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   999→\n  1000→            # 组装元数据（适配UnifiedStorageManager的格式）\n  1001→            params = result.get(\"parameters\", {}) or {}\n  1002→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n  1003→            try:\n  1004→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n  1005→                    from math import gcd\n  1006→                    g = gcd(real_w, real_h)\n  1007→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n  1008→            except Exception:\n  1009→                pass\n  1010→\n  1011→            metadata = {\n  1012→                'generation_id': result.get(\"task_id\", \"\"),\n  1013→                'prompt': result.get(\"prompt\", \"\"),\n  1014→                'parameters': params,\n  1015→                'model': params.get(\"model\", \"seedream\"),\n  1016→                'width': real_w,\n  1017→                'height': real_h,\n  1018→                'generation_time': result.get(\"generation_time\", 0),\n  1019→                'batch_id': result.get(\"batch_id\", \"\"),\n  1020→                'status': 'completed'\n  1021→            }\n  1022→            \n  1023→            # 使用统一存储管理器保存文件\n  1024→            save_result = self.storage_manager.save_content_file(\n  1025→                content_type='images',\n  1026→                file_data=response.content,\n  1027→                url=image_url,\n  1028→                metadata=metadata\n  1029→            )\n  1030→\n  1031→            # 获取图像信息（再次确认像素尺寸）\n  1032→            image_info = self._get_image_info(Path(save_result['local_path']))\n  1033→            file_size = Path(save_result['local_path']).stat().st_size\n  1034→\n  1035→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n  1036→\n  1037→            result_obj = {\n  1038→                \"local_path\": save_result['local_path'],\n  1039→                \"filename\": Path(save_result['local_path']).name,\n  1040→                \"file_size\": file_size,\n  1041→                \"image_info\": image_info,\n  1042→                \"file_path\": save_result['local_path'],  # 保持兼容性\n  1043→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n  1044→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n  1045→                \"file_id\": save_result.get('file_id'),\n  1046→                \"relative_path\": save_result.get('relative_path'),\n  1047→            }\n  1048→            try:\n  1049→                w = image_info.get('width') if isinstance(image_info, dict) else None\n  1050→                h = image_info.get('height') if isinstance(image_info, dict) else None\n  1051→                logger.info(\n  1052→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n  1053→                )\n  1054→            except Exception:\n  1055→                pass\n  1056→\n  1057→            # 体验版本地图片水印（使用统一水印服务）\n  1058→            if should_add_watermark():\n  1059→                try:\n  1060→                    from edition.watermark_service import WatermarkService\n  1061→\n  1062→                    watermark_text = get_watermark_text() or \"PIGEON\"\n  1063→                    try:\n  1064→                        opacity = get_watermark_opacity()\n  1065→                    except Exception:\n  1066→                        opacity = 0.3\n  1067→                    opacity = max(0.0, min(opacity, 1.0))\n  1068→\n  1069→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n  1070→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n  1071→                    if watermark_applied:\n  1072→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n  1073→                        result_obj[\"watermark_applied\"] = True\n  1074→                    else:\n  1075→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n  1076→                        result_obj[\"watermark_applied\"] = False\n  1077→                except Exception as e:\n  1078→                    logger.warning(f\"添加图片水印时出错: {e}\")\n  1079→                    result_obj[\"watermark_applied\"] = False\n  1080→\n  1081→            return result_obj\n  1082→\n  1083→        except Exception as e:\n  1084→            logger.error(f\"保存图像到本地失败: {e}\")\n  1085→            try:\n  1086→                logger.info(\"摘要|operation=save_image status=failed\")\n  1087→            except Exception:\n  1088→                pass\n  1089→            return {\"local_save_error\": str(e)}\n  1090→\n  1091→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1092→        checksum = hashlib.sha1(file_data).hexdigest()\n  1093→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1094→        return f\"ref_{ts}_{checksum[:8]}\"\n  1095→\n  1096→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1097→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1098→        source_meta: Dict[str, Any] = {}\n  1099→        raw = ref\n  1100→        if isinstance(ref, dict):\n  1101→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1102→                if ref.get(key) is not None:\n  1103→                    source_meta[key] = ref.get(key)\n  1104→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1105→        if raw is None:\n  1106→            return None\n  1107→\n  1108→        extension = source_meta.get('extension')\n  1109→        data = None\n  1110→        source_repr = source_meta.get('source')\n  1111→\n  1112→        try:\n  1113→            if isinstance(raw, bytes):\n  1114→                data = raw\n  1115→            elif isinstance(raw, str):\n  1116→                stripped = raw.strip()\n  1117→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1118→                    header, payload = stripped.split(';base64,', 1)\n  1119→                    mime_part = header[5:]\n  1120→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n  1121→                    data = base64.b64decode(payload)\n  1122→                    source_repr = source_repr or mime_part\n  1123→                    source_meta.setdefault('type', 'image')\n  1124→                elif stripped.startswith(('http://', 'https://')):\n  1125→                    resp = safe_requests_get(stripped, timeout=15)\n  1126→                    data = resp.content\n  1127→                    parsed = urlparse(stripped)\n  1128→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1129→                    source_repr = source_repr or stripped\n  1130→                    source_meta.setdefault('source_url', stripped)\n  1131→                else:\n  1132→                    path = Path(stripped)\n  1133→                    if not path.exists():\n  1134→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1135→                        return None\n  1136→                    data = path.read_bytes()\n  1137→                    extension = extension or path.suffix or '.png'\n  1138→                    source_repr = source_repr or path.name\n  1139→                    source_meta.setdefault('source_path', str(path))\n  1140→            else:\n  1141→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1142→                return None\n  1143→        except Exception as exc:\n  1144→            logger.warning(f\"加载参考图失败: {exc}\")\n  1145→            return None\n  1146→\n  1147→        if data is None:\n  1148→            return None\n  1149→\n  1150→        width = source_meta.get('width')\n  1151→        height = source_meta.get('height')\n  1152→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1153→            try:\n  1154→                from io import BytesIO\n  1155→\n  1156→                with Image.open(BytesIO(data)) as img:\n  1157→                    width = img.width\n  1158→                    height = img.height\n  1159→            except Exception:\n  1160→                pass\n  1161→\n  1162→        source_meta['width'] = width\n  1163→        source_meta['height'] = height\n  1164→        source_meta.setdefault('type', 'image')\n  1165→        source_meta['source'] = source_repr or source_meta.get('source')\n  1166→\n  1167→        return data, extension, source_meta\n  1168→\n  1169→    def _process_reference_assets(\n  1170→        self,\n  1171→        references: Optional[List[Any]],\n  1172→        *,\n  1173→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1174→        expected_outputs: int = 1,\n  1175→    ) -> Dict[str, Any]:\n  1176→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1177→        stored: List[Dict[str, Any]] = []\n  1178→        absolute_paths: List[str] = []\n  1179→        errors: List[str] = []\n  1180→        warnings: List[str] = []\n  1181→\n  1182→        if not references:\n  1183→            return {\n  1184→                'assets': stored,\n  1185→                'paths': absolute_paths,\n  1186→                'errors': errors,\n  1187→                'warnings': warnings,\n  1188→            }\n  1189→\n  1190→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1191→            warnings.append(\n  1192→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1193→            )\n  1194→            references = references[:max_refs]\n  1195→\n  1196→        for order, item in enumerate(references):\n  1197→            load_result = self._load_reference_source(item)\n  1198→            if not load_result:\n  1199→                errors.append(f\"ref[{order}] 加载失败\")\n  1200→                continue\n  1201→\n  1202→            file_data, extension, meta = load_result\n  1203→            meta.setdefault('order', order)\n  1204→            meta.setdefault('kind', meta.get('type', 'image'))\n  1205→\n  1206→            try:\n  1207→                asset_id = self._generate_reference_asset_id(file_data)\n  1208→                record = self.storage_manager.save_reference_asset(\n  1209→                    'images',\n  1210→                    file_data,\n  1211→                    asset_id=asset_id,\n  1212→                    extension=extension,\n  1213→                    metadata=meta,\n  1214→                )\n  1215→                try:\n  1216→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1217→                except Exception:\n  1218→                    record['_payload_b64'] = None\n  1219→                record['_source_meta'] = meta\n  1220→                stored.append(record)\n  1221→                if record.get('absolute_path'):\n  1222→                    absolute_paths.append(record['absolute_path'])\n  1223→            except Exception as exc:\n  1224→                logger.warning(f\"保存参考图失败: {exc}\")\n  1225→                errors.append(f\"ref[{order}] 保存失败\")\n  1226→\n  1227→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1228→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1229→            if len(stored) > allowed:\n  1230→                warnings.append(\n  1231→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1232→                )\n  1233→                stored = stored[:allowed]\n  1234→                absolute_paths = absolute_paths[:allowed]\n  1235→\n  1236→        return {\n  1237→            'assets': stored,\n  1238→            'paths': absolute_paths,\n  1239→            'errors': errors,\n  1240→            'warnings': warnings,\n  1241→        }\n  1242→\n  1243→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1244→        payloads: List[str] = []\n  1245→        for asset in assets or []:\n  1246→            payload = asset.get('_payload_b64')\n  1247→            if not payload:\n  1248→                continue\n  1249→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1250→            mime = 'image/png'\n  1251→            try:\n  1252→                if path_hint:\n  1253→                    suffix = Path(path_hint).suffix.lower()\n  1254→                    if suffix in {'.jpg', '.jpeg'}:\n  1255→                        mime = 'image/jpeg'\n  1256→                    elif suffix == '.webp':\n  1257→                        mime = 'image/webp'\n  1258→                    elif suffix == '.bmp':\n  1259→                        mime = 'image/bmp'\n  1260→                    elif suffix == '.gif':\n  1261→                        mime = 'image/gif'\n  1262→            except Exception:\n  1263→                pass\n  1264→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1265→        return payloads\n  1266→\n  1267→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1268→        provider = (self.client.last_provider() or \"\").lower()\n  1269→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1270→            return v4_5_model or v4_model\n  1271→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1272→            return v4_model\n  1273→        return default_model\n  1274→\n  1275→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1276→        cleaned: List[Dict[str, Any]] = []\n  1277→        for rec in assets or []:\n  1278→            rec.pop('_payload_b64', None)\n  1279→            rec.pop('_source_meta', None)\n  1280→            rec.pop('absolute_path', None)\n  1281→            cleaned.append({\n  1282→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1283→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1284→                'type': rec.get('type'),\n  1285→                'kind': rec.get('kind'),\n  1286→                'source': rec.get('source'),\n  1287→                'order': rec.get('order'),\n  1288→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1289→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1290→                'width': rec.get('width'),\n  1291→                'height': rec.get('height'),\n  1292→                'created_at': rec.get('created_at'),\n  1293→            })\n  1294→        return cleaned\n  1295→\n  1296→    @staticmethod\n  1297→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1298→        masked: List[str] = []\n  1299→        for rec in assets or []:\n  1300→            rid = rec.get('id') or ''\n  1301→            if not rid:\n  1302→                continue\n  1303→            masked.append(f\"{rid[:6]}***\")\n  1304→        return \",\".join(masked)\n  1305→\n  1306→    @staticmethod\n  1307→    def _provider_hint() -> str:\n  1308→        try:\n  1309→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1310→        except Exception:\n  1311→            return \"unknown\"\n  1312→\n  1313→    def _provider_used(self) -> str:\n  1314→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1315→        if provider:\n  1316→            return provider\n  1317→        return self._provider_hint()\n  1318→\n  1319→    @staticmethod\n  1320→    def _cleanup_reference_paths(paths: List[str]):\n  1321→        for path in paths or []:\n  1322→            try:\n  1323→                if path and Path(path).exists():\n  1324→                    Path(path).unlink(missing_ok=True)\n  1325→            except Exception as exc:\n  1326→                logger.debug(f\"参考图清理失败: {exc}\")\n  1327→\n  1328→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1329→        \"\"\"\n  1330→        准备输入图像，支持本地文件和URL\n  1331→        \n  1332→        Args:\n  1333→            image_path: 图像路径（本地路径或URL）\n  1334→            \n  1335→        Returns:\n  1336→            str: 图像URL、base64数据或None\n  1337→        \"\"\"\n  1338→        try:\n  1339→            # 如果是URL，直接返回\n  1340→            if image_path.startswith((\"http://\", \"https://\")):\n  1341→                return image_path\n  1342→\n  1343→            # 如果是本地文件，转换为Base64\n  1344→            local_path = Path(image_path)\n  1345→            if local_path.exists():\n  1346→                with open(local_path, \"rb\") as f:\n  1347→                    image_data = f.read()\n  1348→\n  1349→                # 检测图像格式\n  1350→                image = Image.open(local_path)\n  1351→                format_name = image.format.lower()\n  1352→\n  1353→                # 转换为Base64\n  1354→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1355→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1356→\n  1357→            logger.error(f\"图像文件不存在: {image_path}\")\n  1358→            return None\n  1359→\n  1360→        except Exception as e:\n  1361→            logger.error(f\"处理输入图像失败: {e}\")\n  1362→            return None\n  1363→\n  1364→    def _extract_width_from_size(self, size: str) -> int:\n  1365→        \"\"\"\n  1366→        从尺寸字符串中提取宽度\n  1367→        \n  1368→        Args:\n  1369→            size: 尺寸字符串，如 \"1024x1024\"\n  1370→            \n  1371→        Returns:\n  1372→            int: 宽度值\n  1373→        \"\"\"\n  1374→        try:\n  1375→            return int(size.split('x')[0])\n  1376→        except (ValueError, IndexError):\n  1377→            return 1024  # 默认值\n  1378→    \n  1379→    def _extract_height_from_size(self, size: str) -> int:\n  1380→        \"\"\"\n  1381→        从尺寸字符串中提取高度\n  1382→        \n  1383→        Args:\n  1384→            size: 尺寸字符串，如 \"1024x1024\"\n  1385→            \n  1386→        Returns:\n  1387→            int: 高度值\n  1388→        \"\"\"\n  1389→        try:\n  1390→            return int(size.split('x')[1])\n  1391→        except (ValueError, IndexError):\n  1392→            return 1024  # 默认值\n  1393→\n  1394→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1395→        \"\"\"\n  1396→        获取图像信息\n  1397→\n  1398→        Args:\n  1399→            image_path: 图像文件路径\n  1400→\n  1401→        Returns:\n  1402→            Dict: 图像信息\n  1403→        \"\"\"\n  1404→        try:\n  1405→            with Image.open(image_path) as img:\n  1406→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1407→        except Exception as e:\n  1408→            logger.error(f\"获取图像信息失败: {e}\")\n  1409→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1410→\n  1411→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1412→        \"\"\"\n  1413→        获取图像生成历史记录\n  1414→\n  1415→        Args:\n  1416→            limit: 返回记录数量限制\n  1417→\n  1418→        Returns:\n  1419→            List[Dict]: 历史记录列表\n  1420→        \"\"\"\n  1421→        return self.storage_manager.load_history('images', limit=limit)\n  1422→\n  1423→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1424→        \"\"\"\n  1425→        根据提示词关键字搜索历史记录\n  1426→\n  1427→        Args:\n  1428→            keyword: 搜索关键字\n  1429→\n  1430→        Returns:\n  1431→            List[Dict]: 匹配的记录列表\n  1432→        \"\"\"\n  1433→        # 获取所有历史记录并在内存中过滤\n  1434→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1435→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1436→\n  1437→    def get_statistics(self) -> Dict[str, Any]:\n  1438→        \"\"\"\n  1439→        获取生成统计信息\n  1440→\n  1441→        Returns:\n  1442→            Dict: 统计信息\n  1443→        \"\"\"\n  1444→        try:\n  1445→            # 使用统一存储管理器获取存储统计\n  1446→            storage_stats = self.storage_manager.get_storage_stats()\n  1447→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1448→            \n  1449→            # 获取历史记录进行详细统计\n  1450→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1451→            \n  1452→            if not all_records:\n  1453→                return {\n  1454→                    \"total_images\": 0,\n  1455→                    \"text_to_image_count\": 0,\n  1456→                    \"image_to_image_count\": 0,\n  1457→                    \"total_file_size\": 0,\n  1458→                    \"average_file_size\": 0,\n  1459→                    \"most_common_size\": \"unknown\"\n  1460→                }\n  1461→\n  1462→            # 统计不同类型的图片数量\n  1463→            text_to_image_count = 0\n  1464→            image_to_image_count = 0\n  1465→            total_file_size = 0\n  1466→            sizes = []\n  1467→            \n  1468→            for record in all_records:\n  1469→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1470→                if 'input_image' in record.get('parameters', {}):\n  1471→                    image_to_image_count += 1\n  1472→                else:\n  1473→                    text_to_image_count += 1\n  1474→                \n  1475→                # 计算文件大小\n  1476→                file_size = record.get('file_size', 0)\n  1477→                if isinstance(file_size, str) and file_size.isdigit():\n  1478→                    file_size = int(file_size)\n  1479→                elif not isinstance(file_size, (int, float)):\n  1480→                    file_size = 0\n  1481→                total_file_size += file_size\n  1482→                \n  1483→                # 收集尺寸信息\n  1484→                width = record.get('width', 0)\n  1485→                height = record.get('height', 0)\n  1486→                if width and height:\n  1487→                    sizes.append(f\"{width}x{height}\")\n  1488→\n  1489→            stats = {\n  1490→                \"total_images\": len(all_records),\n  1491→                \"text_to_image_count\": text_to_image_count,\n  1492→                \"image_to_image_count\": image_to_image_count,\n  1493→                \"total_file_size\": total_file_size,\n  1494→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1495→                \"most_common_size\": \"unknown\",\n  1496→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1497→            }\n  1498→\n  1499→            # 最常用的尺寸\n  1500→            if sizes:\n  1501→                from collections import Counter\n  1502→                size_counts = Counter(sizes)\n  1503→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1504→\n  1505→            return stats\n  1506→\n  1507→        except Exception as e:\n  1508→            logger.error(f\"获取统计信息失败: {e}\")\n  1509→            return {\n  1510→                \"total_images\": 0,\n  1511→                \"text_to_image_count\": 0,\n  1512→                \"image_to_image_count\": 0,\n  1513→                \"total_file_size\": 0,\n  1514→                \"average_file_size\": 0,\n  1515→                \"most_common_size\": \"unknown\"\n  1516→            }\n  1517→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e3b5beef-52df-4a47-ae28-c5b446a866c9","timestamp":"2026-01-05T11:51:03.822Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config.unified_config import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        storage_dir = get_storage_dir()\n        if not storage_dir:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        self.storage_manager = get_v2_storage_manager(storage_dir)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n        count: int = 1,\n        sequential_mode: bool = False,\n        derived_ids: Optional[List[str]] = None,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            count: 生成图片数量（组图模式下生效）\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n            derived_ids: 组图生成的ID列表（用于关联）\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n\n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n\n        # 根据 model_variant 选择 provider（并发安全：不写 env）\n        seedream_provider: Optional[str] = None\n        try:\n            mv = (model_variant or \"\").strip().lower()\n            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n                seedream_provider = \"volc_v4\"\n            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n                seedream_provider = \"volc_v4_5\"\n            elif mv.startswith(\"volc_\"):\n                seedream_provider = mv\n        except Exception:\n            seedream_provider = None\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            actual_count = max(1, count)\n            use_group_mode = bool(sequential_mode and actual_count > 1)\n\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n                n=actual_count if use_group_mode else 1,\n                sequential_mode=sequential_mode,\n                seedream_provider=seedream_provider,\n            )\n\n            # 组图模式：API 返回多张图，需要逐一保存\n            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n            images_count = len(images_list)\n            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n\n            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n            if use_group_mode and images_count < actual_count:\n                logger.warning(\n                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n                )\n\n            if use_group_mode and images_count > 1:\n                results_batch = []\n                success_count = 0\n                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n                total_images = len(images_list)\n\n                for idx, img_data in enumerate(images_list):\n                    # 发送下载进度（每张图开始下载时）\n                    if progress_callback:\n                        try:\n                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n                        except Exception:\n                            pass\n\n                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n                    per_result = {\n                        \"task_id\": per_id,\n                        \"success\": True,\n                        \"type\": \"text_to_image\",\n                        \"prompt\": prompt,\n                        \"image_url\": img_data[\"url\"],\n                        \"parameters\": {\n                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            \"seed\": seed,\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,\n                        },\n                        \"created_at\": datetime.now().isoformat(),\n                        \"usage\": api_result.get(\"usage\", {}),\n                    }\n\n                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n                    if sanitized_refs:\n                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                        per_result[\"reference_assets\"] = sanitized_refs\n\n                    if save_local and per_result.get(\"image_url\"):\n                        local_result = self._save_image_locally(per_result)\n                        per_result.update(local_result)\n                        if not local_result.get('local_save_error'):\n                            success_count += 1\n\n                    results_batch.append(per_result)\n\n                    # 发送下载完成进度\n                    if progress_callback:\n                        try:\n                            progress_callback(idx + 1, total_images, per_result)\n                        except Exception:\n                            pass\n\n                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n                return {\n                    \"batch\": True,\n                    \"results\": results_batch,\n                    \"success_count\": success_count,\n                    \"total_count\": len(results_batch),\n                    \"derived_ids\": group_ids,\n                }\n\n            # 单图模式（默认）\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    \"seed\": seed,\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    ),\n                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale, \n                    \"seed\": seed, \n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        sequential_mode: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n        max_allowed = 15 if sequential_mode else 10\n        if count < 1 or count > max_allowed:\n            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n\n        # 组图模式：单次 API 调用返回多张图\n        if sequential_mode:\n            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n            return self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=save_local,\n                model_variant=model_variant,\n                generation_id=generation_id,\n                count=count,\n                sequential_mode=True,\n                derived_ids=derived_ids,\n                progress_callback=progress_callback,\n            )\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1517,"startLine":1,"totalLines":1517}}}
{"parentUuid":"e3b5beef-52df-4a47-ae28-c5b446a866c9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F4vGA5CWbMWJfw9GsfVYpo","type":"tool_result","content":"     1→# Seedance视频生成管理器\n     2→# 负责视频生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→import base64\n    13→import pandas as pd\n    14→from datetime import datetime\n    15→from pathlib import Path\n    16→from typing import Dict, Any, List, Optional, Tuple\n    17→from urllib.parse import urlparse\n    18→from loguru import logger\n    19→from PIL import Image\n    20→\n    21→from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n    22→\n    23→from .client import SeedanceClient\n    24→from ..storage import get_v2_storage_manager\n    25→from ..provider.schema import (\n    26→    VideoParams,\n    27→    validate_and_normalize_video,\n    28→)\n    29→from config.unified_config import get_unified_config\n    30→from config.unified_config import get_storage_dir\n    31→# 使用统一水印服务（edition/watermark_service.py）\n    32→from edition.watermark_service import (\n    33→    should_add_watermark,\n    34→    get_watermark_text,\n    35→    get_watermark_opacity,\n    36→)\n    37→\n    38→# Q-006 固化策略：\n    39→# - 本地水印由 edition/watermark_service 控制（trial 强制开 / prod 关闭）\n    40→# - API 服务端水印固定关闭（不依赖 config_api）\n    41→\n    42→\n    43→class SeedanceManager:\n    44→    \"\"\"Seedance视频生成管理器\"\"\"\n    45→\n    46→    def __init__(self, api_key: str = None):\n    47→        \"\"\"\n    48→        初始化Seedance管理器\n    49→\n    50→        Args:\n    51→            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n    52→        \"\"\"\n    53→        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n    54→        if api_key is None:\n    55→            try:\n    56→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    57→            except Exception as exc:\n    58→                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n    59→        \n    60→        self.client = SeedanceClient(api_key)\n    61→\n    62→        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n    63→        storage_path = get_storage_dir()\n    64→        if not storage_path:\n    65→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    66→        Path(storage_path).mkdir(parents=True, exist_ok=True)\n    67→\n    68→        # 使用V2统一存储管理器（与单一真源对齐）\n    69→        self.storage_manager = get_v2_storage_manager(storage_path)\n    70→        \n    71→        # 保持兼容性别名\n    72→        self.file_manager = self.storage_manager\n    73→        self.metadata_manager = self.storage_manager\n    74→        self.video_storage_manager = self.storage_manager\n    75→        \n    76→        # 保留原有的目录属性以保持兼容性\n    77→        self.data_dir = Path(self.storage_manager.root_path)\n    78→        self.videos_dir = self.data_dir / \"videos\"\n    79→        self.metadata_dir = self.data_dir / \"metadata\"\n    80→\n    81→        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    82→\n    83→    def generate_video(\n    84→        self,\n    85→        prompt: str,\n    86→        image_path: Optional[str] = None,\n    87→        first_frame_path: Optional[str] = None,\n    88→        last_frame_path: Optional[str] = None,\n    89→        duration: float = 4.0,\n    90→        seed: int = -1,\n    91→        watermark: bool = False,\n    92→        save_local: bool = True,\n    93→        wait_for_completion: bool = True,\n    94→        # 新增参数（P0b）\n    95→        resolution_grade: Optional[str] = None,\n    96→        ratio: Optional[str] = None,\n    97→        fps: int = 24,\n    98→        camera_fixed: bool = True,\n    99→        use_pro_model: bool = True,\n   100→        model_type: Optional[str] = None,\n   101→        model_variant: Optional[str] = None,\n   102→        generate_audio: Optional[bool] = None,\n   103→        reference_images: Optional[List[Any]] = None,\n   104→        generation_id: Optional[str] = None,\n   105→    ) -> Dict[str, Any]:\n   106→        \"\"\"\n   107→        生成视频并保存到本地\n   108→\n   109→        Args:\n   110→            image_path: 输入图像路径\n   111→            duration: 视频时长（秒）\n   112→            motion_strength: 运动强度 (0.1-1.0)\n   113→            seed: 随机种子\n   114→            watermark: 保留参数（服务端水印由配置决定）\n   115→            save_local: 是否保存到本地\n   116→            wait_for_completion: 是否等待任务完成\n   117→\n   118→        Returns:\n   119→            Dict: 生成结果\n   120→        \"\"\"\n   121→        logger.info(\"开始视频生成任务(Manager)\")\n   122→\n   123→        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n   124→        task_id = generation_id or str(uuid.uuid4())\n   125→\n   126→        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n   127→        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n   128→            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n   129→\n   130→        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n   131→        # 构建待处理的图片列表\n   132→        all_input_images = []\n   133→\n   134→        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n   135→        frame_inputs = []\n   136→        if first_frame_path:\n   137→            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n   138→        if last_frame_path:\n   139→            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n   140→        elif image_path and not first_frame_path:\n   141→            frame_inputs.append({'path': image_path, 'type': 'image'})\n   142→\n   143→        all_input_images.extend(frame_inputs)\n   144→\n   145→        # 2. 添加参考图\n   146→        if reference_images:\n   147→            for ref in reference_images:\n   148→                if isinstance(ref, dict):\n   149→                    ref_copy = dict(ref)\n   150→                    ref_copy['type'] = ref_copy.get('type', 'reference')\n   151→                    all_input_images.append(ref_copy)\n   152→                else:\n   153→                    all_input_images.append({'path': ref, 'type': 'reference'})\n   154→\n   155→        # 3. 统一处理（复制到 references 目录）\n   156→        ref_summary = self._process_reference_assets(\n   157→            all_input_images if all_input_images else None,\n   158→            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n   159→            expected_outputs=1,\n   160→        )\n   161→        ref_assets = ref_summary.get('assets', [])\n   162→        ref_paths: List[str] = list(ref_summary.get('paths', []))\n   163→\n   164→        # 4. 分离帧图片和参考图\n   165→        frame_assets = {}\n   166→        pure_ref_assets = []\n   167→        for asset in ref_assets:\n   168→            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n   169→            if asset_type in ('first_frame', 'last_frame', 'image'):\n   170→                frame_assets[asset_type] = asset\n   171→            else:\n   172→                pure_ref_assets.append(asset)\n   173→\n   174→        # 5. 提取帧图片的相对路径（用于存储）\n   175→        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n   176→        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n   177→        stored_image_path = frame_assets.get('image', {}).get('path')\n   178→\n   179→        # 6. 提取参考图的 payload（用于 API 调用）\n   180→        ref_payloads: List[str] = []\n   181→        for asset in pure_ref_assets:\n   182→            payload = asset.get('_payload_b64')\n   183→            if payload:\n   184→                ref_payloads.append(payload)\n   185→\n   186→        if ref_summary.get('errors'):\n   187→            logger.warning(\n   188→                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   189→            )\n   190→        if ref_summary.get('warnings'):\n   191→            for warn in ref_summary['warnings']:\n   192→                logger.warning(f\"图片处理提示: {warn}\")\n   193→\n   194→        # Q-006：API 服务端水印固定关闭；体验版仅做本地水印（落盘后处理）\n   195→        watermark_enabled = False\n   196→\n   197→        create_kwargs = dict(\n   198→            prompt=prompt,\n   199→            duration=int(duration),\n   200→            seed=None if seed == -1 else seed,\n   201→            fps=fps,\n   202→            resolution_grade=resolution_grade,\n   203→            ratio=ratio,\n   204→            watermark=watermark_enabled,\n   205→            camera_fixed=bool(camera_fixed),\n   206→            use_pro_model=use_pro_model,\n   207→            model_type=model_type,\n   208→            model_variant=model_variant,\n   209→            generate_audio=generate_audio,\n   210→        )\n   211→        if ref_payloads:\n   212→            create_kwargs['reference_images'] = ref_payloads\n   213→        if first_frame_path and last_frame_path:\n   214→            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n   215→        elif image_path:\n   216→            create_kwargs.update(dict(image_path=image_path))\n   217→        # 文生视频：不追加图片参数\n   218→\n   219→        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n   220→        precheck_fb = False\n   221→        precheck_reason = \"\"\n   222→        try:\n   223→            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n   224→                VideoParams(\n   225→                    prompt=prompt,\n   226→                    image_path=None,  # 校验不依赖图像数据\n   227→                    first_frame_path=None,\n   228→                    last_frame_path=None,\n   229→                    duration=int(duration),\n   230→                    fps=int(fps),\n   231→                    seed=(None if seed == -1 else seed),\n   232→                    camera_fixed=bool(camera_fixed),\n   233→                    watermark=bool(watermark),\n   234→                    resolution_grade=resolution_grade,\n   235→                    ratio=ratio,\n   236→                    use_pro_model=bool(use_pro_model),\n   237→                    model_variant=model_variant,\n   238→                    generate_audio=generate_audio,\n   239→                )\n   240→            )\n   241→            logger.info(\n   242→                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   243→            )\n   244→            if fb:\n   245→                logger.warning(f\"前置参数回退建议: {reason}\")\n   246→            precheck_fb = fb\n   247→            precheck_reason = reason\n   248→        except Exception as _e:\n   249→            logger.debug(f\"前置参数校验跳过: {_e}\")\n   250→\n   251→        create_result = self.client.create_video_task(**create_kwargs)\n   252→        params_sent = create_result.get(\"params_sent\") if isinstance(create_result, dict) else None\n   253→\n   254→        # 用实际执行参数覆盖用户输入（如 Lite 参考图模式 1080p→720p 降级）\n   255→        if create_result.get(\"success\"):\n   256→            actual_rs = create_result.get('used_rs')\n   257→            actual_rt = create_result.get('used_rt')\n   258→            if actual_rs:\n   259→                logger.debug(f\"参数覆盖|resolution_grade: 用户输入={resolution_grade} -> 实际执行={actual_rs}\")\n   260→                resolution_grade = actual_rs\n   261→            if actual_rt:\n   262→                logger.debug(f\"参数覆盖|ratio: 用户输入={ratio} -> 实际执行={actual_rt}\")\n   263→                ratio = actual_rt\n   264→\n   265→        if not create_result[\"success\"]:\n   266→            self._cleanup_reference_paths(ref_paths)\n   267→            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n   268→            return create_result\n   269→\n   270→        api_task_id = create_result[\"task_id\"]\n   271→\n   272→        result = {\n   273→            \"task_id\": task_id,\n   274→            \"api_task_id\": api_task_id,\n   275→            \"params_sent\": params_sent,\n   276→            \"success\": True,\n   277→            \"type\": \"image_to_video\",\n   278→            \"input_image\": image_path,\n   279→            \"status\": \"pending\",\n   280→            \"parameters\": {\n   281→                \"prompt\": prompt,\n   282→                \"duration\": duration,\n   283→                \"seed\": (None if seed == -1 else seed),\n   284→                \"watermark\": watermark_enabled,\n   285→                \"resolution_grade\": resolution_grade,\n   286→                \"ratio\": ratio,\n   287→                \"fps\": fps,\n   288→                \"camera_fixed\": bool(camera_fixed),\n   289→                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n   290→                \"first_frame\": stored_first_frame,\n   291→                \"last_frame\": stored_last_frame,\n   292→                \"image_path\": stored_image_path,\n   293→            },\n   294→            \"created_at\": datetime.now().isoformat(),\n   295→        }\n   296→\n   297→        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   298→        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n   299→        result['reference_assets'] = sanitized_refs\n   300→        if ref_summary.get('errors'):\n   301→            result['reference_asset_errors'] = ref_summary['errors']\n   302→        if ref_summary.get('warnings'):\n   303→            result['reference_asset_warnings'] = ref_summary['warnings']\n   304→        if precheck_fb and precheck_reason:\n   305→            result.setdefault('fallback_applied', True)\n   306→            if result.get('fallback_reason'):\n   307→                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n   308→            else:\n   309→                result['fallback_reason'] = precheck_reason\n   310→\n   311→        masked_ids = self._summarize_reference_ids(sanitized_refs)\n   312→        logger.info(\n   313→            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n   314→            len(sanitized_refs),\n   315→            masked_ids or \"-\",\n   316→            self._provider_hint(),\n   317→        )\n   318→\n   319→        # 透传回退信息\n   320→        if create_result.get(\"fallback_applied\"):\n   321→            result[\"fallback_applied\"] = True\n   322→            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n   323→\n   324→        # 如果等待完成，轮询任务状态\n   325→        if wait_for_completion:\n   326→            completion_result = self.client.wait_for_completion(api_task_id)\n   327→\n   328→            if completion_result[\"success\"]:\n   329→                if completion_result[\"status\"] == \"success\":\n   330→                    result[\"status\"] = \"success\"\n   331→                    result[\"video_url\"] = completion_result[\"video_url\"]\n   332→                    result[\"duration\"] = completion_result.get(\"duration\")\n   333→                    result[\"file_size\"] = completion_result.get(\"file_size\")\n   334→                    result[\"completed_at\"] = datetime.now().isoformat()\n   335→\n   336→                    # 保存到本地\n   337→                    if save_local:\n   338→                        local_result = self._save_video_locally(result)\n   339→                        result.update(local_result)\n   340→                        # 注：file_size 已在 _save_video_locally 内部设置到 metadata['parameters'] 中\n   341→                        if local_result.get('local_save_error'):\n   342→                            self._cleanup_reference_paths(ref_paths)\n   343→                            result['parameters'][\"reference_assets\"] = []\n   344→                            result['reference_assets'] = []\n   345→                            warnings = result.setdefault('reference_asset_warnings', [])\n   346→                            warnings.append(\"视频保存失败，参考图已回滚\")\n   347→                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   348→\n   349→                    logger.success(f\"视频生成任务完成: {task_id}\")\n   350→                else:\n   351→                    result[\"status\"] = completion_result[\"status\"]\n   352→                    result[\"error\"] = completion_result.get(\"error\")\n   353→                    result[\"error_code\"] = completion_result.get(\"error_code\")\n   354→                    logger.error(f\"视频生成任务失败: {result['error']}\")\n   355→            else:\n   356→                result[\"status\"] = \"failed\"\n   357→                result[\"error\"] = completion_result[\"error\"]\n   358→                result[\"error_code\"] = completion_result[\"error_code\"]\n   359→                logger.error(f\"等待任务完成失败: {result['error']}\")\n   360→\n   361→        # 注：元数据已通过 save_content_file() 保存，无需重复调用\n   362→\n   363→        return result\n   364→\n   365→    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n   366→        \"\"\"\n   367→        检查任务状态\n   368→\n   369→        Args:\n   370→            task_id: 本地任务ID\n   371→\n   372→        Returns:\n   373→            Dict: 任务状态信息\n   374→        \"\"\"\n   375→        logger.info(f\"检查任务状态: {task_id}\")\n   376→\n   377→        # 从元数据中获取任务信息\n   378→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   379→\n   380→        if not task_record:\n   381→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   382→\n   383→        api_task_id = task_record.get(\"api_task_id\")\n   384→        if not api_task_id:\n   385→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   386→\n   387→        # 查询API任务状态\n   388→        status_result = self.client.get_task_status(api_task_id)\n   389→\n   390→        if status_result[\"success\"]:\n   391→            # 更新本地记录\n   392→            updates = {\n   393→                \"status\": status_result[\"status\"],\n   394→                \"progress\": status_result.get(\"progress\", 0),\n   395→                \"updated_at\": datetime.now().isoformat(),\n   396→            }\n   397→\n   398→            # 如果任务完成，添加结果信息\n   399→            if status_result[\"status\"] == \"success\":\n   400→                updates[\"video_url\"] = status_result[\"video_url\"]\n   401→                updates[\"duration\"] = status_result.get(\"duration\")\n   402→                updates[\"file_size\"] = status_result.get(\"file_size\")\n   403→                updates[\"completed_at\"] = datetime.now().isoformat()\n   404→\n   405→            # 如果任务失败，添加错误信息\n   406→            elif status_result[\"status\"] == \"failed\":\n   407→                updates[\"error\"] = status_result.get(\"error\")\n   408→                updates[\"error_code\"] = status_result.get(\"error_code\")\n   409→\n   410→            # 更新元数据\n   411→            self.metadata_manager.update_record(task_id, updates)\n   412→\n   413→            # 合并任务信息\n   414→            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n   415→\n   416→            return result\n   417→        else:\n   418→            return status_result\n   419→\n   420→    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n   421→        \"\"\"\n   422→        下载已完成的视频\n   423→\n   424→        Args:\n   425→            task_id: 本地任务ID\n   426→\n   427→        Returns:\n   428→            Dict: 下载结果\n   429→        \"\"\"\n   430→        logger.info(f\"下载视频: {task_id}\")\n   431→\n   432→        # 获取任务信息\n   433→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   434→\n   435→        if not task_record:\n   436→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   437→\n   438→        # 检查任务状态\n   439→        if task_record.get(\"status\") != \"success\":\n   440→            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n   441→\n   442→        video_url = task_record.get(\"video_url\")\n   443→        if not video_url:\n   444→            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n   445→\n   446→        # 检查是否已下载\n   447→        local_path = task_record.get(\"local_path\")\n   448→        if local_path and Path(local_path).exists():\n   449→            logger.info(\n   450→                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n   451→            )\n   452→            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n   453→\n   454→        # 下载视频\n   455→        try:\n   456→            response = safe_requests_get(video_url, timeout=300)\n   457→\n   458→            # 生成本地文件名\n   459→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n   460→            task_id_short = task_id[:8]\n   461→            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n   462→\n   463→            # 保存文件\n   464→            local_path = self.file_manager.save_file(filename, response.content)\n   465→\n   466→            # 获取视频信息\n   467→            video_info = self._get_video_info(local_path)\n   468→\n   469→            # 更新元数据\n   470→            updates = {\n   471→                \"filename\": filename,\n   472→                \"local_path\": str(local_path),\n   473→                \"local_file_size\": local_path.stat().st_size,\n   474→                \"downloaded_at\": datetime.now().isoformat(),\n   475→            }\n   476→\n   477→            if video_info:\n   478→                updates.update(video_info)\n   479→\n   480→            self.metadata_manager.update_record(task_id, updates)\n   481→\n   482→            logger.success(f\"视频下载成功: {filename}\")\n   483→\n   484→            summary = {\n   485→                \"success\": True,\n   486→                \"local_path\": str(local_path),\n   487→                \"filename\": filename,\n   488→                \"file_size\": local_path.stat().st_size,\n   489→                \"video_info\": video_info,\n   490→            }\n   491→            try:\n   492→                logger.info(\n   493→                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n   494→                )\n   495→            except Exception:\n   496→                pass\n   497→            return summary\n   498→\n   499→        except Exception as e:\n   500→            logger.error(f\"下载视频失败: {e}\")\n   501→            try:\n   502→                logger.info(\n   503→                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n   504→                )\n   505→            except Exception:\n   506→                pass\n   507→            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n   508→\n   509→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n   510→        \"\"\"\n   511→        取消任务\n   512→\n   513→        Args:\n   514→            task_id: 本地任务ID\n   515→\n   516→        Returns:\n   517→            Dict: 取消结果\n   518→        \"\"\"\n   519→        logger.info(f\"取消任务: {task_id}\")\n   520→\n   521→        # 获取任务信息\n   522→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   523→\n   524→        if not task_record:\n   525→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   526→\n   527→        api_task_id = task_record.get(\"api_task_id\")\n   528→        if not api_task_id:\n   529→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   530→\n   531→        # 调用API取消任务\n   532→        cancel_result = self.client.cancel_task(api_task_id)\n   533→\n   534→        if cancel_result[\"success\"]:\n   535→            # 更新本地记录\n   536→            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n   537→\n   538→            self.metadata_manager.update_record(task_id, updates)\n   539→\n   540→            logger.success(f\"任务取消成功: {task_id}\")\n   541→\n   542→        return cancel_result\n   543→\n   544→    def batch_generate_videos(\n   545→        self,\n   546→        image_paths: List[str],\n   547→        duration: float = 4.0,\n   548→        motion_strength: float = 0.8,\n   549→        watermark: bool = True,\n   550→        save_local: bool = True,\n   551→        wait_for_completion: bool = False,\n   552→    ) -> List[Dict[str, Any]]:\n   553→        \"\"\"\n   554→        批量生成视频\n   555→\n   556→        Args:\n   557→            image_paths: 图像路径列表\n   558→            duration: 视频时长\n   559→            motion_strength: 运动强度\n   560→            watermark: 保留参数（服务端水印由配置决定）\n   561→            save_local: 是否保存到本地\n   562→            wait_for_completion: 是否等待任务完成\n   563→\n   564→        Returns:\n   565→            List[Dict]: 生成结果列表\n   566→        \"\"\"\n   567→        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n   568→\n   569→        results = []\n   570→        for i, image_path in enumerate(image_paths, 1):\n   571→            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n   572→\n   573→            result = self.generate_video(\n   574→                image_path=image_path,\n   575→                duration=duration,\n   576→                motion_strength=motion_strength,\n   577→                watermark=watermark,\n   578→                save_local=save_local,\n   579→                wait_for_completion=wait_for_completion,\n   580→            )\n   581→\n   582→            results.append(result)\n   583→\n   584→        success_count = sum(1 for r in results if r[\"success\"])\n   585→        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n   586→\n   587→        return results\n   588→\n   589→    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   590→        \"\"\"\n   591→        保存视频到本地\n   592→\n   593→        Args:\n   594→            result: API生成结果\n   595→\n   596→        Returns:\n   597→            Dict: 包含本地文件信息的字典\n   598→        \"\"\"\n   599→        try:\n   600→            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n   601→\n   602→            # Validate inputs\n   603→            task_id = result.get(\"task_id\")\n   604→            video_url = result.get(\"video_url\")\n   605→            if not task_id:\n   606→                raise ValueError(\"Task ID is required\")\n   607→            if not video_url:\n   608→                raise ValueError(\"Video URL is required\")\n   609→            \n   610→            # 下载视频（带重试机制）\n   611→            logger.info(f\"Downloading video from {video_url}\")\n   612→            max_retries = 3\n   613→            retry_delay = 5  # 秒\n   614→            video_data = None\n   615→            last_error = None\n   616→\n   617→            for attempt in range(max_retries):\n   618→                try:\n   619→                    if attempt > 0:\n   620→                        logger.info(f\"重试下载视频 (第 {attempt + 1}/{max_retries} 次)...\")\n   621→\n   622→                    response = safe_requests_get(video_url, stream=True, timeout=300)\n   623→\n   624→                    # Check content type\n   625→                    content_type = response.headers.get('content-type', '')\n   626→                    if 'video' not in content_type:\n   627→                        logger.warning(f\"Unexpected content type: {content_type}\")\n   628→\n   629→                    # Get file size for progress tracking\n   630→                    total_size = int(response.headers.get('content-length', 0))\n   631→                    video_data = response.content\n   632→\n   633→                    logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n   634→                    break  # 下载成功，跳出重试循环\n   635→\n   636→                except requests.exceptions.RequestException as e:\n   637→                    last_error = e\n   638→                    logger.warning(f\"下载视频失败 (第 {attempt + 1}/{max_retries} 次): {e}\")\n   639→                    if attempt < max_retries - 1:\n   640→                        import time\n   641→                        time.sleep(retry_delay)\n   642→\n   643→            if video_data is None:\n   644→                logger.error(f\"Network error downloading video after {max_retries} attempts: {last_error}\")\n   645→                raise Exception(f\"Failed to download video after {max_retries} attempts: {str(last_error)}\")\n   646→            \n   647→            # 在保存前获取真实视频信息（写临时文件以便读取）\n   648→            actual_width = None\n   649→            actual_height = None\n   650→            actual_fps = None\n   651→            actual_duration = None\n   652→            try:\n   653→                import tempfile\n   654→                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   655→                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n   656→                    tf.write(video_data)\n   657→                    temp_path = Path(tf.name)\n   658→                # 使用缩略图工具的get_video_info\n   659→                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   660→                gen = VideoThumbnailGenerator(str(thumbs_dir))\n   661→                info = gen.get_video_info(str(temp_path))\n   662→                try:\n   663→                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n   664→                except Exception:\n   665→                    pass\n   666→                if info:\n   667→                    actual_width = info.get('width')\n   668→                    actual_height = info.get('height')\n   669→                    actual_fps = info.get('fps')\n   670→                    actual_duration = info.get('duration')\n   671→            except Exception as e:\n   672→                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n   673→\n   674→            # 准备元数据（适配UnifiedStorageManager的格式）\n   675→            metadata = {\n   676→                'generation_id': task_id,\n   677→                'task_id': task_id,\n   678→                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n   679→                'parameters': {\n   680→                    **result.get('parameters', {}),\n   681→                    # 设置文件大小（在保存前就设置，确保写入数据库）\n   682→                    'file_size': len(video_data),\n   683→                    # 回填真实视频信息\n   684→                    **({} if actual_width is None else {'width': actual_width}),\n   685→                    **({} if actual_height is None else {'height': actual_height}),\n   686→                    **({} if actual_fps is None else {'fps': actual_fps}),\n   687→                    **({} if actual_duration is None else {'duration': actual_duration}),\n   688→                    # 透传fallback信息\n   689→                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n   690→                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n   691→                },\n   692→                'model': self._get_display_model_name(result),\n   693→                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n   694→                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n   695→                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n   696→                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n   697→                'generation_time': result.get('generation_time', 0),\n   698→                'status': result.get('status', 'completed'),\n   699→                'batch_id': result.get('batch_id', '')\n   700→            }\n   701→\n   702→            # 使用统一存储管理器保存文件\n   703→            save_result = self.storage_manager.save_content_file(\n   704→                content_type='videos',\n   705→                file_data=video_data,\n   706→                url=video_url,\n   707→                metadata=metadata\n   708→            )\n   709→\n   710→            # 缩略图生成（已由UnifiedStorageManager处理）\n   711→            thumbnail_local_path = save_result.get('thumbnail_path')\n   712→            thumbnail_filename = None\n   713→            if thumbnail_local_path:\n   714→                thumbnail_filename = Path(thumbnail_local_path).name\n   715→                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n   716→            else:\n   717→                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n   718→\n   719→            # 下载并保存API返回的缩略图（如果有）作为备用\n   720→            api_thumbnail_local_path = None\n   721→            api_thumbnail_filename = None\n   722→            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n   723→                try:\n   724→                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n   725→                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n   726→                    \n   727→                    # 使用统一存储管理器保存备用缩略图\n   728→                    backup_metadata = {\n   729→                        'generation_id': task_id,\n   730→                        'prompt': 'API backup thumbnail for video',\n   731→                        'model': 'seedance',\n   732→                        'width': 320,\n   733→                        'height': 180,\n   734→                        'status': 'completed'\n   735→                    }\n   736→                    \n   737→                    backup_result = self.storage_manager.save_content_file(\n   738→                        content_type='images',  # 缩略图保存为图片\n   739→                        file_data=thumbnail_response.content,\n   740→                        url=result[\"thumbnail_url\"],\n   741→                        metadata=backup_metadata\n   742→                    )\n   743→                    \n   744→                    api_thumbnail_local_path = backup_result['local_path']\n   745→                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n   746→                    \n   747→                    # 如果本地缩略图生成失败，使用API缩略图\n   748→                    if not thumbnail_local_path:\n   749→                        thumbnail_local_path = api_thumbnail_local_path\n   750→                        thumbnail_filename = api_thumbnail_filename\n   751→                    \n   752→                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n   753→                        \n   754→                except Exception as e:\n   755→                    logger.warning(f\"下载API缩略图失败: {e}\")\n   756→                    api_thumbnail_local_path = None\n   757→                    api_thumbnail_filename = None\n   758→\n   759→            # 获取视频信息\n   760→            local_path = Path(save_result['local_path'])\n   761→            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n   762→            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n   763→                try:\n   764→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   765→                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   766→                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n   767→                    video_info = gen.get_video_info(str(local_path))\n   768→                except Exception:\n   769→                    video_info = {}\n   770→            else:\n   771→                video_info = {\n   772→                    'width': actual_width,\n   773→                    'height': actual_height,\n   774→                    'fps': actual_fps,\n   775→                    'duration': actual_duration,\n   776→                }\n   777→            file_size = local_path.stat().st_size if local_path.exists() else 0\n   778→            \n   779→            logger.success(f\"视频已保存到本地: {local_path.name}\")\n   780→            \n   781→            # 本地视频水印（使用统一水印服务控制）\n   782→            if should_add_watermark():\n   783→                try:\n   784→                    from edition.watermark_service import WatermarkService\n   785→\n   786→                    watermark_text = get_watermark_text() or \"PIGEON\"\n   787→                    try:\n   788→                        opacity = get_watermark_opacity()\n   789→                    except Exception:\n   790→                        opacity = 0.3\n   791→                    opacity = max(0.0, min(opacity, 1.0))\n   792→\n   793→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n   794→                    watermark_applied = watermark_service.apply_to_video(local_path)\n   795→                    if watermark_applied:\n   796→                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n   797→                    else:\n   798→                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n   799→                except Exception as e:\n   800→                    logger.warning(f\"添加视频水印时出错: {e}\")\n   801→\n   802→            result_obj = {\n   803→                \"local_path\": save_result['local_path'],\n   804→                \"filename\": local_path.name,\n   805→                \"file_path\": save_result['local_path'],  # 保持兼容性\n   806→                \"local_file_size\": file_size,\n   807→                \"video_info\": video_info,\n   808→                # 同步回填至顶层，便于上游使用\n   809→                **({} if not video_info else {\n   810→                    'width': video_info.get('width'),\n   811→                    'height': video_info.get('height'),\n   812→                    'fps': video_info.get('fps'),\n   813→                    'duration': video_info.get('duration'),\n   814→                }),\n   815→                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n   816→                \"thumbnail_filename\": thumbnail_filename,\n   817→                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n   818→                \"api_thumbnail_filename\": api_thumbnail_filename,\n   819→                \"task_id\": task_id,  # 添加task_id以供后续使用\n   820→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n   821→                \"file_id\": save_result.get('file_id'),\n   822→                \"relative_path\": save_result.get('relative_path'),\n   823→            }\n   824→            try:\n   825→                logger.info(\n   826→                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n   827→                )\n   828→            except Exception:\n   829→                pass\n   830→            return result_obj\n   831→\n   832→        except Exception as e:\n   833→            logger.error(f\"保存视频到本地失败: {e}\")\n   834→            logger.exception(\"Full traceback for video save error:\")\n   835→            try:\n   836→                logger.info(\n   837→                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n   838→                )\n   839→            except Exception:\n   840→                pass\n   841→            return {\"local_save_error\": str(e)}\n   842→\n   843→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n   844→        checksum = hashlib.sha1(file_data).hexdigest()\n   845→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n   846→        return f\"ref_{ts}_{checksum[:8]}\"\n   847→\n   848→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n   849→        source_meta: Dict[str, Any] = {}\n   850→        raw = ref\n   851→        if isinstance(ref, dict):\n   852→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n   853→                if ref.get(key) is not None:\n   854→                    source_meta[key] = ref.get(key)\n   855→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n   856→        if raw is None:\n   857→            return None\n   858→\n   859→        extension = source_meta.get('extension')\n   860→        data = None\n   861→        source_repr = source_meta.get('source')\n   862→\n   863→        try:\n   864→            if isinstance(raw, bytes):\n   865→                data = raw\n   866→            elif isinstance(raw, str):\n   867→                stripped = raw.strip()\n   868→                if stripped.startswith('data:') and ';base64,' in stripped:\n   869→                    header, payload = stripped.split(';base64,', 1)\n   870→                    mime_part = header[5:]\n   871→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n   872→                    data = base64.b64decode(payload)\n   873→                    source_repr = source_repr or mime_part\n   874→                    source_meta.setdefault('type', 'image')\n   875→                elif stripped.startswith(('http://', 'https://')):\n   876→                    resp = safe_requests_get(stripped, timeout=15)\n   877→                    data = resp.content\n   878→                    parsed = urlparse(stripped)\n   879→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n   880→                    source_repr = source_repr or stripped\n   881→                    source_meta.setdefault('source_url', stripped)\n   882→                else:\n   883→                    path = Path(stripped)\n   884→                    if not path.exists():\n   885→                        logger.warning(f\"参考图像不存在: {stripped}\")\n   886→                        return None\n   887→                    data = path.read_bytes()\n   888→                    extension = extension or path.suffix or '.png'\n   889→                    source_repr = source_repr or path.name\n   890→                    source_meta.setdefault('source_path', str(path))\n   891→            else:\n   892→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n   893→                return None\n   894→        except Exception as exc:\n   895→            logger.warning(f\"加载参考图失败: {exc}\")\n   896→            return None\n   897→\n   898→        if data is None:\n   899→            return None\n   900→\n   901→        width = source_meta.get('width')\n   902→        height = source_meta.get('height')\n   903→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n   904→            try:\n   905→                from io import BytesIO\n   906→\n   907→                with Image.open(BytesIO(data)) as img:\n   908→                    width = img.width\n   909→                    height = img.height\n   910→            except Exception:\n   911→                pass\n   912→\n   913→        source_meta['width'] = width\n   914→        source_meta['height'] = height\n   915→        source_meta.setdefault('type', 'image')\n   916→        source_meta['source'] = source_repr or source_meta.get('source')\n   917→\n   918→        return data, extension, source_meta\n   919→\n   920→    def _process_reference_assets(\n   921→        self,\n   922→        references: Optional[List[Any]],\n   923→        *,\n   924→        max_refs: int = MAX_REFERENCE_IMAGES,\n   925→        expected_outputs: int = 1,\n   926→    ) -> Dict[str, Any]:\n   927→        stored: List[Dict[str, Any]] = []\n   928→        absolute_paths: List[str] = []\n   929→        errors: List[str] = []\n   930→        warnings: List[str] = []\n   931→\n   932→        if not references:\n   933→            return {\n   934→                'assets': stored,\n   935→                'paths': absolute_paths,\n   936→                'errors': errors,\n   937→                'warnings': warnings,\n   938→            }\n   939→\n   940→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n   941→            warnings.append(\n   942→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n   943→            )\n   944→            references = references[:max_refs]\n   945→\n   946→        for order, item in enumerate(references):\n   947→            load_result = self._load_reference_source(item)\n   948→            if not load_result:\n   949→                errors.append(f\"ref[{order}] 加载失败\")\n   950→                continue\n   951→\n   952→            file_data, extension, meta = load_result\n   953→            meta.setdefault('order', order)\n   954→            meta.setdefault('kind', meta.get('type', 'image'))\n   955→\n   956→            try:\n   957→                asset_id = self._generate_reference_asset_id(file_data)\n   958→                record = self.storage_manager.save_reference_asset(\n   959→                    'images',\n   960→                    file_data,\n   961→                    asset_id=asset_id,\n   962→                    extension=extension,\n   963→                    metadata=meta,\n   964→                )\n   965→                try:\n   966→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n   967→                except Exception:\n   968→                    record['_payload_b64'] = None\n   969→                record['_source_meta'] = meta\n   970→                stored.append(record)\n   971→                if record.get('absolute_path'):\n   972→                    absolute_paths.append(record['absolute_path'])\n   973→            except Exception as exc:\n   974→                logger.warning(f\"保存参考图失败: {exc}\")\n   975→                errors.append(f\"ref[{order}] 保存失败\")\n   976→\n   977→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n   978→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n   979→            if len(stored) > allowed:\n   980→                warnings.append(\n   981→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n   982→                )\n   983→                stored = stored[:allowed]\n   984→                absolute_paths = absolute_paths[:allowed]\n   985→\n   986→        return {\n   987→            'assets': stored,\n   988→            'paths': absolute_paths,\n   989→            'errors': errors,\n   990→            'warnings': warnings,\n   991→        }\n   992→\n   993→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   994→        cleaned: List[Dict[str, Any]] = []\n   995→        for rec in assets or []:\n   996→            rec.pop('_payload_b64', None)\n   997→            rec.pop('_source_meta', None)\n   998→            rec.pop('absolute_path', None)\n   999→            cleaned.append({\n  1000→                'id': rec.get('id') or rec.get('reference_id'),\n  1001→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n  1002→                'type': rec.get('type'),\n  1003→                'kind': rec.get('kind'),\n  1004→                'source': rec.get('source'),\n  1005→                'order': rec.get('order'),\n  1006→                'checksum': rec.get('checksum'),\n  1007→                'size': rec.get('size'),\n  1008→                'width': rec.get('width'),\n  1009→                'height': rec.get('height'),\n  1010→                'created_at': rec.get('created_at'),\n  1011→            })\n  1012→        return cleaned\n  1013→\n  1014→    @staticmethod\n  1015→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1016→        masked: List[str] = []\n  1017→        for rec in assets or []:\n  1018→            rid = rec.get('id') or ''\n  1019→            if not rid:\n  1020→                continue\n  1021→            masked.append(f\"{rid[:6]}***\")\n  1022→        return \",\".join(masked)\n  1023→\n  1024→    @staticmethod\n  1025→    def _provider_hint() -> str:\n  1026→        try:\n  1027→            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n  1028→        except Exception:\n  1029→            return \"seedance\"\n  1030→\n  1031→    @staticmethod\n  1032→    def _cleanup_reference_paths(paths: List[str]):\n  1033→        for path in paths or []:\n  1034→            try:\n  1035→                if path and Path(path).exists():\n  1036→                    Path(path).unlink(missing_ok=True)\n  1037→            except Exception as exc:\n  1038→                logger.debug(f\"参考图清理失败: {exc}\")\n  1039→\n  1040→    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n  1041→        \"\"\"\n  1042→        将绝对路径转换为相对路径（相对于存储根目录）\n  1043→\n  1044→        如果路径已经是相对路径或无法转换，返回原路径。\n  1045→        这确保数据库中存储的是相对路径，支持跨平台迁移。\n  1046→\n  1047→        Args:\n  1048→            abs_path: 绝对路径或相对路径\n  1049→\n  1050→        Returns:\n  1051→            相对路径字符串，如 \"images/xxx.png\"\n  1052→        \"\"\"\n  1053→        if not abs_path:\n  1054→            return None\n  1055→\n  1056→        try:\n  1057→            path = Path(abs_path)\n  1058→\n  1059→            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n  1060→            if not path.is_absolute():\n  1061→                return str(path).replace('\\\\', '/')\n  1062→\n  1063→            # 尝试转换为相对于存储根目录的路径\n  1064→            storage_root = Path(self.storage_manager.root_path)\n  1065→            try:\n  1066→                relative = path.relative_to(storage_root)\n  1067→                return str(relative).replace('\\\\', '/')\n  1068→            except ValueError:\n  1069→                # 路径不在存储根目录下，尝试提取文件名部分\n  1070→                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n  1071→                parts = path.parts\n  1072→                for i, part in enumerate(parts):\n  1073→                    if part in ('images', 'videos', 'thumbnails', 'references'):\n  1074→                        relative = Path(*parts[i:])\n  1075→                        return str(relative).replace('\\\\', '/')\n  1076→\n  1077→                # 无法提取，返回原路径（记录警告）\n  1078→                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n  1079→                return str(path).replace('\\\\', '/')\n  1080→\n  1081→        except Exception as e:\n  1082→            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n  1083→            return abs_path\n  1084→\n  1085→    def _extract_width_from_resolution(self, resolution: str) -> int:\n  1086→        \"\"\"\n  1087→        从分辨率字符串中提取宽度\n  1088→        \n  1089→        Args:\n  1090→            resolution: 分辨率字符串，如 \"1280x720\"\n  1091→            \n  1092→        Returns:\n  1093→            int: 宽度值\n  1094→        \"\"\"\n  1095→        try:\n  1096→            return int(resolution.split('x')[0])\n  1097→        except (ValueError, IndexError):\n  1098→            return 1280  # 默认值\n  1099→    \n  1100→    def _extract_height_from_resolution(self, resolution: str) -> int:\n  1101→        \"\"\"\n  1102→        从分辨率字符串中提取高度\n  1103→        \n  1104→        Args:\n  1105→            resolution: 分辨率字符串，如 \"1280x720\"\n  1106→            \n  1107→        Returns:\n  1108→            int: 高度值\n  1109→        \"\"\"\n  1110→        try:\n  1111→            return int(resolution.split('x')[1])\n  1112→        except (ValueError, IndexError):\n  1113→            return 720  # 默认值\n  1114→\n  1115→    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n  1116→        \"\"\"\n  1117→        获取视频信息\n  1118→\n  1119→        Args:\n  1120→            video_path: 视频文件路径\n  1121→\n  1122→        Returns:\n  1123→            Dict: 视频信息\n  1124→        \"\"\"\n  1125→        try:\n  1126→            # 这里可以使用ffprobe或其他工具获取视频信息\n  1127→            # 暂时返回基本信息\n  1128→            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n  1129→        except Exception as e:\n  1130→            logger.error(f\"获取视频信息失败: {e}\")\n  1131→            return {}\n  1132→\n  1133→    def _save_task_metadata(self, result: Dict[str, Any]):\n  1134→        \"\"\"\n  1135→        保存任务元数据\n  1136→\n  1137→        Args:\n  1138→            result: 任务结果\n  1139→        \"\"\"\n  1140→        try:\n  1141→            # 构建视频元数据\n  1142→            metadata = {\n  1143→                \"generation_id\": result[\"task_id\"],\n  1144→                \"file_id\": result[\"task_id\"],\n  1145→                \"filename\": result.get(\"filename\", \"\"),\n  1146→                \"file_path\": result.get(\"local_path\", \"\"),\n  1147→                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n  1148→                \"parameters\": result.get(\"parameters\", {}),\n  1149→                \"created_at\": result[\"created_at\"],\n  1150→                \"file_size\": result.get(\"local_file_size\", 0),\n  1151→                \"source_url\": result.get(\"video_url\", \"\"),\n  1152→                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n  1153→                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n  1154→            }\n  1155→\n  1156→            # 调用视频元数据保存方法\n  1157→            self.metadata_manager.save_video_metadata(metadata)\n  1158→            \n  1159→            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n  1160→\n  1161→        except Exception as e:\n  1162→            logger.error(f\"保存任务元数据失败: {e}\")\n  1163→\n  1164→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1165→        \"\"\"\n  1166→        获取视频生成历史记录\n  1167→\n  1168→        Args:\n  1169→            limit: 返回记录数量限制\n  1170→\n  1171→        Returns:\n  1172→            List[Dict]: 历史记录列表\n  1173→        \"\"\"\n  1174→        return self.storage_manager.load_history('videos', limit=limit)\n  1175→\n  1176→    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n  1177→        \"\"\"\n  1178→        根据输入图像路径搜索历史记录\n  1179→\n  1180→        Args:\n  1181→            keyword: 搜索关键字\n  1182→\n  1183→        Returns:\n  1184→            List[Dict]: 匹配的记录列表\n  1185→        \"\"\"\n  1186→        return self.metadata_manager.search_records(\"input_image\", keyword)\n  1187→\n  1188→    def get_statistics(self) -> Dict[str, Any]:\n  1189→        \"\"\"\n  1190→        获取生成统计信息\n  1191→\n  1192→        Returns:\n  1193→            Dict: 统计信息\n  1194→        \"\"\"\n  1195→        try:\n  1196→            df = self.metadata_manager.get_dataframe()\n  1197→\n  1198→            if df.empty:\n  1199→                return {\n  1200→                    \"total_videos\": 0,\n  1201→                    \"success_count\": 0,\n  1202→                    \"failed_count\": 0,\n  1203→                    \"pending_count\": 0,\n  1204→                    \"total_file_size\": 0,\n  1205→                    \"average_file_size\": 0,\n  1206→                    \"total_duration\": 0,\n  1207→                    \"average_duration\": 0,\n  1208→                }\n  1209→\n  1210→            stats = {\n  1211→                \"total_videos\": len(df),\n  1212→                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n  1213→                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n  1214→                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n  1215→                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n  1216→                \"total_file_size\": df[\"local_file_size\"].sum(),\n  1217→                \"average_file_size\": df[\"local_file_size\"].mean(),\n  1218→                \"total_duration\": df[\"duration\"].sum(),\n  1219→                \"average_duration\": df[\"duration\"].mean(),\n  1220→                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n  1221→            }\n  1222→\n  1223→            return stats\n  1224→\n  1225→        except Exception as e:\n  1226→            logger.error(f\"获取统计信息失败: {e}\")\n  1227→            return {}\n  1228→\n  1229→    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n  1230→        \"\"\"\n  1231→        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n  1232→\n  1233→        注意：\n  1234→        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n  1235→          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n  1236→        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n  1237→        \"\"\"\n  1238→        params = result.get(\"parameters\", {}) or {}\n  1239→\n  1240→        # 新三层参数结构优先：actual > sent > requested\n  1241→        if isinstance(params, dict):\n  1242→            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n  1243→                layer_obj = params.get(layer)\n  1244→                if isinstance(layer_obj, dict):\n  1245→                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n  1246→                    if cand:\n  1247→                        return str(cand)\n  1248→                    if layer == \"params_requested\":\n  1249→                        mv = layer_obj.get(\"model_variant\")\n  1250→                        if mv:\n  1251→                            return str(mv)\n  1252→\n  1253→        # 顶层 model（VideoService 会尽量补齐）\n  1254→        top = result.get(\"model\")\n  1255→        if top:\n  1256→            return str(top)\n  1257→\n  1258→        # 旧结构兼容：从 parameters 推断\n  1259→        if isinstance(params, dict):\n  1260→            mv = params.get(\"model_variant\") or \"\"\n  1261→            mt = params.get(\"model_type\") or \"\"\n  1262→            use_pro_model = params.get(\"use_pro_model\", True)\n  1263→\n  1264→            if mv:\n  1265→                return str(mv)\n  1266→            if isinstance(mt, str) and mt.strip():\n  1267→                return mt.strip()\n  1268→            if bool(use_pro_model):\n  1269→                return \"pro\"\n  1270→            return \"lite\"\n  1271→\n  1272→        return \"seedance\"\n  1273→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5b46192d-6971-4d7e-88db-b02e7c4711e5","timestamp":"2026-01-05T11:51:04.291Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"# Seedance视频生成管理器\n# 负责视频生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nimport base64\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom urllib.parse import urlparse\nfrom loguru import logger\nfrom PIL import Image\n\nfrom ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n\nfrom .client import SeedanceClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    VideoParams,\n    validate_and_normalize_video,\n)\nfrom config.unified_config import get_unified_config\nfrom config.unified_config import get_storage_dir\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n# Q-006 固化策略：\n# - 本地水印由 edition/watermark_service 控制（trial 强制开 / prod 关闭）\n# - API 服务端水印固定关闭（不依赖 config_api）\n\n\nclass SeedanceManager:\n    \"\"\"Seedance视频生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedance管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n        \"\"\"\n        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n        \n        self.client = SeedanceClient(api_key)\n\n        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n        storage_path = get_storage_dir()\n        if not storage_path:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        Path(storage_path).mkdir(parents=True, exist_ok=True)\n\n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(storage_path)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.video_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.videos_dir = self.data_dir / \"videos\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_video(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: float = 4.0,\n        seed: int = -1,\n        watermark: bool = False,\n        save_local: bool = True,\n        wait_for_completion: bool = True,\n        # 新增参数（P0b）\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        fps: int = 24,\n        camera_fixed: bool = True,\n        use_pro_model: bool = True,\n        model_type: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        generate_audio: Optional[bool] = None,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成视频并保存到本地\n\n        Args:\n            image_path: 输入图像路径\n            duration: 视频时长（秒）\n            motion_strength: 运动强度 (0.1-1.0)\n            seed: 随机种子\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            Dict: 生成结果\n        \"\"\"\n        logger.info(\"开始视频生成任务(Manager)\")\n\n        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n        # 构建待处理的图片列表\n        all_input_images = []\n\n        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n        frame_inputs = []\n        if first_frame_path:\n            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n        if last_frame_path:\n            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n        elif image_path and not first_frame_path:\n            frame_inputs.append({'path': image_path, 'type': 'image'})\n\n        all_input_images.extend(frame_inputs)\n\n        # 2. 添加参考图\n        if reference_images:\n            for ref in reference_images:\n                if isinstance(ref, dict):\n                    ref_copy = dict(ref)\n                    ref_copy['type'] = ref_copy.get('type', 'reference')\n                    all_input_images.append(ref_copy)\n                else:\n                    all_input_images.append({'path': ref, 'type': 'reference'})\n\n        # 3. 统一处理（复制到 references 目录）\n        ref_summary = self._process_reference_assets(\n            all_input_images if all_input_images else None,\n            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n            expected_outputs=1,\n        )\n        ref_assets = ref_summary.get('assets', [])\n        ref_paths: List[str] = list(ref_summary.get('paths', []))\n\n        # 4. 分离帧图片和参考图\n        frame_assets = {}\n        pure_ref_assets = []\n        for asset in ref_assets:\n            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n            if asset_type in ('first_frame', 'last_frame', 'image'):\n                frame_assets[asset_type] = asset\n            else:\n                pure_ref_assets.append(asset)\n\n        # 5. 提取帧图片的相对路径（用于存储）\n        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n        stored_image_path = frame_assets.get('image', {}).get('path')\n\n        # 6. 提取参考图的 payload（用于 API 调用）\n        ref_payloads: List[str] = []\n        for asset in pure_ref_assets:\n            payload = asset.get('_payload_b64')\n            if payload:\n                ref_payloads.append(payload)\n\n        if ref_summary.get('errors'):\n            logger.warning(\n                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n            )\n        if ref_summary.get('warnings'):\n            for warn in ref_summary['warnings']:\n                logger.warning(f\"图片处理提示: {warn}\")\n\n        # Q-006：API 服务端水印固定关闭；体验版仅做本地水印（落盘后处理）\n        watermark_enabled = False\n\n        create_kwargs = dict(\n            prompt=prompt,\n            duration=int(duration),\n            seed=None if seed == -1 else seed,\n            fps=fps,\n            resolution_grade=resolution_grade,\n            ratio=ratio,\n            watermark=watermark_enabled,\n            camera_fixed=bool(camera_fixed),\n            use_pro_model=use_pro_model,\n            model_type=model_type,\n            model_variant=model_variant,\n            generate_audio=generate_audio,\n        )\n        if ref_payloads:\n            create_kwargs['reference_images'] = ref_payloads\n        if first_frame_path and last_frame_path:\n            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n        elif image_path:\n            create_kwargs.update(dict(image_path=image_path))\n        # 文生视频：不追加图片参数\n\n        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n        precheck_fb = False\n        precheck_reason = \"\"\n        try:\n            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n                VideoParams(\n                    prompt=prompt,\n                    image_path=None,  # 校验不依赖图像数据\n                    first_frame_path=None,\n                    last_frame_path=None,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if seed == -1 else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=bool(watermark),\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                    model_variant=model_variant,\n                    generate_audio=generate_audio,\n                )\n            )\n            logger.info(\n                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n            )\n            if fb:\n                logger.warning(f\"前置参数回退建议: {reason}\")\n            precheck_fb = fb\n            precheck_reason = reason\n        except Exception as _e:\n            logger.debug(f\"前置参数校验跳过: {_e}\")\n\n        create_result = self.client.create_video_task(**create_kwargs)\n        params_sent = create_result.get(\"params_sent\") if isinstance(create_result, dict) else None\n\n        # 用实际执行参数覆盖用户输入（如 Lite 参考图模式 1080p→720p 降级）\n        if create_result.get(\"success\"):\n            actual_rs = create_result.get('used_rs')\n            actual_rt = create_result.get('used_rt')\n            if actual_rs:\n                logger.debug(f\"参数覆盖|resolution_grade: 用户输入={resolution_grade} -> 实际执行={actual_rs}\")\n                resolution_grade = actual_rs\n            if actual_rt:\n                logger.debug(f\"参数覆盖|ratio: 用户输入={ratio} -> 实际执行={actual_rt}\")\n                ratio = actual_rt\n\n        if not create_result[\"success\"]:\n            self._cleanup_reference_paths(ref_paths)\n            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n            return create_result\n\n        api_task_id = create_result[\"task_id\"]\n\n        result = {\n            \"task_id\": task_id,\n            \"api_task_id\": api_task_id,\n            \"params_sent\": params_sent,\n            \"success\": True,\n            \"type\": \"image_to_video\",\n            \"input_image\": image_path,\n            \"status\": \"pending\",\n            \"parameters\": {\n                \"prompt\": prompt,\n                \"duration\": duration,\n                \"seed\": (None if seed == -1 else seed),\n                \"watermark\": watermark_enabled,\n                \"resolution_grade\": resolution_grade,\n                \"ratio\": ratio,\n                \"fps\": fps,\n                \"camera_fixed\": bool(camera_fixed),\n                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n                \"first_frame\": stored_first_frame,\n                \"last_frame\": stored_last_frame,\n                \"image_path\": stored_image_path,\n            },\n            \"created_at\": datetime.now().isoformat(),\n        }\n\n        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n        result['reference_assets'] = sanitized_refs\n        if ref_summary.get('errors'):\n            result['reference_asset_errors'] = ref_summary['errors']\n        if ref_summary.get('warnings'):\n            result['reference_asset_warnings'] = ref_summary['warnings']\n        if precheck_fb and precheck_reason:\n            result.setdefault('fallback_applied', True)\n            if result.get('fallback_reason'):\n                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n            else:\n                result['fallback_reason'] = precheck_reason\n\n        masked_ids = self._summarize_reference_ids(sanitized_refs)\n        logger.info(\n            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n            len(sanitized_refs),\n            masked_ids or \"-\",\n            self._provider_hint(),\n        )\n\n        # 透传回退信息\n        if create_result.get(\"fallback_applied\"):\n            result[\"fallback_applied\"] = True\n            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n\n        # 如果等待完成，轮询任务状态\n        if wait_for_completion:\n            completion_result = self.client.wait_for_completion(api_task_id)\n\n            if completion_result[\"success\"]:\n                if completion_result[\"status\"] == \"success\":\n                    result[\"status\"] = \"success\"\n                    result[\"video_url\"] = completion_result[\"video_url\"]\n                    result[\"duration\"] = completion_result.get(\"duration\")\n                    result[\"file_size\"] = completion_result.get(\"file_size\")\n                    result[\"completed_at\"] = datetime.now().isoformat()\n\n                    # 保存到本地\n                    if save_local:\n                        local_result = self._save_video_locally(result)\n                        result.update(local_result)\n                        # 注：file_size 已在 _save_video_locally 内部设置到 metadata['parameters'] 中\n                        if local_result.get('local_save_error'):\n                            self._cleanup_reference_paths(ref_paths)\n                            result['parameters'][\"reference_assets\"] = []\n                            result['reference_assets'] = []\n                            warnings = result.setdefault('reference_asset_warnings', [])\n                            warnings.append(\"视频保存失败，参考图已回滚\")\n                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n                    logger.success(f\"视频生成任务完成: {task_id}\")\n                else:\n                    result[\"status\"] = completion_result[\"status\"]\n                    result[\"error\"] = completion_result.get(\"error\")\n                    result[\"error_code\"] = completion_result.get(\"error_code\")\n                    logger.error(f\"视频生成任务失败: {result['error']}\")\n            else:\n                result[\"status\"] = \"failed\"\n                result[\"error\"] = completion_result[\"error\"]\n                result[\"error_code\"] = completion_result[\"error_code\"]\n                logger.error(f\"等待任务完成失败: {result['error']}\")\n\n        # 注：元数据已通过 save_content_file() 保存，无需重复调用\n\n        return result\n\n    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        检查任务状态\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        logger.info(f\"检查任务状态: {task_id}\")\n\n        # 从元数据中获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 查询API任务状态\n        status_result = self.client.get_task_status(api_task_id)\n\n        if status_result[\"success\"]:\n            # 更新本地记录\n            updates = {\n                \"status\": status_result[\"status\"],\n                \"progress\": status_result.get(\"progress\", 0),\n                \"updated_at\": datetime.now().isoformat(),\n            }\n\n            # 如果任务完成，添加结果信息\n            if status_result[\"status\"] == \"success\":\n                updates[\"video_url\"] = status_result[\"video_url\"]\n                updates[\"duration\"] = status_result.get(\"duration\")\n                updates[\"file_size\"] = status_result.get(\"file_size\")\n                updates[\"completed_at\"] = datetime.now().isoformat()\n\n            # 如果任务失败，添加错误信息\n            elif status_result[\"status\"] == \"failed\":\n                updates[\"error\"] = status_result.get(\"error\")\n                updates[\"error_code\"] = status_result.get(\"error_code\")\n\n            # 更新元数据\n            self.metadata_manager.update_record(task_id, updates)\n\n            # 合并任务信息\n            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n\n            return result\n        else:\n            return status_result\n\n    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        下载已完成的视频\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 下载结果\n        \"\"\"\n        logger.info(f\"下载视频: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        # 检查任务状态\n        if task_record.get(\"status\") != \"success\":\n            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n\n        video_url = task_record.get(\"video_url\")\n        if not video_url:\n            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n\n        # 检查是否已下载\n        local_path = task_record.get(\"local_path\")\n        if local_path and Path(local_path).exists():\n            logger.info(\n                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n            )\n            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n\n        # 下载视频\n        try:\n            response = safe_requests_get(video_url, timeout=300)\n\n            # 生成本地文件名\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            task_id_short = task_id[:8]\n            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n\n            # 保存文件\n            local_path = self.file_manager.save_file(filename, response.content)\n\n            # 获取视频信息\n            video_info = self._get_video_info(local_path)\n\n            # 更新元数据\n            updates = {\n                \"filename\": filename,\n                \"local_path\": str(local_path),\n                \"local_file_size\": local_path.stat().st_size,\n                \"downloaded_at\": datetime.now().isoformat(),\n            }\n\n            if video_info:\n                updates.update(video_info)\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"视频下载成功: {filename}\")\n\n            summary = {\n                \"success\": True,\n                \"local_path\": str(local_path),\n                \"filename\": filename,\n                \"file_size\": local_path.stat().st_size,\n                \"video_info\": video_info,\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n                )\n            except Exception:\n                pass\n            return summary\n\n        except Exception as e:\n            logger.error(f\"下载视频失败: {e}\")\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n                )\n            except Exception:\n                pass\n            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消任务\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 取消结果\n        \"\"\"\n        logger.info(f\"取消任务: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 调用API取消任务\n        cancel_result = self.client.cancel_task(api_task_id)\n\n        if cancel_result[\"success\"]:\n            # 更新本地记录\n            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"任务取消成功: {task_id}\")\n\n        return cancel_result\n\n    def batch_generate_videos(\n        self,\n        image_paths: List[str],\n        duration: float = 4.0,\n        motion_strength: float = 0.8,\n        watermark: bool = True,\n        save_local: bool = True,\n        wait_for_completion: bool = False,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成视频\n\n        Args:\n            image_paths: 图像路径列表\n            duration: 视频时长\n            motion_strength: 运动强度\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n\n        results = []\n        for i, image_path in enumerate(image_paths, 1):\n            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n\n            result = self.generate_video(\n                image_path=image_path,\n                duration=duration,\n                motion_strength=motion_strength,\n                watermark=watermark,\n                save_local=save_local,\n                wait_for_completion=wait_for_completion,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n\n        return results\n\n    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存视频到本地\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n\n            # Validate inputs\n            task_id = result.get(\"task_id\")\n            video_url = result.get(\"video_url\")\n            if not task_id:\n                raise ValueError(\"Task ID is required\")\n            if not video_url:\n                raise ValueError(\"Video URL is required\")\n            \n            # 下载视频（带重试机制）\n            logger.info(f\"Downloading video from {video_url}\")\n            max_retries = 3\n            retry_delay = 5  # 秒\n            video_data = None\n            last_error = None\n\n            for attempt in range(max_retries):\n                try:\n                    if attempt > 0:\n                        logger.info(f\"重试下载视频 (第 {attempt + 1}/{max_retries} 次)...\")\n\n                    response = safe_requests_get(video_url, stream=True, timeout=300)\n\n                    # Check content type\n                    content_type = response.headers.get('content-type', '')\n                    if 'video' not in content_type:\n                        logger.warning(f\"Unexpected content type: {content_type}\")\n\n                    # Get file size for progress tracking\n                    total_size = int(response.headers.get('content-length', 0))\n                    video_data = response.content\n\n                    logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n                    break  # 下载成功，跳出重试循环\n\n                except requests.exceptions.RequestException as e:\n                    last_error = e\n                    logger.warning(f\"下载视频失败 (第 {attempt + 1}/{max_retries} 次): {e}\")\n                    if attempt < max_retries - 1:\n                        import time\n                        time.sleep(retry_delay)\n\n            if video_data is None:\n                logger.error(f\"Network error downloading video after {max_retries} attempts: {last_error}\")\n                raise Exception(f\"Failed to download video after {max_retries} attempts: {str(last_error)}\")\n            \n            # 在保存前获取真实视频信息（写临时文件以便读取）\n            actual_width = None\n            actual_height = None\n            actual_fps = None\n            actual_duration = None\n            try:\n                import tempfile\n                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n                    tf.write(video_data)\n                    temp_path = Path(tf.name)\n                # 使用缩略图工具的get_video_info\n                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                gen = VideoThumbnailGenerator(str(thumbs_dir))\n                info = gen.get_video_info(str(temp_path))\n                try:\n                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n                except Exception:\n                    pass\n                if info:\n                    actual_width = info.get('width')\n                    actual_height = info.get('height')\n                    actual_fps = info.get('fps')\n                    actual_duration = info.get('duration')\n            except Exception as e:\n                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n\n            # 准备元数据（适配UnifiedStorageManager的格式）\n            metadata = {\n                'generation_id': task_id,\n                'task_id': task_id,\n                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n                'parameters': {\n                    **result.get('parameters', {}),\n                    # 设置文件大小（在保存前就设置，确保写入数据库）\n                    'file_size': len(video_data),\n                    # 回填真实视频信息\n                    **({} if actual_width is None else {'width': actual_width}),\n                    **({} if actual_height is None else {'height': actual_height}),\n                    **({} if actual_fps is None else {'fps': actual_fps}),\n                    **({} if actual_duration is None else {'duration': actual_duration}),\n                    # 透传fallback信息\n                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n                },\n                'model': self._get_display_model_name(result),\n                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n                'generation_time': result.get('generation_time', 0),\n                'status': result.get('status', 'completed'),\n                'batch_id': result.get('batch_id', '')\n            }\n\n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='videos',\n                file_data=video_data,\n                url=video_url,\n                metadata=metadata\n            )\n\n            # 缩略图生成（已由UnifiedStorageManager处理）\n            thumbnail_local_path = save_result.get('thumbnail_path')\n            thumbnail_filename = None\n            if thumbnail_local_path:\n                thumbnail_filename = Path(thumbnail_local_path).name\n                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n            else:\n                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n\n            # 下载并保存API返回的缩略图（如果有）作为备用\n            api_thumbnail_local_path = None\n            api_thumbnail_filename = None\n            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n                try:\n                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n                    \n                    # 使用统一存储管理器保存备用缩略图\n                    backup_metadata = {\n                        'generation_id': task_id,\n                        'prompt': 'API backup thumbnail for video',\n                        'model': 'seedance',\n                        'width': 320,\n                        'height': 180,\n                        'status': 'completed'\n                    }\n                    \n                    backup_result = self.storage_manager.save_content_file(\n                        content_type='images',  # 缩略图保存为图片\n                        file_data=thumbnail_response.content,\n                        url=result[\"thumbnail_url\"],\n                        metadata=backup_metadata\n                    )\n                    \n                    api_thumbnail_local_path = backup_result['local_path']\n                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n                    \n                    # 如果本地缩略图生成失败，使用API缩略图\n                    if not thumbnail_local_path:\n                        thumbnail_local_path = api_thumbnail_local_path\n                        thumbnail_filename = api_thumbnail_filename\n                    \n                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n                        \n                except Exception as e:\n                    logger.warning(f\"下载API缩略图失败: {e}\")\n                    api_thumbnail_local_path = None\n                    api_thumbnail_filename = None\n\n            # 获取视频信息\n            local_path = Path(save_result['local_path'])\n            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n                try:\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n                    video_info = gen.get_video_info(str(local_path))\n                except Exception:\n                    video_info = {}\n            else:\n                video_info = {\n                    'width': actual_width,\n                    'height': actual_height,\n                    'fps': actual_fps,\n                    'duration': actual_duration,\n                }\n            file_size = local_path.stat().st_size if local_path.exists() else 0\n            \n            logger.success(f\"视频已保存到本地: {local_path.name}\")\n            \n            # 本地视频水印（使用统一水印服务控制）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_video(local_path)\n                    if watermark_applied:\n                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n                    else:\n                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n                except Exception as e:\n                    logger.warning(f\"添加视频水印时出错: {e}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": local_path.name,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"local_file_size\": file_size,\n                \"video_info\": video_info,\n                # 同步回填至顶层，便于上游使用\n                **({} if not video_info else {\n                    'width': video_info.get('width'),\n                    'height': video_info.get('height'),\n                    'fps': video_info.get('fps'),\n                    'duration': video_info.get('duration'),\n                }),\n                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n                \"thumbnail_filename\": thumbnail_filename,\n                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n                \"api_thumbnail_filename\": api_thumbnail_filename,\n                \"task_id\": task_id,  # 添加task_id以供后续使用\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n                )\n            except Exception:\n                pass\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存视频到本地失败: {e}\")\n            logger.exception(\"Full traceback for video save error:\")\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n                )\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"参考图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('reference_id'),\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum'),\n                'size': rec.get('size'),\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n        except Exception:\n            return \"seedance\"\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n        \"\"\"\n        将绝对路径转换为相对路径（相对于存储根目录）\n\n        如果路径已经是相对路径或无法转换，返回原路径。\n        这确保数据库中存储的是相对路径，支持跨平台迁移。\n\n        Args:\n            abs_path: 绝对路径或相对路径\n\n        Returns:\n            相对路径字符串，如 \"images/xxx.png\"\n        \"\"\"\n        if not abs_path:\n            return None\n\n        try:\n            path = Path(abs_path)\n\n            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n            if not path.is_absolute():\n                return str(path).replace('\\\\', '/')\n\n            # 尝试转换为相对于存储根目录的路径\n            storage_root = Path(self.storage_manager.root_path)\n            try:\n                relative = path.relative_to(storage_root)\n                return str(relative).replace('\\\\', '/')\n            except ValueError:\n                # 路径不在存储根目录下，尝试提取文件名部分\n                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n                parts = path.parts\n                for i, part in enumerate(parts):\n                    if part in ('images', 'videos', 'thumbnails', 'references'):\n                        relative = Path(*parts[i:])\n                        return str(relative).replace('\\\\', '/')\n\n                # 无法提取，返回原路径（记录警告）\n                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n                return str(path).replace('\\\\', '/')\n\n        except Exception as e:\n            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n            return abs_path\n\n    def _extract_width_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取宽度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[0])\n        except (ValueError, IndexError):\n            return 1280  # 默认值\n    \n    def _extract_height_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取高度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[1])\n        except (ValueError, IndexError):\n            return 720  # 默认值\n\n    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取视频信息\n\n        Args:\n            video_path: 视频文件路径\n\n        Returns:\n            Dict: 视频信息\n        \"\"\"\n        try:\n            # 这里可以使用ffprobe或其他工具获取视频信息\n            # 暂时返回基本信息\n            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n        except Exception as e:\n            logger.error(f\"获取视频信息失败: {e}\")\n            return {}\n\n    def _save_task_metadata(self, result: Dict[str, Any]):\n        \"\"\"\n        保存任务元数据\n\n        Args:\n            result: 任务结果\n        \"\"\"\n        try:\n            # 构建视频元数据\n            metadata = {\n                \"generation_id\": result[\"task_id\"],\n                \"file_id\": result[\"task_id\"],\n                \"filename\": result.get(\"filename\", \"\"),\n                \"file_path\": result.get(\"local_path\", \"\"),\n                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n                \"parameters\": result.get(\"parameters\", {}),\n                \"created_at\": result[\"created_at\"],\n                \"file_size\": result.get(\"local_file_size\", 0),\n                \"source_url\": result.get(\"video_url\", \"\"),\n                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n            }\n\n            # 调用视频元数据保存方法\n            self.metadata_manager.save_video_metadata(metadata)\n            \n            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n\n        except Exception as e:\n            logger.error(f\"保存任务元数据失败: {e}\")\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取视频生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('videos', limit=limit)\n\n    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据输入图像路径搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        return self.metadata_manager.search_records(\"input_image\", keyword)\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            df = self.metadata_manager.get_dataframe()\n\n            if df.empty:\n                return {\n                    \"total_videos\": 0,\n                    \"success_count\": 0,\n                    \"failed_count\": 0,\n                    \"pending_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"total_duration\": 0,\n                    \"average_duration\": 0,\n                }\n\n            stats = {\n                \"total_videos\": len(df),\n                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n                \"total_file_size\": df[\"local_file_size\"].sum(),\n                \"average_file_size\": df[\"local_file_size\"].mean(),\n                \"total_duration\": df[\"duration\"].sum(),\n                \"average_duration\": df[\"duration\"].mean(),\n                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n            }\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {}\n\n    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n        \"\"\"\n        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n\n        注意：\n        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n        \"\"\"\n        params = result.get(\"parameters\", {}) or {}\n\n        # 新三层参数结构优先：actual > sent > requested\n        if isinstance(params, dict):\n            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n                layer_obj = params.get(layer)\n                if isinstance(layer_obj, dict):\n                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n                    if cand:\n                        return str(cand)\n                    if layer == \"params_requested\":\n                        mv = layer_obj.get(\"model_variant\")\n                        if mv:\n                            return str(mv)\n\n        # 顶层 model（VideoService 会尽量补齐）\n        top = result.get(\"model\")\n        if top:\n            return str(top)\n\n        # 旧结构兼容：从 parameters 推断\n        if isinstance(params, dict):\n            mv = params.get(\"model_variant\") or \"\"\n            mt = params.get(\"model_type\") or \"\"\n            use_pro_model = params.get(\"use_pro_model\", True)\n\n            if mv:\n                return str(mv)\n            if isinstance(mt, str) and mt.strip():\n                return mt.strip()\n            if bool(use_pro_model):\n                return \"pro\"\n            return \"lite\"\n\n        return \"seedance\"\n","numLines":1273,"startLine":1,"totalLines":1273}}}
{"parentUuid":"5b46192d-6971-4d7e-88db-b02e7c4711e5","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BeJgFubTKxFPX2YC3NoN2b","type":"tool_result","content":"     1→# Seedance视频生成客户端\n     2→# 封装火山引擎Seedance1.0pro的API调用\n     3→\n     4→import os\n     5→import time\n     6→import json\n     7→import base64\n     8→import requests\n     9→import logging\n    10→import asyncio\n    11→from typing import Dict, Any, Optional, List, Tuple\n    12→from pathlib import Path\n    13→from loguru import logger\n    14→# volcenginesdkarkruntime import removed - not used in current implementation\n    15→from requests.adapters import HTTPAdapter\n    16→from urllib3.util.retry import Retry\n    17→\n    18→# 导入配置管理器和错误处理\n    19→from config.unified_config import get_unified_config\n    20→from utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n    21→from .config import SeedanceModels, TaskStatus, SeedanceConfig\n    22→\n    23→\"\"\"\n    24→常量与辅助方法（视频参数 P0b）\n    25→- 仅保留“分辨率档位 + 比例”的新路径；不再支持旧 width/height → --rs 映射\n    26→\"\"\"\n    27→\n    28→# 白名单常量\n    29→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    30→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n    31→\n    32→def _summarize_payload_for_storage(\n    33→    data: Dict[str, Any],\n    34→    *,\n    35→    resolution_grade: Optional[str],\n    36→    ratio: Optional[str],\n    37→    duration: int,\n    38→    fps: int,\n    39→    seed: Optional[int],\n    40→    camera_fixed: bool,\n    41→    used_rs: str,\n    42→    used_rt: str,\n    43→    mode: str,\n    44→) -> Dict[str, Any]:\n    45→    \"\"\"\n    46→    生成可落盘的 params_sent（避免保存 base64 / 大字段）。\n    47→\n    48→    注意：\n    49→    - 仅存储与“参数一致性/复用/恢复”相关信息，不落 content.image_url.url 等内容。\n    50→    \"\"\"\n    51→    try:\n    52→        content = data.get(\"content\") or []\n    53→        image_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"image_url\"]\n    54→        text_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"text\"]\n    55→        text_len = 0\n    56→        if text_items:\n    57→            try:\n    58→                text_len = len(str(text_items[0].get(\"text\") or \"\"))\n    59→            except Exception:\n    60→                text_len = 0\n    61→\n    62→        roles = []\n    63→        for item in image_items:\n    64→            role = item.get(\"role\")\n    65→            if role:\n    66→                roles.append(str(role))\n    67→\n    68→        resolved_rs = used_rs or (resolution_grade or \"\")\n    69→        resolved_rt = used_rt or (ratio or \"\")\n    70→        return {\n    71→            \"model\": data.get(\"model\"),\n    72→            \"mode\": mode,\n    73→            \"service_tier\": data.get(\"service_tier\"),\n    74→            \"execution_expires_after\": data.get(\"execution_expires_after\"),\n    75→            \"generate_audio\": data.get(\"generate_audio\"),\n    76→            \"resolution\": resolved_rs,\n    77→            \"ratio\": resolved_rt,\n    78→            \"duration\": int(duration),\n    79→            \"framespersecond\": int(fps),\n    80→            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n    81→            \"camera_fixed\": bool(camera_fixed),\n    82→            # 服务端 watermark 已强制关闭（仅本地水印）\n    83→            \"watermark\": bool(data.get(\"watermark\", False)) if isinstance(data, dict) else False,\n    84→            \"content_summary\": {\n    85→                \"image_count\": len(image_items),\n    86→                \"image_roles\": roles,\n    87→                \"text_prompt_length\": text_len,\n    88→            },\n    89→        }\n    90→    except Exception:\n    91→        # 兜底：永远不让 params_sent 影响主流程\n    92→        return {\n    93→            \"model\": data.get(\"model\") if isinstance(data, dict) else None,\n    94→            \"mode\": mode,\n    95→            \"resolution\": used_rs or resolution_grade,\n    96→            \"ratio\": used_rt or ratio,\n    97→            \"duration\": int(duration),\n    98→            \"framespersecond\": int(fps),\n    99→            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n   100→        }\n   101→\n   102→def _validate_and_build_flags(\n   103→    resolution_grade: Optional[str],\n   104→    ratio: Optional[str],\n   105→    duration: int,\n   106→    fps: int,\n   107→    watermark: bool,\n   108→    camera_fixed: bool,\n   109→    seed: Optional[int],\n   110→) -> Tuple[str, bool, str, str, str]:\n   111→    \"\"\"生成安全版文本命令片段；返回 (flags_text, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n   112→    used_rs = resolution_grade or \"\"\n   113→    used_rt = ratio or \"\"\n   114→    fallback_applied = False\n   115→    fallback_reasons: List[str] = []\n   116→\n   117→    # 校验白名单\n   118→    if not used_rs or used_rs not in RES_GRADES:\n   119→        fallback_applied = True\n   120→        fallback_reasons.append(f\"无效分辨率: {used_rs or '缺失'}\")\n   121→        used_rs = \"1080p\"\n   122→    if not used_rt or used_rt not in RATIOS:\n   123→        fallback_applied = True\n   124→        fallback_reasons.append(f\"无效比例: {used_rt or '缺失'}\")\n   125→        used_rt = \"16:9\"\n   126→\n   127→    # 组装顺序: --rs --rt --dur --fps --wm --seed --cf\n   128→    parts: List[str] = []\n   129→    parts += [\"--rs\", used_rs, \"--rt\", used_rt, \"--dur\", str(int(duration)), \"--fps\", str(int(fps))]\n   130→    parts += [\"--wm\", str(bool(watermark)).lower()]\n   131→    if seed is not None and seed != -1:\n   132→        try:\n   133→            parts += [\"--seed\", str(int(seed))]\n   134→        except Exception:\n   135→            # 种子解析异常时忽略，不触发全局fallback\n   136→            logger.warning(\"种子参数无效，已忽略 --seed\")\n   137→    parts += [\"--cf\", str(bool(camera_fixed)).lower()]\n   138→\n   139→    flags_text = \" \".join(parts)\n   140→    fallback_reason = \", \".join(fallback_reasons) if fallback_applied else \"\"\n   141→    return flags_text, fallback_applied, fallback_reason, used_rs, used_rt\n   142→\n   143→\n   144→class SeedanceClient:\n   145→    \"\"\"火山引擎Seedance视频生成客户端\n   146→\n   147→    提供文生视频、图生视频和首尾帧视频生成功能\n   148→    \"\"\"\n   149→\n   150→    def __init__(\n   151→        self,\n   152→        api_key: Optional[str] = None,\n   153→        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n   154→        timeout: int = 60,\n   155→        max_retries: int = 3,\n   156→    ):\n   157→        \"\"\"初始化Seedance客户端\n   158→\n   159→        Args:\n   160→            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n   161→            base_url: API基础URL\n   162→            timeout: 请求超时时间（秒）\n   163→            max_retries: 最大重试次数\n   164→        \"\"\"\n   165→        # 获取API密钥\n   166→        if api_key is None:\n   167→            try:\n   168→                api_key = get_unified_config().get_api_key(\"volcengine\")\n   169→            except Exception as exc:\n   170→                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n   171→\n   172→        self.api_key = api_key\n   173→        self.base_url = base_url.rstrip(\"/\")\n   174→        self.timeout = timeout\n   175→        self.max_retries = max_retries\n   176→        self.retry_delay = 2\n   177→        self.config = SeedanceConfig()\n   178→        self._active_tasks = set()  # 跟踪活跃任务\n   179→\n   180→        # 配置会话\n   181→        self.session = requests.Session()\n   182→        \n   183→        # 配置SSL和连接参数\n   184→        import ssl\n   185→        from requests.adapters import HTTPAdapter\n   186→        from urllib3.util.retry import Retry\n   187→        from urllib3.util.ssl_ import create_urllib3_context\n   188→        \n   189→        # 创建自定义SSL上下文\n   190→        ssl_context = create_urllib3_context()\n   191→        ssl_context.check_hostname = False\n   192→        ssl_context.verify_mode = ssl.CERT_NONE\n   193→        ssl_context.set_ciphers('DEFAULT@SECLEVEL=1')\n   194→        \n   195→        # 配置更强的重试策略\n   196→        retry_strategy = Retry(\n   197→            total=max_retries * 2,  # 增加重试次数\n   198→            status_forcelist=[429, 500, 502, 503, 504],\n   199→            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n   200→            backoff_factor=2,  # 增加退避因子\n   201→            raise_on_status=False\n   202→        )\n   203→        \n   204→        # 创建自定义适配器\n   205→        class SSLAdapter(HTTPAdapter):\n   206→            def init_poolmanager(self, *args, **kwargs):\n   207→                kwargs['ssl_context'] = ssl_context\n   208→                kwargs['socket_options'] = [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]\n   209→                return super().init_poolmanager(*args, **kwargs)\n   210→        \n   211→        import socket\n   212→        adapter = SSLAdapter(\n   213→            max_retries=retry_strategy,\n   214→            pool_connections=10,\n   215→            pool_maxsize=20,\n   216→            pool_block=False\n   217→        )\n   218→        \n   219→        self.session.mount(\"http://\", adapter)\n   220→        self.session.mount(\"https://\", adapter)\n   221→\n   222→        # 设置会话级别的超时和连接参数\n   223→        self.session.timeout = (30, 120)  # (连接超时, 读取超时)\n   224→        self.session.verify = False  # 直接禁用SSL验证，避免证书问题\n   225→\n   226→        # 禁用SSL警告\n   227→        import urllib3\n   228→        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   229→\n   230→        self.session.headers.update({\n   231→            'Connection': 'keep-alive',\n   232→            'Keep-Alive': 'timeout=30, max=100'\n   233→        })\n   234→\n   235→        # 初始化性能监控\n   236→        self._performance_stats = {\n   237→            \"total_requests\": 0,\n   238→            \"successful_requests\": 0,\n   239→            \"failed_requests\": 0,\n   240→            \"total_response_time\": 0,\n   241→            \"last_request_time\": None\n   242→        }\n   243→        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n   244→        \n   245→        logger.info(\"Seedance客户端初始化完成\")\n   246→        logger.info(f\"使用配置: 基础URL={self.base_url}, 超时={timeout}秒, 最大重试={max_retries}次\")\n   247→\n   248→    def _provider_enabled(self) -> bool:\n   249→        try:\n   250→            import os\n   251→            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n   252→            return v not in {\"0\", \"false\", \"no\"}\n   253→        except Exception:\n   254→            return True\n   255→\n   256→    def _get_headers(self) -> Dict[str, str]:\n   257→        \"\"\"获取请求头\"\"\"\n   258→        api_key = str(self.api_key).strip()\n   259→\n   260→        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n   261→        try:\n   262→            api_key.encode('ascii')\n   263→        except UnicodeEncodeError:\n   264→            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n   265→\n   266→        return {\n   267→            \"Authorization\": f\"Bearer {api_key}\",\n   268→            \"Content-Type\": \"application/json; charset=utf-8\",\n   269→            \"User-Agent\": \"Seedance-Client/1.0.0\",\n   270→        }\n   271→\n   272→    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout=60):\n   273→        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n   274→        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   275→        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n   276→\n   277→    def _handle_response(self, response: requests.Response, operation: str = \"API调用\") -> Dict[str, Any]:\n   278→        \"\"\"处理API响应\n   279→\n   280→        Args:\n   281→            response: HTTP响应对象\n   282→            operation: 操作描述，用于日志记录\n   283→\n   284→        Returns:\n   285→            解析后的响应数据\n   286→\n   287→        Raises:\n   288→            Exception: 当API返回错误时\n   289→        \"\"\"\n   290→        try:\n   291→            # 记录响应基本信息\n   292→            logger.info(f\"{operation} - 响应状态码: {response.status_code}\")\n   293→            \n   294→            # 处理HTTP错误状态码\n   295→            if not response.ok:\n   296→                error_details = {\n   297→                    \"status_code\": response.status_code,\n   298→                    \"url\": response.url,\n   299→                    \"headers\": dict(response.headers),\n   300→                    \"operation\": operation\n   301→                }\n   302→                \n   303→                try:\n   304→                    error_body = response.json()\n   305→                    error_details[\"response_body\"] = error_body\n   306→                except Exception:\n   307→                    try:\n   308→                        error_details[\"response_text\"] = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   309→                    except Exception:\n   310→                        error_details[\"response_text\"] = str(response.content[:500])\n   311→                \n   312→                # 根据状态码分类错误\n   313→                if response.status_code == 400:\n   314→                    logger.error(f\"{operation} - 请求参数错误: {error_details}\")\n   315→                    try:\n   316→                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   317→                    except Exception:\n   318→                        preview = str(response.content[:500])\n   319→                    raise Exception(f\"请求参数错误: {preview}\")\n   320→                elif response.status_code == 401:\n   321→                    logger.error(f\"{operation} - 认证失败: API密钥无效\")\n   322→                    raise Exception(\"认证失败: 请检查API密钥是否正确\")\n   323→                elif response.status_code == 403:\n   324→                    logger.error(f\"{operation} - 权限不足: {error_details}\")\n   325→                    raise Exception(\"权限不足: 请检查API密钥权限\")\n   326→                elif response.status_code == 404:\n   327→                    logger.error(f\"{operation} - 资源不存在: {error_details}\")\n   328→                    raise Exception(\"资源不存在: 请检查API端点或任务ID\")\n   329→                elif response.status_code == 429:\n   330→                    logger.error(f\"{operation} - 请求频率限制: {error_details}\")\n   331→                    raise Exception(\"请求频率过高: 请稍后重试\")\n   332→                elif response.status_code >= 500:\n   333→                    logger.error(f\"{operation} - 服务器错误: {error_details}\")\n   334→                    raise Exception(f\"服务器错误: {response.status_code}\")\n   335→                else:\n   336→                    logger.error(f\"{operation} - HTTP错误: {error_details}\")\n   337→                    try:\n   338→                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   339→                    except Exception:\n   340→                        preview = str(response.content[:500])\n   341→                    raise Exception(f\"HTTP错误: {response.status_code} - {preview}\")\n   342→\n   343→            # 解析JSON响应（增强容错：包括编码问题回退）\n   344→            try:\n   345→                result = response.json()\n   346→            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n   347→                raw = response.content or b\"\"\n   348→                tried = set()\n   349→                result = None\n   350→                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n   351→                    if not enc or enc in tried:\n   352→                        continue\n   353→                    tried.add(enc)\n   354→                    try:\n   355→                        text = raw.decode(enc, errors=\"strict\")\n   356→                        result = json.loads(text)\n   357→                        logger.debug(f\"{operation} - 通过备用编码解析成功: {enc}\")\n   358→                        break\n   359→                    except Exception:\n   360→                        continue\n   361→                if result is None:\n   362→                    # 最后尝试宽松日志预览，抛出统一错误\n   363→                    try:\n   364→                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n   365→                    except Exception:\n   366→                        preview = str(raw[:200])\n   367→                    logger.error(f\"{operation} - JSON解析失败(编码问题): {preview}\")\n   368→                    raise Exception(f\"响���格式错误: 无法解析JSON - {str(e)}\")\n   369→\n   370→            # 检查业务错误\n   371→            if \"error\" in result:\n   372→                error_info = result[\"error\"]\n   373→                error_msg = error_info.get(\"message\", \"未知错误\")\n   374→                error_code = error_info.get(\"code\", \"UNKNOWN_ERROR\")\n   375→                \n   376→                logger.error(f\"{operation} - API业务错误: {error_msg} (代码: {error_code})\")\n   377→                logger.error(f\"完整错误信息: {result}\")\n   378→                \n   379→                # 根据错误代码提供更友好的错误信息\n   380→                friendly_msg = self._get_friendly_error_message(error_code, error_msg)\n   381→                raise Exception(f\"API业务错误: {friendly_msg}\")\n   382→\n   383→            # 记录成功响应的关键信息\n   384→            if \"id\" in result:\n   385→                logger.info(f\"{operation} - 成功，任务ID: {result['id']}\")\n   386→            elif \"status\" in result:\n   387→                logger.info(f\"{operation} - 成功，状态: {result['status']}\")\n   388→            else:\n   389→                logger.info(f\"{operation} - 成功\")\n   390→\n   391→            return result\n   392→\n   393→        except requests.exceptions.Timeout as e:\n   394→            logger.error(f\"{operation} - 请求超时: {str(e)}\")\n   395→            raise Exception(f\"请求超时: 请检查网络连接或稍后重试\")\n   396→        except requests.exceptions.ConnectionError as e:\n   397→            logger.error(f\"{operation} - 连接错误: {str(e)}\")\n   398→            raise Exception(f\"网络连接错误: 请检查网络连接\")\n   399→        except requests.exceptions.RequestException as e:\n   400→            logger.error(f\"{operation} - 网络请求错误: {str(e)}\")\n   401→            raise Exception(f\"网络请求失败: {str(e)}\")\n   402→        except Exception as e:\n   403→            if \"API业务错误\" in str(e) or \"请求参数错误\" in str(e) or \"认证失败\" in str(e):\n   404→                # 重新抛出已处理的业务错误\n   405→                raise\n   406→            else:\n   407→                logger.error(f\"{operation} - 未知错误: {str(e)}\")\n   408→                raise Exception(f\"处理响应时发生未知错误: {str(e)}\")\n   409→    \n   410→    def _get_friendly_error_message(self, error_code: str, error_msg: str) -> str:\n   411→        \"\"\"获取友好的错误信息\n   412→        \n   413→        Args:\n   414→            error_code: 错误代码\n   415→            error_msg: 原始错误信息\n   416→            \n   417→        Returns:\n   418→            友好的错误信息\n   419→        \"\"\"\n   420→        error_mapping = {\n   421→            \"INVALID_PARAMETER\": \"参数无效，请检查输入参数\",\n   422→            \"INSUFFICIENT_QUOTA\": \"配额不足，请检查账户余额\",\n   423→            \"MODEL_NOT_FOUND\": \"模型不存在，请检查模型名称\",\n   424→            \"TASK_NOT_FOUND\": \"任务不存在，请检查任务ID\",\n   425→            \"TASK_ALREADY_CANCELLED\": \"任务已被取消\",\n   426→            \"TASK_ALREADY_COMPLETED\": \"任务已完成，无法取消\",\n   427→            \"RATE_LIMIT_EXCEEDED\": \"请求频率过高，请稍后重试\",\n   428→            \"INTERNAL_ERROR\": \"服务内部错误，请稍后重试\",\n   429→            \"UNAUTHORIZED\": \"未授权访问，请检查API密钥\",\n   430→            \"FORBIDDEN\": \"禁止访问，请检查权限设置\"\n   431→        }\n   432→        \n   433→        return error_mapping.get(error_code, f\"{error_msg} (错误代码: {error_code})\")\n   434→    \n   435→    def _record_request_stats(\n   436→        self,\n   437→        operation: str,\n   438→        success: bool,\n   439→        response_time: float,\n   440→        error_code: Optional[str] = None,\n   441→        error_message: Optional[str] = None,\n   442→    ):\n   443→        \"\"\"记录请求统计信息（统一结构 + 最近错误）。\"\"\"\n   444→        try:\n   445→            self._performance_stats[\"total_requests\"] += 1\n   446→            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n   447→            self._performance_stats[\"last_request_time\"] = time.time()\n   448→            \n   449→            if success:\n   450→                self._performance_stats[\"successful_requests\"] += 1\n   451→            else:\n   452→                self._performance_stats[\"failed_requests\"] += 1\n   453→                if error_code or error_message:\n   454→                    self._last_error = {\"code\": error_code, \"message\": (str(error_message)[:200] if error_message else None)}\n   455→            \n   456→            # 记录性能日志（安全摘要）\n   457→            total = max(1, self._performance_stats[\"total_requests\"])\n   458→            avg = self._performance_stats[\"total_response_time\"] / total\n   459→            success_rate = (self._performance_stats[\"successful_requests\"] / total) * 100\n   460→            logger.debug(f\"{operation} - 响应时间: {response_time:.2f}s, 平均: {avg:.2f}s, 成功率: {success_rate:.1f}%\")\n   461→        except Exception:\n   462→            pass\n   463→    \n   464→    def get_performance_stats(self) -> Dict[str, Any]:\n   465→        \"\"\"获取性能统计信息（统一字段命名）。\"\"\"\n   466→        stats = dict(self._performance_stats)\n   467→        total = stats.get(\"total_requests\", 0) or 0\n   468→        if total > 0:\n   469→            avg = stats.get(\"total_response_time\", 0.0) / total\n   470→            suc_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n   471→        else:\n   472→            avg = 0.0\n   473→            suc_rate = 0.0\n   474→        return {\n   475→            \"total_requests\": total,\n   476→            \"successful_requests\": stats.get(\"successful_requests\", 0),\n   477→            \"failed_requests\": stats.get(\"failed_requests\", 0),\n   478→            \"avg_response_time\": avg,\n   479→            \"success_rate\": suc_rate,\n   480→            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n   481→        }\n   482→\n   483→    def dump_metrics(self) -> Dict[str, Any]:\n   484→        \"\"\"导出统一指标，便于诊断脚本读取。\"\"\"\n   485→        m = self.get_performance_stats()\n   486→        m.update({\n   487→            \"client\": \"Seedance\",\n   488→            \"base_url\": self.base_url,\n   489→        })\n   490→        return m\n   491→\n   492→    def create_video_task(\n   493→        self,\n   494→        prompt: str,\n   495→        image_path: Optional[str] = None,\n   496→        first_frame_path: Optional[str] = None,\n   497→        last_frame_path: Optional[str] = None,\n   498→        duration: int = 8,\n   499→        fps: int = 24,\n   500→        width: Optional[int] = None,\n   501→        height: Optional[int] = None,\n   502→        seed: Optional[int] = None,\n   503→        use_pro_model: bool = True,\n   504→        model_type: Optional[str] = None,\n   505→        model_variant: Optional[str] = None,\n   506→        camera_fixed: bool = True,\n   507→        resolution_grade: Optional[str] = None,\n   508→        ratio: Optional[str] = None,\n   509→        watermark: bool = False,\n   510→        reference_images: Optional[List[str]] = None,\n   511→        generate_audio: Optional[bool] = None,\n   512→    ) -> Dict[str, Any]:\n   513→        \"\"\"\n   514→        创建视频生成任务（新路径：分辨率档位 + 比例）\n   515→\n   516→        Args:\n   517→            prompt: 视频描述提示词\n   518→            image_path: 输入图片路径（图生视频）\n   519→            first_frame_path: 首帧图片路径（首尾帧模式）\n   520→            last_frame_path: 尾帧图片路径（首尾帧模式）\n   521→            duration: 视频时长（秒），默认8秒\n   522→            fps: 帧率，默认24fps\n   523→            width/height: 旧路径兼容（关闭灰度时使用）\n   524→            seed: 随机种子\n   525→            use_pro_model: 是否使用Pro模型（兼容旧调用）\n   526→            model_type: 模型类型 \"pro\"/\"pro_fast\"/\"lite\"（优先级高于 use_pro_model）\n   527→            model_variant: UI 侧模型变体（如 seedance_1_5_pro）\n   528→            camera_fixed: 是否固定摄像头视角\n   529→            resolution_grade: 分辨率档位\n   530→            ratio: 画面比例\n   531→            watermark: 是否添加水印\n   532→            reference_images: 额外参考图（base64/url），Seedream 4.0 视频扩展预留\n   533→            generate_audio: 是否生成同步音频（仅 Seedance 1.5 Pro 生效）\n   534→\n   535→        Returns:\n   536→            包含任务ID的响应结果\n   537→        \"\"\"\n   538→        url = f\"{self.base_url}/contents/generations/tasks\"\n   539→        is_seedance_1_5_variant = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n   540→\n   541→        # 通过 Provider Schema 映射（默认启用；关闭时回退旧逻辑）\n   542→        data = None\n   543→        mode = \"\"\n   544→        fallback_applied = False\n   545→        fallback_reason = \"\"\n   546→        used_rs = \"\"\n   547→        used_rt = \"\"\n   548→        if self._provider_enabled():\n   549→            try:\n   550→                # 预编码图片为 data URL（与旧实现一致），再交由 Provider 组装 content\n   551→                enc_first = self._encode_image(first_frame_path) if first_frame_path else None\n   552→                enc_last = self._encode_image(last_frame_path) if last_frame_path else None\n   553→                enc_img = self._encode_image(image_path) if image_path else None\n   554→\n   555→                from modules.provider.factory import get_default_provider\n   556→                from modules.provider.schema import VideoParams\n   557→                provider = get_default_provider()\n   558→                mapped, fb, reason, used_rs, used_rt = provider.map_video(VideoParams(\n   559→                    prompt=prompt,\n   560→                    image_path=enc_img,\n   561→                    first_frame_path=enc_first,\n   562→                    last_frame_path=enc_last,\n   563→                    duration=int(duration),\n   564→                    fps=int(fps),\n   565→                    seed=(None if (seed is None or seed == -1) else seed),\n   566→                    camera_fixed=bool(camera_fixed),\n   567→                    watermark=False,\n   568→                    resolution_grade=resolution_grade,\n   569→                    ratio=ratio,\n   570→                    use_pro_model=bool(use_pro_model),\n   571→                    model_variant=model_variant,\n   572→                    generate_audio=generate_audio,\n   573→                    reference_images=(reference_images or []),\n   574→                ))\n   575→                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\n   576→                mode = mapped.get(\"mode\", \"视频\")\n   577→                model = data[\"model\"]\n   578→                fallback_applied, fallback_reason = fb, reason\n   579→                if fb:\n   580→                    logger.warning(f\"参数回退: {reason}\")\n   581→                logger.info(f\"安全版参数: {mapped.get('flags_text', '')}\")\n   582→            except Exception as _e:\n   583→                logger.warning(f\"Provider 映射失败，回退旧路径: {_e}\")\n   584→\n   585→        if data is None:\n   586→            # 旧内容组装路径\n   587→            content: List[Dict[str, Any]] = []\n   588→\n   589→            # 解析 model_type（优先级高于 use_pro_model）\n   590→            effective_model_type = model_type\n   591→            if not effective_model_type:\n   592→                effective_model_type = \"pro\" if use_pro_model else \"lite\"\n   593→\n   594→            # Seedance 1.5 Pro：独立模型（有声），不支持参考图模式\n   595→            is_seedance_1_5 = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n   596→            if is_seedance_1_5 and reference_images:\n   597→                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n   598→\n   599→            # 1.5 Pro 暂不支持 1080p，提前降级避免走到 flags fallback\n   600→            if is_seedance_1_5 and (not resolution_grade or resolution_grade == \"1080p\"):\n   601→                resolution_grade = \"720p\"\n   602→            if is_seedance_1_5 and not ratio:\n   603→                ratio = \"adaptive\"\n   604→\n   605→            # Pro-fast 不支持首尾帧模式，如果用户选了 pro_fast 但又传了首尾帧，回退到 Pro\n   606→            has_first_last_frame = bool(first_frame_path and last_frame_path)\n   607→            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n   608→                logger.warning(\"Pro-fast 不支持首尾帧模式，自动切换到 Pro 模型\")\n   609→                effective_model_type = \"pro\"\n   610→\n   611→            if is_seedance_1_5:\n   612→                model = SeedanceModels.PRO_1_5.value\n   613→                mode = (\n   614→                    \"首尾帧视频(1.5 Pro)\"\n   615→                    if has_first_last_frame\n   616→                    else (\"图生视频(1.5 Pro)\" if image_path else \"文生视频(1.5 Pro)\")\n   617→                )\n   618→            else:\n   619→                # 模型选择逻辑\n   620→                if has_first_last_frame:\n   621→                    # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面被回退）\n   622→                    if effective_model_type in (\"pro\", \"pro_fast\"):\n   623→                        model = SeedanceModels.PRO.value\n   624→                        mode = \"首尾帧视频(Pro)\"\n   625→                    else:\n   626→                        model = SeedanceModels.LITE_I2V.value\n   627→                        mode = \"首尾帧视频(Lite)\"\n   628→                elif effective_model_type == \"pro_fast\":\n   629→                    # Pro-fast 模式（文生视频或首帧图生视频）\n   630→                    model = SeedanceModels.PRO_FAST.value\n   631→                    mode = \"图生视频(Pro-fast)\" if image_path else \"文生视频(Pro-fast)\"\n   632→                elif effective_model_type == \"pro\":\n   633→                    model = SeedanceModels.PRO.value\n   634→                    mode = \"图生视频(Pro)\" if image_path else \"文生视频(Pro)\"\n   635→                else:\n   636→                    # Lite 模式\n   637→                    if image_path or reference_images:\n   638→                        model = SeedanceModels.LITE_I2V.value\n   639→                        if reference_images and not image_path:\n   640→                            mode = f\"参考图视频(Lite, {len(reference_images)}张)\"\n   641→                        else:\n   642→                            mode = \"图生视频(Lite)\"\n   643→                    else:\n   644→                        model = SeedanceModels.LITE_T2V.value\n   645→                        mode = \"文生视频(Lite)\"\n   646→\n   647→            if first_frame_path and last_frame_path:\n   648→                content.append({\n   649→                    \"type\": \"image_url\",\n   650→                    \"image_url\": {\"url\": self._encode_image(first_frame_path)},\n   651→                    \"role\": \"first_frame\"\n   652→                })\n   653→                content.append({\n   654→                    \"type\": \"image_url\",\n   655→                    \"image_url\": {\"url\": self._encode_image(last_frame_path)},\n   656→                    \"role\": \"last_frame\"\n   657→                })\n   658→            elif image_path:\n   659→                content.append({\n   660→                    \"type\": \"image_url\",\n   661→                    \"image_url\": {\"url\": self._encode_image(image_path)},\n   662→                    \"role\": \"first_frame\"\n   663→                })\n   664→            if reference_images:\n   665→                for ref_img in reference_images:\n   666→                    ref_path = ref_img.get('path') if isinstance(ref_img, dict) else ref_img\n   667→                    if ref_path:\n   668→                        content.append({\n   669→                            \"type\": \"image_url\",\n   670→                            \"image_url\": {\"url\": self._encode_image(ref_path)},\n   671→                            \"role\": \"reference_image\"\n   672→                        })\n   673→                logger.info(f\"添加 {len(reference_images)} 张参考图到请求\")\n   674→\n   675→            # Lite 参考图模式（r2v）不支持 1080p，强制降级到 720p\n   676→            if reference_images and not image_path and effective_model_type == \"lite\":\n   677→                if resolution_grade == \"1080p\" or not resolution_grade:\n   678→                    resolution_grade = \"720p\"\n   679→                    logger.info(\"Lite 参考图模式不支持 1080p，已自动降级到 720p\")\n   680→\n   681→            # 文本命令\n   682→            # Force server-side watermark off for Plan B (local watermark only)\n   683→            flags_text, fallback_applied, fallback_reason, used_rs, used_rt = _validate_and_build_flags(\n   684→                resolution_grade=resolution_grade,\n   685→                ratio=ratio,\n   686→                duration=duration,\n   687→                fps=fps,\n   688→                watermark=False,\n   689→                camera_fixed=camera_fixed,\n   690→                seed=seed,\n   691→            )\n   692→            text_prompt = f\"{prompt} {flags_text}\".strip()\n   693→            if fallback_applied:\n   694→                logger.warning(f\"参数回退: {fallback_reason}\")\n   695→            logger.info(f\"安全版参数: {flags_text}\")\n   696→            content.append({\"type\": \"text\", \"text\": text_prompt})\n   697→            data = {\"model\": model, \"content\": content}\n   698→\n   699→        # 固定后端参数：service_tier=default, execution_expires_after=6h（21600s）\n   700→        # 不暴露 UI；用于服务端任务超时治理\n   701→        try:\n   702→            data.setdefault(\"service_tier\", \"default\")\n   703→            data.setdefault(\"execution_expires_after\", 21600)\n   704→        except Exception:\n   705→            pass\n   706→\n   707→        # Seedance 1.5 Pro：生成音频开关（默认 true）\n   708→        try:\n   709→            if is_seedance_1_5_variant or data.get(\"model\") == SeedanceModels.PRO_1_5.value:\n   710→                data[\"generate_audio\"] = bool(True if generate_audio is None else generate_audio)\n   711→        except Exception:\n   712→            pass\n   713→\n   714→        headers = self._get_headers()\n   715→        logger.info(f\"创建{mode}任务: {prompt[:50]}...\")\n   716→        logger.info(f\"使用模型: {model}\")\n   717→        logger.info(f\"参数: {used_rs or resolution_grade}+{used_rt or ratio}, dur={duration}s, fps={fps}\")\n   718→\n   719→        params_sent_summary = _summarize_payload_for_storage(\n   720→            data,\n   721→            resolution_grade=resolution_grade,\n   722→            ratio=ratio,\n   723→            duration=duration,\n   724→            fps=fps,\n   725→            seed=seed,\n   726→            camera_fixed=camera_fixed,\n   727→            used_rs=used_rs,\n   728→            used_rt=used_rt,\n   729→            mode=mode,\n   730→        )\n   731→\n   732→        start_time = time.time()\n   733→        success = False\n   734→        err_code: Optional[str] = None\n   735→        err_msg: Optional[str] = None\n   736→        try:\n   737→            logger.info(f\"发送请求到: {url}\")\n   738→            # 安全日志对象，避免 content 结构异常导致索引错误\n   739→            text_items = [item for item in data.get(\"content\", []) if item.get(\"type\") == \"text\"]\n   740→            text_len = 0\n   741→            if text_items:\n   742→                try:\n   743→                    text_len = len(text_items[0].get(\"text\", \"\"))\n   744→                except Exception:\n   745→                    text_len = 0\n   746→            safe_data = {\n   747→                \"model\": data.get(\"model\"),\n   748→                \"content_types\": [item.get(\"type\") for item in data.get(\"content\", [])],\n   749→                \"text_prompt_length\": text_len,\n   750→                \"image_count\": len([item for item in data.get(\"content\", []) if item.get(\"type\") == \"image_url\"]) \n   751→            }\n   752→            logger.info(f\"请求参数: {json.dumps(safe_data, indent=2, ensure_ascii=False)}\")\n   753→\n   754→            response = self._safe_json_post(url, headers, data, timeout=60)\n   755→            response_time = time.time() - start_time\n   756→            logger.info(f\"响应状态码: {response.status_code}, 响应时间: {response_time:.2f}s\")\n   757→\n   758→            result = self._handle_response(response, \"创建视频任务\")\n   759→            success = True\n   760→            task_id = result.get(\"id\")\n   761→            if task_id:\n   762→                self._active_tasks.add(task_id)\n   763→                logger.info(f\"{mode}任务创建成功，任务ID: {task_id}\")\n   764→                try:\n   765→                    params_sent_summary[\"api_task_id\"] = task_id\n   766→                except Exception:\n   767→                    pass\n   768→                result_obj = {\n   769→                    \"success\": True,\n   770→                    \"task_id\": task_id,\n   771→                    \"status\": result.get(\"status\", \"processing\"),\n   772→                    \"model\": model,\n   773→                    \"mode\": mode,\n   774→                    \"estimated_cost\": self._calculate_cost(model, duration),\n   775→                    \"created_at\": time.time(),\n   776→                    \"fallback_applied\": fallback_applied,\n   777→                    \"fallback_reason\": fallback_reason,\n   778→                    \"used_rs\": used_rs,\n   779→                    \"used_rt\": used_rt,\n   780→                    \"params_sent\": params_sent_summary,\n   781→                }\n   782→                # 安全摘要日志\n   783→                logger.info(\n   784→                    f\"摘要|operation=create_task status=success elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id}\"\n   785→                )\n   786→                return result_obj\n   787→            else:\n   788→                logger.error(f\"{mode}任务创建失败，未获取到任务ID\")\n   789→                return {\"success\": False, \"error\": \"未获取到任务ID\", \"response\": result}\n   790→\n   791→        except requests.exceptions.SSLError as e:\n   792→            logger.error(f\"{mode}任务创建失败 - SSL错误: {str(e)}\")\n   793→            logger.info(\"尝试使用备用SSL配置重新连接...\")\n   794→            try:\n   795→                backup_session = requests.Session()\n   796→                backup_session.verify = False\n   797→                import urllib3\n   798→                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   799→                # 手动编码避免 PyInstaller latin-1 问题\n   800→                body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   801→                response = backup_session.post(url, headers=headers, data=body, timeout=(30, 120))\n   802→                result = self._handle_response(response, \"创建视频任务(备用连接)\")\n   803→                success = True\n   804→                task_id = result.get(\"id\")\n   805→                if task_id:\n   806→                    self._active_tasks.add(task_id)\n   807→                    logger.info(f\"{mode}任务创建成功(备用连接)，任务ID: {task_id}\")\n   808→                    try:\n   809→                        params_sent_summary[\"api_task_id\"] = task_id\n   810→                    except Exception:\n   811→                        pass\n   812→                    result_obj = {\n   813→                        \"success\": True,\n   814→                        \"task_id\": task_id,\n   815→                        \"status\": result.get(\"status\", \"processing\"),\n   816→                        \"model\": model,\n   817→                        \"mode\": mode,\n   818→                        \"estimated_cost\": self._calculate_cost(model, duration),\n   819→                        \"created_at\": time.time(),\n   820→                        \"fallback_applied\": fallback_applied,\n   821→                        \"fallback_reason\": fallback_reason,\n   822→                        \"used_rs\": used_rs,\n   823→                        \"used_rt\": used_rt,\n   824→                        \"params_sent\": params_sent_summary,\n   825→                    }\n   826→                    logger.info(\n   827→                        f\"摘要|operation=create_task status=success elapsed={time.time() - start_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id} (backup)\"\n   828→                    )\n   829→                    return result_obj\n   830→                else:\n   831→                    raise Exception(\"备用连接也未获取到任务ID\")\n   832→            except Exception as backup_e:\n   833→                logger.error(f\"备用连接也失败: {str(backup_e)}\")\n   834→                err_code, err_msg = \"SSL_ERROR\", f\"SSL连接失败: {str(e)}; 备用: {str(backup_e)}\"\n   835→                raise Exception(f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}\")\n   836→        except requests.exceptions.ConnectionError as e:\n   837→            logger.error(f\"{mode}任务创建失败 - 连接错误: {str(e)}\")\n   838→            err_code, err_msg = \"NETWORK_ERROR\", str(e)\n   839→            raise Exception(f\"网络连接失败，请检查网络连接: {str(e)}\")\n   840→        except requests.exceptions.Timeout as e:\n   841→            logger.error(f\"{mode}任务创建失败 - 超时: {str(e)}\")\n   842→            err_code, err_msg = \"TIMEOUT_ERROR\", str(e)\n   843→            raise Exception(f\"请求超时，请稍后重试: {str(e)}\")\n   844→        except Exception as e:\n   845→            logger.error(f\"{mode}任务创建失败: {str(e)}\")\n   846→            err_code, err_msg = \"UNKNOWN_ERROR\", str(e)\n   847→            raise Exception(f\"视频生成任务创建失败: {str(e)}\")\n   848→        finally:\n   849→            response_time = time.time() - start_time\n   850→            # 失败时记录摘要\n   851→            if not success:\n   852→                logger.info(\n   853→                    f\"摘要|operation=create_task status=failed elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s error={err_code}\"\n   854→                )\n   855→            self._record_request_stats(\"创建视频任务\", success, response_time, err_code, err_msg)\n   856→\n   857→    \n   858→    def _calculate_cost(self, model: str, duration: int) -> float:\n   859→        \"\"\"计算预估成本\"\"\"\n   860→        base_cost = self.config.MODEL_PRICING.get(model, 15)\n   861→        # 简单的成本估算：基础价格 * 时长系数\n   862→        return base_cost * (duration / 5.0)  # 以5秒为基准\n   863→\n   864→    def query_video_task(self, task_id: str) -> Dict[str, Any]:\n   865→        \"\"\"查询视频生成任务状态\n   866→\n   867→        Args:\n   868→            task_id: 任务ID\n   869→\n   870→        Returns:\n   871→            任务状态信息\n   872→\n   873→        Raises:\n   874→            AppError: 当API调用失败时\n   875→        \"\"\"\n   876→        # 使用正确的查询API端点\n   877→        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n   878→        headers = self._get_headers()\n   879→\n   880→        logger.info(f\"查询视频任务状态: {task_id}\")\n   881→\n   882→        try:\n   883→            try:\n   884→                response = self.session.get(url, headers=headers, timeout=30)\n   885→            except requests.exceptions.SSLError as e:\n   886→                logger.error(f\"查询视频任务状态失败 - SSL错误: {str(e)}\")\n   887→                logger.info(\"尝试使用备用SSL配置重新查询任务状态...\")\n   888→                try:\n   889→                    backup_session = requests.Session()\n   890→                    backup_session.verify = False\n   891→                    import urllib3\n   892→                    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   893→                    response = backup_session.get(url, headers=headers, timeout=30)\n   894→                except Exception as backup_e:\n   895→                    logger.error(f\"备用SSL配置查询失败: {str(backup_e)}\")\n   896→                    raise Exception(\n   897→                        f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}; 备用: {str(backup_e)}\"\n   898→                    ) from e\n   899→\n   900→            result = self._handle_response(response, \"查询视频任务\")\n   901→\n   902→            # 根据官方API返回格式解析状态\n   903→            status = result.get(\"status\", \"unknown\")\n   904→            video_url = result.get(\"content\", {}).get(\"video_url\")\n   905→            \n   906→            logger.info(f\"任务 {task_id} 状态: {status}\")\n   907→            \n   908→            if status == \"succeeded\" and video_url:\n   909→                logger.info(f\"视频生成完成: {video_url}\")\n   910→\n   911→            # 获取缩略图URL\n   912→            thumbnail_url = result.get(\"content\", {}).get(\"thumbnail_url\") or result.get(\"thumbnail_url\")\n   913→            preview_url = result.get(\"content\", {}).get(\"preview_url\") or result.get(\"preview_url\")\n   914→\n   915→            # 解析关键“实际参数”（用于 params_actual 落盘）\n   916→            seed_value = result.get(\"seed\")\n   917→            ratio_value = result.get(\"ratio\")\n   918→            fps_value = result.get(\"framespersecond\")\n   919→            service_tier = result.get(\"service_tier\")\n   920→            execution_expires_after = result.get(\"execution_expires_after\")\n   921→            generate_audio = result.get(\"generate_audio\")\n   922→            \n   923→            result_obj = {\n   924→                \"success\": True,\n   925→                \"task_id\": task_id,\n   926→                \"status\": status,\n   927→                \"video_url\": video_url,\n   928→                \"thumbnail_url\": thumbnail_url,\n   929→                \"preview_url\": preview_url,\n   930→                \"model\": result.get(\"model\"),\n   931→                \"resolution\": result.get(\"resolution\"),\n   932→                \"ratio\": ratio_value,\n   933→                \"duration\": result.get(\"duration\"),\n   934→                \"fps\": fps_value,\n   935→                \"framespersecond\": fps_value,\n   936→                \"seed\": seed_value,\n   937→                \"service_tier\": service_tier,\n   938→                \"execution_expires_after\": execution_expires_after,\n   939→                \"generate_audio\": generate_audio,\n   940→                \"usage\": result.get(\"usage\"),\n   941→                \"created_at\": result.get(\"created_at\"),\n   942→                \"updated_at\": result.get(\"updated_at\")\n   943→            }\n   944→            # 安全摘要日志\n   945→            logger.info(\n   946→                f\"摘要|operation=query_task status={status} task_id={task_id} video_ready={'yes' if bool(video_url) else 'no'}\"\n   947→            )\n   948→            return result_obj\n   949→\n   950→        except Exception as e:\n   951→            logger.error(f\"查询视频任务状态失败: {str(e)}\")\n   952→            raise Exception(f\"查询任务状态失败: {str(e)}\")\n   953→\n   954→    def get_task_status(self, task_id: str) -> Dict[str, Any]:\n   955→        \"\"\"\n   956→        查询任务状态（兼容旧接口）\n   957→\n   958→        Args:\n   959→            task_id: 任务ID\n   960→\n   961→        Returns:\n   962→            Dict: 任务状态信息\n   963→        \"\"\"\n   964→        return self.query_video_task(task_id)\n   965→\n   966→    def wait_for_completion(self, task_id: str, max_wait_time: Optional[int] = None) -> Dict[str, Any]:\n   967→        \"\"\"\n   968→        等待任务完成（智能轮询）\n   969→\n   970→        Args:\n   971→            task_id: 任务ID\n   972→            max_wait_time: 最大等待时间（秒），默认使用配置值\n   973→\n   974→        Returns:\n   975→            Dict: 最终任务结果\n   976→        \"\"\"\n   977→        max_wait_time = max_wait_time or self.config.POLLING[\"max_wait_time\"]\n   978→        intervals = self.config.POLLING[\"intervals\"]\n   979→        \n   980→        logger.info(f\"开始智能轮询任务: {task_id}\")\n   981→        \n   982→        start_time = time.time()\n   983→        attempt = 0\n   984→\n   985→        while time.time() - start_time < max_wait_time:\n   986→            try:\n   987→                # 查询任务状态\n   988→                status_result = self.get_task_status(task_id)\n   989→\n   990→                if not status_result[\"success\"]:\n   991→                    return status_result\n   992→\n   993→                status = status_result[\"status\"]\n   994→                progress = status_result.get(\"progress\", 0)\n   995→\n   996→                logger.info(f\"任务 {task_id} 状态: {status}, 进度: {progress}%\")\n   997→\n   998→                # 检查是否为终态\n   999→                if TaskStatus.is_terminal(status):\n  1000→                    if status == TaskStatus.SUCCEEDED.value:\n  1001→                        logger.success(f\"任务完成: {task_id}\")\n  1002→                    elif status == TaskStatus.FAILED.value:\n  1003→                        logger.error(f\"任务失败: {task_id}\")\n  1004→                    elif status == TaskStatus.CANCELLED.value:\n  1005→                        logger.warning(f\"任务被取消: {task_id}\")\n  1006→                    \n  1007→                    # 从活跃任务中移除\n  1008→                    self._active_tasks.discard(task_id)\n  1009→                    return status_result\n  1010→\n  1011→                # 动态调整轮询间隔\n  1012→                interval = intervals[min(attempt, len(intervals) - 1)]\n  1013→                logger.debug(f\"等待 {interval} 秒后继续轮询\")\n  1014→                time.sleep(interval)\n  1015→                attempt += 1\n  1016→                \n  1017→            except Exception as e:\n  1018→                logger.error(f\"轮询异常: {e}\")\n  1019→                time.sleep(5)  # 异常时等待5秒\n  1020→\n  1021→        # 超时处理\n  1022→        logger.error(f\"轮询超时: {task_id}\")\n  1023→        self._active_tasks.discard(task_id)\n  1024→        return {\n  1025→            \"success\": False, \n  1026→            \"error\": \"等待任务完成超时\", \n  1027→            \"error_code\": \"TIMEOUT_ERROR\", \n  1028→            \"task_id\": task_id,\n  1029→            \"elapsed_time\": time.time() - start_time\n  1030→        }\n  1031→\n  1032→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n  1033→        \"\"\"\n  1034→        取消视频生成任务（仅在queued状态有效）\n  1035→\n  1036→        Args:\n  1037→            task_id: 任务ID\n  1038→\n  1039→        Returns:\n  1040→            成功: {\"success\": True, \"status\": \"cancelled\"}\n  1041→            失败: {\"success\": False, \"error\": \"错误信息\"}\n  1042→        \"\"\"\n  1043→        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n  1044→        headers = {\n  1045→            \"Content-Type\": \"application/json\",\n  1046→            \"Authorization\": f\"Bearer {self.api_key}\"\n  1047→        }\n  1048→\n  1049→        try:\n  1050→            response = requests.delete(url, headers=headers, timeout=10)\n  1051→\n  1052→            if response.status_code == 200:\n  1053→                # DELETE请求成功，等待0.5秒后查询实际状态\n  1054→                time.sleep(0.5)\n  1055→\n  1056→                # 查询任务状态以确认是否真的变成cancelled\n  1057→                try:\n  1058→                    status_result = self.query_video_task(task_id)\n  1059→                    current_status = status_result.get(\"status\", \"unknown\")\n  1060→\n  1061→                    if current_status == \"cancelled\":\n  1062→                        # 真正成功取消\n  1063→                        self._active_tasks.discard(task_id)\n  1064→                        logger.info(f\"任务已成功取消: {task_id}，状态已变更为 cancelled\")\n  1065→                        return {\"success\": True, \"status\": \"cancelled\"}\n  1066→                    else:\n  1067→                        # DELETE成功但状态不是cancelled（任务可能已在执行中）\n  1068→                        logger.warning(f\"DELETE请求成功，但任务状态为 {current_status}（任务可能已在执行中，无法取消）\")\n  1069→                        return {\"success\": False, \"status\": current_status, \"error\": f\"任务状态为 {current_status}，无法取消\"}\n  1070→                except Exception as query_e:\n  1071→                    # 状态查询失败，但DELETE请求成功\n  1072→                    logger.warning(f\"DELETE请求成功，但状态查询失败: {query_e}\")\n  1073→                    self._active_tasks.discard(task_id)\n  1074→                    return {\"success\": True, \"status\": \"cancelled\", \"warning\": \"状态确认失败\"}\n  1075→\n  1076→            if response.status_code == 400:\n  1077→                error_msg = response.json().get(\"error\", {}).get(\"message\", \"任务无法取消（可能已在执行中）\")\n  1078→                logger.warning(f\"取消任务失败: {task_id} - {error_msg}\")\n  1079→                return {\"success\": False, \"error\": error_msg}\n  1080→\n  1081→            error_msg = f\"HTTP {response.status_code}: {response.text}\"\n  1082→            logger.error(f\"取消任务请求失败: {error_msg}\")\n  1083→            return {\"success\": False, \"error\": error_msg}\n  1084→\n  1085→        except Exception as e:  # pylint: disable=broad-except\n  1086→            logger.error(f\"取消任务异常: {task_id} - {e}\")\n  1087→            return {\"success\": False, \"error\": str(e)}\n  1088→\n  1089→    def list_tasks(self, limit: int = 20, offset: int = 0, status_filter: Optional[str] = None) -> Dict[str, Any]:\n  1090→        \"\"\"\n  1091→        获取任务列表（改进版）\n  1092→\n  1093→        Args:\n  1094→            limit: 返回数量限制\n  1095→            offset: 偏移量\n  1096→            status_filter: 状态过滤器\n  1097→\n  1098→        Returns:\n  1099→            Dict: 任务列表\n  1100→        \"\"\"\n  1101→        url = f\"{self.base_url}{self.config.ENDPOINTS['list_tasks']}\"\n  1102→        headers = self._get_headers()\n  1103→        \n  1104→        params = {\n  1105→            \"limit\": limit,\n  1106→            \"offset\": offset\n  1107→        }\n  1108→        \n  1109→        if status_filter:\n  1110→            params[\"status\"] = status_filter\n  1111→        \n  1112→        logger.info(f\"获取任务列表: limit={limit}, offset={offset}, status_filter={status_filter}\")\n  1113→        \n  1114→        # 记录开始时间\n  1115→        start_time = time.time()\n  1116→        success = False\n  1117→\n  1118→        try:\n  1119→            response = self.session.get(url, headers=headers, params=params, timeout=30)\n  1120→            result = self._handle_response(response, \"获取任务列表\")\n  1121→            \n  1122→            tasks = result.get(\"data\", [])\n  1123→            total = result.get(\"total\", len(tasks))\n  1124→            \n  1125→            logger.success(f\"获取任务列表成功，共{len(tasks)}个任务\")\n  1126→            success = True\n  1127→            \n  1128→            return {\n  1129→                \"success\": True,\n  1130→                \"tasks\": tasks,\n  1131→                \"total\": total,\n  1132→                \"limit\": limit,\n  1133→                \"offset\": offset,\n  1134→                \"has_more\": offset + len(tasks) < total\n  1135→            }\n  1136→            \n  1137→        except Exception as e:\n  1138→            logger.error(f\"获取任务列表失败: {e}\")\n  1139→            return {\n  1140→                 \"success\": False,\n  1141→                 \"error\": str(e)\n  1142→             }\n  1143→        finally:\n  1144→            # 记录性能统计\n  1145→            response_time = time.time() - start_time\n  1146→            self._record_request_stats(\"获取任务列表\", success, response_time)\n  1147→    \n  1148→    def batch_query_tasks(self, task_ids: List[str]) -> Dict[str, Any]:\n  1149→        \"\"\"\n  1150→        批量查询任务状态\n  1151→        \n  1152→        Args:\n  1153→            task_ids: 任务ID列表\n  1154→        \n  1155→        Returns:\n  1156→            批量查询结果\n  1157→        \"\"\"\n  1158→        results = {}\n  1159→        success_count = 0\n  1160→        \n  1161→        logger.info(f\"批量查询{len(task_ids)}个任务\")\n  1162→        \n  1163→        for task_id in task_ids:\n  1164→            try:\n  1165→                result = self.query_video_task(task_id)\n  1166→                if result.get(\"success\", True):  # 兼容不同的返回格式\n  1167→                    success_count += 1\n  1168→                results[task_id] = result\n  1169→            except Exception as e:\n  1170→                results[task_id] = {\n  1171→                    \"success\": False,\n  1172→                    \"error\": str(e)\n  1173→                }\n  1174→        \n  1175→        return {\n  1176→            \"success\": True,\n  1177→            \"results\": results,\n  1178→            \"total\": len(task_ids),\n  1179→            \"success_count\": success_count,\n  1180→            \"failed_count\": len(task_ids) - success_count\n  1181→        }\n  1182→    \n  1183→    def cancel_all_active_tasks(self) -> Dict[str, Any]:\n  1184→        \"\"\"\n  1185→        取消所有活跃任务\n  1186→        \n  1187→        Returns:\n  1188→            取消结果统计\n  1189→        \"\"\"\n  1190→        active_tasks = list(self._active_tasks)\n  1191→        \n  1192→        if not active_tasks:\n  1193→            return {\n  1194→                \"success\": True,\n  1195→                \"message\": \"没有活跃任务需要取消\",\n  1196→                \"cancelled\": 0\n  1197→            }\n  1198→        \n  1199→        cancelled_count = 0\n  1200→        failed_count = 0\n  1201→        \n  1202→        logger.info(f\"取消{len(active_tasks)}个活跃任务\")\n  1203→        \n  1204→        for task_id in active_tasks:\n  1205→            result = self.cancel_task(task_id)\n  1206→            if result.get(\"success\"):\n  1207→                cancelled_count += 1\n  1208→            else:\n  1209→                failed_count += 1\n  1210→        \n  1211→        return {\n  1212→            \"success\": True,\n  1213→            \"cancelled\": cancelled_count,\n  1214→            \"failed\": failed_count,\n  1215→            \"total_active\": len(active_tasks)\n  1216→        }\n  1217→    \n  1218→    def get_task_statistics(self) -> Dict[str, Any]:\n  1219→        \"\"\"\n  1220→        获取任务统计信息\n  1221→        \n  1222→        Returns:\n  1223→            统计信息\n  1224→        \"\"\"\n  1225→        try:\n  1226→            # 获取最近的任务列表\n  1227→            tasks_result = self.list_tasks(limit=100)\n  1228→            \n  1229→            if not tasks_result.get(\"success\"):\n  1230→                return tasks_result\n  1231→            \n  1232→            tasks = tasks_result.get(\"tasks\", [])\n  1233→            \n  1234→            # 统计各状态任务数量\n  1235→            status_counts = {}\n  1236→            total_cost = 0\n  1237→            \n  1238→            for task in tasks:\n  1239→                status = task.get(\"status\", \"unknown\")\n  1240→                status_counts[status] = status_counts.get(status, 0) + 1\n  1241→                \n  1242→                # 估算成本\n  1243→                model = task.get(\"model\", \"\")\n  1244→                if model in self.config.MODEL_PRICING:\n  1245→                    total_cost += self.config.MODEL_PRICING[model]\n  1246→            \n  1247→            return {\n  1248→                \"success\": True,\n  1249→                \"total_tasks\": len(tasks),\n  1250→                \"active_tasks\": len(self._active_tasks),\n  1251→                \"status_counts\": status_counts,\n  1252→                \"estimated_total_cost\": total_cost,\n  1253→                \"timestamp\": time.time()\n  1254→            }\n  1255→            \n  1256→        except Exception as e:\n  1257→            logger.error(f\"获取统计信息失败: {e}\")\n  1258→            return {\n  1259→                \"success\": False,\n  1260→                \"error\": str(e)\n  1261→            }\n  1262→\n  1263→    def _prepare_image(self, image_path: str) -> str:\n  1264→        \"\"\"准备图片数据，返回data URL格式\"\"\"\n  1265→        try:\n  1266→            # 使用新的图片格式验证器\n  1267→            from utils.image_format_validator import validate_and_prepare_image\n  1268→            \n  1269→            result = validate_and_prepare_image(image_path, auto_convert=True)\n  1270→            \n  1271→            if result['success']:\n  1272→                if result['is_converted']:\n  1273→                    logger.info(f\"图片已自动转换: {result['original_format']} -> {result['final_format']}\")\n  1274→                return result['data_url']\n  1275→            else:\n  1276→                raise Exception(result['error'])\n  1277→                \n  1278→        except Exception as e:\n  1279→            logger.error(f\"图片处理失败: {str(e)}\")\n  1280→            raise Exception(f\"图片处理失败: {str(e)}\")\n  1281→\n  1282→    def _encode_image(self, image_path: str) -> str:\n  1283→        \"\"\"将图像文件编码为data URL格式\n  1284→        集成图片格式验证和自动转换功能\n  1285→        \n  1286→        Args:\n  1287→            image_path: 图像文件路径\n  1288→            \n  1289→        Returns:\n  1290→            data URL格式的图像字符串\n  1291→            \n  1292→        Raises:\n  1293→            AppError: 当图像文件不存在或编码失败时\n  1294→        \"\"\"\n  1295→        try:\n  1296→            image_path = Path(image_path)\n  1297→            if not image_path.exists():\n  1298→                raise AppError(f\"图像文件不存在: {image_path}\", ErrorType.FILE_ERROR)\n  1299→            \n  1300→            # 使用图片格式验证器处理\n  1301→            from utils.image_format_validator import validate_and_prepare_image\n  1302→            \n  1303→            result = validate_and_prepare_image(str(image_path), auto_convert=True)\n  1304→            \n  1305→            if result['success']:\n  1306→                if result['is_converted']:\n  1307→                    logger.info(f\"图片格式已自动转换: {result['original_format']} -> {result['final_format']}\")\n  1308→                return result['data_url']\n  1309→            else:\n  1310→                logger.error(f\"图片处理失败: {result['error']}\")\n  1311→                raise AppError(f\"图片处理失败: {result['error']}\", ErrorType.FILE_ERROR)\n  1312→                \n  1313→        except AppError:\n  1314→            raise\n  1315→        except Exception as e:\n  1316→            # 避免在日志中显示可能包含base64数据的异常信息\n  1317→            error_msg = str(e)\n  1318→            if len(error_msg) > 200:\n  1319→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n  1320→            logger.error(f\"图像编码失败: {error_msg}\")\n  1321→            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n  1322→\n  1323→    def _get_mime_type(self, extension: str) -> str:\n  1324→        \"\"\"\n  1325→        根据文件扩展名获取MIME类型\n  1326→\n  1327→        Args:\n  1328→            extension: 文件扩展名\n  1329→\n  1330→        Returns:\n  1331→            str: MIME类型\n  1332→        \"\"\"\n  1333→        mime_types = {\".jpg\": \"image/jpeg\", \".jpeg\": \"image/jpeg\", \".png\": \"image/png\", \".webp\": \"image/webp\"}\n  1334→        return mime_types.get(extension, \"image/jpeg\")\n  1335→\n  1336→    def _make_request(\n  1337→        self,\n  1338→        endpoint: str,\n  1339→        data: Optional[Dict[str, Any]] = None,\n  1340→        params: Optional[Dict[str, Any]] = None,\n  1341→        method: str = \"POST\",\n  1342→    ) -> Dict[str, Any]:\n  1343→        \"\"\"\n  1344→        发送HTTP请求\n  1345→\n  1346→        Args:\n  1347→            endpoint: API端点\n  1348→            data: 请求数据\n  1349→            params: 查询参数\n  1350→            method: HTTP方法\n  1351→\n  1352→        Returns:\n  1353→            Dict: 响应结果\n  1354→        \"\"\"\n  1355→        url = f\"{self.base_url}{endpoint}\"\n  1356→\n  1357→        headers = {\"Authorization\": f\"Bearer {self.api_key}\", \"Content-Type\": \"application/json\"}\n  1358→\n  1359→        for attempt in range(self.max_retries):\n  1360→            try:\n  1361→                if method.upper() == \"GET\":\n  1362→                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)\n  1363→                else:\n  1364→                    response = requests.post(url, headers=headers, json=data, params=params, timeout=self.timeout)\n  1365→\n  1366→                response.raise_for_status()\n  1367→\n  1368→                # 解析响应（增强容错：包括编码问题回退）\n  1369→                try:\n  1370→                    result = response.json()\n  1371→                except (json.JSONDecodeError, UnicodeDecodeError) as e:\n  1372→                    raw = response.content or b\"\"\n  1373→                    tried = set()\n  1374→                    result = None\n  1375→                    for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n  1376→                        if not enc or enc in tried:\n  1377→                            continue\n  1378→                        tried.add(enc)\n  1379→                        try:\n  1380→                            text = raw.decode(enc, errors=\"strict\")\n  1381→                            result = json.loads(text)\n  1382→                            logger.debug(f\"_make_request - 通过备用编码解析成功: {enc}\")\n  1383→                            break\n  1384→                        except Exception:\n  1385→                            continue\n  1386→                    if result is None:\n  1387→                        try:\n  1388→                            preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n  1389→                        except Exception:\n  1390→                            preview = str(raw[:200])\n  1391→                        logger.error(f\"_make_request - JSON解析失败(编码问题): {preview}\")\n  1392→                        raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n  1393→\n  1394→                return {\"success\": True, \"data\": result}\n  1395→\n  1396→            except requests.exceptions.Timeout:\n  1397→                logger.warning(f\"请求超时，第{attempt + 1}次重试\")\n  1398→                if attempt < self.max_retries - 1:\n  1399→                    time.sleep(self.retry_delay)\n  1400→                    continue\n  1401→                else:\n  1402→                    return {\"success\": False, \"error\": \"请求超时\", \"error_code\": \"TIMEOUT_ERROR\"}\n  1403→\n  1404→            except requests.exceptions.HTTPError as e:\n  1405→                if response.status_code == 429:\n  1406→                    logger.warning(f\"API配额限制，第{attempt + 1}次重试\")\n  1407→                    if attempt < self.max_retries - 1:\n  1408→                        time.sleep(self.retry_delay * 2)  # 配额限制时等待更长时间\n  1409→                        continue\n  1410→                    else:\n  1411→                        return {\"success\": False, \"error\": \"API配额已用完\", \"error_code\": \"QUOTA_EXCEEDED\"}\n  1412→                else:\n  1413→                    try:\n  1414→                        # 安全解析错误响应\n  1415→                        try:\n  1416→                            error_data = response.json()\n  1417→                        except (json.JSONDecodeError, UnicodeDecodeError):\n  1418→                            # 编码问题时使用安全解码\n  1419→                            try:\n  1420→                                safe_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n  1421→                                error_data = json.loads(safe_text)\n  1422→                            except Exception:\n  1423→                                error_data = {\"error\": {\"message\": \"响应解析失败\"}}\n  1424→                        error_message = error_data.get(\"error\", {}).get(\"message\", str(e))\n  1425→                    except:\n  1426→                        error_message = str(e)\n  1427→\n  1428→                    return {\n  1429→                        \"success\": False,\n  1430→                        \"error\": error_message,\n  1431→                        \"error_code\": \"API_ERROR\",\n  1432→                        \"status_code\": response.status_code,\n  1433→                    }\n  1434→\n  1435→            except requests.exceptions.RequestException as e:\n  1436→                logger.warning(f\"网络错误，第{attempt + 1}次重试: {e}\")\n  1437→                if attempt < self.max_retries - 1:\n  1438→                    time.sleep(self.retry_delay)\n  1439→                    continue\n  1440→                else:\n  1441→                    return {\"success\": False, \"error\": f\"网络连接错误: {e}\", \"error_code\": \"NETWORK_ERROR\"}\n  1442→\n  1443→            except Exception as e:\n  1444→                logger.error(f\"未知错误: {e}\")\n  1445→                return {\"success\": False, \"error\": str(e), \"error_code\": \"UNKNOWN_ERROR\"}\n  1446→\n  1447→        return {\"success\": False, \"error\": \"达到最大重试次数\", \"error_code\": \"MAX_RETRIES_EXCEEDED\"}\n  1448→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a2ea6149-236a-42fa-9230-a4123d34eb97","timestamp":"2026-01-05T11:51:04.691Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py","content":"# Seedance视频生成客户端\n# 封装火山引擎Seedance1.0pro的API调用\n\nimport os\nimport time\nimport json\nimport base64\nimport requests\nimport logging\nimport asyncio\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom pathlib import Path\nfrom loguru import logger\n# volcenginesdkarkruntime import removed - not used in current implementation\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\n# 导入配置管理器和错误处理\nfrom config.unified_config import get_unified_config\nfrom utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\nfrom .config import SeedanceModels, TaskStatus, SeedanceConfig\n\n\"\"\"\n常量与辅助方法（视频参数 P0b）\n- 仅保留“分辨率档位 + 比例”的新路径；不再支持旧 width/height → --rs 映射\n\"\"\"\n\n# 白名单常量\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n\ndef _summarize_payload_for_storage(\n    data: Dict[str, Any],\n    *,\n    resolution_grade: Optional[str],\n    ratio: Optional[str],\n    duration: int,\n    fps: int,\n    seed: Optional[int],\n    camera_fixed: bool,\n    used_rs: str,\n    used_rt: str,\n    mode: str,\n) -> Dict[str, Any]:\n    \"\"\"\n    生成可落盘的 params_sent（避免保存 base64 / 大字段）。\n\n    注意：\n    - 仅存储与“参数一致性/复用/恢复”相关信息，不落 content.image_url.url 等内容。\n    \"\"\"\n    try:\n        content = data.get(\"content\") or []\n        image_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"image_url\"]\n        text_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"text\"]\n        text_len = 0\n        if text_items:\n            try:\n                text_len = len(str(text_items[0].get(\"text\") or \"\"))\n            except Exception:\n                text_len = 0\n\n        roles = []\n        for item in image_items:\n            role = item.get(\"role\")\n            if role:\n                roles.append(str(role))\n\n        resolved_rs = used_rs or (resolution_grade or \"\")\n        resolved_rt = used_rt or (ratio or \"\")\n        return {\n            \"model\": data.get(\"model\"),\n            \"mode\": mode,\n            \"service_tier\": data.get(\"service_tier\"),\n            \"execution_expires_after\": data.get(\"execution_expires_after\"),\n            \"generate_audio\": data.get(\"generate_audio\"),\n            \"resolution\": resolved_rs,\n            \"ratio\": resolved_rt,\n            \"duration\": int(duration),\n            \"framespersecond\": int(fps),\n            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n            \"camera_fixed\": bool(camera_fixed),\n            # 服务端 watermark 已强制关闭（仅本地水印）\n            \"watermark\": bool(data.get(\"watermark\", False)) if isinstance(data, dict) else False,\n            \"content_summary\": {\n                \"image_count\": len(image_items),\n                \"image_roles\": roles,\n                \"text_prompt_length\": text_len,\n            },\n        }\n    except Exception:\n        # 兜底：永远不让 params_sent 影响主流程\n        return {\n            \"model\": data.get(\"model\") if isinstance(data, dict) else None,\n            \"mode\": mode,\n            \"resolution\": used_rs or resolution_grade,\n            \"ratio\": used_rt or ratio,\n            \"duration\": int(duration),\n            \"framespersecond\": int(fps),\n            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n        }\n\ndef _validate_and_build_flags(\n    resolution_grade: Optional[str],\n    ratio: Optional[str],\n    duration: int,\n    fps: int,\n    watermark: bool,\n    camera_fixed: bool,\n    seed: Optional[int],\n) -> Tuple[str, bool, str, str, str]:\n    \"\"\"生成安全版文本命令片段；返回 (flags_text, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n    used_rs = resolution_grade or \"\"\n    used_rt = ratio or \"\"\n    fallback_applied = False\n    fallback_reasons: List[str] = []\n\n    # 校验白名单\n    if not used_rs or used_rs not in RES_GRADES:\n        fallback_applied = True\n        fallback_reasons.append(f\"无效分辨率: {used_rs or '缺失'}\")\n        used_rs = \"1080p\"\n    if not used_rt or used_rt not in RATIOS:\n        fallback_applied = True\n        fallback_reasons.append(f\"无效比例: {used_rt or '缺失'}\")\n        used_rt = \"16:9\"\n\n    # 组装顺序: --rs --rt --dur --fps --wm --seed --cf\n    parts: List[str] = []\n    parts += [\"--rs\", used_rs, \"--rt\", used_rt, \"--dur\", str(int(duration)), \"--fps\", str(int(fps))]\n    parts += [\"--wm\", str(bool(watermark)).lower()]\n    if seed is not None and seed != -1:\n        try:\n            parts += [\"--seed\", str(int(seed))]\n        except Exception:\n            # 种子解析异常时忽略，不触发全局fallback\n            logger.warning(\"种子参数无效，已忽略 --seed\")\n    parts += [\"--cf\", str(bool(camera_fixed)).lower()]\n\n    flags_text = \" \".join(parts)\n    fallback_reason = \", \".join(fallback_reasons) if fallback_applied else \"\"\n    return flags_text, fallback_applied, fallback_reason, used_rs, used_rt\n\n\nclass SeedanceClient:\n    \"\"\"火山引擎Seedance视频生成客户端\n\n    提供文生视频、图生视频和首尾帧视频生成功能\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n        timeout: int = 60,\n        max_retries: int = 3,\n    ):\n        \"\"\"初始化Seedance客户端\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n            base_url: API基础URL\n            timeout: 请求超时时间（秒）\n            max_retries: 最大重试次数\n        \"\"\"\n        # 获取API密钥\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n\n        self.api_key = api_key\n        self.base_url = base_url.rstrip(\"/\")\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self.retry_delay = 2\n        self.config = SeedanceConfig()\n        self._active_tasks = set()  # 跟踪活跃任务\n\n        # 配置会话\n        self.session = requests.Session()\n        \n        # 配置SSL和连接参数\n        import ssl\n        from requests.adapters import HTTPAdapter\n        from urllib3.util.retry import Retry\n        from urllib3.util.ssl_ import create_urllib3_context\n        \n        # 创建自定义SSL上下文\n        ssl_context = create_urllib3_context()\n        ssl_context.check_hostname = False\n        ssl_context.verify_mode = ssl.CERT_NONE\n        ssl_context.set_ciphers('DEFAULT@SECLEVEL=1')\n        \n        # 配置更强的重试策略\n        retry_strategy = Retry(\n            total=max_retries * 2,  # 增加重试次数\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n            backoff_factor=2,  # 增加退避因子\n            raise_on_status=False\n        )\n        \n        # 创建自定义适配器\n        class SSLAdapter(HTTPAdapter):\n            def init_poolmanager(self, *args, **kwargs):\n                kwargs['ssl_context'] = ssl_context\n                kwargs['socket_options'] = [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]\n                return super().init_poolmanager(*args, **kwargs)\n        \n        import socket\n        adapter = SSLAdapter(\n            max_retries=retry_strategy,\n            pool_connections=10,\n            pool_maxsize=20,\n            pool_block=False\n        )\n        \n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        # 设置会话级别的超时和连接参数\n        self.session.timeout = (30, 120)  # (连接超时, 读取超时)\n        self.session.verify = False  # 直接禁用SSL验证，避免证书问题\n\n        # 禁用SSL警告\n        import urllib3\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n        self.session.headers.update({\n            'Connection': 'keep-alive',\n            'Keep-Alive': 'timeout=30, max=100'\n        })\n\n        # 初始化性能监控\n        self._performance_stats = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"total_response_time\": 0,\n            \"last_request_time\": None\n        }\n        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n        \n        logger.info(\"Seedance客户端初始化完成\")\n        logger.info(f\"使用配置: 基础URL={self.base_url}, 超时={timeout}秒, 最大重试={max_retries}次\")\n\n    def _provider_enabled(self) -> bool:\n        try:\n            import os\n            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n            return v not in {\"0\", \"false\", \"no\"}\n        except Exception:\n            return True\n\n    def _get_headers(self) -> Dict[str, str]:\n        \"\"\"获取请求头\"\"\"\n        api_key = str(self.api_key).strip()\n\n        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n        try:\n            api_key.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n\n        return {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"User-Agent\": \"Seedance-Client/1.0.0\",\n        }\n\n    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout=60):\n        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n\n    def _handle_response(self, response: requests.Response, operation: str = \"API调用\") -> Dict[str, Any]:\n        \"\"\"处理API响应\n\n        Args:\n            response: HTTP响应对象\n            operation: 操作描述，用于日志记录\n\n        Returns:\n            解析后的响应数据\n\n        Raises:\n            Exception: 当API返回错误时\n        \"\"\"\n        try:\n            # 记录响应基本信息\n            logger.info(f\"{operation} - 响应状态码: {response.status_code}\")\n            \n            # 处理HTTP错误状态码\n            if not response.ok:\n                error_details = {\n                    \"status_code\": response.status_code,\n                    \"url\": response.url,\n                    \"headers\": dict(response.headers),\n                    \"operation\": operation\n                }\n                \n                try:\n                    error_body = response.json()\n                    error_details[\"response_body\"] = error_body\n                except Exception:\n                    try:\n                        error_details[\"response_text\"] = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        error_details[\"response_text\"] = str(response.content[:500])\n                \n                # 根据状态码分类错误\n                if response.status_code == 400:\n                    logger.error(f\"{operation} - 请求参数错误: {error_details}\")\n                    try:\n                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        preview = str(response.content[:500])\n                    raise Exception(f\"请求参数错误: {preview}\")\n                elif response.status_code == 401:\n                    logger.error(f\"{operation} - 认证失败: API密钥无效\")\n                    raise Exception(\"认证失败: 请检查API密钥是否正确\")\n                elif response.status_code == 403:\n                    logger.error(f\"{operation} - 权限不足: {error_details}\")\n                    raise Exception(\"权限不足: 请检查API密钥权限\")\n                elif response.status_code == 404:\n                    logger.error(f\"{operation} - 资源不存在: {error_details}\")\n                    raise Exception(\"资源不存在: 请检查API端点或任务ID\")\n                elif response.status_code == 429:\n                    logger.error(f\"{operation} - 请求频率限制: {error_details}\")\n                    raise Exception(\"请求频率过高: 请稍后重试\")\n                elif response.status_code >= 500:\n                    logger.error(f\"{operation} - 服务器错误: {error_details}\")\n                    raise Exception(f\"服务器错误: {response.status_code}\")\n                else:\n                    logger.error(f\"{operation} - HTTP错误: {error_details}\")\n                    try:\n                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        preview = str(response.content[:500])\n                    raise Exception(f\"HTTP错误: {response.status_code} - {preview}\")\n\n            # 解析JSON响应（增强容错：包括编码问题回退）\n            try:\n                result = response.json()\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                raw = response.content or b\"\"\n                tried = set()\n                result = None\n                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                    if not enc or enc in tried:\n                        continue\n                    tried.add(enc)\n                    try:\n                        text = raw.decode(enc, errors=\"strict\")\n                        result = json.loads(text)\n                        logger.debug(f\"{operation} - 通过备用编码解析成功: {enc}\")\n                        break\n                    except Exception:\n                        continue\n                if result is None:\n                    # 最后尝试宽松日志预览，抛出统一错误\n                    try:\n                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                    except Exception:\n                        preview = str(raw[:200])\n                    logger.error(f\"{operation} - JSON解析失败(编码问题): {preview}\")\n                    raise Exception(f\"响���格式错误: 无法解析JSON - {str(e)}\")\n\n            # 检查业务错误\n            if \"error\" in result:\n                error_info = result[\"error\"]\n                error_msg = error_info.get(\"message\", \"未知错误\")\n                error_code = error_info.get(\"code\", \"UNKNOWN_ERROR\")\n                \n                logger.error(f\"{operation} - API业务错误: {error_msg} (代码: {error_code})\")\n                logger.error(f\"完整错误信息: {result}\")\n                \n                # 根据错误代码提供更友好的错误信息\n                friendly_msg = self._get_friendly_error_message(error_code, error_msg)\n                raise Exception(f\"API业务错误: {friendly_msg}\")\n\n            # 记录成功响应的关键信息\n            if \"id\" in result:\n                logger.info(f\"{operation} - 成功，任务ID: {result['id']}\")\n            elif \"status\" in result:\n                logger.info(f\"{operation} - 成功，状态: {result['status']}\")\n            else:\n                logger.info(f\"{operation} - 成功\")\n\n            return result\n\n        except requests.exceptions.Timeout as e:\n            logger.error(f\"{operation} - 请求超时: {str(e)}\")\n            raise Exception(f\"请求超时: 请检查网络连接或稍后重试\")\n        except requests.exceptions.ConnectionError as e:\n            logger.error(f\"{operation} - 连接错误: {str(e)}\")\n            raise Exception(f\"网络连接错误: 请检查网络连接\")\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"{operation} - 网络请求错误: {str(e)}\")\n            raise Exception(f\"网络请求失败: {str(e)}\")\n        except Exception as e:\n            if \"API业务错误\" in str(e) or \"请求参数错误\" in str(e) or \"认证失败\" in str(e):\n                # 重新抛出已处理的业务错误\n                raise\n            else:\n                logger.error(f\"{operation} - 未知错误: {str(e)}\")\n                raise Exception(f\"处理响应时发生未知错误: {str(e)}\")\n    \n    def _get_friendly_error_message(self, error_code: str, error_msg: str) -> str:\n        \"\"\"获取友好的错误信息\n        \n        Args:\n            error_code: 错误代码\n            error_msg: 原始错误信息\n            \n        Returns:\n            友好的错误信息\n        \"\"\"\n        error_mapping = {\n            \"INVALID_PARAMETER\": \"参数无效，请检查输入参数\",\n            \"INSUFFICIENT_QUOTA\": \"配额不足，请检查账户余额\",\n            \"MODEL_NOT_FOUND\": \"模型不存在，请检查模型名称\",\n            \"TASK_NOT_FOUND\": \"任务不存在，请检查任务ID\",\n            \"TASK_ALREADY_CANCELLED\": \"任务已被取消\",\n            \"TASK_ALREADY_COMPLETED\": \"任务已完成，无法取消\",\n            \"RATE_LIMIT_EXCEEDED\": \"请求频率过高，请稍后重试\",\n            \"INTERNAL_ERROR\": \"服务内部错误，请稍后重试\",\n            \"UNAUTHORIZED\": \"未授权访问，请检查API密钥\",\n            \"FORBIDDEN\": \"禁止访问，请检查权限设置\"\n        }\n        \n        return error_mapping.get(error_code, f\"{error_msg} (错误代码: {error_code})\")\n    \n    def _record_request_stats(\n        self,\n        operation: str,\n        success: bool,\n        response_time: float,\n        error_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n    ):\n        \"\"\"记录请求统计信息（统一结构 + 最近错误）。\"\"\"\n        try:\n            self._performance_stats[\"total_requests\"] += 1\n            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n            self._performance_stats[\"last_request_time\"] = time.time()\n            \n            if success:\n                self._performance_stats[\"successful_requests\"] += 1\n            else:\n                self._performance_stats[\"failed_requests\"] += 1\n                if error_code or error_message:\n                    self._last_error = {\"code\": error_code, \"message\": (str(error_message)[:200] if error_message else None)}\n            \n            # 记录性能日志（安全摘要）\n            total = max(1, self._performance_stats[\"total_requests\"])\n            avg = self._performance_stats[\"total_response_time\"] / total\n            success_rate = (self._performance_stats[\"successful_requests\"] / total) * 100\n            logger.debug(f\"{operation} - 响应时间: {response_time:.2f}s, 平均: {avg:.2f}s, 成功率: {success_rate:.1f}%\")\n        except Exception:\n            pass\n    \n    def get_performance_stats(self) -> Dict[str, Any]:\n        \"\"\"获取性能统计信息（统一字段命名）。\"\"\"\n        stats = dict(self._performance_stats)\n        total = stats.get(\"total_requests\", 0) or 0\n        if total > 0:\n            avg = stats.get(\"total_response_time\", 0.0) / total\n            suc_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n        else:\n            avg = 0.0\n            suc_rate = 0.0\n        return {\n            \"total_requests\": total,\n            \"successful_requests\": stats.get(\"successful_requests\", 0),\n            \"failed_requests\": stats.get(\"failed_requests\", 0),\n            \"avg_response_time\": avg,\n            \"success_rate\": suc_rate,\n            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n        }\n\n    def dump_metrics(self) -> Dict[str, Any]:\n        \"\"\"导出统一指标，便于诊断脚本读取。\"\"\"\n        m = self.get_performance_stats()\n        m.update({\n            \"client\": \"Seedance\",\n            \"base_url\": self.base_url,\n        })\n        return m\n\n    def create_video_task(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: int = 8,\n        fps: int = 24,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        seed: Optional[int] = None,\n        use_pro_model: bool = True,\n        model_type: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        camera_fixed: bool = True,\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        watermark: bool = False,\n        reference_images: Optional[List[str]] = None,\n        generate_audio: Optional[bool] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        创建视频生成任务（新路径：分辨率档位 + 比例）\n\n        Args:\n            prompt: 视频描述提示词\n            image_path: 输入图片路径（图生视频）\n            first_frame_path: 首帧图片路径（首尾帧模式）\n            last_frame_path: 尾帧图片路径（首尾帧模式）\n            duration: 视频时长（秒），默认8秒\n            fps: 帧率，默认24fps\n            width/height: 旧路径兼容（关闭灰度时使用）\n            seed: 随机种子\n            use_pro_model: 是否使用Pro模型（兼容旧调用）\n            model_type: 模型类型 \"pro\"/\"pro_fast\"/\"lite\"（优先级高于 use_pro_model）\n            model_variant: UI 侧模型变体（如 seedance_1_5_pro）\n            camera_fixed: 是否固定摄像头视角\n            resolution_grade: 分辨率档位\n            ratio: 画面比例\n            watermark: 是否添加水印\n            reference_images: 额外参考图（base64/url），Seedream 4.0 视频扩展预留\n            generate_audio: 是否生成同步音频（仅 Seedance 1.5 Pro 生效）\n\n        Returns:\n            包含任务ID的响应结果\n        \"\"\"\n        url = f\"{self.base_url}/contents/generations/tasks\"\n        is_seedance_1_5_variant = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n\n        # 通过 Provider Schema 映射（默认启用；关闭时回退旧逻辑）\n        data = None\n        mode = \"\"\n        fallback_applied = False\n        fallback_reason = \"\"\n        used_rs = \"\"\n        used_rt = \"\"\n        if self._provider_enabled():\n            try:\n                # 预编码图片为 data URL（与旧实现一致），再交由 Provider 组装 content\n                enc_first = self._encode_image(first_frame_path) if first_frame_path else None\n                enc_last = self._encode_image(last_frame_path) if last_frame_path else None\n                enc_img = self._encode_image(image_path) if image_path else None\n\n                from modules.provider.factory import get_default_provider\n                from modules.provider.schema import VideoParams\n                provider = get_default_provider()\n                mapped, fb, reason, used_rs, used_rt = provider.map_video(VideoParams(\n                    prompt=prompt,\n                    image_path=enc_img,\n                    first_frame_path=enc_first,\n                    last_frame_path=enc_last,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if (seed is None or seed == -1) else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=False,\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                    model_variant=model_variant,\n                    generate_audio=generate_audio,\n                    reference_images=(reference_images or []),\n                ))\n                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\n                mode = mapped.get(\"mode\", \"视频\")\n                model = data[\"model\"]\n                fallback_applied, fallback_reason = fb, reason\n                if fb:\n                    logger.warning(f\"参数回退: {reason}\")\n                logger.info(f\"安全版参数: {mapped.get('flags_text', '')}\")\n            except Exception as _e:\n                logger.warning(f\"Provider 映射失败，回退旧路径: {_e}\")\n\n        if data is None:\n            # 旧内容组装路径\n            content: List[Dict[str, Any]] = []\n\n            # 解析 model_type（优先级高于 use_pro_model）\n            effective_model_type = model_type\n            if not effective_model_type:\n                effective_model_type = \"pro\" if use_pro_model else \"lite\"\n\n            # Seedance 1.5 Pro：独立模型（有声），不支持参考图模式\n            is_seedance_1_5 = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n            if is_seedance_1_5 and reference_images:\n                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n            # 1.5 Pro 暂不支持 1080p，提前降级避免走到 flags fallback\n            if is_seedance_1_5 and (not resolution_grade or resolution_grade == \"1080p\"):\n                resolution_grade = \"720p\"\n            if is_seedance_1_5 and not ratio:\n                ratio = \"adaptive\"\n\n            # Pro-fast 不支持首尾帧模式，如果用户选了 pro_fast 但又传了首尾帧，回退到 Pro\n            has_first_last_frame = bool(first_frame_path and last_frame_path)\n            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n                logger.warning(\"Pro-fast 不支持首尾帧模式，自动切换到 Pro 模型\")\n                effective_model_type = \"pro\"\n\n            if is_seedance_1_5:\n                model = SeedanceModels.PRO_1_5.value\n                mode = (\n                    \"首尾帧视频(1.5 Pro)\"\n                    if has_first_last_frame\n                    else (\"图生视频(1.5 Pro)\" if image_path else \"文生视频(1.5 Pro)\")\n                )\n            else:\n                # 模型选择逻辑\n                if has_first_last_frame:\n                    # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面被回退）\n                    if effective_model_type in (\"pro\", \"pro_fast\"):\n                        model = SeedanceModels.PRO.value\n                        mode = \"首尾帧视频(Pro)\"\n                    else:\n                        model = SeedanceModels.LITE_I2V.value\n                        mode = \"首尾帧视频(Lite)\"\n                elif effective_model_type == \"pro_fast\":\n                    # Pro-fast 模式（文生视频或首帧图生视频）\n                    model = SeedanceModels.PRO_FAST.value\n                    mode = \"图生视频(Pro-fast)\" if image_path else \"文生视频(Pro-fast)\"\n                elif effective_model_type == \"pro\":\n                    model = SeedanceModels.PRO.value\n                    mode = \"图生视频(Pro)\" if image_path else \"文生视频(Pro)\"\n                else:\n                    # Lite 模式\n                    if image_path or reference_images:\n                        model = SeedanceModels.LITE_I2V.value\n                        if reference_images and not image_path:\n                            mode = f\"参考图视频(Lite, {len(reference_images)}张)\"\n                        else:\n                            mode = \"图生视频(Lite)\"\n                    else:\n                        model = SeedanceModels.LITE_T2V.value\n                        mode = \"文生视频(Lite)\"\n\n            if first_frame_path and last_frame_path:\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(first_frame_path)},\n                    \"role\": \"first_frame\"\n                })\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(last_frame_path)},\n                    \"role\": \"last_frame\"\n                })\n            elif image_path:\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(image_path)},\n                    \"role\": \"first_frame\"\n                })\n            if reference_images:\n                for ref_img in reference_images:\n                    ref_path = ref_img.get('path') if isinstance(ref_img, dict) else ref_img\n                    if ref_path:\n                        content.append({\n                            \"type\": \"image_url\",\n                            \"image_url\": {\"url\": self._encode_image(ref_path)},\n                            \"role\": \"reference_image\"\n                        })\n                logger.info(f\"添加 {len(reference_images)} 张参考图到请求\")\n\n            # Lite 参考图模式（r2v）不支持 1080p，强制降级到 720p\n            if reference_images and not image_path and effective_model_type == \"lite\":\n                if resolution_grade == \"1080p\" or not resolution_grade:\n                    resolution_grade = \"720p\"\n                    logger.info(\"Lite 参考图模式不支持 1080p，已自动降级到 720p\")\n\n            # 文本命令\n            # Force server-side watermark off for Plan B (local watermark only)\n            flags_text, fallback_applied, fallback_reason, used_rs, used_rt = _validate_and_build_flags(\n                resolution_grade=resolution_grade,\n                ratio=ratio,\n                duration=duration,\n                fps=fps,\n                watermark=False,\n                camera_fixed=camera_fixed,\n                seed=seed,\n            )\n            text_prompt = f\"{prompt} {flags_text}\".strip()\n            if fallback_applied:\n                logger.warning(f\"参数回退: {fallback_reason}\")\n            logger.info(f\"安全版参数: {flags_text}\")\n            content.append({\"type\": \"text\", \"text\": text_prompt})\n            data = {\"model\": model, \"content\": content}\n\n        # 固定后端参数：service_tier=default, execution_expires_after=6h（21600s）\n        # 不暴露 UI；用于服务端任务超时治理\n        try:\n            data.setdefault(\"service_tier\", \"default\")\n            data.setdefault(\"execution_expires_after\", 21600)\n        except Exception:\n            pass\n\n        # Seedance 1.5 Pro：生成音频开关（默认 true）\n        try:\n            if is_seedance_1_5_variant or data.get(\"model\") == SeedanceModels.PRO_1_5.value:\n                data[\"generate_audio\"] = bool(True if generate_audio is None else generate_audio)\n        except Exception:\n            pass\n\n        headers = self._get_headers()\n        logger.info(f\"创建{mode}任务: {prompt[:50]}...\")\n        logger.info(f\"使用模型: {model}\")\n        logger.info(f\"参数: {used_rs or resolution_grade}+{used_rt or ratio}, dur={duration}s, fps={fps}\")\n\n        params_sent_summary = _summarize_payload_for_storage(\n            data,\n            resolution_grade=resolution_grade,\n            ratio=ratio,\n            duration=duration,\n            fps=fps,\n            seed=seed,\n            camera_fixed=camera_fixed,\n            used_rs=used_rs,\n            used_rt=used_rt,\n            mode=mode,\n        )\n\n        start_time = time.time()\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        try:\n            logger.info(f\"发送请求到: {url}\")\n            # 安全日志对象，避免 content 结构异常导致索引错误\n            text_items = [item for item in data.get(\"content\", []) if item.get(\"type\") == \"text\"]\n            text_len = 0\n            if text_items:\n                try:\n                    text_len = len(text_items[0].get(\"text\", \"\"))\n                except Exception:\n                    text_len = 0\n            safe_data = {\n                \"model\": data.get(\"model\"),\n                \"content_types\": [item.get(\"type\") for item in data.get(\"content\", [])],\n                \"text_prompt_length\": text_len,\n                \"image_count\": len([item for item in data.get(\"content\", []) if item.get(\"type\") == \"image_url\"]) \n            }\n            logger.info(f\"请求参数: {json.dumps(safe_data, indent=2, ensure_ascii=False)}\")\n\n            response = self._safe_json_post(url, headers, data, timeout=60)\n            response_time = time.time() - start_time\n            logger.info(f\"响应状态码: {response.status_code}, 响应时间: {response_time:.2f}s\")\n\n            result = self._handle_response(response, \"创建视频任务\")\n            success = True\n            task_id = result.get(\"id\")\n            if task_id:\n                self._active_tasks.add(task_id)\n                logger.info(f\"{mode}任务创建成功，任务ID: {task_id}\")\n                try:\n                    params_sent_summary[\"api_task_id\"] = task_id\n                except Exception:\n                    pass\n                result_obj = {\n                    \"success\": True,\n                    \"task_id\": task_id,\n                    \"status\": result.get(\"status\", \"processing\"),\n                    \"model\": model,\n                    \"mode\": mode,\n                    \"estimated_cost\": self._calculate_cost(model, duration),\n                    \"created_at\": time.time(),\n                    \"fallback_applied\": fallback_applied,\n                    \"fallback_reason\": fallback_reason,\n                    \"used_rs\": used_rs,\n                    \"used_rt\": used_rt,\n                    \"params_sent\": params_sent_summary,\n                }\n                # 安全摘要日志\n                logger.info(\n                    f\"摘要|operation=create_task status=success elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id}\"\n                )\n                return result_obj\n            else:\n                logger.error(f\"{mode}任务创建失败，未获取到任务ID\")\n                return {\"success\": False, \"error\": \"未获取到任务ID\", \"response\": result}\n\n        except requests.exceptions.SSLError as e:\n            logger.error(f\"{mode}任务创建失败 - SSL错误: {str(e)}\")\n            logger.info(\"尝试使用备用SSL配置重新连接...\")\n            try:\n                backup_session = requests.Session()\n                backup_session.verify = False\n                import urllib3\n                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n                # 手动编码避免 PyInstaller latin-1 问题\n                body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n                response = backup_session.post(url, headers=headers, data=body, timeout=(30, 120))\n                result = self._handle_response(response, \"创建视频任务(备用连接)\")\n                success = True\n                task_id = result.get(\"id\")\n                if task_id:\n                    self._active_tasks.add(task_id)\n                    logger.info(f\"{mode}任务创建成功(备用连接)，任务ID: {task_id}\")\n                    try:\n                        params_sent_summary[\"api_task_id\"] = task_id\n                    except Exception:\n                        pass\n                    result_obj = {\n                        \"success\": True,\n                        \"task_id\": task_id,\n                        \"status\": result.get(\"status\", \"processing\"),\n                        \"model\": model,\n                        \"mode\": mode,\n                        \"estimated_cost\": self._calculate_cost(model, duration),\n                        \"created_at\": time.time(),\n                        \"fallback_applied\": fallback_applied,\n                        \"fallback_reason\": fallback_reason,\n                        \"used_rs\": used_rs,\n                        \"used_rt\": used_rt,\n                        \"params_sent\": params_sent_summary,\n                    }\n                    logger.info(\n                        f\"摘要|operation=create_task status=success elapsed={time.time() - start_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id} (backup)\"\n                    )\n                    return result_obj\n                else:\n                    raise Exception(\"备用连接也未获取到任务ID\")\n            except Exception as backup_e:\n                logger.error(f\"备用连接也失败: {str(backup_e)}\")\n                err_code, err_msg = \"SSL_ERROR\", f\"SSL连接失败: {str(e)}; 备用: {str(backup_e)}\"\n                raise Exception(f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}\")\n        except requests.exceptions.ConnectionError as e:\n            logger.error(f\"{mode}任务创建失败 - 连接错误: {str(e)}\")\n            err_code, err_msg = \"NETWORK_ERROR\", str(e)\n            raise Exception(f\"网络连接失败，请检查网络连接: {str(e)}\")\n        except requests.exceptions.Timeout as e:\n            logger.error(f\"{mode}任务创建失败 - 超时: {str(e)}\")\n            err_code, err_msg = \"TIMEOUT_ERROR\", str(e)\n            raise Exception(f\"请求超时，请稍后重试: {str(e)}\")\n        except Exception as e:\n            logger.error(f\"{mode}任务创建失败: {str(e)}\")\n            err_code, err_msg = \"UNKNOWN_ERROR\", str(e)\n            raise Exception(f\"视频生成任务创建失败: {str(e)}\")\n        finally:\n            response_time = time.time() - start_time\n            # 失败时记录摘要\n            if not success:\n                logger.info(\n                    f\"摘要|operation=create_task status=failed elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s error={err_code}\"\n                )\n            self._record_request_stats(\"创建视频任务\", success, response_time, err_code, err_msg)\n\n    \n    def _calculate_cost(self, model: str, duration: int) -> float:\n        \"\"\"计算预估成本\"\"\"\n        base_cost = self.config.MODEL_PRICING.get(model, 15)\n        # 简单的成本估算：基础价格 * 时长系数\n        return base_cost * (duration / 5.0)  # 以5秒为基准\n\n    def query_video_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"查询视频生成任务状态\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            任务状态信息\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        # 使用正确的查询API端点\n        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n        headers = self._get_headers()\n\n        logger.info(f\"查询视频任务状态: {task_id}\")\n\n        try:\n            try:\n                response = self.session.get(url, headers=headers, timeout=30)\n            except requests.exceptions.SSLError as e:\n                logger.error(f\"查询视频任务状态失败 - SSL错误: {str(e)}\")\n                logger.info(\"尝试使用备用SSL配置重新查询任务状态...\")\n                try:\n                    backup_session = requests.Session()\n                    backup_session.verify = False\n                    import urllib3\n                    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n                    response = backup_session.get(url, headers=headers, timeout=30)\n                except Exception as backup_e:\n                    logger.error(f\"备用SSL配置查询失败: {str(backup_e)}\")\n                    raise Exception(\n                        f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}; 备用: {str(backup_e)}\"\n                    ) from e\n\n            result = self._handle_response(response, \"查询视频任务\")\n\n            # 根据官方API返回格式解析状态\n            status = result.get(\"status\", \"unknown\")\n            video_url = result.get(\"content\", {}).get(\"video_url\")\n            \n            logger.info(f\"任务 {task_id} 状态: {status}\")\n            \n            if status == \"succeeded\" and video_url:\n                logger.info(f\"视频生成完成: {video_url}\")\n\n            # 获取缩略图URL\n            thumbnail_url = result.get(\"content\", {}).get(\"thumbnail_url\") or result.get(\"thumbnail_url\")\n            preview_url = result.get(\"content\", {}).get(\"preview_url\") or result.get(\"preview_url\")\n\n            # 解析关键“实际参数”（用于 params_actual 落盘）\n            seed_value = result.get(\"seed\")\n            ratio_value = result.get(\"ratio\")\n            fps_value = result.get(\"framespersecond\")\n            service_tier = result.get(\"service_tier\")\n            execution_expires_after = result.get(\"execution_expires_after\")\n            generate_audio = result.get(\"generate_audio\")\n            \n            result_obj = {\n                \"success\": True,\n                \"task_id\": task_id,\n                \"status\": status,\n                \"video_url\": video_url,\n                \"thumbnail_url\": thumbnail_url,\n                \"preview_url\": preview_url,\n                \"model\": result.get(\"model\"),\n                \"resolution\": result.get(\"resolution\"),\n                \"ratio\": ratio_value,\n                \"duration\": result.get(\"duration\"),\n                \"fps\": fps_value,\n                \"framespersecond\": fps_value,\n                \"seed\": seed_value,\n                \"service_tier\": service_tier,\n                \"execution_expires_after\": execution_expires_after,\n                \"generate_audio\": generate_audio,\n                \"usage\": result.get(\"usage\"),\n                \"created_at\": result.get(\"created_at\"),\n                \"updated_at\": result.get(\"updated_at\")\n            }\n            # 安全摘要日志\n            logger.info(\n                f\"摘要|operation=query_task status={status} task_id={task_id} video_ready={'yes' if bool(video_url) else 'no'}\"\n            )\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"查询视频任务状态失败: {str(e)}\")\n            raise Exception(f\"查询任务状态失败: {str(e)}\")\n\n    def get_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        查询任务状态（兼容旧接口）\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        return self.query_video_task(task_id)\n\n    def wait_for_completion(self, task_id: str, max_wait_time: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"\n        等待任务完成（智能轮询）\n\n        Args:\n            task_id: 任务ID\n            max_wait_time: 最大等待时间（秒），默认使用配置值\n\n        Returns:\n            Dict: 最终任务结果\n        \"\"\"\n        max_wait_time = max_wait_time or self.config.POLLING[\"max_wait_time\"]\n        intervals = self.config.POLLING[\"intervals\"]\n        \n        logger.info(f\"开始智能轮询任务: {task_id}\")\n        \n        start_time = time.time()\n        attempt = 0\n\n        while time.time() - start_time < max_wait_time:\n            try:\n                # 查询任务状态\n                status_result = self.get_task_status(task_id)\n\n                if not status_result[\"success\"]:\n                    return status_result\n\n                status = status_result[\"status\"]\n                progress = status_result.get(\"progress\", 0)\n\n                logger.info(f\"任务 {task_id} 状态: {status}, 进度: {progress}%\")\n\n                # 检查是否为终态\n                if TaskStatus.is_terminal(status):\n                    if status == TaskStatus.SUCCEEDED.value:\n                        logger.success(f\"任务完成: {task_id}\")\n                    elif status == TaskStatus.FAILED.value:\n                        logger.error(f\"任务失败: {task_id}\")\n                    elif status == TaskStatus.CANCELLED.value:\n                        logger.warning(f\"任务被取消: {task_id}\")\n                    \n                    # 从活跃任务中移除\n                    self._active_tasks.discard(task_id)\n                    return status_result\n\n                # 动态调整轮询间隔\n                interval = intervals[min(attempt, len(intervals) - 1)]\n                logger.debug(f\"等待 {interval} 秒后继续轮询\")\n                time.sleep(interval)\n                attempt += 1\n                \n            except Exception as e:\n                logger.error(f\"轮询异常: {e}\")\n                time.sleep(5)  # 异常时等待5秒\n\n        # 超时处理\n        logger.error(f\"轮询超时: {task_id}\")\n        self._active_tasks.discard(task_id)\n        return {\n            \"success\": False, \n            \"error\": \"等待任务完成超时\", \n            \"error_code\": \"TIMEOUT_ERROR\", \n            \"task_id\": task_id,\n            \"elapsed_time\": time.time() - start_time\n        }\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消视频生成任务（仅在queued状态有效）\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            成功: {\"success\": True, \"status\": \"cancelled\"}\n            失败: {\"success\": False, \"error\": \"错误信息\"}\n        \"\"\"\n        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.api_key}\"\n        }\n\n        try:\n            response = requests.delete(url, headers=headers, timeout=10)\n\n            if response.status_code == 200:\n                # DELETE请求成功，等待0.5秒后查询实际状态\n                time.sleep(0.5)\n\n                # 查询任务状态以确认是否真的变成cancelled\n                try:\n                    status_result = self.query_video_task(task_id)\n                    current_status = status_result.get(\"status\", \"unknown\")\n\n                    if current_status == \"cancelled\":\n                        # 真正成功取消\n                        self._active_tasks.discard(task_id)\n                        logger.info(f\"任务已成功取消: {task_id}，状态已变更为 cancelled\")\n                        return {\"success\": True, \"status\": \"cancelled\"}\n                    else:\n                        # DELETE成功但状态不是cancelled（任务可能已在执行中）\n                        logger.warning(f\"DELETE请求成功，但任务状态为 {current_status}（任务可能已在执行中，无法取消）\")\n                        return {\"success\": False, \"status\": current_status, \"error\": f\"任务状态为 {current_status}，无法取消\"}\n                except Exception as query_e:\n                    # 状态查询失败，但DELETE请求成功\n                    logger.warning(f\"DELETE请求成功，但状态查询失败: {query_e}\")\n                    self._active_tasks.discard(task_id)\n                    return {\"success\": True, \"status\": \"cancelled\", \"warning\": \"状态确认失败\"}\n\n            if response.status_code == 400:\n                error_msg = response.json().get(\"error\", {}).get(\"message\", \"任务无法取消（可能已在执行中）\")\n                logger.warning(f\"取消任务失败: {task_id} - {error_msg}\")\n                return {\"success\": False, \"error\": error_msg}\n\n            error_msg = f\"HTTP {response.status_code}: {response.text}\"\n            logger.error(f\"取消任务请求失败: {error_msg}\")\n            return {\"success\": False, \"error\": error_msg}\n\n        except Exception as e:  # pylint: disable=broad-except\n            logger.error(f\"取消任务异常: {task_id} - {e}\")\n            return {\"success\": False, \"error\": str(e)}\n\n    def list_tasks(self, limit: int = 20, offset: int = 0, status_filter: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        获取任务列表（改进版）\n\n        Args:\n            limit: 返回数量限制\n            offset: 偏移量\n            status_filter: 状态过滤器\n\n        Returns:\n            Dict: 任务列表\n        \"\"\"\n        url = f\"{self.base_url}{self.config.ENDPOINTS['list_tasks']}\"\n        headers = self._get_headers()\n        \n        params = {\n            \"limit\": limit,\n            \"offset\": offset\n        }\n        \n        if status_filter:\n            params[\"status\"] = status_filter\n        \n        logger.info(f\"获取任务列表: limit={limit}, offset={offset}, status_filter={status_filter}\")\n        \n        # 记录开始时间\n        start_time = time.time()\n        success = False\n\n        try:\n            response = self.session.get(url, headers=headers, params=params, timeout=30)\n            result = self._handle_response(response, \"获取任务列表\")\n            \n            tasks = result.get(\"data\", [])\n            total = result.get(\"total\", len(tasks))\n            \n            logger.success(f\"获取任务列表成功，共{len(tasks)}个任务\")\n            success = True\n            \n            return {\n                \"success\": True,\n                \"tasks\": tasks,\n                \"total\": total,\n                \"limit\": limit,\n                \"offset\": offset,\n                \"has_more\": offset + len(tasks) < total\n            }\n            \n        except Exception as e:\n            logger.error(f\"获取任务列表失败: {e}\")\n            return {\n                 \"success\": False,\n                 \"error\": str(e)\n             }\n        finally:\n            # 记录性能统计\n            response_time = time.time() - start_time\n            self._record_request_stats(\"获取任务列表\", success, response_time)\n    \n    def batch_query_tasks(self, task_ids: List[str]) -> Dict[str, Any]:\n        \"\"\"\n        批量查询任务状态\n        \n        Args:\n            task_ids: 任务ID列表\n        \n        Returns:\n            批量查询结果\n        \"\"\"\n        results = {}\n        success_count = 0\n        \n        logger.info(f\"批量查询{len(task_ids)}个任务\")\n        \n        for task_id in task_ids:\n            try:\n                result = self.query_video_task(task_id)\n                if result.get(\"success\", True):  # 兼容不同的返回格式\n                    success_count += 1\n                results[task_id] = result\n            except Exception as e:\n                results[task_id] = {\n                    \"success\": False,\n                    \"error\": str(e)\n                }\n        \n        return {\n            \"success\": True,\n            \"results\": results,\n            \"total\": len(task_ids),\n            \"success_count\": success_count,\n            \"failed_count\": len(task_ids) - success_count\n        }\n    \n    def cancel_all_active_tasks(self) -> Dict[str, Any]:\n        \"\"\"\n        取消所有活跃任务\n        \n        Returns:\n            取消结果统计\n        \"\"\"\n        active_tasks = list(self._active_tasks)\n        \n        if not active_tasks:\n            return {\n                \"success\": True,\n                \"message\": \"没有活跃任务需要取消\",\n                \"cancelled\": 0\n            }\n        \n        cancelled_count = 0\n        failed_count = 0\n        \n        logger.info(f\"取消{len(active_tasks)}个活跃任务\")\n        \n        for task_id in active_tasks:\n            result = self.cancel_task(task_id)\n            if result.get(\"success\"):\n                cancelled_count += 1\n            else:\n                failed_count += 1\n        \n        return {\n            \"success\": True,\n            \"cancelled\": cancelled_count,\n            \"failed\": failed_count,\n            \"total_active\": len(active_tasks)\n        }\n    \n    def get_task_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取任务统计信息\n        \n        Returns:\n            统计信息\n        \"\"\"\n        try:\n            # 获取最近的任务列表\n            tasks_result = self.list_tasks(limit=100)\n            \n            if not tasks_result.get(\"success\"):\n                return tasks_result\n            \n            tasks = tasks_result.get(\"tasks\", [])\n            \n            # 统计各状态任务数量\n            status_counts = {}\n            total_cost = 0\n            \n            for task in tasks:\n                status = task.get(\"status\", \"unknown\")\n                status_counts[status] = status_counts.get(status, 0) + 1\n                \n                # 估算成本\n                model = task.get(\"model\", \"\")\n                if model in self.config.MODEL_PRICING:\n                    total_cost += self.config.MODEL_PRICING[model]\n            \n            return {\n                \"success\": True,\n                \"total_tasks\": len(tasks),\n                \"active_tasks\": len(self._active_tasks),\n                \"status_counts\": status_counts,\n                \"estimated_total_cost\": total_cost,\n                \"timestamp\": time.time()\n            }\n            \n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\n    def _prepare_image(self, image_path: str) -> str:\n        \"\"\"准备图片数据，返回data URL格式\"\"\"\n        try:\n            # 使用新的图片格式验证器\n            from utils.image_format_validator import validate_and_prepare_image\n            \n            result = validate_and_prepare_image(image_path, auto_convert=True)\n            \n            if result['success']:\n                if result['is_converted']:\n                    logger.info(f\"图片已自动转换: {result['original_format']} -> {result['final_format']}\")\n                return result['data_url']\n            else:\n                raise Exception(result['error'])\n                \n        except Exception as e:\n            logger.error(f\"图片处理失败: {str(e)}\")\n            raise Exception(f\"图片处理失败: {str(e)}\")\n\n    def _encode_image(self, image_path: str) -> str:\n        \"\"\"将图像文件编码为data URL格式\n        集成图片格式验证和自动转换功能\n        \n        Args:\n            image_path: 图像文件路径\n            \n        Returns:\n            data URL格式的图像字符串\n            \n        Raises:\n            AppError: 当图像文件不存在或编码失败时\n        \"\"\"\n        try:\n            image_path = Path(image_path)\n            if not image_path.exists():\n                raise AppError(f\"图像文件不存在: {image_path}\", ErrorType.FILE_ERROR)\n            \n            # 使用图片格式验证器处理\n            from utils.image_format_validator import validate_and_prepare_image\n            \n            result = validate_and_prepare_image(str(image_path), auto_convert=True)\n            \n            if result['success']:\n                if result['is_converted']:\n                    logger.info(f\"图片格式已自动转换: {result['original_format']} -> {result['final_format']}\")\n                return result['data_url']\n            else:\n                logger.error(f\"图片处理失败: {result['error']}\")\n                raise AppError(f\"图片处理失败: {result['error']}\", ErrorType.FILE_ERROR)\n                \n        except AppError:\n            raise\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图像编码失败: {error_msg}\")\n            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n\n    def _get_mime_type(self, extension: str) -> str:\n        \"\"\"\n        根据文件扩展名获取MIME类型\n\n        Args:\n            extension: 文件扩展名\n\n        Returns:\n            str: MIME类型\n        \"\"\"\n        mime_types = {\".jpg\": \"image/jpeg\", \".jpeg\": \"image/jpeg\", \".png\": \"image/png\", \".webp\": \"image/webp\"}\n        return mime_types.get(extension, \"image/jpeg\")\n\n    def _make_request(\n        self,\n        endpoint: str,\n        data: Optional[Dict[str, Any]] = None,\n        params: Optional[Dict[str, Any]] = None,\n        method: str = \"POST\",\n    ) -> Dict[str, Any]:\n        \"\"\"\n        发送HTTP请求\n\n        Args:\n            endpoint: API端点\n            data: 请求数据\n            params: 查询参数\n            method: HTTP方法\n\n        Returns:\n            Dict: 响应结果\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n\n        headers = {\"Authorization\": f\"Bearer {self.api_key}\", \"Content-Type\": \"application/json\"}\n\n        for attempt in range(self.max_retries):\n            try:\n                if method.upper() == \"GET\":\n                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)\n                else:\n                    response = requests.post(url, headers=headers, json=data, params=params, timeout=self.timeout)\n\n                response.raise_for_status()\n\n                # 解析响应（增强容错：包括编码问题回退）\n                try:\n                    result = response.json()\n                except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                    raw = response.content or b\"\"\n                    tried = set()\n                    result = None\n                    for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                        if not enc or enc in tried:\n                            continue\n                        tried.add(enc)\n                        try:\n                            text = raw.decode(enc, errors=\"strict\")\n                            result = json.loads(text)\n                            logger.debug(f\"_make_request - 通过备用编码解析成功: {enc}\")\n                            break\n                        except Exception:\n                            continue\n                    if result is None:\n                        try:\n                            preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                        except Exception:\n                            preview = str(raw[:200])\n                        logger.error(f\"_make_request - JSON解析失败(编码问题): {preview}\")\n                        raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n\n                return {\"success\": True, \"data\": result}\n\n            except requests.exceptions.Timeout:\n                logger.warning(f\"请求超时，第{attempt + 1}次重试\")\n                if attempt < self.max_retries - 1:\n                    time.sleep(self.retry_delay)\n                    continue\n                else:\n                    return {\"success\": False, \"error\": \"请求超时\", \"error_code\": \"TIMEOUT_ERROR\"}\n\n            except requests.exceptions.HTTPError as e:\n                if response.status_code == 429:\n                    logger.warning(f\"API配额限制，第{attempt + 1}次重试\")\n                    if attempt < self.max_retries - 1:\n                        time.sleep(self.retry_delay * 2)  # 配额限制时等待更长时间\n                        continue\n                    else:\n                        return {\"success\": False, \"error\": \"API配额已用完\", \"error_code\": \"QUOTA_EXCEEDED\"}\n                else:\n                    try:\n                        # 安全解析错误响应\n                        try:\n                            error_data = response.json()\n                        except (json.JSONDecodeError, UnicodeDecodeError):\n                            # 编码问题时使用安全解码\n                            try:\n                                safe_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n                                error_data = json.loads(safe_text)\n                            except Exception:\n                                error_data = {\"error\": {\"message\": \"响应解析失败\"}}\n                        error_message = error_data.get(\"error\", {}).get(\"message\", str(e))\n                    except:\n                        error_message = str(e)\n\n                    return {\n                        \"success\": False,\n                        \"error\": error_message,\n                        \"error_code\": \"API_ERROR\",\n                        \"status_code\": response.status_code,\n                    }\n\n            except requests.exceptions.RequestException as e:\n                logger.warning(f\"网络错误，第{attempt + 1}次重试: {e}\")\n                if attempt < self.max_retries - 1:\n                    time.sleep(self.retry_delay)\n                    continue\n                else:\n                    return {\"success\": False, \"error\": f\"网络连接错误: {e}\", \"error_code\": \"NETWORK_ERROR\"}\n\n            except Exception as e:\n                logger.error(f\"未知错误: {e}\")\n                return {\"success\": False, \"error\": str(e), \"error_code\": \"UNKNOWN_ERROR\"}\n\n        return {\"success\": False, \"error\": \"达到最大重试次数\", \"error_code\": \"MAX_RETRIES_EXCEEDED\"}\n","numLines":1448,"startLine":1,"totalLines":1448}}}
{"parentUuid":"a2ea6149-236a-42fa-9230-a4123d34eb97","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01SdMDYHjMQzBE9Bxkej5Tzt","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me search for provider-related code to understand the abstraction layer:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":20158,"cache_creation_input_tokens":61192,"cache_read_input_tokens":22559,"cache_creation":{"ephemeral_5m_input_tokens":61192,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"bb543007-e778-467c-a599-e85349a317d7","timestamp":"2026-01-05T11:51:19.141Z"}
{"parentUuid":"bb543007-e778-467c-a599-e85349a317d7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01SdMDYHjMQzBE9Bxkej5Tzt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GRwDmVs6RKQZ6NUsQVutts","name":"Glob","input":{"pattern":"modules/provider/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":20158,"cache_creation_input_tokens":61192,"cache_read_input_tokens":22559,"cache_creation":{"ephemeral_5m_input_tokens":61192,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"02b214a7-1e4b-4edb-ad0c-09bef1d26c7a","timestamp":"2026-01-05T11:51:19.334Z"}
{"parentUuid":"02b214a7-1e4b-4edb-ad0c-09bef1d26c7a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GRwDmVs6RKQZ6NUsQVutts","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4_5.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py"}]},"uuid":"831a65f6-fffd-4305-b317-c6371b106319","timestamp":"2026-01-05T11:51:19.468Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc_v4_5.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py"],"durationMs":38,"numFiles":7,"truncated":false}}
{"parentUuid":"831a65f6-fffd-4305-b317-c6371b106319","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DfVt1UrNd9NV3orF8bFJxF","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the provider abstraction layer:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":20444,"cache_read_input_tokens":83751,"cache_creation":{"ephemeral_5m_input_tokens":20444,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"f2af6050-96d6-449f-ae37-07780bef95fd","timestamp":"2026-01-05T11:51:30.429Z"}
{"parentUuid":"f2af6050-96d6-449f-ae37-07780bef95fd","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DfVt1UrNd9NV3orF8bFJxF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014SpphSgay219JFGYQUyWt7","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":20444,"cache_read_input_tokens":83751,"cache_creation":{"ephemeral_5m_input_tokens":20444,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"6028e580-e5c7-419d-b1a2-47f9820a123b","timestamp":"2026-01-05T11:51:30.639Z"}
{"parentUuid":"6028e580-e5c7-419d-b1a2-47f9820a123b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DfVt1UrNd9NV3orF8bFJxF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014CBBCvuFLE5wW1s7bVd1gx","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":20444,"cache_read_input_tokens":83751,"cache_creation":{"ephemeral_5m_input_tokens":20444,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"2fad250c-7e34-4958-9591-8d812492d228","timestamp":"2026-01-05T11:51:30.897Z"}
{"parentUuid":"2fad250c-7e34-4958-9591-8d812492d228","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DfVt1UrNd9NV3orF8bFJxF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F3f2DakN3Egd877icddsZS","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":20444,"cache_read_input_tokens":83751,"cache_creation":{"ephemeral_5m_input_tokens":20444,"ephemeral_1h_input_tokens":0},"output_tokens":232,"service_tier":"standard"}},"type":"assistant","uuid":"70658f8d-061a-4c31-8125-d8a455b6cfdf","timestamp":"2026-01-05T11:51:31.144Z"}
{"parentUuid":"70658f8d-061a-4c31-8125-d8a455b6cfdf","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014SpphSgay219JFGYQUyWt7","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 抽象基类与工厂接口（轻量）。\n     5→\n     6→本阶段目标：仅提供参数映射（map_*）能力，实际 HTTP 调用仍由 Client 完成，降低侵入性。\n     7→\"\"\"\n     8→from typing import Dict, Any, Optional, Tuple\n     9→from .schema import (\n    10→    TextToImageParams, ImageToImageParams, VideoParams,\n    11→    validate_and_normalize_t2i, validate_and_normalize_i2i, validate_and_normalize_video\n    12→)\n    13→\n    14→\n    15→class BaseProvider:\n    16→    name: str = \"base\"\n    17→\n    18→    # 图片：文生图参数映射\n    19→    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    20→        raise NotImplementedError\n    21→\n    22→    # 图片：图生图参数映射\n    23→    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    24→        raise NotImplementedError\n    25→\n    26→    # 视频：参数映射（model+content+flags 摘要）\n    27→    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n    28→        raise NotImplementedError\n    29→\n    30→    # 统一的校验入口（可选）\n    31→    @staticmethod\n    32→    def validate_t2i(p: TextToImageParams):\n    33→        return validate_and_normalize_t2i(p)\n    34→\n    35→    @staticmethod\n    36→    def validate_i2i(p: ImageToImageParams):\n    37→        return validate_and_normalize_i2i(p)\n    38→\n    39→    @staticmethod\n    40→    def validate_video(p: VideoParams):\n    41→        return validate_and_normalize_video(p)\n    42→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b2aac874-6de3-4a60-b2b8-5b47859305b2","timestamp":"2026-01-05T11:51:31.183Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 抽象基类与工厂接口（轻量）。\n\n本阶段目标：仅提供参数映射（map_*）能力，实际 HTTP 调用仍由 Client 完成，降低侵入性。\n\"\"\"\nfrom typing import Dict, Any, Optional, Tuple\nfrom .schema import (\n    TextToImageParams, ImageToImageParams, VideoParams,\n    validate_and_normalize_t2i, validate_and_normalize_i2i, validate_and_normalize_video\n)\n\n\nclass BaseProvider:\n    name: str = \"base\"\n\n    # 图片：文生图参数映射\n    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        raise NotImplementedError\n\n    # 图片：图生图参数映射\n    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        raise NotImplementedError\n\n    # 视频：参数映射（model+content+flags 摘要）\n    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n        raise NotImplementedError\n\n    # 统一的校验入口（可选）\n    @staticmethod\n    def validate_t2i(p: TextToImageParams):\n        return validate_and_normalize_t2i(p)\n\n    @staticmethod\n    def validate_i2i(p: ImageToImageParams):\n        return validate_and_normalize_i2i(p)\n\n    @staticmethod\n    def validate_video(p: VideoParams):\n        return validate_and_normalize_video(p)\n","numLines":42,"startLine":1,"totalLines":42}}}
{"parentUuid":"b2aac874-6de3-4a60-b2b8-5b47859305b2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014CBBCvuFLE5wW1s7bVd1gx","type":"tool_result","content":"     1→﻿#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 参数 Schema 与校验（最小落地）\n     5→\n     6→目标：\n     7→- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n     8→- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n     9→- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n    10→\"\"\"\n    11→\n    12→import copy\n    13→from dataclasses import dataclass, field\n    14→from typing import Any, Optional, Tuple, List, Dict\n    15→\n    16→# 参考图限制（见官方文档 lines 203-204）\n    17→MAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\n    18→MAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n    19→\n    20→\n    21→# 白名单与范围\n    22→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    23→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n    24→\n    25→\n    26→@dataclass\n    27→class TextToImageParams:\n    28→    prompt: str\n    29→    size: str = \"1024x1024\"\n    30→    guidance_scale: float = 2.5\n    31→    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    32→    reference_images: List[str] = field(default_factory=list)\n    33→    sequential_mode: bool = False\n    34→    count: int = 1\n    35→\n    36→\n    37→@dataclass\n    38→class ImageToImageParams:\n    39→    prompt: str\n    40→    image: str  # URL 或 data URL\n    41→    guidance_scale: float = 5.5\n    42→    seed: Optional[int] = None\n    43→    reference_images: List[str] = field(default_factory=list)\n    44→    sequential_mode: bool = False\n    45→    count: int = 1\n    46→\n    47→\n    48→@dataclass\n    49→class VideoParams:\n    50→    prompt: str\n    51→    image_path: Optional[str] = None\n    52→    first_frame_path: Optional[str] = None\n    53→    last_frame_path: Optional[str] = None\n    54→    duration: int = 8\n    55→    fps: int = 24\n    56→    seed: Optional[int] = None\n    57→    camera_fixed: bool = True\n    58→    watermark: bool = False\n    59→    resolution_grade: Optional[str] = None\n    60→    ratio: Optional[str] = None\n    61→    use_pro_model: bool = True\n    62→    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    63→    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    64→    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    65→    reference_images: List[str] = field(default_factory=list)\n    66→\n    67→\n    68→@dataclass(frozen=True)\n    69→class UIOption:\n    70→    value: Any\n    71→    label: str\n    72→    description: Optional[str] = None\n    73→    meta: Dict[str, Any] = field(default_factory=dict)\n    74→\n    75→\n    76→@dataclass(frozen=True)\n    77→class UIDependency:\n    78→    field: str\n    79→    equals: Any = None\n    80→    not_equals: Any = None\n    81→    exists: bool = False\n    82→\n    83→\n    84→@dataclass\n    85→class UISchemaField:\n    86→    name: str\n    87→    field_type: str\n    88→    label: str\n    89→    default: Any = None\n    90→    required: bool = False\n    91→    help_text: Optional[str] = None\n    92→    placeholder: Optional[str] = None\n    93→    options: List[UIOption] = field(default_factory=list)\n    94→    min_value: Optional[float] = None\n    95→    max_value: Optional[float] = None\n    96→    step: Optional[float] = None\n    97→    visible_if: List[UIDependency] = field(default_factory=list)\n    98→    enabled_if: List[UIDependency] = field(default_factory=list)\n    99→    extra: Dict[str, Any] = field(default_factory=dict)\n   100→\n   101→    def to_dict(self) -> Dict[str, Any]:\n   102→        return {\n   103→            \"name\": self.name,\n   104→            \"type\": self.field_type,\n   105→            \"label\": self.label,\n   106→            \"default\": self.default,\n   107→            \"required\": self.required,\n   108→            \"help_text\": self.help_text,\n   109→            \"placeholder\": self.placeholder,\n   110→            \"options\": [\n   111→                {\n   112→                    \"value\": opt.value,\n   113→                    \"label\": opt.label,\n   114→                    \"description\": opt.description,\n   115→                    \"meta\": opt.meta,\n   116→                }\n   117→                for opt in self.options\n   118→            ],\n   119→            \"min\": self.min_value,\n   120→            \"max\": self.max_value,\n   121→            \"step\": self.step,\n   122→            \"visible_if\": [\n   123→                {\n   124→                    \"field\": dep.field,\n   125→                    \"equals\": dep.equals,\n   126→                    \"not_equals\": dep.not_equals,\n   127→                    \"exists\": dep.exists,\n   128→                }\n   129→                for dep in self.visible_if\n   130→            ],\n   131→            \"enabled_if\": [\n   132→                {\n   133→                    \"field\": dep.field,\n   134→                    \"equals\": dep.equals,\n   135→                    \"not_equals\": dep.not_equals,\n   136→                    \"exists\": dep.exists,\n   137→                }\n   138→                for dep in self.enabled_if\n   139→            ],\n   140→            \"extra\": self.extra,\n   141→        }\n   142→\n   143→\n   144→@dataclass\n   145→class UISchema:\n   146→    provider: str\n   147→    mode: str\n   148→    variant: str\n   149→    fields: List[UISchemaField] = field(default_factory=list)\n   150→    primary_image: Dict[str, Any] = field(default_factory=dict)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f4f67de7-abd7-437c-991c-aa6809436db9","timestamp":"2026-01-05T11:51:31.183Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","content":"﻿#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 参数 Schema 与校验（最小落地）\n\n目标：\n- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n\"\"\"\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Any, Optional, Tuple, List, Dict\n\n# 参考图限制（见官方文档 lines 203-204）\nMAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\nMAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n\n\n# 白名单与范围\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n\n\n@dataclass\nclass TextToImageParams:\n    prompt: str\n    size: str = \"1024x1024\"\n    guidance_scale: float = 2.5\n    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass ImageToImageParams:\n    prompt: str\n    image: str  # URL 或 data URL\n    guidance_scale: float = 5.5\n    seed: Optional[int] = None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass VideoParams:\n    prompt: str\n    image_path: Optional[str] = None\n    first_frame_path: Optional[str] = None\n    last_frame_path: Optional[str] = None\n    duration: int = 8\n    fps: int = 24\n    seed: Optional[int] = None\n    camera_fixed: bool = True\n    watermark: bool = False\n    resolution_grade: Optional[str] = None\n    ratio: Optional[str] = None\n    use_pro_model: bool = True\n    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    reference_images: List[str] = field(default_factory=list)\n\n\n@dataclass(frozen=True)\nclass UIOption:\n    value: Any\n    label: str\n    description: Optional[str] = None\n    meta: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass(frozen=True)\nclass UIDependency:\n    field: str\n    equals: Any = None\n    not_equals: Any = None\n    exists: bool = False\n\n\n@dataclass\nclass UISchemaField:\n    name: str\n    field_type: str\n    label: str\n    default: Any = None\n    required: bool = False\n    help_text: Optional[str] = None\n    placeholder: Optional[str] = None\n    options: List[UIOption] = field(default_factory=list)\n    min_value: Optional[float] = None\n    max_value: Optional[float] = None\n    step: Optional[float] = None\n    visible_if: List[UIDependency] = field(default_factory=list)\n    enabled_if: List[UIDependency] = field(default_factory=list)\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"type\": self.field_type,\n            \"label\": self.label,\n            \"default\": self.default,\n            \"required\": self.required,\n            \"help_text\": self.help_text,\n            \"placeholder\": self.placeholder,\n            \"options\": [\n                {\n                    \"value\": opt.value,\n                    \"label\": opt.label,\n                    \"description\": opt.description,\n                    \"meta\": opt.meta,\n                }\n                for opt in self.options\n            ],\n            \"min\": self.min_value,\n            \"max\": self.max_value,\n            \"step\": self.step,\n            \"visible_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.visible_if\n            ],\n            \"enabled_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.enabled_if\n            ],\n            \"extra\": self.extra,\n        }\n\n\n@dataclass\nclass UISchema:\n    provider: str\n    mode: str\n    variant: str\n    fields: List[UISchemaField] = field(default_factory=list)\n    primary_image: Dict[str, Any] = field(default_factory=dict)","numLines":150,"startLine":1,"totalLines":866}}}
{"parentUuid":"f4f67de7-abd7-437c-991c-aa6809436db9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F3f2DakN3Egd877icddsZS","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 工厂（最小实现）\n     5→\"\"\"\n     6→import os\n     7→from typing import Optional\n     8→from .base import BaseProvider\n     9→from .volc import VolcProvider\n    10→from .volc_v4 import VolcV4Provider\n    11→from .volc_v4_5 import VolcV4_5Provider\n    12→\n    13→\n    14→def get_default_provider(provider_name: Optional[str] = None) -> BaseProvider:\n    15→    raw_name = provider_name or os.environ.get(\"GEMENG_PROVIDER\", \"volc_v3\")\n    16→    try:\n    17→        name = str(raw_name).strip().lower()\n    18→    except Exception:\n    19→        name = \"volc_v3\"\n    20→\n    21→    if name in {\"volc_v4\", \"volcengine_v4\", \"seedream_v4\", \"seedream4\", \"volc4\"}:\n    22→        return VolcV4Provider()\n    23→    elif name in {\"volc_v4_5\", \"volcengine_v4_5\", \"seedream_v4_5\", \"seedream4_5\", \"volc4_5\"}:\n    24→        return VolcV4_5Provider()\n    25→    # 默认与历史兼容，返回 v3 实现\n    26→    return VolcProvider()\n    27→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"355cd2c9-765c-492e-bbb0-f124464fefae","timestamp":"2026-01-05T11:51:31.183Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 工厂（最小实现）\n\"\"\"\nimport os\nfrom typing import Optional\nfrom .base import BaseProvider\nfrom .volc import VolcProvider\nfrom .volc_v4 import VolcV4Provider\nfrom .volc_v4_5 import VolcV4_5Provider\n\n\ndef get_default_provider(provider_name: Optional[str] = None) -> BaseProvider:\n    raw_name = provider_name or os.environ.get(\"GEMENG_PROVIDER\", \"volc_v3\")\n    try:\n        name = str(raw_name).strip().lower()\n    except Exception:\n        name = \"volc_v3\"\n\n    if name in {\"volc_v4\", \"volcengine_v4\", \"seedream_v4\", \"seedream4\", \"volc4\"}:\n        return VolcV4Provider()\n    elif name in {\"volc_v4_5\", \"volcengine_v4_5\", \"seedream_v4_5\", \"seedream4_5\", \"volc4_5\"}:\n        return VolcV4_5Provider()\n    # 默认与历史兼容，返回 v3 实现\n    return VolcProvider()\n","numLines":27,"startLine":1,"totalLines":27}}}
{"parentUuid":"355cd2c9-765c-492e-bbb0-f124464fefae","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UrJqMBxDy3Cd8CJMeWkhPY","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me read one more provider implementation to see how the mapping works:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":3873,"cache_read_input_tokens":104195,"cache_creation":{"ephemeral_5m_input_tokens":3873,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"d438a448-edb9-41f1-a19e-bc20e1f8335a","timestamp":"2026-01-05T11:51:44.715Z"}
{"parentUuid":"d438a448-edb9-41f1-a19e-bc20e1f8335a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UrJqMBxDy3Cd8CJMeWkhPY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AS9B5TFgkPHJ7pkdb14UjG","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":3873,"cache_read_input_tokens":104195,"cache_creation":{"ephemeral_5m_input_tokens":3873,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9545be4b-8698-4ece-8aff-c2ff2018cd62","timestamp":"2026-01-05T11:51:45.054Z"}
{"parentUuid":"9545be4b-8698-4ece-8aff-c2ff2018cd62","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AS9B5TFgkPHJ7pkdb14UjG","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Volc (Ark) Provider 映射（最小实现）\n     5→\n     6→职责：将统一 Schema 归一化后的参数映射到当前 Ark v3 的请求载荷/文本 flag。\n     7→HTTP 请求仍在各自 Client 内执行。\n     8→\"\"\"\n     9→from typing import Dict, Any, Tuple\n    10→from .base import BaseProvider\n    11→from .schema import TextToImageParams, ImageToImageParams, VideoParams\n    12→try:\n    13→    # 复用现有模型 ID 定义，避免硬编码漂移\n    14→    from modules.seedance.config import SeedanceModels\n    15→except Exception:\n    16→    SeedanceModels = None\n    17→\n    18→\n    19→class VolcProvider(BaseProvider):\n    20→    name = \"volcengine\"\n    21→\n    22→    # Seedream 3.0/3.1 - 文生图\n    23→    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    24→        norm, fb, reason = self.validate_t2i(params)\n    25→        # 与当前实现保持一致：固定 watermark=False，response_format=url\n    26→        data = {\n    27→            \"model\": \"doubao-seedream-3-0-t2i-250415\",\n    28→            \"prompt\": norm.prompt,\n    29→            \"size\": norm.size,\n    30→            \"response_format\": \"url\",\n    31→            \"watermark\": False,\n    32→            \"guidance_scale\": norm.guidance_scale,\n    33→        }\n    34→        if norm.seed is not None:\n    35→            data[\"seed\"] = norm.seed\n    36→        return data, fb, reason, \"/images/generations\"\n    37→\n    38→    # Seedream 3.0/3.1 - 图生图\n    39→    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    40→        norm, fb, reason = self.validate_i2i(params)\n    41→        data = {\n    42→            \"model\": \"doubao-seededit-3-0-i2i-250628\",\n    43→            \"prompt\": norm.prompt,\n    44→            \"image\": norm.image,\n    45→            \"size\": \"adaptive\",\n    46→            \"response_format\": \"url\",\n    47→            \"watermark\": False,\n    48→            \"guidance_scale\": norm.guidance_scale,\n    49→        }\n    50→        if norm.seed is not None:\n    51→            data[\"seed\"] = norm.seed\n    52→        return data, fb, reason, \"/images/generations\"\n    53→\n    54→    # Seedance pro/pro_fast/lite - 视频\n    55→    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n    56→        norm, fb, reason, used_rs, used_rt = self.validate_video(params)\n    57→\n    58→        # Seedance 1.5 Pro：独立模型，支持有声视频；不支持参考图模式\n    59→        if (norm.model_variant or \"\").strip().lower() == \"seedance_1_5_pro\":\n    60→            if norm.reference_images:\n    61→                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n    62→\n    63→            model = (\n    64→                SeedanceModels.PRO_1_5.value\n    65→                if SeedanceModels\n    66→                else \"doubao-seedance-1-5-pro-251215\"\n    67→            )\n    68→\n    69→            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n    70→            if has_first_last_frame:\n    71→                mode = \"首尾帧视频(1.5 Pro)\"\n    72→            elif norm.image_path:\n    73→                mode = \"图生视频(1.5 Pro)\"\n    74→            else:\n    75→                mode = \"文生视频(1.5 Pro)\"\n    76→        else:\n    77→            # 解析 model_type（优先级高于 use_pro_model）\n    78→            effective_model_type = norm.model_type\n    79→            if not effective_model_type:\n    80→                effective_model_type = \"pro\" if norm.use_pro_model else \"lite\"\n    81→\n    82→            # Pro-fast 不支持首尾帧模式\n    83→            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n    84→            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n    85→                effective_model_type = \"pro\"  # 自动回退\n    86→\n    87→            # 模型选择逻辑\n    88→            if has_first_last_frame:\n    89→                # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面回退）\n    90→                if effective_model_type in (\"pro\", \"pro_fast\"):\n    91→                    model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n    92→                    mode = \"首尾帧视频(Pro)\"\n    93→                else:\n    94→                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n    95→                    mode = \"首尾帧视频(Lite)\"\n    96→            elif effective_model_type == \"pro_fast\":\n    97→                model = SeedanceModels.PRO_FAST.value if SeedanceModels else \"doubao-seedance-1-0-pro-fast-251015\"\n    98→                mode = \"图生视频(Pro-fast)\" if norm.image_path else \"文生视频(Pro-fast)\"\n    99→            elif effective_model_type == \"pro\":\n   100→                model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n   101→                mode = \"图生视频(Pro)\" if norm.image_path else \"文生视频(Pro)\"\n   102→            else:\n   103→                # Lite 模式：检查 image_path 或 reference_images\n   104→                if norm.image_path or norm.reference_images:\n   105→                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n   106→                    if norm.image_path:\n   107→                        mode = \"图生视频(Lite)\"\n   108→                    else:\n   109→                        mode = f\"参考图视频(Lite, {len(norm.reference_images[:4])}张)\"\n   110→                else:\n   111→                    model = SeedanceModels.LITE_T2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-t2v-250428\"\n   112→                    mode = \"文生视频(Lite)\"\n   113→\n   114→        # 参考图场景（所有模型）不支持 1080p，强制降级到 720p\n   115→        has_reference_images = bool(norm.reference_images)\n   116→        if has_reference_images and used_rs == \"1080p\":\n   117→            used_rs = \"720p\"\n   118→            fb = True\n   119→            reason = (reason + \"; \" if reason else \"\") + \"参考图模式不支持1080p，已降级到720p\"\n   120→\n   121→        # 文本 flags（与客户端 _validate_and_build_flags 顺序对齐）\n   122→        parts = [\n   123→            \"--rs\", used_rs,\n   124→            \"--rt\", used_rt,\n   125→            \"--dur\", str(norm.duration),\n   126→            \"--fps\", str(norm.fps),\n   127→            \"--wm\", str(bool(norm.watermark)).lower(),\n   128→        ]\n   129→        if norm.seed is not None:\n   130→            parts += [\"--seed\", str(norm.seed)]\n   131→        parts += [\"--cf\", str(bool(norm.camera_fixed)).lower()]\n   132→        flags_text = \" \".join(parts)\n   133→\n   134→        content = []\n   135→        if norm.first_frame_path and norm.last_frame_path:\n   136→            content.append({\n   137→                \"type\": \"image_url\",\n   138→                \"image_url\": {\"url\": norm.first_frame_path},\n   139→                \"role\": \"first_frame\"\n   140→            })\n   141→            content.append({\n   142→                \"type\": \"image_url\",\n   143→                \"image_url\": {\"url\": norm.last_frame_path},\n   144→                \"role\": \"last_frame\"\n   145→            })\n   146→        elif norm.image_path:\n   147→            content.append({\n   148→                \"type\": \"image_url\",\n   149→                \"image_url\": {\"url\": norm.image_path},\n   150→                \"role\": \"first_frame\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"72fb3cb9-d584-41c1-b3fb-95db2ade7e6e","timestamp":"2026-01-05T11:51:45.114Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVolc (Ark) Provider 映射（最小实现）\n\n职责：将统一 Schema 归一化后的参数映射到当前 Ark v3 的请求载荷/文本 flag。\nHTTP 请求仍在各自 Client 内执行。\n\"\"\"\nfrom typing import Dict, Any, Tuple\nfrom .base import BaseProvider\nfrom .schema import TextToImageParams, ImageToImageParams, VideoParams\ntry:\n    # 复用现有模型 ID 定义，避免硬编码漂移\n    from modules.seedance.config import SeedanceModels\nexcept Exception:\n    SeedanceModels = None\n\n\nclass VolcProvider(BaseProvider):\n    name = \"volcengine\"\n\n    # Seedream 3.0/3.1 - 文生图\n    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_t2i(params)\n        # 与当前实现保持一致：固定 watermark=False，response_format=url\n        data = {\n            \"model\": \"doubao-seedream-3-0-t2i-250415\",\n            \"prompt\": norm.prompt,\n            \"size\": norm.size,\n            \"response_format\": \"url\",\n            \"watermark\": False,\n            \"guidance_scale\": norm.guidance_scale,\n        }\n        if norm.seed is not None:\n            data[\"seed\"] = norm.seed\n        return data, fb, reason, \"/images/generations\"\n\n    # Seedream 3.0/3.1 - 图生图\n    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_i2i(params)\n        data = {\n            \"model\": \"doubao-seededit-3-0-i2i-250628\",\n            \"prompt\": norm.prompt,\n            \"image\": norm.image,\n            \"size\": \"adaptive\",\n            \"response_format\": \"url\",\n            \"watermark\": False,\n            \"guidance_scale\": norm.guidance_scale,\n        }\n        if norm.seed is not None:\n            data[\"seed\"] = norm.seed\n        return data, fb, reason, \"/images/generations\"\n\n    # Seedance pro/pro_fast/lite - 视频\n    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n        norm, fb, reason, used_rs, used_rt = self.validate_video(params)\n\n        # Seedance 1.5 Pro：独立模型，支持有声视频；不支持参考图模式\n        if (norm.model_variant or \"\").strip().lower() == \"seedance_1_5_pro\":\n            if norm.reference_images:\n                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n            model = (\n                SeedanceModels.PRO_1_5.value\n                if SeedanceModels\n                else \"doubao-seedance-1-5-pro-251215\"\n            )\n\n            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n            if has_first_last_frame:\n                mode = \"首尾帧视频(1.5 Pro)\"\n            elif norm.image_path:\n                mode = \"图生视频(1.5 Pro)\"\n            else:\n                mode = \"文生视频(1.5 Pro)\"\n        else:\n            # 解析 model_type（优先级高于 use_pro_model）\n            effective_model_type = norm.model_type\n            if not effective_model_type:\n                effective_model_type = \"pro\" if norm.use_pro_model else \"lite\"\n\n            # Pro-fast 不支持首尾帧模式\n            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n                effective_model_type = \"pro\"  # 自动回退\n\n            # 模型选择逻辑\n            if has_first_last_frame:\n                # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面回退）\n                if effective_model_type in (\"pro\", \"pro_fast\"):\n                    model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n                    mode = \"首尾帧视频(Pro)\"\n                else:\n                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n                    mode = \"首尾帧视频(Lite)\"\n            elif effective_model_type == \"pro_fast\":\n                model = SeedanceModels.PRO_FAST.value if SeedanceModels else \"doubao-seedance-1-0-pro-fast-251015\"\n                mode = \"图生视频(Pro-fast)\" if norm.image_path else \"文生视频(Pro-fast)\"\n            elif effective_model_type == \"pro\":\n                model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n                mode = \"图生视频(Pro)\" if norm.image_path else \"文生视频(Pro)\"\n            else:\n                # Lite 模式：检查 image_path 或 reference_images\n                if norm.image_path or norm.reference_images:\n                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n                    if norm.image_path:\n                        mode = \"图生视频(Lite)\"\n                    else:\n                        mode = f\"参考图视频(Lite, {len(norm.reference_images[:4])}张)\"\n                else:\n                    model = SeedanceModels.LITE_T2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-t2v-250428\"\n                    mode = \"文生视频(Lite)\"\n\n        # 参考图场景（所有模型）不支持 1080p，强制降级到 720p\n        has_reference_images = bool(norm.reference_images)\n        if has_reference_images and used_rs == \"1080p\":\n            used_rs = \"720p\"\n            fb = True\n            reason = (reason + \"; \" if reason else \"\") + \"参考图模式不支持1080p，已降级到720p\"\n\n        # 文本 flags（与客户端 _validate_and_build_flags 顺序对齐）\n        parts = [\n            \"--rs\", used_rs,\n            \"--rt\", used_rt,\n            \"--dur\", str(norm.duration),\n            \"--fps\", str(norm.fps),\n            \"--wm\", str(bool(norm.watermark)).lower(),\n        ]\n        if norm.seed is not None:\n            parts += [\"--seed\", str(norm.seed)]\n        parts += [\"--cf\", str(bool(norm.camera_fixed)).lower()]\n        flags_text = \" \".join(parts)\n\n        content = []\n        if norm.first_frame_path and norm.last_frame_path:\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.first_frame_path},\n                \"role\": \"first_frame\"\n            })\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.last_frame_path},\n                \"role\": \"last_frame\"\n            })\n        elif norm.image_path:\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.image_path},\n                \"role\": \"first_frame\"","numLines":150,"startLine":1,"totalLines":177}}}
{"parentUuid":"72fb3cb9-d584-41c1-b3fb-95db2ade7e6e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a19cb7b","slug":"inherited-napping-neumann","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012F1ccm79PmDvXQLykyx74N","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! I have gathered sufficient information. Now let me compile a comprehensive analysis report:\n\n## 鸽梦 (GoDream) 模块架构分析报告\n\n### 1. 整体架构概览\n\n**项目结构：** Seedream（图像生成）和 Seedance（视频生成）两大模块，均采用客户端-管理器分离的三层架构。\n\n```\nmodules/\n├── seedream/              # 图像生成模块\n│   ├── client.py         # API 客户端（HTTP 封装）\n│   ├── manager.py        # 业务逻辑管理\n│   └── __init__.py       # 模块入口与特性定义\n├── seedance/             # 视频生成模块\n│   ├── client.py         # API 客户端（HTTP 封装）\n│   ├── manager.py        # 业务逻辑管理\n│   ├── config.py         # 模型与配置常量\n│   └── __init__.py       # 模块入口\n└── provider/             # 参数映射层（抽象）\n    ├── base.py           # 基类接口\n    ├── schema.py         # 统一参数 Schema\n    ├── factory.py        # 工厂模式选择器\n    ├── volc.py           # v3.0 实现\n    ├── volc_v4.py        # v4.0 实现\n    └── volc_v4_5.py      # v4.5 实现\n```\n\n---\n\n### 2. API 调用流程分析\n\n#### **2.1 Seedream 文生图（Text-to-Image）流程**\n\n```\nManager.generate_text_to_image()\n    │\n    ├─ 处理参考图资产 (_process_reference_assets)\n    │  └─ 存储到本地 (storage_manager.save_reference_asset)\n    │\n    ├─ 调用客户端 (Client.text_to_image)\n    │  ├─ Provider 路径（如果启用）\n    │  │  └─ _call_seedream_provider()\n    │  │     ├─ 根据 model_variant 选择 provider（v3/v4/v4.5）\n    │  │     ├─ provider.map_t2i() 映射参数\n    │  │     └─ 动态计算超时（组图模式 120+60*N 秒）\n    │  │\n    │  └─ 旧路径回退（provider 失败或禁用）\n    │     └─ text_to_image() 直接使用硬编码参数\n    │\n    ├─ 下载图像 (safe_requests_get)\n    │\n    ├─ 保存本地 (_save_image_locally)\n    │  ├─ 写入文件\n    │  ├─ 提取真实像素尺寸\n    │  └─ 应用水印（如需要）\n    │\n    └─ 组图模式处理（返回 batch 结果）\n```\n\n**关键特点：**\n- Provider 路径支持参数回退（fallback mechanism）\n- 组图模式（sequential_mode=true）可返回多张图\n- 超时动态调整：组图模式超时 = 120 + 60*count（最大 1200 秒）\n\n---\n\n#### **2.2 Seedance 视频生成流程**\n\n```\nManager.generate_video()\n    │\n    ├─ 统一处理所有图片（帧图 + 参考图）\n    │  └─ _process_reference_assets()\n    │\n    ├─ 构建视频任务参数\n    │  ├─ Client.create_video_task()\n    │  │  ├─ Provider 路径（如果启用）\n    │  │  │  └─ provider.map_video() 构建 content 结构\n    │  │  │\n    │  │  └─ 旧路径回退\n    │  │     └─ 直接构建 content（图片 + 文本 flags）\n    │  │\n    │  └─ 发送 POST → /contents/generations/tasks\n    │\n    ├─ 等待完成（如需要）\n    │  ├─ Client.wait_for_completion()\n    │  │  └─ 智能轮询（间隔 2,3,5,8,10 秒，最大 600 秒）\n    │  │\n    │  └─ GET → /contents/generations/tasks/{task_id}\n    │\n    ├─ 下载视频\n    │\n    └─ 保存本地 (_save_video_locally)\n       ├─ 提取真实视频信息（宽高、帧率、时长）\n       ├─ 生成缩略图\n       └─ 应用水印（如需要）\n```\n\n---\n\n### 3. API 特定性分析\n\n#### **3.1 火山引擎 (Volcengine) 耦合点**\n\n**强耦合（难以替换）：**\n\n1. **模型 ID 硬编码**\n   - 图像：`doubao-seedream-3-0-t2i-250415` / `doubao-seedream-4-0-250828` / `doubao-seedream-4-5-251128`\n   - 视频：`doubao-seedance-1-0-pro-250528` / `doubao-seedance-1-5-pro-251215` 等\n   - **位置：** `__init__.py` 和 `config.py`\n\n2. **API 端点路径**\n   - 图像：`/images/generations`\n   - 视频：`/contents/generations/tasks`\n   - **位置：** Client 和 Config 中硬编码\n\n3. **参数结构体系**\n   ```python\n   # Seedream 请求格式（与火山引擎 OpenAI-compatible API 对齐）\n   {\n       \"model\": \"doubao-seedream-3-0-t2i-250415\",\n       \"prompt\": \"...\",\n       \"size\": \"1024x1024\",\n       \"guidance_scale\": 2.5,\n       \"seed\": 12345,\n       \"response_format\": \"url\",  # 固定为 URL（不支持 b64_json）\n       \"watermark\": False,\n   }\n   \n   # Seedance 请求格式（混合结构）\n   {\n       \"model\": \"doubao-seedance-1-0-pro-250528\",\n       \"content\": [\n           {\"type\": \"text\", \"text\": \"prompt --rs 1080p --rt 16:9 --dur 8 ...\"},\n           {\"type\": \"image_url\", \"image_url\": {\"url\": \"data:image/...\"}},\n       ]\n   }\n   ```\n\n4. **HTTP 细节**\n   - 认证：`Bearer {api_key}` （OpenAI-style）\n   - 编码：UTF-8 with BOM 处理\n   - SSL 验证：自定义绕过（存在通用性问题）\n\n**弱耦合（可替换）：**\n\n1. **Client.session 与 HTTPAdapter 配置**\n   - 重试策略、连接池、超时设置都可独立配置\n\n2. **错误处理**\n   - AppError 类与 ErrorType 枚举定义在 `utils/error_handler.py`\n   - 易于添加其他提供商的错误映射\n\n---\n\n#### **3.2 Provider 抽象层（参数映射）**\n\n**架构设计：**\n\n```python\nBaseProvider (interface)\n├── map_t2i(TextToImageParams) -> (payload, fallback_bool, reason, endpoint)\n├── map_i2i(ImageToImageParams) -> (payload, fallback_bool, reason, endpoint)\n└── map_video(VideoParams) -> (payload, fallback_bool, reason, rs, rt)\n\nVolcProvider (v3.0 实现)  # 图像和视频\nVolcV4Provider (v4.0 实现)  # 仅图像\nVolcV4_5Provider (v4.5 实现)  # 仅图像\n```\n\n**Schema 定义（通用）：**\n\n```python\n@dataclass\nclass TextToImageParams:\n    prompt: str\n    size: str = \"1024x1024\"\n    guidance_scale: float = 2.5\n    seed: Optional[int] = None\n    reference_images: List[str] = []\n    sequential_mode: bool = False\n    count: int = 1\n\n# 类似结构适用于 ImageToImageParams 和 VideoParams\n```\n\n**映射示例（volc.py）：**\n\n```python\ndef map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    norm, fb, reason = self.validate_t2i(params)\n    data = {\n        \"model\": \"doubao-seedream-3-0-t2i-250415\",  # 硬编码\n        \"prompt\": norm.prompt,\n        \"size\": norm.size,\n        \"response_format\": \"url\",  # 固定\n        \"watermark\": False,  # 固定\n        \"guidance_scale\": norm.guidance_scale,\n    }\n    if norm.seed is not None:\n        data[\"seed\"] = norm.seed\n    return data, fb, reason, \"/images/generations\"  # 返回 4 元组\n```\n\n**关键观察：**\n- Provider 只负责参数映射，不执行 HTTP 请求\n- HTTP 调用仍在 Client 内执行（降低侵入性）\n- 支持参数回退（如 guidance_scale 超出范围时降级到默认值）\n\n---\n\n### 4. 代码耦合程度评估\n\n#### **4.1 耦合度矩阵**\n\n| 层级 | 火山引擎特定 | 可配置化 | 备注 |\n|------|-----------|--------|------|\n| **模型 ID** | 100% | 低 | 硬编码在 Config；Provider 可部分隐藏 |\n| **API 端点** | 100% | 低 | 硬编码在 Client；Config 有 ENDPOINTS 字典 |\n| **认证方式** | 100% | 低 | 固定为 Bearer Token |\n| **参数结构** | 95% | 中 | Schema 通用但映射逻辑不通用 |\n| **HTTP 细节** | 90% | 中 | Session/Adapter 可配置，但 SSL 处理不通用 |\n| **业务逻辑** | 5% | 高 | Manager 基本通用，仅模型选择逻辑依赖 |\n| **错误处理** | 30% | 中 | AppError 通用，但火山引擎错误码映射固定 |\n\n**耦合度评分：** \n- **整体：7.5/10** （高耦合）\n- **可扩展性：6/10** （需改造）\n\n---\n\n### 5. 代码耦合的具体体现\n\n#### **5.1 必须改动才能支持新提供商的文件**\n\n```\n必须修改：\n├── modules/provider/\n│   ├── factory.py           # 添加新 provider 选择分支\n│   ├── new_provider.py      # 新增实现类\n│   └── schema.py            # 可能需要扩展参数字段\n├── modules/seedream/\n│   ├── client.py            # API 端点 / 模型 ID（~50 处）\n│   └── manager.py           # 回退逻辑处理\n└── modules/seedance/\n    ├── client.py            # API 端点 / 模型 ID（~30 处）\n    ├── manager.py           # 模型选择逻辑\n    └── config.py            # 新增模型 enum\n\n可能修改：\n├── config/unified_config.py # 新 API key 字段\n└── utils/error_handler.py   # 新 error code 映射\n```\n\n#### **5.2 难以替换的三个核心点**\n\n**问题 1：模型 ID 硬编码**\n```python\n# client.py L 642（Seedream）\ndata = {\"model\": \"doubao-seedream-3-0-t2i-250415\", ...}\n\n# config.py L 8-14（Seedance）\nclass SeedanceModels(Enum):\n    PRO_1_5 = \"doubao-seedance-1-5-pro-251215\"\n    PRO = \"doubao-seedance-1-0-pro-250528\"\n    ...\n```\n**影响：** 要支持新提供商，需要添加新的 enum 值或 Provider 类\n\n**问题 2：API 端点路径**\n```python\n# client.py L 538\nurl = f\"{self.base_url}/contents/generations/tasks\"\n\n# config.py L 53-59\nENDPOINTS = {\n    \"create_task\": \"/contents/generations/tasks\",\n    \"query_task\": \"/contents/generations/tasks/{task_id}\",\n    ...\n}\n```\n**影响：** 新提供商不能使用相同的端点结构，需要自定义 Client 类\n\n**问题 3：参数结构体系（混合文本+JSON）**\n```python\n# Seedance 的混合格式要求\ncontent = [\n    {\"type\": \"text\", \"text\": \"prompt --rs 1080p --rt 16:9 ...\"},\n    {\"type\": \"image_url\", \"image_url\": {\"url\": \"...\"}},\n]\n\n# 如果新提供商使用纯 JSON，需要改写整个映射逻辑\n```\n**影响：** 视频参数映射逻辑无法复用\n\n---\n\n### 6. 可扩展性架构分析\n\n#### **6.1 现状优势**\n\n1. **三层架构清晰**\n   - Client：HTTP 封装（可继承复用）\n   - Provider：参数映射（易于扩展）\n   - Manager：业务逻辑（基本通用）\n\n2. **Schema 定义统一**\n   - TextToImageParams、ImageToImageParams、VideoParams\n   - 每个提供商实现自己的 map_* 方法\n\n3. **错误处理框架**\n   - AppError 与 ErrorType 枚举\n   - RetryHandler 装饰器用于重试\n\n4. **存储解耦**\n   - UnifiedStorageManager V2 与 Provider 无关\n   - 参考图处理与 API 调用分离\n\n#### **6.1 现状劣势**\n\n1. **硬编码蔓延**\n   - 模型 ID、端点、参数默认值分散在多个文件\n   - 没有统一的配置中心\n\n2. **Provider 路径不完整**\n   - 仅提供参数映射，HTTP 调用仍在 Client 内\n   - Client 需要为每个 Provider 添加特殊逻辑（见 L 227-341）\n\n3. **缺乏接口约束**\n   - BaseProvider 定义了 map_* 方法，但没有强制约束返回值结构\n   - 不同 Provider 的返回格式可能不一致（导致调用端复杂性高）\n\n4. **参数回退逻辑复杂**\n   - validate_and_normalize_* 函数中有大量白名单检查\n   - 新提供商需要复制这些逻辑\n\n---\n\n### 7. 替换友好度评估\n\n#### **7.1 替换为通用 API（如 Stability AI、OpenAI DALL-E）的难度**\n\n**替换难度：9/10（极难）**\n\n**原因：**\n1. 参数结构完全不同（Seedream/Seedance 特定）\n2. 模型选择逻辑与火山引擎绑定（L~50 处硬编码）\n3. 视频生成的混合文本+JSON 格式无法复用\n4. 水印、参考图、组图模式都是火山引擎特性\n\n**最小改造方案：**\n```python\n# 不创建新 Provider，而是创建新 Client\nclass OpenAIImageClient:\n    def __init__(self, api_key):\n        self.api_key = api_key\n        # OpenAI 特定的初始化\n    \n    def text_to_image(self, prompt, size, ...):\n        # 完全不同的实现\n        pass\n\n# Manager 中添加条件分支\nif use_openai_provider:\n    client = OpenAIImageClient(...)\nelse:\n    client = SeedreamClient(...)\n```\n\n**成本：** 500+ 行新代码 + 50+ 处条件分支\n\n---\n\n### 8. 现有扩展能力（火山引擎内部）\n\n#### **8.1 版本升级兼容性**\n\n**从 v3 → v4 的升级路径：**\n\n```\n现状：\n├── Client.text_to_image() \n│   ├─ Provider 路径（volc_v4 实现）\n│   └─ 旧路径回退（固定用 v3 参数）\n└─ 效果：可共存，但逻辑复杂（L 560-627）\n\n优势：\n- 无需修改 Manager\n- 无需修改数据库 schema\n- 仅需添加新 Provider 类\n\n劣势：\n- Client 内 fallback 逻辑复杂（3 层 try-except）\n- 没有统一的版本管理策略\n```\n\n**L 227-341 的提供商回退逻辑：**\n```python\ndef _call_seedream_provider(self, ..., preferred_provider=None):\n    order = self._get_seedream_provider_order(preferred_provider)\n    for idx, name in enumerate(order):\n        try:\n            provider = get_default_provider(name)  # 按顺序尝试\n            mapped = provider.map_t2i(...)\n            response = self._safe_json_post(...)   # HTTP 调用\n            return result, payload, endpoint, name, fb, reason, elapsed\n        except AppError as e:\n            # v4.5 特有功能失败时不回退（L 302-310）\n            if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                is_v45_feature = (payload.get(\"sequential_image_generation\") == \"auto\" ...)\n                if is_v45_feature:\n                    raise  # 不回退\n            continue\n    raise last_error\n```\n\n**关键设计：**\n- Provider 选择顺序：preferred_provider → 环境变量 → volc_v3\n- v4.5 特有功能（组图、超大尺寸）失败时不回退\n- 每次请求都尝试映射和调用（性能开销）\n\n---\n\n### 9. 总结与建议\n\n#### **9.1 当前架构评分**\n\n| 维度 | 评分 | 备注 |\n|------|------|------|\n| **代码复用性** | 6/10 | Manager 通用，但 Client 需要定制 |\n| **可维护性** | 7/10 | 三层架构清晰，但硬编码多 |\n| **可扩展性** | 5/10 | Provider 机制好，但 Client 耦合紧 |\n| **易于测试** | 6/10 | 依赖较多，但有错误处理框架 |\n| **火山引擎依赖度** | 9/10 | 深度耦合，难以替换 |\n\n#### **9.2 优化方向（若要提高可扩展性）**\n\n1. **配置中心化**\n   ```python\n   # 创建 ProviderConfig 基类\n   class ProviderConfig:\n       api_key_name: str\n       base_url: str\n       model_ids: Dict[str, str]\n       endpoints: Dict[str, str]\n       defaults: Dict[str, Any]\n   \n   # 新提供商只需继承配置\n   class OpenAIConfig(ProviderConfig):\n       api_key_name = \"openai\"\n       base_url = \"https://api.openai.com/v1\"\n       model_ids = {\"t2i\": \"dall-e-3\", ...}\n   ```\n\n2. **HTTP 调用归入 Provider**\n   ```python\n   # 当前：Provider 只做映射，HTTP 在 Client 中\n   # 改进：Provider 同时负责 HTTP 调用\n   class BaseProvider:\n       def execute_t2i(self, params) -> Result:\n           payload, fb, reason = self.map_t2i(params)\n           response = self._post(payload)  # Provider 内部实现\n           return self._handle_response(response)\n   ```\n\n3. **统一错误码映射**\n   ```python\n   # 提供商特定的错误处理\n   class ProviderErrorHandler:\n       ERROR_MAPPING = {\n           \"INSUFFICIENT_QUOTA\": ErrorType.QUOTA_ERROR,\n           ...\n       }\n   ```\n\n---\n\n### 10. 关键代码片段位置索引\n\n| 功能 | 文件 | 行号 | 备注 |\n|------|------|------|------|\n| **模型 ID** | modules/seedream/__init__.py | 15-27 | Seedream 模型列表 |\n| | modules/seedance/config.py | 8-14 | Seedance 模型 Enum |\n| **API 端点** | modules/seedance/config.py | 52-59 | 端点定义 |\n| **Provider 选择** | modules/seedream/client.py | 227-341 | 提供商回退逻辑 |\n| | modules/provider/factory.py | 14-26 | 工厂选择器 |\n| **参数映射** | modules/provider/volc.py | 23-52 | 图像映射实现 |\n| | modules/provider/volc.py | 55-180 | 视频映射实现 |\n| **参数校验** | modules/provider/schema.py | - | Schema 定义 |\n| **水印控制** | edition/watermark_service.py | - | 统一水印服务 |\n| **存储管理** | modules/storage/unified_storage_manager_v2.py | - | 统一存储层 |\n\n---\n\nThis comprehensive analysis provides a thorough examination of the Seedream and Seedance modules' implementation structure, API encapsulation, interface design, and extensibility. The architecture shows clear three-layer separation with growing abstraction (Provider layer), but is tightly coupled to Volcengine's specific requirements."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":2801,"cache_read_input_tokens":108068,"cache_creation":{"ephemeral_5m_input_tokens":2801,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"c9cff159-e06c-4182-8082-4faaf4b4b77b","timestamp":"2026-01-05T11:52:47.098Z"}
