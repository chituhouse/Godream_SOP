{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":"请帮我探索以下内容：\n\n1. 在 `components/dialogs/image_detail_dialog.py` 和 `video_detail_dialog.py` 中：\n   - `export_bundle_btn` (\"导出记录\") 按钮的功能是什么？\n   - `reference_export_btn` (\"导出选中参考图\") 按钮的功能是什么？\n   - 这两个按钮调用了什么方法？\n\n2. 在 `components/controllers/export_bundle_controller.py` 中：\n   - 这个控制器实际导出了什么内容？\n   - 成功/失败时的消息提示是如何实现的？\n\n3. 在 `components/reference_assets/actions.py` 中：\n   - `export_reference_asset` 函数做了什么？\n   - 成功/失败消息是如何显示的？\n\n4. 检查是否有右键菜单已经支持导出参考图的功能\n\n请总结这些功能的实际用途，以及是否存在功能重复。"},"uuid":"b206503a-3f79-430f-935d-b2d0fb0e7195","timestamp":"2025-12-22T06:08:35.531Z"}
{"parentUuid":"b206503a-3f79-430f-935d-b2d0fb0e7195","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019YCSPm5AkeEJrgvKiDMWyK","type":"message","role":"assistant","content":[{"type":"text","text":"我来帮你探索这些导出功能的实现。让我开始进行多并行搜索。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20890,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20890,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"fc63f4cb-523d-451c-ad84-52b25a3291e5","timestamp":"2025-12-22T06:08:38.263Z"}
{"parentUuid":"fc63f4cb-523d-451c-ad84-52b25a3291e5","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019YCSPm5AkeEJrgvKiDMWyK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NCuSC7zXEt9btaKggm2CaY","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20890,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20890,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"16ce107b-5496-4bd4-90cd-c134746feefb","timestamp":"2025-12-22T06:08:38.626Z"}
{"parentUuid":"16ce107b-5496-4bd4-90cd-c134746feefb","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019YCSPm5AkeEJrgvKiDMWyK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WtSGZfaVwJpDyDYVTRkxYQ","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20890,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20890,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f988d3cb-f800-4fb4-bbe4-3294846f25a9","timestamp":"2025-12-22T06:08:38.907Z"}
{"parentUuid":"f988d3cb-f800-4fb4-bbe4-3294846f25a9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019YCSPm5AkeEJrgvKiDMWyK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018aFYCX2evSpS9T3Ha7e85g","name":"Glob","input":{"pattern":"**/export_bundle_controller.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20890,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20890,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"30112db3-b14e-4e31-8674-581c6e0fa463","timestamp":"2025-12-22T06:08:39.110Z"}
{"parentUuid":"30112db3-b14e-4e31-8674-581c6e0fa463","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_019YCSPm5AkeEJrgvKiDMWyK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E69kvA9JbypCSWEUftjyv3","name":"Glob","input":{"pattern":"**/reference_assets/actions.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20890,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20890,"ephemeral_1h_input_tokens":0},"output_tokens":259,"service_tier":"standard"}},"type":"assistant","uuid":"9322ceb8-e9ee-4d87-84fc-d122086b3392","timestamp":"2025-12-22T06:08:39.239Z"}
{"parentUuid":"9322ceb8-e9ee-4d87-84fc-d122086b3392","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E69kvA9JbypCSWEUftjyv3","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/actions.py"}]},"uuid":"66010ba2-fa2c-46ae-b0c9-3320e7436be2","timestamp":"2025-12-22T06:08:39.321Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/actions.py"],"durationMs":36,"numFiles":1,"truncated":false}}
{"parentUuid":"66010ba2-fa2c-46ae-b0c9-3320e7436be2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018aFYCX2evSpS9T3Ha7e85g","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/controllers/export_bundle_controller.py"}]},"uuid":"a4fb103f-d3a4-464a-9300-22efa7a4bbe1","timestamp":"2025-12-22T06:08:39.322Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/components/controllers/export_bundle_controller.py"],"durationMs":38,"numFiles":1,"truncated":false}}
{"parentUuid":"a4fb103f-d3a4-464a-9300-22efa7a4bbe1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NCuSC7zXEt9btaKggm2CaY","type":"tool_result","content":"     1→import os\n     2→import json\n     3→from datetime import datetime\n     4→from typing import Dict, Any, List, Optional\n     5→\n     6→from PySide6.QtWidgets import (\n     7→    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n     8→    QTextEdit, QFileDialog, QMessageBox, QSplitter, QApplication,\n     9→    QMenu, QSizePolicy\n    10→)\n    11→from PySide6.QtGui import QAction, QShortcut\n    12→from PySide6.QtCore import Qt, QTimer, QSize, QEvent\n    13→from PySide6.QtGui import QPixmap, QKeySequence\n    14→\n    15→from utils.logger import logger\n    16→from utils.style_system import unified_style_system\n    17→from components.widgets import ZoomableImageLabel, ClickableLabel\n    18→from components.reference_assets import (\n    19→    ReferenceGalleryWidget,\n    20→    export_reference_asset,\n    21→    open_reference_preview,\n    22→    _find_reference_asset_index,\n    23→)\n    24→from components.controllers import ExportBundleController\n    25→from utils.reference_assets import resolve_asset_path\n    26→from utils.reference_display import ensure_reference_info, resolve_reference_assets\n    27→from PySide6.QtCore import Signal\n    28→\n    29→class ImageDetailDialog(QDialog):\n    30→    \"\"\"图片详细信息对话框\"\"\"\n    31→    \n    32→    # 删除记录后发出信号，通知父视图刷新\n    33→    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    34→    \n    35→    def __init__(self, image_data: Dict[str, Any], image_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n    36→        super().__init__(parent)\n    37→        self.image_data = image_data\n    38→        self.image_list = image_list or [image_data]  # 图片列表\n    39→        self.current_index = current_index  # 当前图片索引\n    40→        self.zoom_factor = 1.0  # 缩放因子\n    41→        self.is_fullscreen = False  # 全屏状态\n    42→        self.original_geometry = None  # 原始窗口几何\n    43→        self._reference_summary = ensure_reference_info(self.image_data)\n    44→        self._reference_assets: List[Dict[str, Any]] = []\n    45→        self._export_controller = ExportBundleController(self, \"image\")\n    46→        \n    47→        # Subscribe to theme changes\n    48→        unified_style_system.styleChanged.connect(self._update_theme)\n    49→        \n    50→        self.setup_ui()\n    51→        \n    52→    def setup_ui(self):\n    53→        \"\"\"设置UI\"\"\"\n    54→        self.setWindowTitle(\"图片详细信息\")\n    55→        self.resize(1100, 800)  # 改为可调整大小\n    56→        self.setMinimumSize(800, 600)  # 设置最小尺寸\n    57→        \n    58→        # 设置焦点策略，确保能接收键盘事件\n    59→        self.setFocusPolicy(Qt.StrongFocus)\n    60→        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n    61→        self.setFocus()\n    62→\n    63→        # 确保窗口激活时获得焦点\n    64→        self.activateWindow()\n    65→        self.raise_()\n    66→\n    67→        try:\n    68→            self.setObjectName(\"DetailDialog\")\n    69→        except Exception:\n    70→            pass\n    71→\n    72→        self._focus_timer = QTimer(self)\n    73→        self._focus_timer.setSingleShot(True)\n    74→        self._focus_timer.timeout.connect(self._ensure_focus)\n    75→\n    76→        layout = QHBoxLayout(self)\n    77→        \n    78→        # 左侧：大图显示（占70%宽度）\n    79→        left_widget = QWidget()\n    80→        left_layout = QVBoxLayout(left_widget)\n    81→        left_layout.setContentsMargins(0, 0, 0, 0)\n    82→        \n    83→        # 图片显示区域（占据上方全部空间）\n    84→        image_container = QWidget()\n    85→        image_container.setObjectName(\"ImageContainer\")\n    86→        image_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n    87→\n    88→        # 在容器内创建布局\n    89→        container_layout = QVBoxLayout(image_container)\n    90→        container_layout.setContentsMargins(0, 0, 0, 0)\n    91→        container_layout.setSpacing(0)\n    92→\n    93→        # 使用可缩放的图片标签，自适应容器大小\n    94→        self.large_image_label = ZoomableImageLabel()\n    95→        self.large_image_label.setAlignment(Qt.AlignCenter)\n    96→        self.large_image_label.setStyleSheet(\"border: none; background-color: transparent;\")\n    97→        \n    98→        # 设置右键菜单\n    99→        self.large_image_label.setContextMenuPolicy(Qt.CustomContextMenu)\n   100→        self.large_image_label.customContextMenuRequested.connect(self.show_context_menu)\n   101→        \n   102→        # 加载大图\n   103→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   104→        if image_path and os.path.exists(image_path):\n   105→            pixmap = QPixmap(image_path)\n   106→            if not pixmap.isNull():\n   107→                self.large_image_label.setPixmap(pixmap)\n   108→        \n   109→        container_layout.addWidget(self.large_image_label, 1)\n   110→\n   111→        reference_section = QWidget()\n   112→        reference_section.setObjectName(\"ReferenceSection\")\n   113→        reference_section.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   114→        reference_section_layout = QVBoxLayout(reference_section)\n   115→        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n   116→        reference_section_layout.setSpacing(8)\n   117→\n   118→        self.reference_gallery = ReferenceGalleryWidget()\n   119→        self.reference_gallery.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   120→        try:\n   121→            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n   122→            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n   123→            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n   124→        except Exception:\n   125→            pass\n   126→        reference_section_layout.addWidget(self.reference_gallery, 1)\n   127→\n   128→        reference_button_layout = QHBoxLayout()\n   129→        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n   130→        reference_button_layout.setSpacing(6)\n   131→        self.export_status_label = QLabel(\"\")\n   132→        self.export_status_label.setObjectName(\"infoLabel\")\n   133→        unified_style_system.apply_to_widget(self.export_status_label)\n   134→        reference_button_layout.addWidget(self.export_status_label)\n   135→        reference_button_layout.addStretch(1)\n   136→        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n   137→        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n   138→        self.reference_export_btn.setEnabled(False)\n   139→        unified_style_system.apply_to_widget(self.reference_export_btn)\n   140→        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n   141→        reference_button_layout.addWidget(self.reference_export_btn)\n   142→        self.export_bundle_btn = QPushButton(\"导出记录\")\n   143→        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n   144→        self.export_bundle_btn.setEnabled(False)\n   145→        unified_style_system.apply_to_widget(self.export_bundle_btn)\n   146→        self._export_controller.configure(\n   147→            self.export_bundle_btn,\n   148→            self.export_status_label,\n   149→            self._resolve_record_id,\n   150→            context_widget=self,\n   151→        )\n   152→        reference_button_layout.addWidget(self.export_bundle_btn)\n   153→        reference_section_layout.addLayout(reference_button_layout)\n   154→\n   155→        self._image_reference_splitter = QSplitter(Qt.Vertical)\n   156→        self._image_reference_splitter.setObjectName(\"ImageReferenceSplitter\")\n   157→        self._image_reference_splitter.setChildrenCollapsible(False)\n   158→        self._image_reference_splitter.setHandleWidth(6)\n   159→        self._image_reference_splitter.addWidget(image_container)\n   160→        self._image_reference_splitter.addWidget(reference_section)\n   161→        self._image_reference_splitter.setStretchFactor(0, 3)\n   162→        self._image_reference_splitter.setStretchFactor(1, 2)\n   163→        self._image_reference_splitter.setSizes([520, 280])\n   164→\n   165→        left_layout.addWidget(self._image_reference_splitter, 1)\n   166→\n   167→        # 底部区域：导航按钮 + 说明文本框（与右侧参数栏高度对齐）\n   168→        bottom_layout = QHBoxLayout()\n   169→        bottom_layout.setContentsMargins(0, 5, 0, 5)\n   170→        bottom_layout.setSpacing(10)\n   171→        \n   172→        # 向左按钮\n   173→        self.prev_btn = QPushButton(\"◀\")\n   174→        self.prev_btn.setFixedSize(30, 30)  # 固定尺寸\n   175→        self.prev_btn.setObjectName(\"NavButton\")\n   176→        unified_style_system.apply_to_widget(self.prev_btn)\n   177→        self.prev_btn.clicked.connect(self.show_previous_image)\n   178→        bottom_layout.addWidget(self.prev_btn)\n   179→        \n   180→        # 中间的说明文本框（完全透明设计）\n   181→        zoom_info = QLabel(\"提示：鼠标位置缩放，点击拖拽，双击重置\")\n   182→        zoom_info.setObjectName(\"infoLabel\")\n   183→        unified_style_system.apply_to_widget(zoom_info)\n   184→        zoom_info.setAlignment(Qt.AlignCenter)\n   185→        zoom_info.setMinimumHeight(30)  # 与按钮高度一致\n   186→        zoom_info.setMaximumHeight(30)  # 固定高度，防止文字被压缩\n   187→        bottom_layout.addWidget(zoom_info, 1)  # 占据中间所有空间\n   188→        \n   189→        # 向右按钮\n   190→        self.next_btn = QPushButton(\"▶\")\n   191→        self.next_btn.setFixedSize(30, 30)  # 固定尺寸\n   192→        self.next_btn.setObjectName(\"NavButton\")\n   193→        unified_style_system.apply_to_widget(self.next_btn)\n   194→        self.next_btn.clicked.connect(self.show_next_image)\n   195→        bottom_layout.addWidget(self.next_btn)\n   196→        \n   197→        left_layout.addLayout(bottom_layout)\n   198→\n   199→        # 更新导航按钮状态\n   200→        self.update_navigation_buttons()\n   201→        self._refresh_reference_gallery()\n   202→        self._export_controller.refresh()\n   203→\n   204→        # 右侧：详细信息（固定30%宽度）\n   205→        right_layout = QVBoxLayout()\n   206→        \n   207→        # 创建参数显示区域（不使用滚动条）\n   208→        params_widget = QWidget()\n   209→        params_widget.setFixedWidth(int(self.width() * 0.3))  # 固定30%宽度\n   210→        params_widget.setObjectName(\"ParamsWidget\")\n   211→        self.params_layout = QVBoxLayout(params_widget)  # 保存引用以便后续更新\n   212→        self.params_layout.setSpacing(0)  # 设置间距为0\n   213→        self.params_layout.setContentsMargins(5, 5, 5, 5)  # 设置紧凑的边距\n   214→\n   215→        # === 固定组件：提示词区域（只创建一次，不随记录切换重建）===\n   216→        self.prompt_label = QLabel(\"<b>提示词:</b>\")\n   217→        self.prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   218→        unified_style_system.apply_to_widget(self.prompt_label)\n   219→        self.params_layout.addWidget(self.prompt_label)\n   220→\n   221→        self.prompt_text_edit = QTextEdit()\n   222→        self.prompt_text_edit.setReadOnly(True)\n   223→        self.prompt_text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n   224→        self.prompt_text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n   225→        # 约 4 行高度\n   226→        try:\n   227→            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n   228→            height = line_height * 4 + 18  # padding + border\n   229→            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n   230→        except Exception:\n   231→            self.prompt_text_edit.setMaximumHeight(96)\n   232→            self.prompt_text_edit.setMinimumHeight(96)\n   233→        unified_style_system.apply_to_widget(self.prompt_text_edit)\n   234→        self.params_layout.addWidget(self.prompt_text_edit)\n   235→\n   236→        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n   237→        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n   238→        self.copy_prompt_btn.setMaximumHeight(30)\n   239→        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n   240→        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n   241→        self.params_layout.addWidget(self.copy_prompt_btn)\n   242→\n   243→        # 参数标签列表（动态填充）\n   244→        self.param_labels = []\n   245→\n   246→        # 初始化参数显示区域（填充动态内容）\n   247→        self.setup_params_area()\n   248→        \n   249→        \n   250→        right_layout.addWidget(params_widget)\n   251→        \n   252→        # 全屏和复制图片按钮（与参数区底部对齐）\n   253→        image_control_layout = QHBoxLayout()\n   254→\n   255→        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n   256→        self.fullscreen_btn.setMaximumHeight(30)\n   257→        unified_style_system.apply_to_widget(self.fullscreen_btn)\n   258→        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n   259→        image_control_layout.addWidget(self.fullscreen_btn)\n   260→\n   261→        self.copy_image_btn = QPushButton(\"复制图片\")\n   262→        self.copy_image_btn.setMaximumHeight(30)\n   263→        unified_style_system.apply_to_widget(self.copy_image_btn)\n   264→        self.copy_image_btn.clicked.connect(self.copy_image)\n   265→        image_control_layout.addWidget(self.copy_image_btn)\n   266→\n   267→        right_layout.addLayout(image_control_layout)\n   268→\n   269→        # 其他按钮\n   270→        button_layout = QHBoxLayout()\n   271→\n   272→        self.delete_btn = QPushButton(\"删除记录\")\n   273→        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n   274→        self.delete_btn.clicked.connect(self._delete_current_record)\n   275→        button_layout.addWidget(self.delete_btn)\n   276→\n   277→        self.close_btn = QPushButton(\"关闭（ESC）\")\n   278→        unified_style_system.apply_to_widget(self.close_btn)\n   279→        self.close_btn.clicked.connect(self.accept)\n   280→        button_layout.addWidget(self.close_btn)\n   281→        \n   282→        right_layout.addLayout(button_layout)\n   283→        \n   284→        # 设置布局比例：左侧70%，右侧30%\n   285→        layout.addWidget(left_widget, 7)\n   286→        layout.addLayout(right_layout, 3)\n   287→        \n   288→        # 添加键盘快捷键\n   289→        self.setup_shortcuts()\n   290→\n   291→        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n   292→        self._focus_timer.start(100)\n   293→\n   294→        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n   295→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   296→        \n   297→        # Apply initial theme\n   298→        self._update_theme()\n   299→    \n   300→    def format_time(self, time_str: str) -> str:\n   301→        \"\"\"格式化时间显示\"\"\"\n   302→        if not time_str:\n   303→            return '未知时间'\n   304→        try:\n   305→            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n   306→            return dt.strftime('%Y-%m-%d %H:%M:%S')\n   307→        except:\n   308→            return time_str[:19] if len(time_str) > 19 else time_str\n   309→    \n   310→    def format_file_size(self, size) -> str:\n   311→        \"\"\"格式化文件大小显示\"\"\"\n   312→        # 处理字符串类型的size\n   313→        try:\n   314→            size = float(size) if size else 0\n   315→        except (ValueError, TypeError):\n   316→            return '未知大小'\n   317→            \n   318→        if size == 0:\n   319→            return '未知大小'\n   320→        \n   321→        for unit in ['B', 'KB', 'MB', 'GB']:\n   322→            if size < 1024.0:\n   323→                return f\"{size:.1f} {unit}\"\n   324→            size /= 1024.0\n   325→        return f\"{size:.1f} TB\"\n   326→    \n   327→    def setup_shortcuts(self):\n   328→        \"\"\"设置键盘快捷键\"\"\"\n   329→        # 移除所有QShortcut，统一使用keyPressEvent处理\n   330→        # 避免快捷键冲突问题\n   331→        pass\n   332→    \n   333→    def _ensure_focus(self):\n   334→        \"\"\"确保窗口获得焦点\"\"\"\n   335→        self.activateWindow()\n   336→        self.raise_()\n   337→        self.setFocus()\n   338→        logger.debug(f\"[FOCUS] ImageDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n   339→        \n   340→    def toggle_fullscreen(self):\n   341→        \"\"\"切换全屏模式\"\"\"\n   342→        if self.is_fullscreen:\n   343→            self.exit_fullscreen()\n   344→        else:\n   345→            self.enter_fullscreen()\n   346→            \n   347→    def enter_fullscreen(self):\n   348→        \"\"\"进入全屏模式\"\"\"\n   349→        if not self.is_fullscreen:\n   350→            self.original_geometry = self.geometry()\n   351→            self.showFullScreen()\n   352→            self.is_fullscreen = True\n   353→            \n   354→    def exit_fullscreen(self):\n   355→        \"\"\"退出全屏模式\"\"\"\n   356→        if self.is_fullscreen:\n   357→            self.showNormal()\n   358→            if self.original_geometry:\n   359→                self.setGeometry(self.original_geometry)\n   360→            self.is_fullscreen = False\n   361→            \n   362→    def handle_escape_key(self):\n   363→        \"\"\"处理ESC键：如果是全屏则退出全屏，否则关闭对话框\"\"\"\n   364→        if self.is_fullscreen:\n   365→            self.exit_fullscreen()\n   366→        else:\n   367→            self.accept()  # 关闭对话框\n   368→            \n   369→    def copy_text_to_clipboard(self, text: str):\n   370→        \"\"\"复制文本到剪贴板并显示提示\"\"\"\n   371→        from PySide6.QtWidgets import QApplication\n   372→        clipboard = QApplication.clipboard()\n   373→        clipboard.setText(text)\n   374→        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n   375→        \n   376→    def show_copy_toast(self, message: str):\n   377→        \"\"\"显示复制成功的轻量提示\"\"\"\n   378→        # 创建一个临时的提示标签\n   379→        toast = QLabel(message, self)\n   380→        toast.setObjectName(\"ToastLabel\")\n   381→        toast.setAlignment(Qt.AlignCenter)\n   382→        toast.adjustSize()\n   383→        \n   384→        # 定位到窗口中央偏上\n   385→        x = (self.width() - toast.width()) // 2\n   386→        y = self.height() // 4\n   387→        toast.move(x, y)\n   388→        toast.show()\n   389→        \n   390→        # 2秒后自动隐藏\n   391→        QTimer.singleShot(2000, toast.deleteLater)\n   392→        \n   393→    def copy_prompt(self):\n   394→        \"\"\"复制提示词到剪贴板\"\"\"\n   395→        prompt_content = self.prompt_text_edit.toPlainText()\n   396→        self.copy_text_to_clipboard(prompt_content)\n   397→    \n   398→    def copy_image(self):\n   399→        \"\"\"复制图片到剪贴板\"\"\"\n   400→        from PySide6.QtWidgets import QApplication\n   401→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   402→        if image_path and os.path.exists(image_path):\n   403→            pixmap = QPixmap(image_path)\n   404→            if not pixmap.isNull():\n   405→                clipboard = QApplication.clipboard()\n   406→                clipboard.setPixmap(pixmap)\n   407→                self.show_copy_toast(\"图片已复制到剪贴板\")\n   408→            else:\n   409→                self.show_copy_toast(\"无法复制图片\")\n   410→        else:\n   411→            self.show_copy_toast(\"图片文件不存在\")\n   412→    \n   413→    def copy_all_info(self):\n   414→        \"\"\"复制所有信息到剪贴板\"\"\"\n   415→        from PySide6.QtWidgets import QApplication\n   416→        \n   417→        params = self.image_data.get('parameters', '{}')\n   418→        if isinstance(params, str):\n   419→            try:\n   420→                params = json.loads(params)\n   421→            except:\n   422→                params = {}\n   423→        \n   424→        info_text = f\"\"\"图片详细信息\n   425→===================\n   426→提示词: {self.image_data.get('prompt', '无提示词')}\n   427→尺寸: {params.get('size', '未知')}\n   428→种子值: {params.get('seed', '未知')}\n   429→引导强度: {params.get('guidance_scale', '未知')}\n   430→生成模型: {params.get('model', '未知模型')}\n   431→生成时间: {self.format_time(self.image_data.get('created_at', ''))}\n   432→文件大小: {self.format_file_size(self.image_data.get('file_size', 0))}\n   433→文件路径: {self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')}\n   434→\"\"\"\n   435→        \n   436→        clipboard = QApplication.clipboard()\n   437→        clipboard.setText(info_text)\n   438→        self.show_copy_toast(\"所有信息已复制到剪贴板\")\n   439→\n   440→    def show_copy_message(self, message: str):\n   441→        \"\"\"显示复制成功消息（已弃用，使用show_copy_toast代替）\"\"\"\n   442→        # 直接使用轻量级Toast提示\n   443→        self.show_copy_toast(message)\n   444→\n   445→    def _delete_current_record(self):\n   446→        \"\"\"删除当前记录及相关文件\"\"\"\n   447→        record_id = self._resolve_record_id()\n   448→        if not record_id:\n   449→            self.show_copy_toast(\"无法获取记录ID\")\n   450→            return\n   451→        \n   452→        try:\n   453→            # 获取 RepositoryManager\n   454→            from config_api import get_storage_dir\n   455→            from modules.repository.manager import RepositoryManager\n   456→            \n   457→            storage_dir = get_storage_dir()\n   458→            repo = RepositoryManager(storage_dir)\n   459→            \n   460→            # 执行删除\n   461→            if repo.delete_record_with_files(record_id):\n   462→                self.show_copy_toast(\"记录已删除\")\n   463→                \n   464→                # 发出信号通知父视图刷新\n   465→                self.recordDeleted.emit(record_id)\n   466→                \n   467→                # 从列表中移除当前记录\n   468→                if len(self.image_list) > 1:\n   469→                    del self.image_list[self.current_index]\n   470→                    \n   471→                    # 导航到后一条记录（保持索引，指向原来的下一条）\n   472→                    # 只有当删除的是最后一条时，才需要调整索引\n   473→                    if self.current_index >= len(self.image_list):\n   474→                        self.current_index = len(self.image_list) - 1\n   475→                    \n   476→                    self.load_current_image()\n   477→                    self.update_navigation_buttons()\n   478→                else:\n   479→                    # 只剩一条记录，关闭对话框\n   480→                    self.accept()\n   481→            else:\n   482→                self.show_copy_toast(\"删除失败\")\n   483→        except Exception as e:\n   484→            from utils.logger import logger\n   485→            logger.error(f\"删除记录异常: {e}\")\n   486→            self.show_copy_toast(f\"删除失败: {str(e)}\")\n   487→\n   488→    def _on_reference_clicked(self, asset: Dict[str, Any]):\n   489→        assets = list(self._reference_assets) if self._reference_assets else [asset]\n   490→        start_idx = _find_reference_asset_index(assets, asset)\n   491→        open_reference_preview(\n   492→            self,\n   493→            asset,\n   494→            title_prefix=\"参考图\",\n   495→            asset_list=assets,\n   496→            start_index=start_idx,\n   497→            on_asset_changed=self._sync_reference_selection,\n   498→        )\n   499→\n   500→    def _on_reference_export(self, asset: Dict[str, Any]):\n   501→        export_reference_asset(self, asset)\n   502→\n   503→    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n   504→        asset_path = resolve_asset_path(asset) if isinstance(asset, dict) else None\n   505→        has_path = bool(asset_path)\n   506→        if hasattr(self, 'reference_export_btn'):\n   507→            self.reference_export_btn.setEnabled(has_path)\n   508→\n   509→    def _export_selected_reference(self):\n   510→        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n   511→        if not asset:\n   512→            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n   513→            return\n   514→        export_reference_asset(self, asset)\n   515→\n   516→    def _refresh_reference_gallery(self):\n   517→        if not hasattr(self, 'reference_gallery'):\n   518→            return\n   519→        self._reference_summary = ensure_reference_info(self.image_data)\n   520→        if self._reference_summary.get('count', 0) <= 0:\n   521→            self.reference_gallery.clear()\n   522→            self.reference_gallery.setVisible(False)\n   523→            if hasattr(self, 'reference_export_btn'):\n   524→                self.reference_export_btn.setEnabled(False)\n   525→            self._reference_assets = []\n   526→            self._export_controller.refresh()\n   527→            return\n   528→        try:\n   529→            self._reference_assets = resolve_reference_assets(self.image_data, absolute=True)\n   530→        except Exception:\n   531→            self._reference_assets = []\n   532→        self.reference_gallery.setVisible(True)\n   533→        self.reference_gallery.set_assets(self._reference_assets)\n   534→        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n   535→        self._export_controller.refresh()\n   536→\n   537→    def _sync_reference_selection(self, asset: Dict[str, Any]):\n   538→        try:\n   539→            self.reference_gallery.select_asset(asset)\n   540→        except Exception:\n   541→            pass\n   542→\n   543→    def _resolve_record_id(self) -> Optional[str]:\n   544→        for key in (\"file_id\", \"id\", \"generation_id\"):\n   545→            value = self.image_data.get(key)\n   546→            if value not in (None, \"\"):\n   547→                return str(value)\n   548→        return None\n   549→\n   550→    def show_context_menu(self, position):\n   551→        \"\"\"显示右键菜单\"\"\"\n   552→        from PySide6.QtWidgets import QMenu\n   553→        from PySide6.QtGui import QAction, QShortcut\n   554→        \n   555→        menu = QMenu(self)\n   556→        \n   557→        # 复制图片动作\n   558→        copy_action = QAction(\"复制图片\", self)\n   559→        copy_action.triggered.connect(self.copy_image)\n   560→        menu.addAction(copy_action)\n   561→        \n   562→        # 下载图片动作\n   563→        download_action = QAction(\"下载图片\", self)\n   564→        download_action.triggered.connect(self.download_image)\n   565→        menu.addAction(download_action)\n   566→        \n   567→        # 显示菜单\n   568→        menu.exec(self.large_image_label.mapToGlobal(position))\n   569→    \n   570→    def download_image(self):\n   571→        \"\"\"下载图片到指定位置\"\"\"\n   572→        from PySide6.QtWidgets import QFileDialog, QMessageBox\n   573→        import shutil\n   574→        \n   575→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   576→        if not image_path or not os.path.exists(image_path):\n   577→            self.show_styled_message(\"错误\", \"图片文件不存在\", \"warning\")\n   578→            return\n   579→        \n   580→        # 获取原始文件名\n   581→        original_filename = os.path.basename(image_path)\n   582→        \n   583→        # 打开保存对话框\n   584→        save_path, _ = QFileDialog.getSaveFileName(\n   585→            self,\n   586→            \"保存图片\",\n   587→            original_filename,\n   588→            \"图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)\"\n   589→        )\n   590→        \n   591→        if save_path:\n   592→            try:\n   593→                shutil.copy2(image_path, save_path)\n   594→                self.show_styled_message(\"成功\", f\"图片已保存到:\\n{save_path}\", \"information\")\n   595→            except Exception as e:\n   596→                self.show_styled_message(\"错误\", f\"保存图片失败:\\n{str(e)}\", \"critical\")\n   597→    \n   598→    def update_navigation_buttons(self):\n   599→        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n   600→        # 检查是否有图片列表\n   601→        if len(self.image_list) <= 1:\n   602→            self.prev_btn.setEnabled(False)\n   603→            self.next_btn.setEnabled(False)\n   604→            self.prev_btn.setToolTip(\"没有更多图片\")\n   605→            self.next_btn.setToolTip(\"没有更多图片\")\n   606→            return\n   607→        \n   608→        # 更新按钮状态（基于有效记录检查）\n   609→        self.prev_btn.setEnabled(self._has_valid_previous_record())\n   610→        self.next_btn.setEnabled(self._has_valid_next_record())\n   611→        \n   612→        # 更新工具提示显示当前位置和快捷键信息\n   613→        current_pos = f\"({self.current_index + 1}/{len(self.image_list)})\"\n   614→        self.prev_btn.setToolTip(f\"上一张 {current_pos} - 快捷键: ←\")\n   615→        self.next_btn.setToolTip(f\"下一张 {current_pos} - 快捷键: →\")\n   616→        \n   617→        # 按钮文本保持简洁的箭头符号\n   618→        self.prev_btn.setText(\"◀\")\n   619→    \n   620→    def _has_valid_previous_record(self):\n   621→        \"\"\"检查是否有有效的上一个记录\"\"\"\n   622→        for i in range(self.current_index - 1, -1, -1):\n   623→            candidate_data = self.image_list[i]\n   624→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   625→            if file_path and os.path.exists(file_path):\n   626→                return True\n   627→        return False\n   628→    \n   629→    def _has_valid_next_record(self):\n   630→        \"\"\"检查是否有有效的下一个记录\"\"\"\n   631→        for i in range(self.current_index + 1, len(self.image_list)):\n   632→            candidate_data = self.image_list[i]\n   633→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   634→            if file_path and os.path.exists(file_path):\n   635→                return True\n   636→        return False\n   637→    \n   638→    def show_previous_image(self):\n   639→        \"\"\"显示上一张图片（带有效性验证）\"\"\"\n   640→        # 寻找上一个有效记录\n   641→        for i in range(self.current_index - 1, -1, -1):\n   642→            candidate_data = self.image_list[i]\n   643→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   644→            \n   645→            if file_path and os.path.exists(file_path):\n   646→                # 找到有效记录\n   647→                self.current_index = i\n   648→                self.load_current_image()\n   649→                self.update_navigation_buttons()\n   650→                return\n   651→        \n   652→        # 没有找到有效的上一个记录，保持当前状态\n   653→        self.update_navigation_buttons()\n   654→    \n   655→    def show_next_image(self):\n   656→        \"\"\"显示下一张图片（带有效性验证）\"\"\"\n   657→        # 寻找下一个有效记录\n   658→        for i in range(self.current_index + 1, len(self.image_list)):\n   659→            candidate_data = self.image_list[i]\n   660→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   661→            \n   662→            if file_path and os.path.exists(file_path):\n   663→                # 找到有效记录\n   664→                self.current_index = i\n   665→                self.load_current_image()\n   666→                self.update_navigation_buttons()\n   667→                return\n   668→        \n   669→        # 没有找到有效的下一个记录，保持当前状态\n   670→        self.update_navigation_buttons()\n   671→    \n   672→    def load_current_image(self):\n   673→        \"\"\"加载当前索引的图片\"\"\"\n   674→        if 0 <= self.current_index < len(self.image_list):\n   675→            # 更新当前图片数据\n   676→            self.image_data = self.image_list[self.current_index]\n   677→            \n   678→            # 重新加载图片\n   679→            image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '') or self.image_data.get('file_path', '')\n   680→            if image_path and os.path.exists(image_path):\n   681→                pixmap = QPixmap(image_path)\n   682→                if not pixmap.isNull():\n   683→                    self.large_image_label.setPixmap(pixmap)\n   684→                else:\n   685→                    self.large_image_label.setText(\"图片加载失败\")\n   686→            else:\n   687→                self.large_image_label.setText(\"图片不存在\")\n   688→            \n   689→            # 更新窗口标题\n   690→            self.setWindowTitle(f\"图片详细信息 ({self.current_index + 1}/{len(self.image_list)})\")\n   691→            \n   692→            # 更新提示词内容\n   693→            prompt_content = self.image_data.get('prompt', '无提示词')\n   694→            self.prompt_text_edit.setPlainText(prompt_content)\n   695→            \n   696→            # 更新参数信息\n   697→            self.update_params_area()\n   698→            self._refresh_reference_gallery()\n   699→\n   700→        self._export_controller.refresh()\n   701→    \n   702→    def setup_params_area(self):\n   703→        \"\"\"更新参数显示区域（只更新内容和动态标签，固定组件在 setup_ui 中创建）\"\"\"\n   704→        # 1. 更新提示词内容（固定组件，只更新文本）\n   705→        prompt_content = self.image_data.get('prompt', '') or '无提示词'\n   706→        if hasattr(self, 'prompt_text_edit'):\n   707→            self.prompt_text_edit.setPlainText(prompt_content)\n   708→\n   709→        # 2. 清理旧的动态标签（保留前3个固定组件）\n   710→        self._clear_param_labels()\n   711→\n   712→        # 3. 重建动态参数标签\n   713→        self.create_param_labels()\n   714→\n   715→    def _clear_param_labels(self):\n   716→        \"\"\"只清理动态参数标签，保留固定组件（prompt_label, prompt_text_edit, copy_prompt_btn）\"\"\"\n   717→        # 清理已保存的参数标签引用\n   718→        if hasattr(self, 'param_labels') and self.param_labels:\n   719→            for label_widget, value_widget in self.param_labels:\n   720→                self.params_layout.removeWidget(label_widget)\n   721→                self.params_layout.removeWidget(value_widget)\n   722→                label_widget.hide()\n   723→                value_widget.hide()\n   724→                label_widget.deleteLater()\n   725→                value_widget.deleteLater()\n   726→            self.param_labels.clear()\n   727→\n   728→        # 移除末尾的 stretch（固定组件是前3个：prompt_label, prompt_text_edit, copy_prompt_btn）\n   729→        while self.params_layout.count() > 3:\n   730→            item = self.params_layout.takeAt(3)\n   731→            if item.widget():\n   732→                w = item.widget()\n   733→                w.hide()\n   734→                w.deleteLater()\n   735→            elif item.spacerItem():\n   736→                del item\n   737→    \n   738→    def _update_theme(self):\n   739→        \"\"\"响应主题变化\"\"\"\n   740→        colors = unified_style_system.get_colors()\n   741→        logger.info(f\"[ImageDetailDialog] _update_theme called. Surface color: {colors.get('palette.neutral.bg_surface')}\")\n   742→        \n   743→        # Apply theme to self (Dialog)\n   744→        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n   745→        text_color = colors.get('text') or colors.get('palette.text.primary')\n   746→        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n   747→        bg_input = colors.get('palette.neutral.bg_input') or bg_card\n   748→        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   749→        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n   750→        \n   751→        self.setStyleSheet(f\"\"\"\n   752→            QDialog {{\n   753→                background-color: {bg_color};\n   754→                color: {text_color};\n   755→            }}\n   756→            QLabel {{\n   757→                color: {text_color};\n   758→            }}\n   759→            QWidget#ParamsWidget {{\n   760→                 background-color: {bg_card};\n   761→                 border-left: 1px solid {border_subtle};\n   762→            }}\n   763→        \"\"\")\n   764→\n   765→        if hasattr(self, 'prompt_text_edit'):\n   766→            self.prompt_text_edit.setStyleSheet(f\"\"\"\n   767→                QTextEdit {{\n   768→                    background-color: {bg_input};\n   769→                    color: {text_color};\n   770→                    border: 1px solid {border_subtle};\n   771→                    border-radius: 8px;\n   772→                    padding: 8px;\n   773→                }}\n   774→                QTextEdit:focus {{\n   775→                    border-color: {brand};\n   776→                }}\n   777→            \"\"\")\n   778→\n   779→        # Reapply button styles (including fixed components)\n   780→        if hasattr(self, 'copy_prompt_btn'):\n   781→            unified_style_system.apply_to_widget(self.copy_prompt_btn)\n   782→        if hasattr(self, 'fullscreen_btn'):\n   783→            unified_style_system.apply_to_widget(self.fullscreen_btn)\n   784→        if hasattr(self, 'copy_image_btn'):\n   785→            unified_style_system.apply_to_widget(self.copy_image_btn)\n   786→        if hasattr(self, 'delete_btn'):\n   787→            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n   788→        if hasattr(self, 'close_btn'):\n   789→            unified_style_system.apply_to_widget(self.close_btn)\n   790→        if hasattr(self, 'reference_export_btn'):\n   791→            unified_style_system.apply_to_widget(self.reference_export_btn)\n   792→        if hasattr(self, 'export_bundle_btn'):\n   793→            unified_style_system.apply_to_widget(self.export_bundle_btn)\n   794→        if hasattr(self, 'prev_btn'):\n   795→            unified_style_system.apply_to_widget(self.prev_btn)\n   796→        if hasattr(self, 'next_btn'):\n   797→            unified_style_system.apply_to_widget(self.next_btn)\n   798→\n   799→        # Rebuild dynamic param labels (fixed components already refreshed above)\n   800→        self.setup_params_area()\n   801→\n   802→    def create_param_labels(self):\n   803→        \"\"\"创建动态参数标签（由 setup_params_area 调用，清理已在 _clear_param_labels 中完成）\"\"\"\n   804→        # 解析生成参数\n   805→        params = self.image_data.get('parameters', '{}')\n   806→        if isinstance(params, str):\n   807→            try:\n   808→                params = json.loads(params)\n   809→            except:\n   810→                params = {}\n   811→        \n   812→        # 详细信息\n   813→        info_items = [\n   814→            (\"尺寸\", f\"{params.get('size', '未知')}\"),\n   815→            (\"种子值\", f\"{params.get('seed', '未知')}\"),\n   816→            (\"引导强度\", f\"{params.get('guidance_scale', '未知')}\"),\n   817→            (\"生成模型\", f\"{params.get('model', '未知模型')}\"),\n   818→            (\"生成时间\", self.format_time(self.image_data.get('created_at', ''))),\n   819→            (\"文件大小\", self.format_file_size(self.image_data.get('file_size', 0))),\n   820→            (\"文件路径\", self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')),\n   821→        ]\n   822→        \n   823→        # 如果是图生图，显示参考图信息\n   824→        if params.get('model', '').find('i2i') != -1:\n   825→            info_items.insert(-2, (\"生成类型\", \"图生图\"))\n   826→            input_image = self.image_data.get('input_image', '')\n   827→            if input_image:\n   828→                info_items.insert(-2, (\"参考图片\", input_image))\n   829→        else:\n   830→            info_items.insert(-2, (\"生成类型\", \"文生图\"))\n   831→        \n   832→        colors = unified_style_system.get_colors()\n   833→        bg_tag = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n   834→        border_tag = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   835→        text_tag = colors.get('text') or colors.get('palette.text.primary')\n   836→        hover_bg = colors.get('palette.neutral.bg_hover') or bg_tag\n   837→        hover_border = colors.get('palette.brand.main') or colors.get('primary') or border_tag\n   838→\n   839→        for label, value in info_items:\n   840→            label_widget = QLabel(f\"<b>{label}:</b>\")\n   841→            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   842→            unified_style_system.apply_to_widget(label_widget)\n   843→            self.params_layout.addWidget(label_widget)\n   844→            \n   845→            # 使用可点击的标签\n   846→            value_clickable = ClickableLabel(str(value))\n   847→            value_clickable.set_text_with_ellipsis(str(value), int(self.width() * 0.25))\n   848→            # File path is long and can otherwise expand to fill the panel, overlapping the prompt area.\n   849→            # Keep it single-line with ellipsis and fixed height.\n   850→            if label == \"文件路径\":\n   851→                value_clickable.setWordWrap(False)\n   852→                value_clickable.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n   853→                value_clickable.setFixedHeight(32)\n   854→                value_clickable.setToolTip(str(value))\n   855→            else:\n   856→                value_clickable.setWordWrap(True)\n   857→            # 使用动态样式\n   858→            value_clickable.setStyleSheet(f\"\"\"\n   859→                QLabel {{\n   860→                    margin: 0px; \n   861→                    padding: 6px; \n   862→                    background-color: {bg_tag}; \n   863→                    color: {text_tag};\n   864→                    border: 1px solid {border_tag};\n   865→                    border-radius: 4px;\n   866→                }}\n   867→                QLabel:hover {{\n   868→                    background-color: {hover_bg};\n   869→                    border-color: {hover_border};\n   870→                }}\n   871→            \"\"\")\n   872→            unified_style_system.apply_to_widget(value_clickable)\n   873→            value_clickable.clicked.connect(self.copy_text_to_clipboard)\n   874→            self.params_layout.addWidget(value_clickable)\n   875→            \n   876→            # 保存标签引用\n   877→            self.param_labels.append((label_widget, value_clickable))\n   878→\n   879→        # Ensure remaining vertical space doesn't get assigned to the last label widget.\n   880→        self.params_layout.addStretch(1)\n   881→    \n   882→    def update_params_area(self):\n   883→        \"\"\"更新参数显示区域（切换图片时调用）\"\"\"\n   884→        # Full rebuild avoids duplicated/stale widgets (e.g. file path blocks prompt area)\n   885→        self.setup_params_area()\n   886→\n   887→    def closeEvent(self, event):\n   888→        try:\n   889→            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n   890→                self._focus_timer.stop()\n   891→        except Exception:\n   892→            pass\n   893→\n   894→        try:\n   895→            self._export_controller.dispose()\n   896→        except Exception:\n   897→            pass\n   898→\n   899→        super().closeEvent(event)\n   900→    \n   901→    def keyPressEvent(self, event):\n   902→        \"\"\"键盘事件处理\"\"\"\n   903→        from PySide6.QtCore import Qt\n   904→        \n   905→        logger.debug(f\"[KEYBOARD] ImageDetailDialog键盘事件: {event.key()}\")\n   906→        \n   907→        if event.key() == Qt.Key_Left:\n   908→            # 左方向键：上一张图片\n   909→            if self.prev_btn.isEnabled():\n   910→                self.show_previous_image()\n   911→            event.accept()\n   912→        elif event.key() == Qt.Key_Right:\n   913→            # 右方向键：下一张图片\n   914→            if self.next_btn.isEnabled():\n   915→                self.show_next_image()\n   916→            event.accept()\n   917→        elif event.key() == Qt.Key_Escape:\n   918→            # ESC键：关闭对话框（保持原有功能）\n   919→            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n   920→            if self.is_fullscreen:\n   921→                self.exit_fullscreen()\n   922→            else:\n   923→                self.accept()\n   924→            event.accept()\n   925→        elif event.key() == Qt.Key_F11:\n   926→            # F11键：全屏切换（保持原有功能）\n   927→            self.toggle_fullscreen()\n   928→            event.accept()\n   929→        else:\n   930→            # 其他按键交给父类处理\n   931→            super().keyPressEvent(event)\n   932→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e3eccda2-0997-42dc-8eff-5123ecb4c664","timestamp":"2025-12-22T06:08:40.080Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py","content":"import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\n\nfrom PySide6.QtWidgets import (\n    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n    QTextEdit, QFileDialog, QMessageBox, QSplitter, QApplication,\n    QMenu, QSizePolicy\n)\nfrom PySide6.QtGui import QAction, QShortcut\nfrom PySide6.QtCore import Qt, QTimer, QSize, QEvent\nfrom PySide6.QtGui import QPixmap, QKeySequence\n\nfrom utils.logger import logger\nfrom utils.style_system import unified_style_system\nfrom components.widgets import ZoomableImageLabel, ClickableLabel\nfrom components.reference_assets import (\n    ReferenceGalleryWidget,\n    export_reference_asset,\n    open_reference_preview,\n    _find_reference_asset_index,\n)\nfrom components.controllers import ExportBundleController\nfrom utils.reference_assets import resolve_asset_path\nfrom utils.reference_display import ensure_reference_info, resolve_reference_assets\nfrom PySide6.QtCore import Signal\n\nclass ImageDetailDialog(QDialog):\n    \"\"\"图片详细信息对话框\"\"\"\n    \n    # 删除记录后发出信号，通知父视图刷新\n    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    \n    def __init__(self, image_data: Dict[str, Any], image_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n        super().__init__(parent)\n        self.image_data = image_data\n        self.image_list = image_list or [image_data]  # 图片列表\n        self.current_index = current_index  # 当前图片索引\n        self.zoom_factor = 1.0  # 缩放因子\n        self.is_fullscreen = False  # 全屏状态\n        self.original_geometry = None  # 原始窗口几何\n        self._reference_summary = ensure_reference_info(self.image_data)\n        self._reference_assets: List[Dict[str, Any]] = []\n        self._export_controller = ExportBundleController(self, \"image\")\n        \n        # Subscribe to theme changes\n        unified_style_system.styleChanged.connect(self._update_theme)\n        \n        self.setup_ui()\n        \n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        self.setWindowTitle(\"图片详细信息\")\n        self.resize(1100, 800)  # 改为可调整大小\n        self.setMinimumSize(800, 600)  # 设置最小尺寸\n        \n        # 设置焦点策略，确保能接收键盘事件\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n        self.setFocus()\n\n        # 确保窗口激活时获得焦点\n        self.activateWindow()\n        self.raise_()\n\n        try:\n            self.setObjectName(\"DetailDialog\")\n        except Exception:\n            pass\n\n        self._focus_timer = QTimer(self)\n        self._focus_timer.setSingleShot(True)\n        self._focus_timer.timeout.connect(self._ensure_focus)\n\n        layout = QHBoxLayout(self)\n        \n        # 左侧：大图显示（占70%宽度）\n        left_widget = QWidget()\n        left_layout = QVBoxLayout(left_widget)\n        left_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 图片显示区域（占据上方全部空间）\n        image_container = QWidget()\n        image_container.setObjectName(\"ImageContainer\")\n        image_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        # 在容器内创建布局\n        container_layout = QVBoxLayout(image_container)\n        container_layout.setContentsMargins(0, 0, 0, 0)\n        container_layout.setSpacing(0)\n\n        # 使用可缩放的图片标签，自适应容器大小\n        self.large_image_label = ZoomableImageLabel()\n        self.large_image_label.setAlignment(Qt.AlignCenter)\n        self.large_image_label.setStyleSheet(\"border: none; background-color: transparent;\")\n        \n        # 设置右键菜单\n        self.large_image_label.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.large_image_label.customContextMenuRequested.connect(self.show_context_menu)\n        \n        # 加载大图\n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if image_path and os.path.exists(image_path):\n            pixmap = QPixmap(image_path)\n            if not pixmap.isNull():\n                self.large_image_label.setPixmap(pixmap)\n        \n        container_layout.addWidget(self.large_image_label, 1)\n\n        reference_section = QWidget()\n        reference_section.setObjectName(\"ReferenceSection\")\n        reference_section.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        reference_section_layout = QVBoxLayout(reference_section)\n        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n        reference_section_layout.setSpacing(8)\n\n        self.reference_gallery = ReferenceGalleryWidget()\n        self.reference_gallery.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        try:\n            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n        except Exception:\n            pass\n        reference_section_layout.addWidget(self.reference_gallery, 1)\n\n        reference_button_layout = QHBoxLayout()\n        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n        reference_button_layout.setSpacing(6)\n        self.export_status_label = QLabel(\"\")\n        self.export_status_label.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(self.export_status_label)\n        reference_button_layout.addWidget(self.export_status_label)\n        reference_button_layout.addStretch(1)\n        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n        self.reference_export_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.reference_export_btn)\n        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n        reference_button_layout.addWidget(self.reference_export_btn)\n        self.export_bundle_btn = QPushButton(\"导出记录\")\n        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n        self.export_bundle_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.export_bundle_btn)\n        self._export_controller.configure(\n            self.export_bundle_btn,\n            self.export_status_label,\n            self._resolve_record_id,\n            context_widget=self,\n        )\n        reference_button_layout.addWidget(self.export_bundle_btn)\n        reference_section_layout.addLayout(reference_button_layout)\n\n        self._image_reference_splitter = QSplitter(Qt.Vertical)\n        self._image_reference_splitter.setObjectName(\"ImageReferenceSplitter\")\n        self._image_reference_splitter.setChildrenCollapsible(False)\n        self._image_reference_splitter.setHandleWidth(6)\n        self._image_reference_splitter.addWidget(image_container)\n        self._image_reference_splitter.addWidget(reference_section)\n        self._image_reference_splitter.setStretchFactor(0, 3)\n        self._image_reference_splitter.setStretchFactor(1, 2)\n        self._image_reference_splitter.setSizes([520, 280])\n\n        left_layout.addWidget(self._image_reference_splitter, 1)\n\n        # 底部区域：导航按钮 + 说明文本框（与右侧参数栏高度对齐）\n        bottom_layout = QHBoxLayout()\n        bottom_layout.setContentsMargins(0, 5, 0, 5)\n        bottom_layout.setSpacing(10)\n        \n        # 向左按钮\n        self.prev_btn = QPushButton(\"◀\")\n        self.prev_btn.setFixedSize(30, 30)  # 固定尺寸\n        self.prev_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.prev_btn)\n        self.prev_btn.clicked.connect(self.show_previous_image)\n        bottom_layout.addWidget(self.prev_btn)\n        \n        # 中间的说明文本框（完全透明设计）\n        zoom_info = QLabel(\"提示：鼠标位置缩放，点击拖拽，双击重置\")\n        zoom_info.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(zoom_info)\n        zoom_info.setAlignment(Qt.AlignCenter)\n        zoom_info.setMinimumHeight(30)  # 与按钮高度一致\n        zoom_info.setMaximumHeight(30)  # 固定高度，防止文字被压缩\n        bottom_layout.addWidget(zoom_info, 1)  # 占据中间所有空间\n        \n        # 向右按钮\n        self.next_btn = QPushButton(\"▶\")\n        self.next_btn.setFixedSize(30, 30)  # 固定尺寸\n        self.next_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.next_btn)\n        self.next_btn.clicked.connect(self.show_next_image)\n        bottom_layout.addWidget(self.next_btn)\n        \n        left_layout.addLayout(bottom_layout)\n\n        # 更新导航按钮状态\n        self.update_navigation_buttons()\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n\n        # 右侧：详细信息（固定30%宽度）\n        right_layout = QVBoxLayout()\n        \n        # 创建参数显示区域（不使用滚动条）\n        params_widget = QWidget()\n        params_widget.setFixedWidth(int(self.width() * 0.3))  # 固定30%宽度\n        params_widget.setObjectName(\"ParamsWidget\")\n        self.params_layout = QVBoxLayout(params_widget)  # 保存引用以便后续更新\n        self.params_layout.setSpacing(0)  # 设置间距为0\n        self.params_layout.setContentsMargins(5, 5, 5, 5)  # 设置紧凑的边距\n\n        # === 固定组件：提示词区域（只创建一次，不随记录切换重建）===\n        self.prompt_label = QLabel(\"<b>提示词:</b>\")\n        self.prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n        unified_style_system.apply_to_widget(self.prompt_label)\n        self.params_layout.addWidget(self.prompt_label)\n\n        self.prompt_text_edit = QTextEdit()\n        self.prompt_text_edit.setReadOnly(True)\n        self.prompt_text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n        self.prompt_text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        # 约 4 行高度\n        try:\n            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n            height = line_height * 4 + 18  # padding + border\n            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n        except Exception:\n            self.prompt_text_edit.setMaximumHeight(96)\n            self.prompt_text_edit.setMinimumHeight(96)\n        unified_style_system.apply_to_widget(self.prompt_text_edit)\n        self.params_layout.addWidget(self.prompt_text_edit)\n\n        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n        self.copy_prompt_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n        self.params_layout.addWidget(self.copy_prompt_btn)\n\n        # 参数标签列表（动态填充）\n        self.param_labels = []\n\n        # 初始化参数显示区域（填充动态内容）\n        self.setup_params_area()\n        \n        \n        right_layout.addWidget(params_widget)\n        \n        # 全屏和复制图片按钮（与参数区底部对齐）\n        image_control_layout = QHBoxLayout()\n\n        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n        self.fullscreen_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.fullscreen_btn)\n        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n        image_control_layout.addWidget(self.fullscreen_btn)\n\n        self.copy_image_btn = QPushButton(\"复制图片\")\n        self.copy_image_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.copy_image_btn)\n        self.copy_image_btn.clicked.connect(self.copy_image)\n        image_control_layout.addWidget(self.copy_image_btn)\n\n        right_layout.addLayout(image_control_layout)\n\n        # 其他按钮\n        button_layout = QHBoxLayout()\n\n        self.delete_btn = QPushButton(\"删除记录\")\n        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        self.delete_btn.clicked.connect(self._delete_current_record)\n        button_layout.addWidget(self.delete_btn)\n\n        self.close_btn = QPushButton(\"关闭（ESC）\")\n        unified_style_system.apply_to_widget(self.close_btn)\n        self.close_btn.clicked.connect(self.accept)\n        button_layout.addWidget(self.close_btn)\n        \n        right_layout.addLayout(button_layout)\n        \n        # 设置布局比例：左侧70%，右侧30%\n        layout.addWidget(left_widget, 7)\n        layout.addLayout(right_layout, 3)\n        \n        # 添加键盘快捷键\n        self.setup_shortcuts()\n\n        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n        self._focus_timer.start(100)\n\n        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n        \n        # Apply initial theme\n        self._update_theme()\n    \n    def format_time(self, time_str: str) -> str:\n        \"\"\"格式化时间显示\"\"\"\n        if not time_str:\n            return '未知时间'\n        try:\n            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n            return dt.strftime('%Y-%m-%d %H:%M:%S')\n        except:\n            return time_str[:19] if len(time_str) > 19 else time_str\n    \n    def format_file_size(self, size) -> str:\n        \"\"\"格式化文件大小显示\"\"\"\n        # 处理字符串类型的size\n        try:\n            size = float(size) if size else 0\n        except (ValueError, TypeError):\n            return '未知大小'\n            \n        if size == 0:\n            return '未知大小'\n        \n        for unit in ['B', 'KB', 'MB', 'GB']:\n            if size < 1024.0:\n                return f\"{size:.1f} {unit}\"\n            size /= 1024.0\n        return f\"{size:.1f} TB\"\n    \n    def setup_shortcuts(self):\n        \"\"\"设置键盘快捷键\"\"\"\n        # 移除所有QShortcut，统一使用keyPressEvent处理\n        # 避免快捷键冲突问题\n        pass\n    \n    def _ensure_focus(self):\n        \"\"\"确保窗口获得焦点\"\"\"\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        logger.debug(f\"[FOCUS] ImageDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n        \n    def toggle_fullscreen(self):\n        \"\"\"切换全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.enter_fullscreen()\n            \n    def enter_fullscreen(self):\n        \"\"\"进入全屏模式\"\"\"\n        if not self.is_fullscreen:\n            self.original_geometry = self.geometry()\n            self.showFullScreen()\n            self.is_fullscreen = True\n            \n    def exit_fullscreen(self):\n        \"\"\"退出全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.showNormal()\n            if self.original_geometry:\n                self.setGeometry(self.original_geometry)\n            self.is_fullscreen = False\n            \n    def handle_escape_key(self):\n        \"\"\"处理ESC键：如果是全屏则退出全屏，否则关闭对话框\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.accept()  # 关闭对话框\n            \n    def copy_text_to_clipboard(self, text: str):\n        \"\"\"复制文本到剪贴板并显示提示\"\"\"\n        from PySide6.QtWidgets import QApplication\n        clipboard = QApplication.clipboard()\n        clipboard.setText(text)\n        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n        \n    def show_copy_toast(self, message: str):\n        \"\"\"显示复制成功的轻量提示\"\"\"\n        # 创建一个临时的提示标签\n        toast = QLabel(message, self)\n        toast.setObjectName(\"ToastLabel\")\n        toast.setAlignment(Qt.AlignCenter)\n        toast.adjustSize()\n        \n        # 定位到窗口中央偏上\n        x = (self.width() - toast.width()) // 2\n        y = self.height() // 4\n        toast.move(x, y)\n        toast.show()\n        \n        # 2秒后自动隐藏\n        QTimer.singleShot(2000, toast.deleteLater)\n        \n    def copy_prompt(self):\n        \"\"\"复制提示词到剪贴板\"\"\"\n        prompt_content = self.prompt_text_edit.toPlainText()\n        self.copy_text_to_clipboard(prompt_content)\n    \n    def copy_image(self):\n        \"\"\"复制图片到剪贴板\"\"\"\n        from PySide6.QtWidgets import QApplication\n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if image_path and os.path.exists(image_path):\n            pixmap = QPixmap(image_path)\n            if not pixmap.isNull():\n                clipboard = QApplication.clipboard()\n                clipboard.setPixmap(pixmap)\n                self.show_copy_toast(\"图片已复制到剪贴板\")\n            else:\n                self.show_copy_toast(\"无法复制图片\")\n        else:\n            self.show_copy_toast(\"图片文件不存在\")\n    \n    def copy_all_info(self):\n        \"\"\"复制所有信息到剪贴板\"\"\"\n        from PySide6.QtWidgets import QApplication\n        \n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        info_text = f\"\"\"图片详细信息\n===================\n提示词: {self.image_data.get('prompt', '无提示词')}\n尺寸: {params.get('size', '未知')}\n种子值: {params.get('seed', '未知')}\n引导强度: {params.get('guidance_scale', '未知')}\n生成模型: {params.get('model', '未知模型')}\n生成时间: {self.format_time(self.image_data.get('created_at', ''))}\n文件大小: {self.format_file_size(self.image_data.get('file_size', 0))}\n文件路径: {self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')}\n\"\"\"\n        \n        clipboard = QApplication.clipboard()\n        clipboard.setText(info_text)\n        self.show_copy_toast(\"所有信息已复制到剪贴板\")\n\n    def show_copy_message(self, message: str):\n        \"\"\"显示复制成功消息（已弃用，使用show_copy_toast代替）\"\"\"\n        # 直接使用轻量级Toast提示\n        self.show_copy_toast(message)\n\n    def _delete_current_record(self):\n        \"\"\"删除当前记录及相关文件\"\"\"\n        record_id = self._resolve_record_id()\n        if not record_id:\n            self.show_copy_toast(\"无法获取记录ID\")\n            return\n        \n        try:\n            # 获取 RepositoryManager\n            from config_api import get_storage_dir\n            from modules.repository.manager import RepositoryManager\n            \n            storage_dir = get_storage_dir()\n            repo = RepositoryManager(storage_dir)\n            \n            # 执行删除\n            if repo.delete_record_with_files(record_id):\n                self.show_copy_toast(\"记录已删除\")\n                \n                # 发出信号通知父视图刷新\n                self.recordDeleted.emit(record_id)\n                \n                # 从列表中移除当前记录\n                if len(self.image_list) > 1:\n                    del self.image_list[self.current_index]\n                    \n                    # 导航到后一条记录（保持索引，指向原来的下一条）\n                    # 只有当删除的是最后一条时，才需要调整索引\n                    if self.current_index >= len(self.image_list):\n                        self.current_index = len(self.image_list) - 1\n                    \n                    self.load_current_image()\n                    self.update_navigation_buttons()\n                else:\n                    # 只剩一条记录，关闭对话框\n                    self.accept()\n            else:\n                self.show_copy_toast(\"删除失败\")\n        except Exception as e:\n            from utils.logger import logger\n            logger.error(f\"删除记录异常: {e}\")\n            self.show_copy_toast(f\"删除失败: {str(e)}\")\n\n    def _on_reference_clicked(self, asset: Dict[str, Any]):\n        assets = list(self._reference_assets) if self._reference_assets else [asset]\n        start_idx = _find_reference_asset_index(assets, asset)\n        open_reference_preview(\n            self,\n            asset,\n            title_prefix=\"参考图\",\n            asset_list=assets,\n            start_index=start_idx,\n            on_asset_changed=self._sync_reference_selection,\n        )\n\n    def _on_reference_export(self, asset: Dict[str, Any]):\n        export_reference_asset(self, asset)\n\n    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n        asset_path = resolve_asset_path(asset) if isinstance(asset, dict) else None\n        has_path = bool(asset_path)\n        if hasattr(self, 'reference_export_btn'):\n            self.reference_export_btn.setEnabled(has_path)\n\n    def _export_selected_reference(self):\n        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n        if not asset:\n            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n            return\n        export_reference_asset(self, asset)\n\n    def _refresh_reference_gallery(self):\n        if not hasattr(self, 'reference_gallery'):\n            return\n        self._reference_summary = ensure_reference_info(self.image_data)\n        if self._reference_summary.get('count', 0) <= 0:\n            self.reference_gallery.clear()\n            self.reference_gallery.setVisible(False)\n            if hasattr(self, 'reference_export_btn'):\n                self.reference_export_btn.setEnabled(False)\n            self._reference_assets = []\n            self._export_controller.refresh()\n            return\n        try:\n            self._reference_assets = resolve_reference_assets(self.image_data, absolute=True)\n        except Exception:\n            self._reference_assets = []\n        self.reference_gallery.setVisible(True)\n        self.reference_gallery.set_assets(self._reference_assets)\n        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n        self._export_controller.refresh()\n\n    def _sync_reference_selection(self, asset: Dict[str, Any]):\n        try:\n            self.reference_gallery.select_asset(asset)\n        except Exception:\n            pass\n\n    def _resolve_record_id(self) -> Optional[str]:\n        for key in (\"file_id\", \"id\", \"generation_id\"):\n            value = self.image_data.get(key)\n            if value not in (None, \"\"):\n                return str(value)\n        return None\n\n    def show_context_menu(self, position):\n        \"\"\"显示右键菜单\"\"\"\n        from PySide6.QtWidgets import QMenu\n        from PySide6.QtGui import QAction, QShortcut\n        \n        menu = QMenu(self)\n        \n        # 复制图片动作\n        copy_action = QAction(\"复制图片\", self)\n        copy_action.triggered.connect(self.copy_image)\n        menu.addAction(copy_action)\n        \n        # 下载图片动作\n        download_action = QAction(\"下载图片\", self)\n        download_action.triggered.connect(self.download_image)\n        menu.addAction(download_action)\n        \n        # 显示菜单\n        menu.exec(self.large_image_label.mapToGlobal(position))\n    \n    def download_image(self):\n        \"\"\"下载图片到指定位置\"\"\"\n        from PySide6.QtWidgets import QFileDialog, QMessageBox\n        import shutil\n        \n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if not image_path or not os.path.exists(image_path):\n            self.show_styled_message(\"错误\", \"图片文件不存在\", \"warning\")\n            return\n        \n        # 获取原始文件名\n        original_filename = os.path.basename(image_path)\n        \n        # 打开保存对话框\n        save_path, _ = QFileDialog.getSaveFileName(\n            self,\n            \"保存图片\",\n            original_filename,\n            \"图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)\"\n        )\n        \n        if save_path:\n            try:\n                shutil.copy2(image_path, save_path)\n                self.show_styled_message(\"成功\", f\"图片已保存到:\\n{save_path}\", \"information\")\n            except Exception as e:\n                self.show_styled_message(\"错误\", f\"保存图片失败:\\n{str(e)}\", \"critical\")\n    \n    def update_navigation_buttons(self):\n        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n        # 检查是否有图片列表\n        if len(self.image_list) <= 1:\n            self.prev_btn.setEnabled(False)\n            self.next_btn.setEnabled(False)\n            self.prev_btn.setToolTip(\"没有更多图片\")\n            self.next_btn.setToolTip(\"没有更多图片\")\n            return\n        \n        # 更新按钮状态（基于有效记录检查）\n        self.prev_btn.setEnabled(self._has_valid_previous_record())\n        self.next_btn.setEnabled(self._has_valid_next_record())\n        \n        # 更新工具提示显示当前位置和快捷键信息\n        current_pos = f\"({self.current_index + 1}/{len(self.image_list)})\"\n        self.prev_btn.setToolTip(f\"上一张 {current_pos} - 快捷键: ←\")\n        self.next_btn.setToolTip(f\"下一张 {current_pos} - 快捷键: →\")\n        \n        # 按钮文本保持简洁的箭头符号\n        self.prev_btn.setText(\"◀\")\n    \n    def _has_valid_previous_record(self):\n        \"\"\"检查是否有有效的上一个记录\"\"\"\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            if file_path and os.path.exists(file_path):\n                return True\n        return False\n    \n    def _has_valid_next_record(self):\n        \"\"\"检查是否有有效的下一个记录\"\"\"\n        for i in range(self.current_index + 1, len(self.image_list)):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            if file_path and os.path.exists(file_path):\n                return True\n        return False\n    \n    def show_previous_image(self):\n        \"\"\"显示上一张图片（带有效性验证）\"\"\"\n        # 寻找上一个有效记录\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            if file_path and os.path.exists(file_path):\n                # 找到有效记录\n                self.current_index = i\n                self.load_current_image()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的上一个记录，保持当前状态\n        self.update_navigation_buttons()\n    \n    def show_next_image(self):\n        \"\"\"显示下一张图片（带有效性验证）\"\"\"\n        # 寻找下一个有效记录\n        for i in range(self.current_index + 1, len(self.image_list)):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            if file_path and os.path.exists(file_path):\n                # 找到有效记录\n                self.current_index = i\n                self.load_current_image()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的下一个记录，保持当前状态\n        self.update_navigation_buttons()\n    \n    def load_current_image(self):\n        \"\"\"加载当前索引的图片\"\"\"\n        if 0 <= self.current_index < len(self.image_list):\n            # 更新当前图片数据\n            self.image_data = self.image_list[self.current_index]\n            \n            # 重新加载图片\n            image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '') or self.image_data.get('file_path', '')\n            if image_path and os.path.exists(image_path):\n                pixmap = QPixmap(image_path)\n                if not pixmap.isNull():\n                    self.large_image_label.setPixmap(pixmap)\n                else:\n                    self.large_image_label.setText(\"图片加载失败\")\n            else:\n                self.large_image_label.setText(\"图片不存在\")\n            \n            # 更新窗口标题\n            self.setWindowTitle(f\"图片详细信息 ({self.current_index + 1}/{len(self.image_list)})\")\n            \n            # 更新提示词内容\n            prompt_content = self.image_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n            \n            # 更新参数信息\n            self.update_params_area()\n            self._refresh_reference_gallery()\n\n        self._export_controller.refresh()\n    \n    def setup_params_area(self):\n        \"\"\"更新参数显示区域（只更新内容和动态标签，固定组件在 setup_ui 中创建）\"\"\"\n        # 1. 更新提示词内容（固定组件，只更新文本）\n        prompt_content = self.image_data.get('prompt', '') or '无提示词'\n        if hasattr(self, 'prompt_text_edit'):\n            self.prompt_text_edit.setPlainText(prompt_content)\n\n        # 2. 清理旧的动态标签（保留前3个固定组件）\n        self._clear_param_labels()\n\n        # 3. 重建动态参数标签\n        self.create_param_labels()\n\n    def _clear_param_labels(self):\n        \"\"\"只清理动态参数标签，保留固定组件（prompt_label, prompt_text_edit, copy_prompt_btn）\"\"\"\n        # 清理已保存的参数标签引用\n        if hasattr(self, 'param_labels') and self.param_labels:\n            for label_widget, value_widget in self.param_labels:\n                self.params_layout.removeWidget(label_widget)\n                self.params_layout.removeWidget(value_widget)\n                label_widget.hide()\n                value_widget.hide()\n                label_widget.deleteLater()\n                value_widget.deleteLater()\n            self.param_labels.clear()\n\n        # 移除末尾的 stretch（固定组件是前3个：prompt_label, prompt_text_edit, copy_prompt_btn）\n        while self.params_layout.count() > 3:\n            item = self.params_layout.takeAt(3)\n            if item.widget():\n                w = item.widget()\n                w.hide()\n                w.deleteLater()\n            elif item.spacerItem():\n                del item\n    \n    def _update_theme(self):\n        \"\"\"响应主题变化\"\"\"\n        colors = unified_style_system.get_colors()\n        logger.info(f\"[ImageDetailDialog] _update_theme called. Surface color: {colors.get('palette.neutral.bg_surface')}\")\n        \n        # Apply theme to self (Dialog)\n        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n        text_color = colors.get('text') or colors.get('palette.text.primary')\n        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n        bg_input = colors.get('palette.neutral.bg_input') or bg_card\n        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n        \n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {bg_color};\n                color: {text_color};\n            }}\n            QLabel {{\n                color: {text_color};\n            }}\n            QWidget#ParamsWidget {{\n                 background-color: {bg_card};\n                 border-left: 1px solid {border_subtle};\n            }}\n        \"\"\")\n\n        if hasattr(self, 'prompt_text_edit'):\n            self.prompt_text_edit.setStyleSheet(f\"\"\"\n                QTextEdit {{\n                    background-color: {bg_input};\n                    color: {text_color};\n                    border: 1px solid {border_subtle};\n                    border-radius: 8px;\n                    padding: 8px;\n                }}\n                QTextEdit:focus {{\n                    border-color: {brand};\n                }}\n            \"\"\")\n\n        # Reapply button styles (including fixed components)\n        if hasattr(self, 'copy_prompt_btn'):\n            unified_style_system.apply_to_widget(self.copy_prompt_btn)\n        if hasattr(self, 'fullscreen_btn'):\n            unified_style_system.apply_to_widget(self.fullscreen_btn)\n        if hasattr(self, 'copy_image_btn'):\n            unified_style_system.apply_to_widget(self.copy_image_btn)\n        if hasattr(self, 'delete_btn'):\n            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        if hasattr(self, 'close_btn'):\n            unified_style_system.apply_to_widget(self.close_btn)\n        if hasattr(self, 'reference_export_btn'):\n            unified_style_system.apply_to_widget(self.reference_export_btn)\n        if hasattr(self, 'export_bundle_btn'):\n            unified_style_system.apply_to_widget(self.export_bundle_btn)\n        if hasattr(self, 'prev_btn'):\n            unified_style_system.apply_to_widget(self.prev_btn)\n        if hasattr(self, 'next_btn'):\n            unified_style_system.apply_to_widget(self.next_btn)\n\n        # Rebuild dynamic param labels (fixed components already refreshed above)\n        self.setup_params_area()\n\n    def create_param_labels(self):\n        \"\"\"创建动态参数标签（由 setup_params_area 调用，清理已在 _clear_param_labels 中完成）\"\"\"\n        # 解析生成参数\n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 详细信息\n        info_items = [\n            (\"尺寸\", f\"{params.get('size', '未知')}\"),\n            (\"种子值\", f\"{params.get('seed', '未知')}\"),\n            (\"引导强度\", f\"{params.get('guidance_scale', '未知')}\"),\n            (\"生成模型\", f\"{params.get('model', '未知模型')}\"),\n            (\"生成时间\", self.format_time(self.image_data.get('created_at', ''))),\n            (\"文件大小\", self.format_file_size(self.image_data.get('file_size', 0))),\n            (\"文件路径\", self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')),\n        ]\n        \n        # 如果是图生图，显示参考图信息\n        if params.get('model', '').find('i2i') != -1:\n            info_items.insert(-2, (\"生成类型\", \"图生图\"))\n            input_image = self.image_data.get('input_image', '')\n            if input_image:\n                info_items.insert(-2, (\"参考图片\", input_image))\n        else:\n            info_items.insert(-2, (\"生成类型\", \"文生图\"))\n        \n        colors = unified_style_system.get_colors()\n        bg_tag = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n        border_tag = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        text_tag = colors.get('text') or colors.get('palette.text.primary')\n        hover_bg = colors.get('palette.neutral.bg_hover') or bg_tag\n        hover_border = colors.get('palette.brand.main') or colors.get('primary') or border_tag\n\n        for label, value in info_items:\n            label_widget = QLabel(f\"<b>{label}:</b>\")\n            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n            unified_style_system.apply_to_widget(label_widget)\n            self.params_layout.addWidget(label_widget)\n            \n            # 使用可点击的标签\n            value_clickable = ClickableLabel(str(value))\n            value_clickable.set_text_with_ellipsis(str(value), int(self.width() * 0.25))\n            # File path is long and can otherwise expand to fill the panel, overlapping the prompt area.\n            # Keep it single-line with ellipsis and fixed height.\n            if label == \"文件路径\":\n                value_clickable.setWordWrap(False)\n                value_clickable.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n                value_clickable.setFixedHeight(32)\n                value_clickable.setToolTip(str(value))\n            else:\n                value_clickable.setWordWrap(True)\n            # 使用动态样式\n            value_clickable.setStyleSheet(f\"\"\"\n                QLabel {{\n                    margin: 0px; \n                    padding: 6px; \n                    background-color: {bg_tag}; \n                    color: {text_tag};\n                    border: 1px solid {border_tag};\n                    border-radius: 4px;\n                }}\n                QLabel:hover {{\n                    background-color: {hover_bg};\n                    border-color: {hover_border};\n                }}\n            \"\"\")\n            unified_style_system.apply_to_widget(value_clickable)\n            value_clickable.clicked.connect(self.copy_text_to_clipboard)\n            self.params_layout.addWidget(value_clickable)\n            \n            # 保存标签引用\n            self.param_labels.append((label_widget, value_clickable))\n\n        # Ensure remaining vertical space doesn't get assigned to the last label widget.\n        self.params_layout.addStretch(1)\n    \n    def update_params_area(self):\n        \"\"\"更新参数显示区域（切换图片时调用）\"\"\"\n        # Full rebuild avoids duplicated/stale widgets (e.g. file path blocks prompt area)\n        self.setup_params_area()\n\n    def closeEvent(self, event):\n        try:\n            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n                self._focus_timer.stop()\n        except Exception:\n            pass\n\n        try:\n            self._export_controller.dispose()\n        except Exception:\n            pass\n\n        super().closeEvent(event)\n    \n    def keyPressEvent(self, event):\n        \"\"\"键盘事件处理\"\"\"\n        from PySide6.QtCore import Qt\n        \n        logger.debug(f\"[KEYBOARD] ImageDetailDialog键盘事件: {event.key()}\")\n        \n        if event.key() == Qt.Key_Left:\n            # 左方向键：上一张图片\n            if self.prev_btn.isEnabled():\n                self.show_previous_image()\n            event.accept()\n        elif event.key() == Qt.Key_Right:\n            # 右方向键：下一张图片\n            if self.next_btn.isEnabled():\n                self.show_next_image()\n            event.accept()\n        elif event.key() == Qt.Key_Escape:\n            # ESC键：关闭对话框（保持原有功能）\n            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n            if self.is_fullscreen:\n                self.exit_fullscreen()\n            else:\n                self.accept()\n            event.accept()\n        elif event.key() == Qt.Key_F11:\n            # F11键：全屏切换（保持原有功能）\n            self.toggle_fullscreen()\n            event.accept()\n        else:\n            # 其他按键交给父类处理\n            super().keyPressEvent(event)\n","numLines":932,"startLine":1,"totalLines":932}}}
{"parentUuid":"e3eccda2-0997-42dc-8eff-5123ecb4c664","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WtSGZfaVwJpDyDYVTRkxYQ","type":"tool_result","content":"     1→import os\n     2→import json\n     3→from pathlib import Path\n     4→from datetime import datetime\n     5→from typing import Dict, Any, List, Optional\n     6→\n     7→from PySide6.QtWidgets import (\n     8→    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n     9→    QTextEdit, QFileDialog, QMessageBox, QStackedWidget, QSplitter,\n    10→    QApplication\n    11→)\n    12→from PySide6.QtGui import QShortcut\n    13→from PySide6.QtCore import Qt, QTimer, QUrl, QSize, QEvent\n    14→from PySide6.QtGui import QPixmap, QFont, QKeySequence, QPainter, QImage\n    15→from PySide6.QtMultimedia import QMediaPlayer\n    16→from PySide6.QtMultimediaWidgets import QVideoWidget\n    17→\n    18→# 使用全局视频管理器单例\n    19→from services.global_video_manager import get_global_video_manager\n    20→\n    21→from utils.logger import logger\n    22→from components.reference_assets import (\n    23→    ReferenceGalleryWidget,\n    24→    export_reference_asset,\n    25→    open_reference_preview,\n    26→    _find_reference_asset_index,\n    27→)\n    28→from utils.style_system import unified_style_system\n    29→from components.controllers import ExportBundleController\n    30→from utils.reference_assets import resolve_asset_path\n    31→from utils.reference_display import (\n    32→    build_resolution_text,\n    33→    ensure_reference_info,\n    34→    get_model_display_name,\n    35→    pick_model_code,\n    36→    resolve_reference_assets,\n    37→)\n    38→from PySide6.QtCore import Signal\n    39→\n    40→class VideoDetailDialog(QDialog):\n    41→    \"\"\"视频详细信息对话框\"\"\"\n    42→    \n    43→    # 删除记录后发出信号，通知父视图刷新\n    44→    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    45→    \n    46→    def __init__(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n    47→        super().__init__(parent)\n    48→        self.video_data = video_data\n    49→        self.video_list = video_list or [video_data]  # 视频列表\n    50→        self.current_index = current_index  # 当前视频索引\n    51→        self.is_fullscreen = False  # 全屏状态\n    52→        self.original_geometry = None  # 原始窗口几何\n    53→        self.param_value_labels = {}  # 存储参数值标签的引用\n    54→        self._reference_summary = ensure_reference_info(self.video_data)\n    55→        self._reference_assets: List[Dict[str, Any]] = []\n    56→        self._export_controller = ExportBundleController(self, \"video\")\n    57→        \n    58→        # Subscribe to theme changes\n    59→        unified_style_system.styleChanged.connect(self._update_theme)\n    60→        \n    61→        self.setup_ui()\n    62→    \n    63→    def set_video_data(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0):\n    64→        \"\"\"更新视频数据（复用对话框时调用，避免重建 QVideoWidget）\"\"\"\n    65→        logger.debug(f\"[REUSE] 复用对话框，更新视频数据: index={current_index}\")\n    66→        \n    67→        # 1. 先停止当前播放\n    68→        if hasattr(self, '_video_manager') and self._video_manager is not None:\n    69→            self._video_manager.stop()\n    70→        \n    71→        # 2. 重置到缩略图模式\n    72→        if hasattr(self, 'video_stack'):\n    73→            self.video_stack.setCurrentIndex(0)\n    74→        self.is_playing = False\n    75→        \n    76→        # 3. 更新数据\n    77→        self.video_data = video_data\n    78→        self.video_list = video_list or [video_data]\n    79→        self.current_index = current_index\n    80→        self._reference_summary = ensure_reference_info(self.video_data)\n    81→        \n    82→        # 4. 刷新UI\n    83→        self.load_thumbnail()\n    84→        \n    85→        # 5. 更新右侧信息\n    86→        if hasattr(self, 'prompt_text_edit'):\n    87→            prompt_content = self.video_data.get('prompt', '无提示词')\n    88→            self.prompt_text_edit.setPlainText(prompt_content)\n    89→        \n    90→        # 6. 更新参数信息\n    91→        if hasattr(self, 'update_video_params'):\n    92→            self.update_video_params()\n    93→        \n    94→        # 7. 更新导航按钮\n    95→        if hasattr(self, 'update_navigation_buttons'):\n    96→            self.update_navigation_buttons()\n    97→        \n    98→        # 8. 刷新参考图画廊\n    99→        if hasattr(self, '_refresh_reference_gallery'):\n   100→            self._refresh_reference_gallery()\n   101→        \n   102→        # 9. 重新激活窗口\n   103→        self.setEnabled(True)\n   104→        self.activateWindow()\n   105→        self.raise_()\n   106→        self.setFocus()\n   107→        \n   108→        logger.debug(\"[REUSE] 视频数据更新完成\")\n   109→        \n   110→    def setup_ui(self):\n   111→        \"\"\"设置UI\"\"\"\n   112→        self.setWindowTitle(\"视频详细信息\")\n   113→        self.resize(1100, 800)  # 改为可调整大小\n   114→        self.setMinimumSize(800, 600)  # 设置最小尺寸\n   115→        \n   116→        # 设置焦点策略，确保能接收键盘事件\n   117→        self.setFocusPolicy(Qt.StrongFocus)\n   118→        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n   119→        self.setFocus()\n   120→\n   121→        # 确保窗口激活时获得焦点\n   122→        self.activateWindow()\n   123→        self.raise_()\n   124→\n   125→        try:\n   126→            self.setObjectName(\"DetailDialog\")\n   127→        except Exception:\n   128→            pass\n   129→\n   130→        self._focus_timer = QTimer(self)\n   131→        self._focus_timer.setSingleShot(True)\n   132→        self._focus_timer.timeout.connect(self._ensure_focus)\n   133→\n   134→        layout = QHBoxLayout(self)\n   135→        \n   136→        # 左侧：视频播放器（占70%宽度）\n   137→        left_widget = QWidget()\n   138→        left_layout = QVBoxLayout(left_widget)\n   139→        left_layout.setContentsMargins(0, 0, 0, 0)\n   140→        \n   141→        # 视频播放区域\n   142→        video_container = QWidget()\n   143→        video_container.setObjectName(\"VideoContainer\")\n   144→        \n   145→        container_layout = QVBoxLayout(video_container)\n   146→        container_layout.setContentsMargins(0, 0, 0, 0)\n   147→        \n   148→        # 创建堆叠布局，用于缩略图和视频播放器的切换\n   149→        from PySide6.QtWidgets import QStackedWidget\n   150→        self.video_stack = QStackedWidget()\n   151→        \n   152→        # 缩略图页面\n   153→        self.thumbnail_widget = QWidget()\n   154→        self.thumbnail_widget.setObjectName(\"ThumbnailWidget\")\n   155→        thumbnail_layout = QVBoxLayout(self.thumbnail_widget)\n   156→        thumbnail_layout.setContentsMargins(0, 0, 0, 0)\n   157→        thumbnail_layout.setAlignment(Qt.AlignCenter)\n   158→        \n   159→        # 缩略图标签\n   160→        self.thumbnail_label = QLabel()\n   161→        self.thumbnail_label.setAlignment(Qt.AlignCenter)\n   162→        colors = unified_style_system.get_colors()\n   163→        player_bg = colors.get('palette.component.player_bg')\n   164→        text_on_brand = (\n   165→            colors.get('palette.text.on_brand')\n   166→            or colors.get('palette.text.primary')\n   167→            or colors.get('text')\n   168→        )\n   169→        self.thumbnail_label.setStyleSheet(f\"\"\"\n   170→            QLabel {{\n   171→                border: none;\n   172→                background-color: {player_bg};\n   173→                color: {text_on_brand};\n   174→            }}\n   175→        \"\"\")\n   176→        self.thumbnail_label.setMinimumSize(400, 300)\n   177→        # 不使用setScaledContents，改为手动缩放\n   178→        # self.thumbnail_label.setScaledContents(True)\n   179→        \n   180→        # 播放按钮覆盖层\n   181→        self.play_overlay = QLabel(\"▶\")\n   182→        self.play_overlay.setAlignment(Qt.AlignCenter)\n   183→        self.play_overlay.setObjectName(\"PlayOverlay\")\n   184→        \n   185→        # 创建缩略图容器，使用相对定位\n   186→        thumbnail_container = QWidget()\n   187→        thumbnail_container.setStyleSheet(f\"border: none; background-color: {player_bg};\")\n   188→        # 设置固定尺寸确保容器有正确的大小\n   189→        thumbnail_container.setFixedSize(640, 480)\n   190→        \n   191→        # 使用绝对定位放置播放按钮\n   192→        def setup_thumbnail_layout():\n   193→            self.thumbnail_label.setParent(thumbnail_container)\n   194→            self.play_overlay.setParent(thumbnail_container)\n   195→            \n   196→            # 确保标签可见\n   197→            self.thumbnail_label.show()\n   198→            self.play_overlay.show()\n   199→            \n   200→            def resize_thumbnail_container():\n   201→                if hasattr(self, 'thumbnail_label') and hasattr(self, 'play_overlay'):\n   202→                    container_size = thumbnail_container.size()\n   203→                    logger.debug(f\"[UI] 详情缩略图容器尺寸: {container_size}\")\n   204→                    \n   205→                    # 设置缩略图标签尺寸和位置\n   206→                    self.thumbnail_label.setGeometry(0, 0, container_size.width(), container_size.height())\n   207→                    \n   208→                    # 播放按钮居中\n   209→                    overlay_x = max(0, (container_size.width() - 70) // 2)\n   210→                    overlay_y = max(0, (container_size.height() - 70) // 2)\n   211→                    self.play_overlay.setGeometry(overlay_x, overlay_y, 70, 70)\n   212→                    \n   213→                    logger.debug(f\"[UI] 缩略图标签位置: {self.thumbnail_label.geometry()}\")\n   214→                    logger.debug(f\"[UI] 播放按钮位置: {self.play_overlay.geometry()}\")\n   215→            \n   216→            def handle_resize_event(event):\n   217→                resize_thumbnail_container()\n   218→                QWidget.resizeEvent(thumbnail_container, event)\n   219→            \n   220→            thumbnail_container.resizeEvent = handle_resize_event\n   221→            \n   222→            # 立即调用布局函数\n   223→            resize_thumbnail_container()\n   224→        \n   225→        setup_thumbnail_layout()\n   226→        \n   227→        # 点击事件\n   228→        self.thumbnail_label.mousePressEvent = self.on_thumbnail_click\n   229→        self.play_overlay.mousePressEvent = self.on_thumbnail_click\n   230→        \n   231→        thumbnail_layout.addWidget(thumbnail_container)\n   232→        \n   233→        # 视频播放器页面\n   234→        self.video_widget = QVideoWidget()\n   235→        self.video_widget.setObjectName(\"VideoWidget\")\n   236→        \n   237→        # 使用全局视频管理器（单例模式）\n   238→        logger.debug(\"[UI] 连接全局视频管理器...\")\n   239→        self._video_manager = get_global_video_manager()\n   240→        \n   241→        # 绑定当前对话框（独占绑定，只有当前对话框接收信号）\n   242→        self._video_manager.bind_dialog(self)\n   243→        logger.debug(\"[UI] 全局视频管理器绑定完成\")\n   244→        \n   245→        # 播放状态标志\n   246→        self.is_playing = False\n   247→        \n   248→        # 添加到堆叠布局\n   249→        self.video_stack.addWidget(self.thumbnail_widget)  # 索引0：缩略图\n   250→        self.video_stack.addWidget(self.video_widget)      # 索引1：Qt视频播放器\n   251→        \n   252→        # 加载视频和缩略图\n   253→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   254→        if video_path and os.path.exists(video_path):\n   255→            # 不在初始化时加载媒体，延迟到用户点击播放时\n   256→            self.load_thumbnail()\n   257→        \n   258→        container_layout.addWidget(self.video_stack)\n   259→        \n   260→        # 视频区域占据所有可用空间\n   261→        left_splitter = QSplitter(Qt.Vertical)\n   262→        left_splitter.addWidget(video_container)\n   263→\n   264→        self.reference_gallery = ReferenceGalleryWidget()\n   265→        try:\n   266→            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n   267→            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n   268→            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n   269→        except Exception:\n   270→            pass\n   271→        # 参考图区域容器，包含画廊与操作按钮\n   272→        reference_section = QWidget()\n   273→        reference_section_layout = QVBoxLayout(reference_section)\n   274→        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n   275→        reference_section_layout.setSpacing(6)\n   276→        reference_section_layout.addWidget(self.reference_gallery)\n   277→        # 将左侧分割器先加入主布局（第二块稍后补充按钮区后再添加）\n   278→        # 注意：最终会把 reference_section 放入分割器\n   279→\n   280→        reference_button_layout = QHBoxLayout()\n   281→        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n   282→        reference_button_layout.setSpacing(6)\n   283→        self.export_status_label = QLabel(\"\")\n   284→        self.export_status_label.setObjectName(\"infoLabel\")\n   285→        unified_style_system.apply_to_widget(self.export_status_label)\n   286→        reference_button_layout.addWidget(self.export_status_label)\n   287→        reference_button_layout.addStretch(1)\n   288→        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n   289→        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n   290→        self.reference_export_btn.setEnabled(False)\n   291→        unified_style_system.apply_to_widget(self.reference_export_btn)\n   292→        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n   293→        reference_button_layout.addWidget(self.reference_export_btn)\n   294→        self.export_bundle_btn = QPushButton(\"导出记录\")\n   295→        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n   296→        self.export_bundle_btn.setEnabled(False)\n   297→        unified_style_system.apply_to_widget(self.export_bundle_btn)\n   298→        self._export_controller.configure(\n   299→            self.export_bundle_btn,\n   300→            self.export_status_label,\n   301→            self._resolve_video_record_id,\n   302→            context_widget=self,\n   303→        )\n   304→        reference_button_layout.addWidget(self.export_bundle_btn)\n   305→        reference_section_layout.addLayout(reference_button_layout)\n   306→        # 将参考图区域加入分割器，并把分割器加入左侧布局\n   307→        left_splitter.addWidget(reference_section)\n   308→        try:\n   309→            left_splitter.setStretchFactor(0, 3)\n   310→            left_splitter.setStretchFactor(1, 2)\n   311→            left_splitter.setSizes([520, 280])\n   312→        except Exception:\n   313→            pass\n   314→        left_layout.addWidget(left_splitter, 1)\n   315→\n   316→        # 底部控制区域\n   317→        controls_layout = QHBoxLayout()\n   318→        controls_layout.setContentsMargins(0, 5, 0, 5)\n   319→        controls_layout.setSpacing(10)\n   320→        \n   321→        # 播放/暂停按钮\n   322→        self.play_button = QPushButton(\"▶\")\n   323→        self.play_button.setFixedSize(40, 30)\n   324→        self.play_button.setObjectName(\"PlayButton\")\n   325→        unified_style_system.apply_to_widget(self.play_button)\n   326→        self.play_button.clicked.connect(self.toggle_play_pause)\n   327→        controls_layout.addWidget(self.play_button)\n   328→        \n   329→        # 进度条（简单的标签显示）\n   330→        self.progress_label = QLabel(\"00:00 / 00:00\")\n   331→        self.progress_label.setObjectName(\"ProgressLabel\")\n   332→        controls_layout.addWidget(self.progress_label, 1)\n   333→        \n   334→        # 音量控制\n   335→        volume_label = QLabel(\"🔊\")\n   336→        volume_label.setObjectName(\"infoLabel\")\n   337→        unified_style_system.apply_to_widget(volume_label)\n   338→        controls_layout.addWidget(volume_label)\n   339→        \n   340→        # 导航按钮\n   341→        self.prev_btn = QPushButton(\"◀\")\n   342→        self.prev_btn.setFixedSize(30, 30)\n   343→        self.prev_btn.setObjectName(\"NavButton\")\n   344→        unified_style_system.apply_to_widget(self.prev_btn)\n   345→        self.prev_btn.clicked.connect(self.show_previous_video)\n   346→        controls_layout.addWidget(self.prev_btn)\n   347→\n   348→        self.next_btn = QPushButton(\"▶\")\n   349→        self.next_btn.setFixedSize(30, 30)\n   350→        self.next_btn.setObjectName(\"NavButton\")\n   351→        unified_style_system.apply_to_widget(self.next_btn)\n   352→        self.next_btn.clicked.connect(self.show_next_video)\n   353→        controls_layout.addWidget(self.next_btn)\n   354→        \n   355→        left_layout.addLayout(controls_layout)\n   356→\n   357→        # 更新导航按钮状态\n   358→        self.update_navigation_buttons()\n   359→        self._refresh_reference_gallery()\n   360→        self._export_controller.refresh()\n   361→\n   362→        # 右侧：详细信息（固定30%宽度）\n   363→        right_layout = QVBoxLayout()\n   364→        \n   365→        # 创建参数显示区域\n   366→        params_widget = QWidget()\n   367→        params_widget.setFixedWidth(int(self.width() * 0.3))\n   368→        params_widget.setObjectName(\"ParamsWidget\")\n   369→        params_layout = QVBoxLayout(params_widget)\n   370→        params_layout.setSpacing(0)\n   371→        params_layout.setContentsMargins(5, 5, 5, 5)\n   372→        \n   373→        # 解析生成参数\n   374→        params = self.video_data.get('parameters', '{}')\n   375→        if isinstance(params, str):\n   376→            try:\n   377→                params = json.loads(params)\n   378→            except:\n   379→                params = {}\n   380→        \n   381→        # 提示词区域\n   382→        prompt_label = QLabel(\"<b>提示词:</b>\")\n   383→        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   384→        unified_style_system.apply_to_widget(prompt_label)\n   385→        params_layout.addWidget(prompt_label)\n   386→        \n   387→        # 提示词文本框\n   388→        prompt_content = self.video_data.get('prompt', '无提示词')\n   389→        self.prompt_text_edit = QTextEdit()\n   390→        self.prompt_text_edit.setPlainText(prompt_content)\n   391→        self.prompt_text_edit.setReadOnly(True)\n   392→        # 约 4 行高度（按当前字体动态计算），避免提示词区域过高挤压其它信息\n   393→        try:\n   394→            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n   395→            target_lines = 4\n   396→            vertical_padding = 16  # 与全局 QTextEdit padding (8*2) 对齐\n   397→            border = 2  # 1px*2\n   398→            height = line_height * target_lines + vertical_padding + border\n   399→            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n   400→        except Exception:\n   401→            self.prompt_text_edit.setMaximumHeight(96)\n   402→            self.prompt_text_edit.setMinimumHeight(96)\n   403→        unified_style_system.apply_to_widget(self.prompt_text_edit)\n   404→        # 应用与 _update_theme 一致的额外样式\n   405→        colors = unified_style_system.get_colors()\n   406→        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card')\n   407→        text_color = colors.get('text') or colors.get('palette.text.primary')\n   408→        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   409→        brand = colors.get('palette.brand.main') or colors.get('primary')\n   410→        self.prompt_text_edit.setStyleSheet(f\"\"\"\n   411→            QTextEdit {{\n   412→                background-color: {bg_input};\n   413→                color: {text_color};\n   414→                border: 1px solid {border_subtle};\n   415→                border-radius: 8px;\n   416→                padding: 8px;\n   417→            }}\n   418→            QTextEdit:focus {{\n   419→                border-color: {brand};\n   420→            }}\n   421→        \"\"\")\n   422→        params_layout.addWidget(self.prompt_text_edit)\n   423→        \n   424→        # 复制提示词按钮（使用统一的 SecondaryButton 样式）\n   425→        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n   426→        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n   427→        self.copy_prompt_btn.setMaximumHeight(30)\n   428→        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n   429→        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n   430→        params_layout.addWidget(self.copy_prompt_btn)\n   431→        \n   432→        # 详细信息 - 保存标签引用以便后续更新\n   433→        self.param_labels = {}  # 存储参数值标签的引用\n   434→\n   435→        # 从 parameters 中获取参数（兼容顶级字段）\n   436→        params = self.video_data.get('parameters', {}) or {}\n   437→        duration = params.get('duration') or self.video_data.get('duration', '未知')\n   438→        file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n   439→\n   440→        info_items = [\n   441→            (\"分辨率\", build_resolution_text(self.video_data)),\n   442→            (\"时长\", f\"{duration}秒\"),\n   443→            (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n   444→            (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n   445→            (\"文件大小\", self.format_file_size(file_size)),\n   446→            (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n   447→        ]\n   448→        \n   449→        for label, value in info_items:\n   450→            label_widget = QLabel(f\"<b>{label}:</b>\")\n   451→            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   452→            unified_style_system.apply_to_widget(label_widget)\n   453→            params_layout.addWidget(label_widget)\n   454→            \n   455→            # Use QLineEdit for better copy interaction\n   456→            from PySide6.QtWidgets import QLineEdit\n   457→            value_label = QLineEdit(str(value))\n   458→            value_label.setReadOnly(True)\n   459→            value_label.setCursorPosition(0)\n   460→            value_label.setCursorPosition(0)\n   461→            # Style is now handled in _update_theme\n   462→            unified_style_system.apply_to_widget(value_label)\n   463→            params_layout.addWidget(value_label)\n   464→            \n   465→            # 保存参数值标签引用，用于后续更新\n   466→            self.param_value_labels[label] = value_label\n   467→        \n   468→        right_layout.addWidget(params_widget)\n   469→        \n   470→        # 控制按钮\n   471→        button_layout = QHBoxLayout()\n   472→\n   473→        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n   474→        self.fullscreen_btn.setMaximumHeight(30)\n   475→        unified_style_system.apply_to_widget(self.fullscreen_btn)\n   476→        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n   477→        button_layout.addWidget(self.fullscreen_btn)\n   478→\n   479→        self.download_btn = QPushButton(\"下载视频\")\n   480→        self.download_btn.setMaximumHeight(30)\n   481→        unified_style_system.apply_to_widget(self.download_btn)\n   482→        self.download_btn.clicked.connect(self.download_video)\n   483→        button_layout.addWidget(self.download_btn)\n   484→\n   485→        self.delete_btn = QPushButton(\"删除记录\")\n   486→        self.delete_btn.setMaximumHeight(30)\n   487→        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n   488→        self.delete_btn.clicked.connect(self._delete_current_record)\n   489→        button_layout.addWidget(self.delete_btn)\n   490→\n   491→        right_layout.addLayout(button_layout)\n   492→\n   493→        self.close_btn = QPushButton(\"关闭（ESC）\")\n   494→        unified_style_system.apply_to_widget(self.close_btn)\n   495→        self.close_btn.clicked.connect(self.accept)\n   496→        right_layout.addWidget(self.close_btn)\n   497→        \n   498→        # 设置布局比例：左侧70%，右侧30%\n   499→        layout.addWidget(left_widget, 7)\n   500→        layout.addLayout(right_layout, 3)\n   501→        \n   502→        # 添加键盘快捷键\n   503→        self.setup_shortcuts()\n   504→\n   505→        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n   506→        self._focus_timer.start(100)\n   507→        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n   508→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   509→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   510→        \n   511→        # Apply initial theme\n   512→        self._update_theme()\n   513→        \n   514→        # 信号已在setup_ui开头连接，不重复连接\n   515→    \n   516→    def closeEvent(self, event):\n   517→        \"\"\"窗口关闭事件，确保停止播放并释放资源\"\"\"\n   518→        # 0. 阻止对话框继续接收事件\n   519→        self.setEnabled(False)\n   520→        \n   521→        # 1. 停止焦点定时器\n   522→        if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n   523→            self._focus_timer.stop()\n   524→        \n   525→        # 2. 清理参考图画廊\n   526→        if hasattr(self, 'reference_gallery') and self.reference_gallery is not None:\n   527→            try:\n   528→                self.reference_gallery.clear()\n   529→            except Exception as e:\n   530→                logger.warning(f\"[CLEANUP] 清理参考图画廊时出错: {e}\")\n   531→        \n   532→        # 3. 解绑并停止全局视频管理器\n   533→        if hasattr(self, '_video_manager') and self._video_manager is not None:\n   534→            try:\n   535→                # 解绑对话框（取消独占绑定）\n   536→                self._video_manager.unbind_dialog(self)\n   537→                \n   538→                # 停止播放并断开视频输出\n   539→                self._video_manager.stop()\n   540→                \n   541→            except Exception as e:\n   542→                logger.warning(f\"[CLEANUP] 停止全局视频管理器时出错: {e}\")\n   543→\n   544→        # 4. 兼容旧字段：若存在本地 media_player 也停止\n   545→        if hasattr(self, 'media_player') and self.media_player:\n   546→            try:\n   547→                self.media_player.stop()\n   548→            except Exception:\n   549→                pass\n   550→\n   551→        # 5. 清理导出控制器\n   552→        try:\n   553→            self._export_controller.dispose()\n   554→        except Exception:\n   555→            pass\n   556→        \n   557→        self.is_playing = False\n   558→        super().closeEvent(event)\n   559→    \n   560→    def load_thumbnail(self):\n   561→        \"\"\"加载视频缩略图\"\"\"\n   562→        import os  # 将os导入移到函数开头\n   563→        try:\n   564→            logger.debug(\"开始加载缩略图...\")\n   565→            logger.debug(f\"视频数据: {self.video_data}\")\n   566→            \n   567→            # 获取缩略图路径\n   568→            thumbnail_path = self.video_data.get('thumbnail_local_path', '')\n   569→            logger.debug(f\"从video_data获取的thumbnail_local_path: {thumbnail_path}\")\n   570→            \n   571→            if thumbnail_path and os.path.exists(thumbnail_path):\n   572→                logger.debug(f\"找到现有缩略图文件: {thumbnail_path}\")\n   573→                # 使用现有缩略图\n   574→                pixmap = QPixmap(thumbnail_path)\n   575→                logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n   576→            else:\n   577→                logger.debug(\"缩略图文件不存在或路径为空，开始生成缩略图...\")\n   578→                # 生成缩略图\n   579→                video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   580→                logger.debug(f\"视频文件路径: {video_path}\")\n   581→                \n   582→                if video_path and os.path.exists(video_path):\n   583→                    logger.debug(\"视频文件存在，开始生成缩略图...\")\n   584→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   585→                    from config_api import get_storage_dir\n   586→                    storage_dir = get_storage_dir()\n   587→                    thumbnails_dir = os.path.join(storage_dir, 'thumbnails')\n   588→                    logger.debug(f\"缩略图目录: {thumbnails_dir}\")\n   589→                    \n   590→                    generator = VideoThumbnailGenerator(thumbnails_dir)\n   591→                    video_id = self.video_data.get('id', os.path.basename(video_path).split('.')[0])\n   592→                    logger.debug(f\"视频ID: {video_id}\")\n   593→                    \n   594→                    thumbnail_path = generator.generate_thumbnail_for_video(video_path, video_id)\n   595→                    logger.debug(f\"生成的缩略图路径: {thumbnail_path}\")\n   596→                    \n   597→                    if thumbnail_path and os.path.exists(thumbnail_path):\n   598→                        logger.debug(\"缩略图生成成功，加载到QPixmap...\")\n   599→                        pixmap = QPixmap(thumbnail_path)\n   600→                        logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n   601→                    else:\n   602→                        logger.debug(\"缩略图生成失败，使用默认图片\")\n   603→                        # 使用默认图片\n   604→                        pixmap = self.create_default_thumbnail()\n   605→                else:\n   606→                    logger.debug(\"视频文件不存在，使用默认图片\")\n   607→                    pixmap = self.create_default_thumbnail()\n   608→            \n   609→            if not pixmap.isNull():\n   610→                logger.debug(\"开始缩放图片...\")\n   611→                # 缩放图片以适应标签大小\n   612→                label_size = self.thumbnail_label.size()\n   613→                logger.debug(f\"标签大小: {label_size}\")\n   614→                \n   615→                scaled_pixmap = pixmap.scaled(\n   616→                    label_size,\n   617→                    Qt.KeepAspectRatio,\n   618→                    Qt.SmoothTransformation\n   619→                )\n   620→                logger.debug(f\"缩放后图片大小: {scaled_pixmap.size()}\")\n   621→                \n   622→                self.thumbnail_label.setPixmap(scaled_pixmap)\n   623→                logger.debug(\"缩略图设置成功\")\n   624→            else:\n   625→                logger.debug(\"QPixmap为空，显示错误文本\")\n   626→                self.thumbnail_label.setText(\"无法加载缩略图\")\n   627→                \n   628→        except Exception as e:\n   629→            logger.debug(f\"加载缩略图异常: {e}\")\n   630→            import traceback\n   631→            traceback.print_exc()\n   632→            self.thumbnail_label.setText(\"缩略图加载失败\")\n   633→    \n   634→    def create_default_thumbnail(self):\n   635→        \"\"\"创建默认缩略图\"\"\"\n   636→        pixmap = QPixmap(400, 300)\n   637→        pixmap.fill(Qt.black)\n   638→        \n   639→        from PySide6.QtGui import QPainter, QFont\n   640→        painter = QPainter(pixmap)\n   641→        painter.setPen(Qt.white)\n   642→        painter.setFont(QFont())  # Font configuration handled by unified style system\n   643→        painter.drawText(pixmap.rect(), Qt.AlignCenter, \"视频预览\")\n   644→        painter.end()\n   645→        \n   646→        return pixmap\n   647→    \n   648→    def on_thumbnail_click(self, event):\n   649→        \"\"\"缩略图点击事件\"\"\"\n   650→        self.start_video_playback()\n   651→    \n   652→    def start_video_playback(self):\n   653→        \"\"\"开始视频播放\"\"\"\n   654→        logger.debug(\"[UI] 开始视频播放…\")\n   655→        \n   656→        # 检查视频文件\n   657→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   658→        \n   659→        if not video_path or not os.path.exists(video_path):\n   660→            logger.warning(f\"[UI] 视频文件不存在: {video_path}\")\n   661→            from PySide6.QtWidgets import QMessageBox\n   662→            QMessageBox.critical(self, \"错误\", \"视频文件不存在\")\n   663→            return\n   664→        \n   665→        # 切换到视频播放器\n   666→        self.video_stack.setCurrentIndex(1)\n   667→        self.is_playing = True\n   668→        \n   669→        # 使用全局视频管理器播放\n   670→        self._video_manager.play(video_path, self.video_widget)\n   671→        logger.debug(\"[UI] 开始播放视频\")\n   672→    \n   673→    def toggle_play_pause(self):\n   674→        \"\"\"切换播放/暂停\"\"\"\n   675→        if not self.is_playing:\n   676→            self.start_video_playback()\n   677→        else:\n   678→            self._video_manager.toggle_play_pause()\n   679→    \n   680→    def on_state_changed(self, state):\n   681→        \"\"\"播放状态改变\"\"\"\n   682→        if state == QMediaPlayer.PlaybackState.PlayingState:\n   683→            self.play_button.setText(\"⏸\")\n   684→        else:\n   685→            self.play_button.setText(\"▶\")\n   686→    \n   687→    def on_position_changed(self, position):\n   688→        \"\"\"播放位置改变\"\"\"\n   689→        if hasattr(self, 'media_player'):\n   690→            duration = self.media_player.duration()\n   691→            if duration > 0:\n   692→                current_time = self.format_duration(position)\n   693→                total_time = self.format_duration(duration)\n   694→                self.progress_label.setText(f\"{current_time} / {total_time}\")\n   695→    \n   696→    def on_duration_changed(self, duration):\n   697→        \"\"\"视频时长改变\"\"\"\n   698→        if duration > 0:\n   699→            total_time = self.format_duration(duration)\n   700→            self.progress_label.setText(f\"00:00 / {total_time}\")\n   701→    \n   702→    def on_media_error(self, error, error_string):\n   703→        \"\"\"媒体播放错误处理\"\"\"\n   704→        logger.error(f\"[MEDIA] 播放错误: {error}, 信息: {error_string}\")\n   705→        \n   706→        from PySide6.QtWidgets import QMessageBox\n   707→        msg_box = QMessageBox(self)\n   708→        msg_box.setIcon(QMessageBox.Critical)\n   709→        msg_box.setText(\"视频播放错误\")\n   710→        msg_box.setInformativeText(f\"无法播放视频: {error_string}\")\n   711→        msg_box.exec()\n   712→        \n   713→        # 返回缩略图模式\n   714→        self.video_stack.setCurrentIndex(0)\n   715→        self.is_playing = False\n   716→    \n   717→    def on_media_status_changed(self, status):\n   718→        \"\"\"媒体状态改变\"\"\"\n   719→        from PySide6.QtMultimedia import QMediaPlayer\n   720→        \n   721→        logger.debug(f\"[MEDIA] 状态改变: {status}\")\n   722→        \n   723→        if status == QMediaPlayer.MediaStatus.EndOfMedia:\n   724→            # 视频播放结束，返回缩略图模式\n   725→            logger.debug(\"[MEDIA] 播放结束，切回缩略图模式\")\n   726→            self.video_stack.setCurrentIndex(0)\n   727→            self.is_playing = False\n   728→            if hasattr(self, 'media_player'):\n   729→                self.media_player.setPosition(0)  # 重置播放位置\n   730→            self.progress_label.setText(\"00:00 / 00:00\")\n   731→        elif status == QMediaPlayer.MediaStatus.InvalidMedia:\n   732→            logger.warning(\"[MEDIA] 媒体文件无效\")\n   733→        elif status == QMediaPlayer.MediaStatus.BufferedMedia:\n   734→            logger.debug(\"[MEDIA] 媒体缓冲完成\")\n   735→        elif status == QMediaPlayer.MediaStatus.LoadingMedia:\n   736→            logger.debug(\"[MEDIA] 正在加载媒体\")\n   737→        elif status == QMediaPlayer.MediaStatus.StalledMedia:\n   738→            logger.debug(\"[MEDIA] 播放卡顿\")\n   739→    \n   740→    def format_duration(self, ms):\n   741→        \"\"\"格式化时长显示\"\"\"\n   742→        seconds = ms // 1000\n   743→        minutes = seconds // 60\n   744→        seconds = seconds % 60\n   745→        return f\"{minutes:02d}:{seconds:02d}\"\n   746→    \n   747→    # OpenCV playback methods removed - using QtMultimedia exclusively\n   748→\n   749→    \n   750→    def format_time(self, time_str: str) -> str:\n   751→        \"\"\"格式化时间显示\"\"\"\n   752→        if not time_str:\n   753→            return '未知时间'\n   754→        try:\n   755→            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n   756→            return dt.strftime('%Y-%m-%d %H:%M:%S')\n   757→        except:\n   758→            return time_str[:19] if len(time_str) > 19 else time_str\n   759→    \n   760→    def format_file_size(self, size) -> str:\n   761→        \"\"\"格式化文件大小显示\"\"\"\n   762→        try:\n   763→            size = float(size) if size else 0\n   764→        except (ValueError, TypeError):\n   765→            return '未知大小'\n   766→            \n   767→        if size == 0:\n   768→            return '未知大小'\n   769→        \n   770→        for unit in ['B', 'KB', 'MB', 'GB']:\n   771→            if size < 1024.0:\n   772→                return f\"{size:.1f} {unit}\"\n   773→            size /= 1024.0\n   774→        return f\"{size:.1f} TB\"\n   775→    \n   776→    def setup_shortcuts(self):\n   777→        \"\"\"设置键盘快捷键\"\"\"\n   778→        # 移除所有QShortcut，统一使用keyPressEvent处理\n   779→        # 避免快捷键冲突问题\n   780→        pass\n   781→    \n   782→    def _ensure_focus(self):\n   783→        \"\"\"确保窗口获得焦点\"\"\"\n   784→        self.activateWindow()\n   785→        self.raise_()\n   786→        self.setFocus()\n   787→        logger.debug(f\"[FOCUS] VideoDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n   788→    \n   789→    def keyPressEvent(self, event):\n   790→        \"\"\"键盘事件处理\"\"\"\n   791→        from PySide6.QtCore import Qt\n   792→        \n   793→        logger.debug(f\"[KEYBOARD] VideoDetailDialog键盘事件: {event.key()}\")\n   794→        \n   795→        if event.key() == Qt.Key_Left:\n   796→            # 左方向键：上一个视频\n   797→            logger.debug(f\"[KEYBOARD] 左键pressed，prev_btn enabled: {self.prev_btn.isEnabled()}\")\n   798→            if self.prev_btn.isEnabled():\n   799→                self.show_previous_video()\n   800→            event.accept()\n   801→        elif event.key() == Qt.Key_Right:\n   802→            # 右方向键：下一个视频\n   803→            logger.debug(f\"[KEYBOARD] 右键pressed，next_btn enabled: {self.next_btn.isEnabled()}\")\n   804→            if self.next_btn.isEnabled():\n   805→                self.show_next_video()\n   806→            event.accept()\n   807→        elif event.key() == Qt.Key_Escape:\n   808→            # ESC键：关闭对话框（保持原有功能）\n   809→            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n   810→            if self.is_fullscreen:\n   811→                self.exit_fullscreen()\n   812→            else:\n   813→                self.accept()\n   814→            event.accept()\n   815→        elif event.key() == Qt.Key_F11:\n   816→            # F11键：全屏切换（保持原有功能）\n   817→            self.toggle_fullscreen()\n   818→            event.accept()\n   819→        elif event.key() == Qt.Key_Space:\n   820→            # 空格键：播放/暂停\n   821→            self.toggle_play_pause()\n   822→            event.accept()\n   823→        else:\n   824→            # 其他按键交给父类处理\n   825→            super().keyPressEvent(event)\n   826→    \n   827→    def toggle_fullscreen(self):\n   828→        \"\"\"切换全屏模式\"\"\"\n   829→        if self.is_fullscreen:\n   830→            self.exit_fullscreen()\n   831→        else:\n   832→            self.enter_fullscreen()\n   833→    \n   834→    def enter_fullscreen(self):\n   835→        \"\"\"进入全屏模式\"\"\"\n   836→        if not self.is_fullscreen:\n   837→            self.original_geometry = self.geometry()\n   838→            self.showFullScreen()\n   839→            self.is_fullscreen = True\n   840→    \n   841→    def exit_fullscreen(self):\n   842→        \"\"\"退出全屏模式\"\"\"\n   843→        if self.is_fullscreen:\n   844→            self.showNormal()\n   845→            if self.original_geometry:\n   846→                self.setGeometry(self.original_geometry)\n   847→            self.is_fullscreen = False\n   848→    \n   849→    def handle_escape_key(self):\n   850→        \"\"\"处理ESC键\"\"\"\n   851→        if self.is_fullscreen:\n   852→            self.exit_fullscreen()\n   853→        else:\n   854→            self.accept()\n   855→    \n   856→    def copy_prompt(self):\n   857→        \"\"\"复制提示词到剪贴板\"\"\"\n   858→        prompt_content = self.prompt_text_edit.toPlainText()\n   859→        clipboard = QApplication.clipboard()\n   860→        clipboard.setText(prompt_content)\n   861→        self.show_copy_toast(\"提示词已复制到剪贴板\")\n   862→    \n   863→    def show_copy_toast(self, message: str):\n   864→        \"\"\"显示复制成功的轻量提示\"\"\"\n   865→        toast = QLabel(message, self)\n   866→        toast.setObjectName(\"ToastLabel\")\n   867→        toast.setAlignment(Qt.AlignCenter)\n   868→        toast.adjustSize()\n   869→        \n   870→        x = (self.width() - toast.width()) // 2\n   871→        y = self.height() // 4\n   872→        toast.move(x, y)\n   873→        toast.show()\n   874→        \n   875→        QTimer.singleShot(2000, toast.deleteLater)\n   876→\n   877→    def _on_reference_clicked(self, asset: Dict[str, Any]):\n   878→        assets = list(self._reference_assets) if self._reference_assets else [asset]\n   879→        start_idx = _find_reference_asset_index(assets, asset)\n   880→        open_reference_preview(\n   881→            self,\n   882→            asset,\n   883→            title_prefix=\"参考图\",\n   884→            asset_list=assets,\n   885→            start_index=start_idx,\n   886→            on_asset_changed=self._sync_reference_selection,\n   887→        )\n   888→\n   889→    def _on_reference_export(self, asset: Dict[str, Any]):\n   890→        export_reference_asset(self, asset)\n   891→\n   892→    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n   893→        asset_path = resolve_asset_path(asset) if isinstance(asset, dict) else None\n   894→        has_path = bool(asset_path)\n   895→        if hasattr(self, 'reference_export_btn'):\n   896→            self.reference_export_btn.setEnabled(has_path)\n   897→\n   898→    def _export_selected_reference(self):\n   899→        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n   900→        if not asset:\n   901→            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n   902→            return\n   903→        export_reference_asset(self, asset)\n   904→\n   905→    def _refresh_reference_gallery(self):\n   906→        if not hasattr(self, 'reference_gallery'):\n   907→            return\n   908→        self._reference_summary = ensure_reference_info(self.video_data)\n   909→        if self._reference_summary.get('count', 0) <= 0:\n   910→            self.reference_gallery.setVisible(False)\n   911→            self.reference_gallery.clear()\n   912→            if hasattr(self, 'reference_export_btn'):\n   913→                self.reference_export_btn.setEnabled(False)\n   914→            self._reference_assets = []\n   915→            self._export_controller.refresh()\n   916→            return\n   917→        try:\n   918→            self._reference_assets = resolve_reference_assets(self.video_data, absolute=True)\n   919→        except Exception:\n   920→            self._reference_assets = []\n   921→        self.reference_gallery.set_assets(self._reference_assets)\n   922→        self.reference_gallery.setVisible(True)\n   923→        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n   924→        self._export_controller.refresh()\n   925→\n   926→    def _sync_reference_selection(self, asset: Dict[str, Any]):\n   927→        try:\n   928→            self.reference_gallery.select_asset(asset)\n   929→        except Exception:\n   930→            pass\n   931→\n   932→    def _resolve_video_record_id(self) -> Optional[str]:\n   933→        for key in (\"file_id\", \"id\", \"generation_id\"):\n   934→            value = self.video_data.get(key)\n   935→            if value not in (None, \"\"):\n   936→                return str(value)\n   937→        return None\n   938→\n   939→    def _delete_current_record(self):\n   940→        \"\"\"删除当前视频记录及相关文件\"\"\"\n   941→        record_id = self._resolve_video_record_id()\n   942→        if not record_id:\n   943→            self.show_copy_toast(\"无法获取记录ID\")\n   944→            return\n   945→        \n   946→        try:\n   947→            # 停止当前播放\n   948→            if hasattr(self, 'media_player'):\n   949→                self.media_player.stop()\n   950→            \n   951→            # 获取 RepositoryManager\n   952→            from config_api import get_storage_dir\n   953→            from modules.repository.manager import RepositoryManager\n   954→            \n   955→            storage_dir = get_storage_dir()\n   956→            repo = RepositoryManager(storage_dir)\n   957→            \n   958→            # 执行删除\n   959→            if repo.delete_record_with_files(record_id):\n   960→                self.show_copy_toast(\"记录已删除\")\n   961→                \n   962→                # 发出信号通知父视图刷新\n   963→                self.recordDeleted.emit(record_id)\n   964→                \n   965→                # 从列表中移除当前记录\n   966→                if len(self.video_list) > 1:\n   967→                    del self.video_list[self.current_index]\n   968→                    \n   969→                    # 导航到后一条记录（保持索引，指向原来的下一条）\n   970→                    # 只有当删除的是最后一条时，才需要调整索引\n   971→                    if self.current_index >= len(self.video_list):\n   972→                        self.current_index = len(self.video_list) - 1\n   973→                    \n   974→                    # 更新 video_data 到新的当前记录\n   975→                    self.video_data = self.video_list[self.current_index]\n   976→                    self.load_video()\n   977→                    self.update_navigation_buttons()\n   978→                else:\n   979→                    # 只剩一条记录，关闭对话框\n   980→                    self.accept()\n   981→            else:\n   982→                self.show_copy_toast(\"删除失败\")\n   983→        except Exception as e:\n   984→            from utils.logger import logger\n   985→            logger.error(f\"删除视频记录异常: {e}\")\n   986→            self.show_copy_toast(f\"删除失败: {str(e)}\")\n   987→\n   988→    def download_video(self):\n   989→        \"\"\"下载视频到指定位置\"\"\"\n   990→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   991→        if not video_path or not os.path.exists(video_path):\n   992→            self.show_styled_message(\"错误\", \"视频文件不存在\", \"warning\")\n   993→            return\n   994→        \n   995→        file_dialog = QFileDialog()\n   996→        save_path, _ = file_dialog.getSaveFileName(\n   997→            self,\n   998→            \"保存视频\",\n   999→            f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4\",\n  1000→            \"视频文件 (*.mp4)\"\n  1001→        )\n  1002→        \n  1003→        if save_path:\n  1004→            try:\n  1005→                import shutil\n  1006→                shutil.copy2(video_path, save_path)\n  1007→                self.show_copy_toast(f\"视频已保存到: {os.path.basename(save_path)}\")\n  1008→            except Exception as e:\n  1009→                self.show_styled_message(\"错误\", f\"保存视频失败: {str(e)}\", \"critical\")\n  1010→    \n  1011→    def update_navigation_buttons(self):\n  1012→        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n  1013→        logger.debug(f\"[NAV] 更新导航按钮：当前索引{self.current_index}，总记录数{len(self.video_list)}\")\n  1014→        \n  1015→        has_prev = self._has_valid_previous_record()\n  1016→        has_next = self._has_valid_next_record()\n  1017→        \n  1018→        logger.debug(f\"[NAV] 有效记录检查：prev={has_prev}, next={has_next}\")\n  1019→        \n  1020→        self.prev_btn.setEnabled(has_prev)\n  1021→        self.next_btn.setEnabled(has_next)\n  1022→    \n  1023→    def _has_valid_previous_record(self):\n  1024→        \"\"\"检查是否有有效的上一个记录\"\"\"\n  1025→        logger.debug(f\"[NAV] 检查上一个记录：从索引{self.current_index - 1}到0\")\n  1026→        for i in range(self.current_index - 1, -1, -1):\n  1027→            candidate_data = self.video_list[i]\n  1028→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1029→            content_type = candidate_data.get('content_type', '')\n  1030→            \n  1031→            # 检查文件扩展名，确保是视频文件\n  1032→            is_video = False\n  1033→            if file_path:\n  1034→                from pathlib import Path\n  1035→                file_ext = Path(file_path).suffix.lower()\n  1036→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1037→            \n  1038→            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n  1039→            \n  1040→            if file_path and os.path.exists(file_path) and is_video:\n  1041→                logger.debug(f\"[NAV] 找到有效的上一个视频记录：索引{i}\")\n  1042→                return True\n  1043→        logger.debug(f\"[NAV] 没有找到有效的上一个视频记录\")\n  1044→        return False\n  1045→    \n  1046→    def _has_valid_next_record(self):\n  1047→        \"\"\"检查是否有有效的下一个记录\"\"\"\n  1048→        logger.debug(f\"[NAV] 检查下一个记录：从索引{self.current_index + 1}到{len(self.video_list) - 1}\")\n  1049→        for i in range(self.current_index + 1, len(self.video_list)):\n  1050→            candidate_data = self.video_list[i]\n  1051→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1052→            content_type = candidate_data.get('content_type', '')\n  1053→            \n  1054→            # 检查文件扩展名，确保是视频文件\n  1055→            is_video = False\n  1056→            if file_path:\n  1057→                from pathlib import Path\n  1058→                file_ext = Path(file_path).suffix.lower()\n  1059→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1060→            \n  1061→            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n  1062→            \n  1063→            if file_path and os.path.exists(file_path) and is_video:\n  1064→                logger.debug(f\"[NAV] 找到有效的下一个视频记录：索引{i}\")\n  1065→                return True\n  1066→        logger.debug(f\"[NAV] 没有找到有效的下一个视频记录\")\n  1067→        return False\n  1068→    \n  1069→    def show_previous_video(self):\n  1070→        \"\"\"显示上一个视频（带有效性验证）\"\"\"\n  1071→        # 寻找上一个有效视频记录\n  1072→        for i in range(self.current_index - 1, -1, -1):\n  1073→            candidate_data = self.video_list[i]\n  1074→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1075→            \n  1076→            # 检查是否为视频文件\n  1077→            is_video = False\n  1078→            if file_path:\n  1079→                from pathlib import Path\n  1080→                file_ext = Path(file_path).suffix.lower()\n  1081→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1082→            \n  1083→            if file_path and os.path.exists(file_path) and is_video:\n  1084→                # 找到有效视频记录\n  1085→                logger.debug(f\"[NAV] 切换到上一个视频：索引{i}\")\n  1086→                self.current_index = i\n  1087→                self.video_data = self.video_list[i]\n  1088→                self.load_video()\n  1089→                self.update_navigation_buttons()\n  1090→                return\n  1091→        \n  1092→        # 没有找到有效的上一个视频记录，保持当前状态\n  1093→        logger.debug(f\"[NAV] 没有上一个视频可切换\")\n  1094→        self.update_navigation_buttons()\n  1095→    \n  1096→    def show_next_video(self):\n  1097→        \"\"\"显示下一个视频（带有效性验证）\"\"\"\n  1098→        # 寻找下一个有效视频记录\n  1099→        for i in range(self.current_index + 1, len(self.video_list)):\n  1100→            candidate_data = self.video_list[i]\n  1101→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1102→            \n  1103→            # 检查是否为视频文件\n  1104→            is_video = False\n  1105→            if file_path:\n  1106→                from pathlib import Path\n  1107→                file_ext = Path(file_path).suffix.lower()\n  1108→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1109→            \n  1110→            if file_path and os.path.exists(file_path) and is_video:\n  1111→                # 找到有效视频记录\n  1112→                logger.debug(f\"[NAV] 切换到下一个视频：索引{i}\")\n  1113→                self.current_index = i\n  1114→                self.video_data = self.video_list[i]\n  1115→                self.load_video()\n  1116→                self.update_navigation_buttons()\n  1117→                return\n  1118→        \n  1119→        # 没有找到有效的下一个视频记录，保持当前状态\n  1120→        logger.debug(f\"[NAV] 没有下一个视频可切换\")\n  1121→        self.update_navigation_buttons()\n  1122→    \n  1123→    def load_video(self):\n  1124→        \"\"\"加载新视频\"\"\"\n  1125→        logger.debug(\"[UI] 加载新视频…\")\n  1126→        \n  1127→        # 停止当前播放器\n  1128→        if hasattr(self, 'media_player') and self.media_player:\n  1129→            self.media_player.stop()\n  1130→        \n  1131→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n  1132→        if video_path and os.path.exists(video_path):\n  1133→            from PySide6.QtCore import QUrl\n  1134→            if hasattr(self, 'media_player') and self.media_player:\n  1135→                self.media_player.setSource(QUrl.fromLocalFile(video_path))\n  1136→            \n  1137→            # 重置到缩略图模式\n  1138→            self.video_stack.setCurrentIndex(0)\n  1139→            self.is_playing = False\n  1140→            \n  1141→            # 重新加载缩略图\n  1142→            self.load_thumbnail()\n  1143→            \n  1144→            # 更新右侧信息\n  1145→            prompt_content = self.video_data.get('prompt', '无提示词')\n  1146→            self.prompt_text_edit.setPlainText(prompt_content)\n  1147→            \n  1148→            # 更新参数信息\n  1149→            self.update_video_params()\n  1150→            \n  1151→            logger.debug(\"[UI] 新视频加载完成\")\n  1152→        else:\n  1153→            self.video_stack.setCurrentIndex(0)\n  1154→            self.is_playing = False\n  1155→\n  1156→        self._refresh_reference_gallery()\n  1157→        self._export_controller.refresh()\n  1158→    \n  1159→    def _update_theme(self):\n  1160→        \"\"\"响应主题变化\"\"\"\n  1161→        colors = unified_style_system.get_colors()\n  1162→        \n  1163→        # Apply theme to self (Dialog)\n  1164→        # Note: In some OS/Qt versions, QDialog styling needs explicit background\n  1165→        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n  1166→        text_color = colors.get('text') or colors.get('palette.text.primary')\n  1167→        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n  1168→        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or bg_card\n  1169→        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n  1170→        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n  1171→        \n  1172→        self.setStyleSheet(f\"\"\"\n  1173→            QDialog {{\n  1174→                background-color: {bg_color};\n  1175→                color: {text_color};\n  1176→            }}\n  1177→            QLabel {{\n  1178→                color: {text_color};\n  1179→            }}\n  1180→            QWidget#ParamsWidget {{\n  1181→                 background-color: {bg_card};\n  1182→                 border-left: 1px solid {border_subtle};\n  1183→            }}\n  1184→        \"\"\")\n  1185→        \n  1186→        # Update specific controls directly\n  1187→        if hasattr(self, 'prompt_text_edit'):\n  1188→             self.prompt_text_edit.setStyleSheet(f\"\"\"\n  1189→                QTextEdit {{\n  1190→                    background-color: {bg_input};\n  1191→                    color: {text_color};\n  1192→                    border: 1px solid {border_subtle};\n  1193→                    border-radius: 8px;\n  1194→                    padding: 8px;\n  1195→                }}\n  1196→                QTextEdit:focus {{\n  1197→                    border-color: {brand};\n  1198→                }}\n  1199→             \"\"\")\n  1200→\n  1201→        # Manually update param labels that were stored\n  1202→        if hasattr(self, 'param_value_labels'):\n  1203→            for label, value_label in self.param_value_labels.items():\n  1204→                value_label.setStyleSheet(f\"\"\"\n  1205→                    QLineEdit {{\n  1206→                        background-color: {bg_input};\n  1207→                        color: {text_color};\n  1208→                        border: 1px solid {border_subtle};\n  1209→                        padding: 4px;\n  1210→                        border-radius: 8px;\n  1211→                    }}\n  1212→                    QLineEdit:focus {{\n  1213→                        border-color: {brand};\n  1214→                    }}\n  1215→                \"\"\")\n  1216→\n  1217→        # Update thumbnail background if visible\n  1218→        if hasattr(self, 'thumbnail_label'):\n  1219→             player_bg = colors.get('palette.component.player_bg') or bg_color\n  1220→             self.thumbnail_label.setStyleSheet(f\"\"\"\n  1221→                QLabel {{\n  1222→                    border: none;\n  1223→                    background-color: {player_bg};\n  1224→                    color: {text_color};\n  1225→                }}\n  1226→             \"\"\")\n  1227→\n  1228→        # Reapply button styles (including fixed components)\n  1229→        if hasattr(self, 'copy_prompt_btn'):\n  1230→            unified_style_system.apply_to_widget(self.copy_prompt_btn)\n  1231→        if hasattr(self, 'fullscreen_btn'):\n  1232→            unified_style_system.apply_to_widget(self.fullscreen_btn)\n  1233→        if hasattr(self, 'download_btn'):\n  1234→            unified_style_system.apply_to_widget(self.download_btn)\n  1235→        if hasattr(self, 'delete_btn'):\n  1236→            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n  1237→        if hasattr(self, 'close_btn'):\n  1238→            unified_style_system.apply_to_widget(self.close_btn)\n  1239→        if hasattr(self, 'reference_export_btn'):\n  1240→            unified_style_system.apply_to_widget(self.reference_export_btn)\n  1241→        if hasattr(self, 'export_bundle_btn'):\n  1242→            unified_style_system.apply_to_widget(self.export_bundle_btn)\n  1243→        if hasattr(self, 'play_button'):\n  1244→            unified_style_system.apply_to_widget(self.play_button)\n  1245→        if hasattr(self, 'prev_btn'):\n  1246→            unified_style_system.apply_to_widget(self.prev_btn)\n  1247→        if hasattr(self, 'next_btn'):\n  1248→            unified_style_system.apply_to_widget(self.next_btn)\n  1249→\n  1250→    def update_video_params(self):\n  1251→        \"\"\"更新视频参数显示（切换视频时调用）\"\"\"\n  1252→        try:\n  1253→            # 解析生成参数\n  1254→            params = self.video_data.get('parameters', '{}')\n  1255→            if isinstance(params, str):\n  1256→                try:\n  1257→                    params = json.loads(params)\n  1258→                except:\n  1259→                    params = {}\n  1260→\n  1261→            # 从 parameters 中获取参数（兼容顶级字段）\n  1262→            duration = params.get('duration') or self.video_data.get('duration', '未知')\n  1263→            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n  1264→\n  1265→            # 重新构建参数信息\n  1266→            info_items = [\n  1267→                (\"分辨率\", build_resolution_text(self.video_data)),\n  1268→                (\"时长\", f\"{duration}秒\"),\n  1269→                (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n  1270→                (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n  1271→                (\"文件大小\", self.format_file_size(file_size)),\n  1272→                (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n  1273→            ]\n  1274→            \n  1275→            # 更新已保存的标签\n  1276→            for label, new_value in info_items:\n  1277→                if label in self.param_value_labels:\n  1278→                    self.param_value_labels[label].setText(str(new_value))\n  1279→            \n  1280→            logger.debug(\"视频参数已更新\")\n  1281→            \n  1282→        except Exception as e:\n  1283→            logger.error(f\"更新视频参数失败: {e}\")\n  1284→    \n  1285→    def update_param_labels(self):\n  1286→        \"\"\"更新参数标签内容\"\"\"\n  1287→        try:\n  1288→            # 从 parameters 中获取参数（兼容顶级字段）\n  1289→            params = self.video_data.get('parameters', {}) or {}\n  1290→            duration = params.get('duration') or self.video_data.get('duration', '未知')\n  1291→            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n  1292→\n  1293→            # 更新各个参数标签\n  1294→            param_updates = {\n  1295→                \"分辨率\": build_resolution_text(self.video_data),\n  1296→                \"时长\": f\"{duration}秒\",\n  1297→                \"模型\": get_model_display_name(pick_model_code(self.video_data)),\n  1298→                \"生成时间\": self.format_time(self.video_data.get('created_at', '')),\n  1299→                \"文件大小\": self.format_file_size(file_size),\n  1300→                \"文件路径\": self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n  1301→            }\n  1302→            \n  1303→            for param_name, new_value in param_updates.items():\n  1304→                if param_name in self.param_labels:\n  1305→                    self.param_labels[param_name].setText(str(new_value))\n  1306→                    logger.debug(f\"已更新参数 {param_name}: {new_value}\")\n  1307→            \n  1308→            logger.debug(\"视频参数标签更新完成\")\n  1309→        except Exception as e:\n  1310→            logger.error(f\"更新视频参数标签失败: {e}\")\n  1311→    \n  1312→    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n  1313→        \"\"\"显示带有深色主题样式的消息框\"\"\"\n  1314→        from PySide6.QtWidgets import QMessageBox\n  1315→        \n  1316→        msg_box = QMessageBox(self)\n  1317→        msg_box.setWindowTitle(title)\n  1318→        msg_box.setText(message)\n  1319→        \n  1320→        # 设置图标\n  1321→        if icon_type == \"warning\":\n  1322→            msg_box.setIcon(QMessageBox.Warning)\n  1323→        elif icon_type == \"critical\":\n  1324→            msg_box.setIcon(QMessageBox.Critical)\n  1325→        elif icon_type == \"question\":\n  1326→            msg_box.setIcon(QMessageBox.Question)\n  1327→        else:\n  1328→            msg_box.setIcon(QMessageBox.Information)\n  1329→        \n  1330→        # 样式由全局QSS控制\n  1331→        \n  1332→        msg_box.exec()\n  1333→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d98246d8-09d4-49fc-b2f2-de2d6a722c02","timestamp":"2025-12-22T06:08:40.601Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py","content":"import os\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\n\nfrom PySide6.QtWidgets import (\n    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n    QTextEdit, QFileDialog, QMessageBox, QStackedWidget, QSplitter,\n    QApplication\n)\nfrom PySide6.QtGui import QShortcut\nfrom PySide6.QtCore import Qt, QTimer, QUrl, QSize, QEvent\nfrom PySide6.QtGui import QPixmap, QFont, QKeySequence, QPainter, QImage\nfrom PySide6.QtMultimedia import QMediaPlayer\nfrom PySide6.QtMultimediaWidgets import QVideoWidget\n\n# 使用全局视频管理器单例\nfrom services.global_video_manager import get_global_video_manager\n\nfrom utils.logger import logger\nfrom components.reference_assets import (\n    ReferenceGalleryWidget,\n    export_reference_asset,\n    open_reference_preview,\n    _find_reference_asset_index,\n)\nfrom utils.style_system import unified_style_system\nfrom components.controllers import ExportBundleController\nfrom utils.reference_assets import resolve_asset_path\nfrom utils.reference_display import (\n    build_resolution_text,\n    ensure_reference_info,\n    get_model_display_name,\n    pick_model_code,\n    resolve_reference_assets,\n)\nfrom PySide6.QtCore import Signal\n\nclass VideoDetailDialog(QDialog):\n    \"\"\"视频详细信息对话框\"\"\"\n    \n    # 删除记录后发出信号，通知父视图刷新\n    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    \n    def __init__(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n        super().__init__(parent)\n        self.video_data = video_data\n        self.video_list = video_list or [video_data]  # 视频列表\n        self.current_index = current_index  # 当前视频索引\n        self.is_fullscreen = False  # 全屏状态\n        self.original_geometry = None  # 原始窗口几何\n        self.param_value_labels = {}  # 存储参数值标签的引用\n        self._reference_summary = ensure_reference_info(self.video_data)\n        self._reference_assets: List[Dict[str, Any]] = []\n        self._export_controller = ExportBundleController(self, \"video\")\n        \n        # Subscribe to theme changes\n        unified_style_system.styleChanged.connect(self._update_theme)\n        \n        self.setup_ui()\n    \n    def set_video_data(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0):\n        \"\"\"更新视频数据（复用对话框时调用，避免重建 QVideoWidget）\"\"\"\n        logger.debug(f\"[REUSE] 复用对话框，更新视频数据: index={current_index}\")\n        \n        # 1. 先停止当前播放\n        if hasattr(self, '_video_manager') and self._video_manager is not None:\n            self._video_manager.stop()\n        \n        # 2. 重置到缩略图模式\n        if hasattr(self, 'video_stack'):\n            self.video_stack.setCurrentIndex(0)\n        self.is_playing = False\n        \n        # 3. 更新数据\n        self.video_data = video_data\n        self.video_list = video_list or [video_data]\n        self.current_index = current_index\n        self._reference_summary = ensure_reference_info(self.video_data)\n        \n        # 4. 刷新UI\n        self.load_thumbnail()\n        \n        # 5. 更新右侧信息\n        if hasattr(self, 'prompt_text_edit'):\n            prompt_content = self.video_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n        \n        # 6. 更新参数信息\n        if hasattr(self, 'update_video_params'):\n            self.update_video_params()\n        \n        # 7. 更新导航按钮\n        if hasattr(self, 'update_navigation_buttons'):\n            self.update_navigation_buttons()\n        \n        # 8. 刷新参考图画廊\n        if hasattr(self, '_refresh_reference_gallery'):\n            self._refresh_reference_gallery()\n        \n        # 9. 重新激活窗口\n        self.setEnabled(True)\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        \n        logger.debug(\"[REUSE] 视频数据更新完成\")\n        \n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        self.setWindowTitle(\"视频详细信息\")\n        self.resize(1100, 800)  # 改为可调整大小\n        self.setMinimumSize(800, 600)  # 设置最小尺寸\n        \n        # 设置焦点策略，确保能接收键盘事件\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n        self.setFocus()\n\n        # 确保窗口激活时获得焦点\n        self.activateWindow()\n        self.raise_()\n\n        try:\n            self.setObjectName(\"DetailDialog\")\n        except Exception:\n            pass\n\n        self._focus_timer = QTimer(self)\n        self._focus_timer.setSingleShot(True)\n        self._focus_timer.timeout.connect(self._ensure_focus)\n\n        layout = QHBoxLayout(self)\n        \n        # 左侧：视频播放器（占70%宽度）\n        left_widget = QWidget()\n        left_layout = QVBoxLayout(left_widget)\n        left_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 视频播放区域\n        video_container = QWidget()\n        video_container.setObjectName(\"VideoContainer\")\n        \n        container_layout = QVBoxLayout(video_container)\n        container_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 创建堆叠布局，用于缩略图和视频播放器的切换\n        from PySide6.QtWidgets import QStackedWidget\n        self.video_stack = QStackedWidget()\n        \n        # 缩略图页面\n        self.thumbnail_widget = QWidget()\n        self.thumbnail_widget.setObjectName(\"ThumbnailWidget\")\n        thumbnail_layout = QVBoxLayout(self.thumbnail_widget)\n        thumbnail_layout.setContentsMargins(0, 0, 0, 0)\n        thumbnail_layout.setAlignment(Qt.AlignCenter)\n        \n        # 缩略图标签\n        self.thumbnail_label = QLabel()\n        self.thumbnail_label.setAlignment(Qt.AlignCenter)\n        colors = unified_style_system.get_colors()\n        player_bg = colors.get('palette.component.player_bg')\n        text_on_brand = (\n            colors.get('palette.text.on_brand')\n            or colors.get('palette.text.primary')\n            or colors.get('text')\n        )\n        self.thumbnail_label.setStyleSheet(f\"\"\"\n            QLabel {{\n                border: none;\n                background-color: {player_bg};\n                color: {text_on_brand};\n            }}\n        \"\"\")\n        self.thumbnail_label.setMinimumSize(400, 300)\n        # 不使用setScaledContents，改为手动缩放\n        # self.thumbnail_label.setScaledContents(True)\n        \n        # 播放按钮覆盖层\n        self.play_overlay = QLabel(\"▶\")\n        self.play_overlay.setAlignment(Qt.AlignCenter)\n        self.play_overlay.setObjectName(\"PlayOverlay\")\n        \n        # 创建缩略图容器，使用相对定位\n        thumbnail_container = QWidget()\n        thumbnail_container.setStyleSheet(f\"border: none; background-color: {player_bg};\")\n        # 设置固定尺寸确保容器有正确的大小\n        thumbnail_container.setFixedSize(640, 480)\n        \n        # 使用绝对定位放置播放按钮\n        def setup_thumbnail_layout():\n            self.thumbnail_label.setParent(thumbnail_container)\n            self.play_overlay.setParent(thumbnail_container)\n            \n            # 确保标签可见\n            self.thumbnail_label.show()\n            self.play_overlay.show()\n            \n            def resize_thumbnail_container():\n                if hasattr(self, 'thumbnail_label') and hasattr(self, 'play_overlay'):\n                    container_size = thumbnail_container.size()\n                    logger.debug(f\"[UI] 详情缩略图容器尺寸: {container_size}\")\n                    \n                    # 设置缩略图标签尺寸和位置\n                    self.thumbnail_label.setGeometry(0, 0, container_size.width(), container_size.height())\n                    \n                    # 播放按钮居中\n                    overlay_x = max(0, (container_size.width() - 70) // 2)\n                    overlay_y = max(0, (container_size.height() - 70) // 2)\n                    self.play_overlay.setGeometry(overlay_x, overlay_y, 70, 70)\n                    \n                    logger.debug(f\"[UI] 缩略图标签位置: {self.thumbnail_label.geometry()}\")\n                    logger.debug(f\"[UI] 播放按钮位置: {self.play_overlay.geometry()}\")\n            \n            def handle_resize_event(event):\n                resize_thumbnail_container()\n                QWidget.resizeEvent(thumbnail_container, event)\n            \n            thumbnail_container.resizeEvent = handle_resize_event\n            \n            # 立即调用布局函数\n            resize_thumbnail_container()\n        \n        setup_thumbnail_layout()\n        \n        # 点击事件\n        self.thumbnail_label.mousePressEvent = self.on_thumbnail_click\n        self.play_overlay.mousePressEvent = self.on_thumbnail_click\n        \n        thumbnail_layout.addWidget(thumbnail_container)\n        \n        # 视频播放器页面\n        self.video_widget = QVideoWidget()\n        self.video_widget.setObjectName(\"VideoWidget\")\n        \n        # 使用全局视频管理器（单例模式）\n        logger.debug(\"[UI] 连接全局视频管理器...\")\n        self._video_manager = get_global_video_manager()\n        \n        # 绑定当前对话框（独占绑定，只有当前对话框接收信号）\n        self._video_manager.bind_dialog(self)\n        logger.debug(\"[UI] 全局视频管理器绑定完成\")\n        \n        # 播放状态标志\n        self.is_playing = False\n        \n        # 添加到堆叠布局\n        self.video_stack.addWidget(self.thumbnail_widget)  # 索引0：缩略图\n        self.video_stack.addWidget(self.video_widget)      # 索引1：Qt视频播放器\n        \n        # 加载视频和缩略图\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if video_path and os.path.exists(video_path):\n            # 不在初始化时加载媒体，延迟到用户点击播放时\n            self.load_thumbnail()\n        \n        container_layout.addWidget(self.video_stack)\n        \n        # 视频区域占据所有可用空间\n        left_splitter = QSplitter(Qt.Vertical)\n        left_splitter.addWidget(video_container)\n\n        self.reference_gallery = ReferenceGalleryWidget()\n        try:\n            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n        except Exception:\n            pass\n        # 参考图区域容器，包含画廊与操作按钮\n        reference_section = QWidget()\n        reference_section_layout = QVBoxLayout(reference_section)\n        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n        reference_section_layout.setSpacing(6)\n        reference_section_layout.addWidget(self.reference_gallery)\n        # 将左侧分割器先加入主布局（第二块稍后补充按钮区后再添加）\n        # 注意：最终会把 reference_section 放入分割器\n\n        reference_button_layout = QHBoxLayout()\n        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n        reference_button_layout.setSpacing(6)\n        self.export_status_label = QLabel(\"\")\n        self.export_status_label.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(self.export_status_label)\n        reference_button_layout.addWidget(self.export_status_label)\n        reference_button_layout.addStretch(1)\n        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n        self.reference_export_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.reference_export_btn)\n        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n        reference_button_layout.addWidget(self.reference_export_btn)\n        self.export_bundle_btn = QPushButton(\"导出记录\")\n        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n        self.export_bundle_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.export_bundle_btn)\n        self._export_controller.configure(\n            self.export_bundle_btn,\n            self.export_status_label,\n            self._resolve_video_record_id,\n            context_widget=self,\n        )\n        reference_button_layout.addWidget(self.export_bundle_btn)\n        reference_section_layout.addLayout(reference_button_layout)\n        # 将参考图区域加入分割器，并把分割器加入左侧布局\n        left_splitter.addWidget(reference_section)\n        try:\n            left_splitter.setStretchFactor(0, 3)\n            left_splitter.setStretchFactor(1, 2)\n            left_splitter.setSizes([520, 280])\n        except Exception:\n            pass\n        left_layout.addWidget(left_splitter, 1)\n\n        # 底部控制区域\n        controls_layout = QHBoxLayout()\n        controls_layout.setContentsMargins(0, 5, 0, 5)\n        controls_layout.setSpacing(10)\n        \n        # 播放/暂停按钮\n        self.play_button = QPushButton(\"▶\")\n        self.play_button.setFixedSize(40, 30)\n        self.play_button.setObjectName(\"PlayButton\")\n        unified_style_system.apply_to_widget(self.play_button)\n        self.play_button.clicked.connect(self.toggle_play_pause)\n        controls_layout.addWidget(self.play_button)\n        \n        # 进度条（简单的标签显示）\n        self.progress_label = QLabel(\"00:00 / 00:00\")\n        self.progress_label.setObjectName(\"ProgressLabel\")\n        controls_layout.addWidget(self.progress_label, 1)\n        \n        # 音量控制\n        volume_label = QLabel(\"🔊\")\n        volume_label.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(volume_label)\n        controls_layout.addWidget(volume_label)\n        \n        # 导航按钮\n        self.prev_btn = QPushButton(\"◀\")\n        self.prev_btn.setFixedSize(30, 30)\n        self.prev_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.prev_btn)\n        self.prev_btn.clicked.connect(self.show_previous_video)\n        controls_layout.addWidget(self.prev_btn)\n\n        self.next_btn = QPushButton(\"▶\")\n        self.next_btn.setFixedSize(30, 30)\n        self.next_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.next_btn)\n        self.next_btn.clicked.connect(self.show_next_video)\n        controls_layout.addWidget(self.next_btn)\n        \n        left_layout.addLayout(controls_layout)\n\n        # 更新导航按钮状态\n        self.update_navigation_buttons()\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n\n        # 右侧：详细信息（固定30%宽度）\n        right_layout = QVBoxLayout()\n        \n        # 创建参数显示区域\n        params_widget = QWidget()\n        params_widget.setFixedWidth(int(self.width() * 0.3))\n        params_widget.setObjectName(\"ParamsWidget\")\n        params_layout = QVBoxLayout(params_widget)\n        params_layout.setSpacing(0)\n        params_layout.setContentsMargins(5, 5, 5, 5)\n        \n        # 解析生成参数\n        params = self.video_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 提示词区域\n        prompt_label = QLabel(\"<b>提示词:</b>\")\n        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n        unified_style_system.apply_to_widget(prompt_label)\n        params_layout.addWidget(prompt_label)\n        \n        # 提示词文本框\n        prompt_content = self.video_data.get('prompt', '无提示词')\n        self.prompt_text_edit = QTextEdit()\n        self.prompt_text_edit.setPlainText(prompt_content)\n        self.prompt_text_edit.setReadOnly(True)\n        # 约 4 行高度（按当前字体动态计算），避免提示词区域过高挤压其它信息\n        try:\n            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n            target_lines = 4\n            vertical_padding = 16  # 与全局 QTextEdit padding (8*2) 对齐\n            border = 2  # 1px*2\n            height = line_height * target_lines + vertical_padding + border\n            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n        except Exception:\n            self.prompt_text_edit.setMaximumHeight(96)\n            self.prompt_text_edit.setMinimumHeight(96)\n        unified_style_system.apply_to_widget(self.prompt_text_edit)\n        # 应用与 _update_theme 一致的额外样式\n        colors = unified_style_system.get_colors()\n        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card')\n        text_color = colors.get('text') or colors.get('palette.text.primary')\n        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        brand = colors.get('palette.brand.main') or colors.get('primary')\n        self.prompt_text_edit.setStyleSheet(f\"\"\"\n            QTextEdit {{\n                background-color: {bg_input};\n                color: {text_color};\n                border: 1px solid {border_subtle};\n                border-radius: 8px;\n                padding: 8px;\n            }}\n            QTextEdit:focus {{\n                border-color: {brand};\n            }}\n        \"\"\")\n        params_layout.addWidget(self.prompt_text_edit)\n        \n        # 复制提示词按钮（使用统一的 SecondaryButton 样式）\n        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n        self.copy_prompt_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n        params_layout.addWidget(self.copy_prompt_btn)\n        \n        # 详细信息 - 保存标签引用以便后续更新\n        self.param_labels = {}  # 存储参数值标签的引用\n\n        # 从 parameters 中获取参数（兼容顶级字段）\n        params = self.video_data.get('parameters', {}) or {}\n        duration = params.get('duration') or self.video_data.get('duration', '未知')\n        file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n\n        info_items = [\n            (\"分辨率\", build_resolution_text(self.video_data)),\n            (\"时长\", f\"{duration}秒\"),\n            (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n            (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n            (\"文件大小\", self.format_file_size(file_size)),\n            (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n        ]\n        \n        for label, value in info_items:\n            label_widget = QLabel(f\"<b>{label}:</b>\")\n            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n            unified_style_system.apply_to_widget(label_widget)\n            params_layout.addWidget(label_widget)\n            \n            # Use QLineEdit for better copy interaction\n            from PySide6.QtWidgets import QLineEdit\n            value_label = QLineEdit(str(value))\n            value_label.setReadOnly(True)\n            value_label.setCursorPosition(0)\n            value_label.setCursorPosition(0)\n            # Style is now handled in _update_theme\n            unified_style_system.apply_to_widget(value_label)\n            params_layout.addWidget(value_label)\n            \n            # 保存参数值标签引用，用于后续更新\n            self.param_value_labels[label] = value_label\n        \n        right_layout.addWidget(params_widget)\n        \n        # 控制按钮\n        button_layout = QHBoxLayout()\n\n        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n        self.fullscreen_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.fullscreen_btn)\n        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n        button_layout.addWidget(self.fullscreen_btn)\n\n        self.download_btn = QPushButton(\"下载视频\")\n        self.download_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.download_btn)\n        self.download_btn.clicked.connect(self.download_video)\n        button_layout.addWidget(self.download_btn)\n\n        self.delete_btn = QPushButton(\"删除记录\")\n        self.delete_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        self.delete_btn.clicked.connect(self._delete_current_record)\n        button_layout.addWidget(self.delete_btn)\n\n        right_layout.addLayout(button_layout)\n\n        self.close_btn = QPushButton(\"关闭（ESC）\")\n        unified_style_system.apply_to_widget(self.close_btn)\n        self.close_btn.clicked.connect(self.accept)\n        right_layout.addWidget(self.close_btn)\n        \n        # 设置布局比例：左侧70%，右侧30%\n        layout.addWidget(left_widget, 7)\n        layout.addLayout(right_layout, 3)\n        \n        # 添加键盘快捷键\n        self.setup_shortcuts()\n\n        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n        self._focus_timer.start(100)\n        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n        \n        # Apply initial theme\n        self._update_theme()\n        \n        # 信号已在setup_ui开头连接，不重复连接\n    \n    def closeEvent(self, event):\n        \"\"\"窗口关闭事件，确保停止播放并释放资源\"\"\"\n        # 0. 阻止对话框继续接收事件\n        self.setEnabled(False)\n        \n        # 1. 停止焦点定时器\n        if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n            self._focus_timer.stop()\n        \n        # 2. 清理参考图画廊\n        if hasattr(self, 'reference_gallery') and self.reference_gallery is not None:\n            try:\n                self.reference_gallery.clear()\n            except Exception as e:\n                logger.warning(f\"[CLEANUP] 清理参考图画廊时出错: {e}\")\n        \n        # 3. 解绑并停止全局视频管理器\n        if hasattr(self, '_video_manager') and self._video_manager is not None:\n            try:\n                # 解绑对话框（取消独占绑定）\n                self._video_manager.unbind_dialog(self)\n                \n                # 停止播放并断开视频输出\n                self._video_manager.stop()\n                \n            except Exception as e:\n                logger.warning(f\"[CLEANUP] 停止全局视频管理器时出错: {e}\")\n\n        # 4. 兼容旧字段：若存在本地 media_player 也停止\n        if hasattr(self, 'media_player') and self.media_player:\n            try:\n                self.media_player.stop()\n            except Exception:\n                pass\n\n        # 5. 清理导出控制器\n        try:\n            self._export_controller.dispose()\n        except Exception:\n            pass\n        \n        self.is_playing = False\n        super().closeEvent(event)\n    \n    def load_thumbnail(self):\n        \"\"\"加载视频缩略图\"\"\"\n        import os  # 将os导入移到函数开头\n        try:\n            logger.debug(\"开始加载缩略图...\")\n            logger.debug(f\"视频数据: {self.video_data}\")\n            \n            # 获取缩略图路径\n            thumbnail_path = self.video_data.get('thumbnail_local_path', '')\n            logger.debug(f\"从video_data获取的thumbnail_local_path: {thumbnail_path}\")\n            \n            if thumbnail_path and os.path.exists(thumbnail_path):\n                logger.debug(f\"找到现有缩略图文件: {thumbnail_path}\")\n                # 使用现有缩略图\n                pixmap = QPixmap(thumbnail_path)\n                logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n            else:\n                logger.debug(\"缩略图文件不存在或路径为空，开始生成缩略图...\")\n                # 生成缩略图\n                video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n                logger.debug(f\"视频文件路径: {video_path}\")\n                \n                if video_path and os.path.exists(video_path):\n                    logger.debug(\"视频文件存在，开始生成缩略图...\")\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    from config_api import get_storage_dir\n                    storage_dir = get_storage_dir()\n                    thumbnails_dir = os.path.join(storage_dir, 'thumbnails')\n                    logger.debug(f\"缩略图目录: {thumbnails_dir}\")\n                    \n                    generator = VideoThumbnailGenerator(thumbnails_dir)\n                    video_id = self.video_data.get('id', os.path.basename(video_path).split('.')[0])\n                    logger.debug(f\"视频ID: {video_id}\")\n                    \n                    thumbnail_path = generator.generate_thumbnail_for_video(video_path, video_id)\n                    logger.debug(f\"生成的缩略图路径: {thumbnail_path}\")\n                    \n                    if thumbnail_path and os.path.exists(thumbnail_path):\n                        logger.debug(\"缩略图生成成功，加载到QPixmap...\")\n                        pixmap = QPixmap(thumbnail_path)\n                        logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n                    else:\n                        logger.debug(\"缩略图生成失败，使用默认图片\")\n                        # 使用默认图片\n                        pixmap = self.create_default_thumbnail()\n                else:\n                    logger.debug(\"视频文件不存在，使用默认图片\")\n                    pixmap = self.create_default_thumbnail()\n            \n            if not pixmap.isNull():\n                logger.debug(\"开始缩放图片...\")\n                # 缩放图片以适应标签大小\n                label_size = self.thumbnail_label.size()\n                logger.debug(f\"标签大小: {label_size}\")\n                \n                scaled_pixmap = pixmap.scaled(\n                    label_size,\n                    Qt.KeepAspectRatio,\n                    Qt.SmoothTransformation\n                )\n                logger.debug(f\"缩放后图片大小: {scaled_pixmap.size()}\")\n                \n                self.thumbnail_label.setPixmap(scaled_pixmap)\n                logger.debug(\"缩略图设置成功\")\n            else:\n                logger.debug(\"QPixmap为空，显示错误文本\")\n                self.thumbnail_label.setText(\"无法加载缩略图\")\n                \n        except Exception as e:\n            logger.debug(f\"加载缩略图异常: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.thumbnail_label.setText(\"缩略图加载失败\")\n    \n    def create_default_thumbnail(self):\n        \"\"\"创建默认缩略图\"\"\"\n        pixmap = QPixmap(400, 300)\n        pixmap.fill(Qt.black)\n        \n        from PySide6.QtGui import QPainter, QFont\n        painter = QPainter(pixmap)\n        painter.setPen(Qt.white)\n        painter.setFont(QFont())  # Font configuration handled by unified style system\n        painter.drawText(pixmap.rect(), Qt.AlignCenter, \"视频预览\")\n        painter.end()\n        \n        return pixmap\n    \n    def on_thumbnail_click(self, event):\n        \"\"\"缩略图点击事件\"\"\"\n        self.start_video_playback()\n    \n    def start_video_playback(self):\n        \"\"\"开始视频播放\"\"\"\n        logger.debug(\"[UI] 开始视频播放…\")\n        \n        # 检查视频文件\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        \n        if not video_path or not os.path.exists(video_path):\n            logger.warning(f\"[UI] 视频文件不存在: {video_path}\")\n            from PySide6.QtWidgets import QMessageBox\n            QMessageBox.critical(self, \"错误\", \"视频文件不存在\")\n            return\n        \n        # 切换到视频播放器\n        self.video_stack.setCurrentIndex(1)\n        self.is_playing = True\n        \n        # 使用全局视频管理器播放\n        self._video_manager.play(video_path, self.video_widget)\n        logger.debug(\"[UI] 开始播放视频\")\n    \n    def toggle_play_pause(self):\n        \"\"\"切换播放/暂停\"\"\"\n        if not self.is_playing:\n            self.start_video_playback()\n        else:\n            self._video_manager.toggle_play_pause()\n    \n    def on_state_changed(self, state):\n        \"\"\"播放状态改变\"\"\"\n        if state == QMediaPlayer.PlaybackState.PlayingState:\n            self.play_button.setText(\"⏸\")\n        else:\n            self.play_button.setText(\"▶\")\n    \n    def on_position_changed(self, position):\n        \"\"\"播放位置改变\"\"\"\n        if hasattr(self, 'media_player'):\n            duration = self.media_player.duration()\n            if duration > 0:\n                current_time = self.format_duration(position)\n                total_time = self.format_duration(duration)\n                self.progress_label.setText(f\"{current_time} / {total_time}\")\n    \n    def on_duration_changed(self, duration):\n        \"\"\"视频时长改变\"\"\"\n        if duration > 0:\n            total_time = self.format_duration(duration)\n            self.progress_label.setText(f\"00:00 / {total_time}\")\n    \n    def on_media_error(self, error, error_string):\n        \"\"\"媒体播放错误处理\"\"\"\n        logger.error(f\"[MEDIA] 播放错误: {error}, 信息: {error_string}\")\n        \n        from PySide6.QtWidgets import QMessageBox\n        msg_box = QMessageBox(self)\n        msg_box.setIcon(QMessageBox.Critical)\n        msg_box.setText(\"视频播放错误\")\n        msg_box.setInformativeText(f\"无法播放视频: {error_string}\")\n        msg_box.exec()\n        \n        # 返回缩略图模式\n        self.video_stack.setCurrentIndex(0)\n        self.is_playing = False\n    \n    def on_media_status_changed(self, status):\n        \"\"\"媒体状态改变\"\"\"\n        from PySide6.QtMultimedia import QMediaPlayer\n        \n        logger.debug(f\"[MEDIA] 状态改变: {status}\")\n        \n        if status == QMediaPlayer.MediaStatus.EndOfMedia:\n            # 视频播放结束，返回缩略图模式\n            logger.debug(\"[MEDIA] 播放结束，切回缩略图模式\")\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n            if hasattr(self, 'media_player'):\n                self.media_player.setPosition(0)  # 重置播放位置\n            self.progress_label.setText(\"00:00 / 00:00\")\n        elif status == QMediaPlayer.MediaStatus.InvalidMedia:\n            logger.warning(\"[MEDIA] 媒体文件无效\")\n        elif status == QMediaPlayer.MediaStatus.BufferedMedia:\n            logger.debug(\"[MEDIA] 媒体缓冲完成\")\n        elif status == QMediaPlayer.MediaStatus.LoadingMedia:\n            logger.debug(\"[MEDIA] 正在加载媒体\")\n        elif status == QMediaPlayer.MediaStatus.StalledMedia:\n            logger.debug(\"[MEDIA] 播放卡顿\")\n    \n    def format_duration(self, ms):\n        \"\"\"格式化时长显示\"\"\"\n        seconds = ms // 1000\n        minutes = seconds // 60\n        seconds = seconds % 60\n        return f\"{minutes:02d}:{seconds:02d}\"\n    \n    # OpenCV playback methods removed - using QtMultimedia exclusively\n\n    \n    def format_time(self, time_str: str) -> str:\n        \"\"\"格式化时间显示\"\"\"\n        if not time_str:\n            return '未知时间'\n        try:\n            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n            return dt.strftime('%Y-%m-%d %H:%M:%S')\n        except:\n            return time_str[:19] if len(time_str) > 19 else time_str\n    \n    def format_file_size(self, size) -> str:\n        \"\"\"格式化文件大小显示\"\"\"\n        try:\n            size = float(size) if size else 0\n        except (ValueError, TypeError):\n            return '未知大小'\n            \n        if size == 0:\n            return '未知大小'\n        \n        for unit in ['B', 'KB', 'MB', 'GB']:\n            if size < 1024.0:\n                return f\"{size:.1f} {unit}\"\n            size /= 1024.0\n        return f\"{size:.1f} TB\"\n    \n    def setup_shortcuts(self):\n        \"\"\"设置键盘快捷键\"\"\"\n        # 移除所有QShortcut，统一使用keyPressEvent处理\n        # 避免快捷键冲突问题\n        pass\n    \n    def _ensure_focus(self):\n        \"\"\"确保窗口获得焦点\"\"\"\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        logger.debug(f\"[FOCUS] VideoDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n    \n    def keyPressEvent(self, event):\n        \"\"\"键盘事件处理\"\"\"\n        from PySide6.QtCore import Qt\n        \n        logger.debug(f\"[KEYBOARD] VideoDetailDialog键盘事件: {event.key()}\")\n        \n        if event.key() == Qt.Key_Left:\n            # 左方向键：上一个视频\n            logger.debug(f\"[KEYBOARD] 左键pressed，prev_btn enabled: {self.prev_btn.isEnabled()}\")\n            if self.prev_btn.isEnabled():\n                self.show_previous_video()\n            event.accept()\n        elif event.key() == Qt.Key_Right:\n            # 右方向键：下一个视频\n            logger.debug(f\"[KEYBOARD] 右键pressed，next_btn enabled: {self.next_btn.isEnabled()}\")\n            if self.next_btn.isEnabled():\n                self.show_next_video()\n            event.accept()\n        elif event.key() == Qt.Key_Escape:\n            # ESC键：关闭对话框（保持原有功能）\n            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n            if self.is_fullscreen:\n                self.exit_fullscreen()\n            else:\n                self.accept()\n            event.accept()\n        elif event.key() == Qt.Key_F11:\n            # F11键：全屏切换（保持原有功能）\n            self.toggle_fullscreen()\n            event.accept()\n        elif event.key() == Qt.Key_Space:\n            # 空格键：播放/暂停\n            self.toggle_play_pause()\n            event.accept()\n        else:\n            # 其他按键交给父类处理\n            super().keyPressEvent(event)\n    \n    def toggle_fullscreen(self):\n        \"\"\"切换全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.enter_fullscreen()\n    \n    def enter_fullscreen(self):\n        \"\"\"进入全屏模式\"\"\"\n        if not self.is_fullscreen:\n            self.original_geometry = self.geometry()\n            self.showFullScreen()\n            self.is_fullscreen = True\n    \n    def exit_fullscreen(self):\n        \"\"\"退出全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.showNormal()\n            if self.original_geometry:\n                self.setGeometry(self.original_geometry)\n            self.is_fullscreen = False\n    \n    def handle_escape_key(self):\n        \"\"\"处理ESC键\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.accept()\n    \n    def copy_prompt(self):\n        \"\"\"复制提示词到剪贴板\"\"\"\n        prompt_content = self.prompt_text_edit.toPlainText()\n        clipboard = QApplication.clipboard()\n        clipboard.setText(prompt_content)\n        self.show_copy_toast(\"提示词已复制到剪贴板\")\n    \n    def show_copy_toast(self, message: str):\n        \"\"\"显示复制成功的轻量提示\"\"\"\n        toast = QLabel(message, self)\n        toast.setObjectName(\"ToastLabel\")\n        toast.setAlignment(Qt.AlignCenter)\n        toast.adjustSize()\n        \n        x = (self.width() - toast.width()) // 2\n        y = self.height() // 4\n        toast.move(x, y)\n        toast.show()\n        \n        QTimer.singleShot(2000, toast.deleteLater)\n\n    def _on_reference_clicked(self, asset: Dict[str, Any]):\n        assets = list(self._reference_assets) if self._reference_assets else [asset]\n        start_idx = _find_reference_asset_index(assets, asset)\n        open_reference_preview(\n            self,\n            asset,\n            title_prefix=\"参考图\",\n            asset_list=assets,\n            start_index=start_idx,\n            on_asset_changed=self._sync_reference_selection,\n        )\n\n    def _on_reference_export(self, asset: Dict[str, Any]):\n        export_reference_asset(self, asset)\n\n    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n        asset_path = resolve_asset_path(asset) if isinstance(asset, dict) else None\n        has_path = bool(asset_path)\n        if hasattr(self, 'reference_export_btn'):\n            self.reference_export_btn.setEnabled(has_path)\n\n    def _export_selected_reference(self):\n        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n        if not asset:\n            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n            return\n        export_reference_asset(self, asset)\n\n    def _refresh_reference_gallery(self):\n        if not hasattr(self, 'reference_gallery'):\n            return\n        self._reference_summary = ensure_reference_info(self.video_data)\n        if self._reference_summary.get('count', 0) <= 0:\n            self.reference_gallery.setVisible(False)\n            self.reference_gallery.clear()\n            if hasattr(self, 'reference_export_btn'):\n                self.reference_export_btn.setEnabled(False)\n            self._reference_assets = []\n            self._export_controller.refresh()\n            return\n        try:\n            self._reference_assets = resolve_reference_assets(self.video_data, absolute=True)\n        except Exception:\n            self._reference_assets = []\n        self.reference_gallery.set_assets(self._reference_assets)\n        self.reference_gallery.setVisible(True)\n        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n        self._export_controller.refresh()\n\n    def _sync_reference_selection(self, asset: Dict[str, Any]):\n        try:\n            self.reference_gallery.select_asset(asset)\n        except Exception:\n            pass\n\n    def _resolve_video_record_id(self) -> Optional[str]:\n        for key in (\"file_id\", \"id\", \"generation_id\"):\n            value = self.video_data.get(key)\n            if value not in (None, \"\"):\n                return str(value)\n        return None\n\n    def _delete_current_record(self):\n        \"\"\"删除当前视频记录及相关文件\"\"\"\n        record_id = self._resolve_video_record_id()\n        if not record_id:\n            self.show_copy_toast(\"无法获取记录ID\")\n            return\n        \n        try:\n            # 停止当前播放\n            if hasattr(self, 'media_player'):\n                self.media_player.stop()\n            \n            # 获取 RepositoryManager\n            from config_api import get_storage_dir\n            from modules.repository.manager import RepositoryManager\n            \n            storage_dir = get_storage_dir()\n            repo = RepositoryManager(storage_dir)\n            \n            # 执行删除\n            if repo.delete_record_with_files(record_id):\n                self.show_copy_toast(\"记录已删除\")\n                \n                # 发出信号通知父视图刷新\n                self.recordDeleted.emit(record_id)\n                \n                # 从列表中移除当前记录\n                if len(self.video_list) > 1:\n                    del self.video_list[self.current_index]\n                    \n                    # 导航到后一条记录（保持索引，指向原来的下一条）\n                    # 只有当删除的是最后一条时，才需要调整索引\n                    if self.current_index >= len(self.video_list):\n                        self.current_index = len(self.video_list) - 1\n                    \n                    # 更新 video_data 到新的当前记录\n                    self.video_data = self.video_list[self.current_index]\n                    self.load_video()\n                    self.update_navigation_buttons()\n                else:\n                    # 只剩一条记录，关闭对话框\n                    self.accept()\n            else:\n                self.show_copy_toast(\"删除失败\")\n        except Exception as e:\n            from utils.logger import logger\n            logger.error(f\"删除视频记录异常: {e}\")\n            self.show_copy_toast(f\"删除失败: {str(e)}\")\n\n    def download_video(self):\n        \"\"\"下载视频到指定位置\"\"\"\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if not video_path or not os.path.exists(video_path):\n            self.show_styled_message(\"错误\", \"视频文件不存在\", \"warning\")\n            return\n        \n        file_dialog = QFileDialog()\n        save_path, _ = file_dialog.getSaveFileName(\n            self,\n            \"保存视频\",\n            f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4\",\n            \"视频文件 (*.mp4)\"\n        )\n        \n        if save_path:\n            try:\n                import shutil\n                shutil.copy2(video_path, save_path)\n                self.show_copy_toast(f\"视频已保存到: {os.path.basename(save_path)}\")\n            except Exception as e:\n                self.show_styled_message(\"错误\", f\"保存视频失败: {str(e)}\", \"critical\")\n    \n    def update_navigation_buttons(self):\n        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n        logger.debug(f\"[NAV] 更新导航按钮：当前索引{self.current_index}，总记录数{len(self.video_list)}\")\n        \n        has_prev = self._has_valid_previous_record()\n        has_next = self._has_valid_next_record()\n        \n        logger.debug(f\"[NAV] 有效记录检查：prev={has_prev}, next={has_next}\")\n        \n        self.prev_btn.setEnabled(has_prev)\n        self.next_btn.setEnabled(has_next)\n    \n    def _has_valid_previous_record(self):\n        \"\"\"检查是否有有效的上一个记录\"\"\"\n        logger.debug(f\"[NAV] 检查上一个记录：从索引{self.current_index - 1}到0\")\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            content_type = candidate_data.get('content_type', '')\n            \n            # 检查文件扩展名，确保是视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                logger.debug(f\"[NAV] 找到有效的上一个视频记录：索引{i}\")\n                return True\n        logger.debug(f\"[NAV] 没有找到有效的上一个视频记录\")\n        return False\n    \n    def _has_valid_next_record(self):\n        \"\"\"检查是否有有效的下一个记录\"\"\"\n        logger.debug(f\"[NAV] 检查下一个记录：从索引{self.current_index + 1}到{len(self.video_list) - 1}\")\n        for i in range(self.current_index + 1, len(self.video_list)):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            content_type = candidate_data.get('content_type', '')\n            \n            # 检查文件扩展名，确保是视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                logger.debug(f\"[NAV] 找到有效的下一个视频记录：索引{i}\")\n                return True\n        logger.debug(f\"[NAV] 没有找到有效的下一个视频记录\")\n        return False\n    \n    def show_previous_video(self):\n        \"\"\"显示上一个视频（带有效性验证）\"\"\"\n        # 寻找上一个有效视频记录\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            # 检查是否为视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                # 找到有效视频记录\n                logger.debug(f\"[NAV] 切换到上一个视频：索引{i}\")\n                self.current_index = i\n                self.video_data = self.video_list[i]\n                self.load_video()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的上一个视频记录，保持当前状态\n        logger.debug(f\"[NAV] 没有上一个视频可切换\")\n        self.update_navigation_buttons()\n    \n    def show_next_video(self):\n        \"\"\"显示下一个视频（带有效性验证）\"\"\"\n        # 寻找下一个有效视频记录\n        for i in range(self.current_index + 1, len(self.video_list)):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            # 检查是否为视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                # 找到有效视频记录\n                logger.debug(f\"[NAV] 切换到下一个视频：索引{i}\")\n                self.current_index = i\n                self.video_data = self.video_list[i]\n                self.load_video()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的下一个视频记录，保持当前状态\n        logger.debug(f\"[NAV] 没有下一个视频可切换\")\n        self.update_navigation_buttons()\n    \n    def load_video(self):\n        \"\"\"加载新视频\"\"\"\n        logger.debug(\"[UI] 加载新视频…\")\n        \n        # 停止当前播放器\n        if hasattr(self, 'media_player') and self.media_player:\n            self.media_player.stop()\n        \n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if video_path and os.path.exists(video_path):\n            from PySide6.QtCore import QUrl\n            if hasattr(self, 'media_player') and self.media_player:\n                self.media_player.setSource(QUrl.fromLocalFile(video_path))\n            \n            # 重置到缩略图模式\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n            \n            # 重新加载缩略图\n            self.load_thumbnail()\n            \n            # 更新右侧信息\n            prompt_content = self.video_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n            \n            # 更新参数信息\n            self.update_video_params()\n            \n            logger.debug(\"[UI] 新视频加载完成\")\n        else:\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n    \n    def _update_theme(self):\n        \"\"\"响应主题变化\"\"\"\n        colors = unified_style_system.get_colors()\n        \n        # Apply theme to self (Dialog)\n        # Note: In some OS/Qt versions, QDialog styling needs explicit background\n        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n        text_color = colors.get('text') or colors.get('palette.text.primary')\n        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or bg_card\n        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n        \n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {bg_color};\n                color: {text_color};\n            }}\n            QLabel {{\n                color: {text_color};\n            }}\n            QWidget#ParamsWidget {{\n                 background-color: {bg_card};\n                 border-left: 1px solid {border_subtle};\n            }}\n        \"\"\")\n        \n        # Update specific controls directly\n        if hasattr(self, 'prompt_text_edit'):\n             self.prompt_text_edit.setStyleSheet(f\"\"\"\n                QTextEdit {{\n                    background-color: {bg_input};\n                    color: {text_color};\n                    border: 1px solid {border_subtle};\n                    border-radius: 8px;\n                    padding: 8px;\n                }}\n                QTextEdit:focus {{\n                    border-color: {brand};\n                }}\n             \"\"\")\n\n        # Manually update param labels that were stored\n        if hasattr(self, 'param_value_labels'):\n            for label, value_label in self.param_value_labels.items():\n                value_label.setStyleSheet(f\"\"\"\n                    QLineEdit {{\n                        background-color: {bg_input};\n                        color: {text_color};\n                        border: 1px solid {border_subtle};\n                        padding: 4px;\n                        border-radius: 8px;\n                    }}\n                    QLineEdit:focus {{\n                        border-color: {brand};\n                    }}\n                \"\"\")\n\n        # Update thumbnail background if visible\n        if hasattr(self, 'thumbnail_label'):\n             player_bg = colors.get('palette.component.player_bg') or bg_color\n             self.thumbnail_label.setStyleSheet(f\"\"\"\n                QLabel {{\n                    border: none;\n                    background-color: {player_bg};\n                    color: {text_color};\n                }}\n             \"\"\")\n\n        # Reapply button styles (including fixed components)\n        if hasattr(self, 'copy_prompt_btn'):\n            unified_style_system.apply_to_widget(self.copy_prompt_btn)\n        if hasattr(self, 'fullscreen_btn'):\n            unified_style_system.apply_to_widget(self.fullscreen_btn)\n        if hasattr(self, 'download_btn'):\n            unified_style_system.apply_to_widget(self.download_btn)\n        if hasattr(self, 'delete_btn'):\n            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        if hasattr(self, 'close_btn'):\n            unified_style_system.apply_to_widget(self.close_btn)\n        if hasattr(self, 'reference_export_btn'):\n            unified_style_system.apply_to_widget(self.reference_export_btn)\n        if hasattr(self, 'export_bundle_btn'):\n            unified_style_system.apply_to_widget(self.export_bundle_btn)\n        if hasattr(self, 'play_button'):\n            unified_style_system.apply_to_widget(self.play_button)\n        if hasattr(self, 'prev_btn'):\n            unified_style_system.apply_to_widget(self.prev_btn)\n        if hasattr(self, 'next_btn'):\n            unified_style_system.apply_to_widget(self.next_btn)\n\n    def update_video_params(self):\n        \"\"\"更新视频参数显示（切换视频时调用）\"\"\"\n        try:\n            # 解析生成参数\n            params = self.video_data.get('parameters', '{}')\n            if isinstance(params, str):\n                try:\n                    params = json.loads(params)\n                except:\n                    params = {}\n\n            # 从 parameters 中获取参数（兼容顶级字段）\n            duration = params.get('duration') or self.video_data.get('duration', '未知')\n            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n\n            # 重新构建参数信息\n            info_items = [\n                (\"分辨率\", build_resolution_text(self.video_data)),\n                (\"时长\", f\"{duration}秒\"),\n                (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n                (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n                (\"文件大小\", self.format_file_size(file_size)),\n                (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n            ]\n            \n            # 更新已保存的标签\n            for label, new_value in info_items:\n                if label in self.param_value_labels:\n                    self.param_value_labels[label].setText(str(new_value))\n            \n            logger.debug(\"视频参数已更新\")\n            \n        except Exception as e:\n            logger.error(f\"更新视频参数失败: {e}\")\n    \n    def update_param_labels(self):\n        \"\"\"更新参数标签内容\"\"\"\n        try:\n            # 从 parameters 中获取参数（兼容顶级字段）\n            params = self.video_data.get('parameters', {}) or {}\n            duration = params.get('duration') or self.video_data.get('duration', '未知')\n            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n\n            # 更新各个参数标签\n            param_updates = {\n                \"分辨率\": build_resolution_text(self.video_data),\n                \"时长\": f\"{duration}秒\",\n                \"模型\": get_model_display_name(pick_model_code(self.video_data)),\n                \"生成时间\": self.format_time(self.video_data.get('created_at', '')),\n                \"文件大小\": self.format_file_size(file_size),\n                \"文件路径\": self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n            }\n            \n            for param_name, new_value in param_updates.items():\n                if param_name in self.param_labels:\n                    self.param_labels[param_name].setText(str(new_value))\n                    logger.debug(f\"已更新参数 {param_name}: {new_value}\")\n            \n            logger.debug(\"视频参数标签更新完成\")\n        except Exception as e:\n            logger.error(f\"更新视频参数标签失败: {e}\")\n    \n    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n        \"\"\"显示带有深色主题样式的消息框\"\"\"\n        from PySide6.QtWidgets import QMessageBox\n        \n        msg_box = QMessageBox(self)\n        msg_box.setWindowTitle(title)\n        msg_box.setText(message)\n        \n        # 设置图标\n        if icon_type == \"warning\":\n            msg_box.setIcon(QMessageBox.Warning)\n        elif icon_type == \"critical\":\n            msg_box.setIcon(QMessageBox.Critical)\n        elif icon_type == \"question\":\n            msg_box.setIcon(QMessageBox.Question)\n        else:\n            msg_box.setIcon(QMessageBox.Information)\n        \n        # 样式由全局QSS控制\n        \n        msg_box.exec()\n","numLines":1333,"startLine":1,"totalLines":1333}}}
{"parentUuid":"d98246d8-09d4-49fc-b2f2-de2d6a722c02","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Trtw81t1gv2YT8vMUmyB5B","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我读取导出控制器和参考资源操作文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":103,"cache_creation_input_tokens":36885,"cache_read_input_tokens":20890,"cache_creation":{"ephemeral_5m_input_tokens":36885,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"792abfdc-617f-4230-b4d3-ccb8654364c1","timestamp":"2025-12-22T06:08:43.847Z"}
{"parentUuid":"792abfdc-617f-4230-b4d3-ccb8654364c1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Trtw81t1gv2YT8vMUmyB5B","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XLwpkcgT7AzLzZoMdAx2Zg","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/controllers/export_bundle_controller.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":103,"cache_creation_input_tokens":36885,"cache_read_input_tokens":20890,"cache_creation":{"ephemeral_5m_input_tokens":36885,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f3651dc5-4412-4e3c-983e-26d9675a0f4f","timestamp":"2025-12-22T06:08:44.029Z"}
{"parentUuid":"f3651dc5-4412-4e3c-983e-26d9675a0f4f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Trtw81t1gv2YT8vMUmyB5B","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XhHXetgTWiUVHkqnFC1ujX","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/actions.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":103,"cache_creation_input_tokens":36885,"cache_read_input_tokens":20890,"cache_creation":{"ephemeral_5m_input_tokens":36885,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"814c0804-e0b7-4de1-b0a6-e4056d38fd55","timestamp":"2025-12-22T06:08:44.254Z"}
{"parentUuid":"814c0804-e0b7-4de1-b0a6-e4056d38fd55","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XLwpkcgT7AzLzZoMdAx2Zg","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"Export bundle controller split from qt_app.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→from pathlib import Path\n     8→from typing import Any, Callable, Dict, Optional\n     9→\n    10→from PySide6.QtCore import QObject, Signal\n    11→from PySide6.QtWidgets import QFileDialog, QLabel, QMessageBox, QPushButton, QWidget\n    12→\n    13→from modules.repository.manager import RepositoryManager\n    14→from utils.logger import logger\n    15→from utils.reference_display import (\n    16→    _format_dir_hint,\n    17→    _mask_record_id,\n    18→    _summarize_masked_ids,\n    19→)\n    20→from utils.task_runner import CancelToken, task_runner\n    21→\n    22→__all__ = [\"ExportBundleController\", \"_resolve_repository_manager\"]\n    23→\n    24→class ExportBundleController(QObject):\n    25→    \"\"\"封装详情页导出逻辑，统一按钮状态与提示信息。\"\"\"\n    26→\n    27→    _result_ready = Signal(object, str, object)\n    28→    _error_ready = Signal(object, str, object)\n    29→\n    30→    def __init__(\n    31→        self,\n    32→        owner: QWidget,\n    33→        record_type: str,\n    34→        *,\n    35→        context_widget: Optional[QWidget] = None,\n    36→    ):\n    37→        super().__init__(owner)\n    38→        normalized_type = (record_type or \"image\").lower()\n    39→        if normalized_type not in {\"image\", \"video\"}:\n    40→            normalized_type = \"image\"\n    41→        self._owner = owner\n    42→        self._context_widget = context_widget or owner\n    43→        self._record_type = normalized_type\n    44→        self._button: Optional[QPushButton] = None\n    45→        self._status_label: Optional[QLabel] = None\n    46→        self._record_supplier: Callable[[], Optional[str]] = lambda: None\n    47→        self._running = False\n    48→        self._idle_text = \"导出记录\"\n    49→        self._cancel_token: Optional[CancelToken] = None\n    50→        self._disposed = False\n    51→        self._result_ready.connect(self._handle_result)\n    52→        self._error_ready.connect(self._handle_error)\n    53→\n    54→    # ------------------------------------------------------------------\n    55→    # Lifecycle helpers\n    56→    # ------------------------------------------------------------------\n    57→    def configure(\n    58→        self,\n    59→        button: QPushButton,\n    60→        status_label: Optional[QLabel],\n    61→        record_supplier: Callable[[], Optional[str]],\n    62→        *,\n    63→        context_widget: Optional[QWidget] = None,\n    64→    ) -> None:\n    65→        if self._disposed:\n    66→            return\n    67→        self._button = button\n    68→        self._status_label = status_label\n    69→        self._record_supplier = record_supplier\n    70→        if context_widget is not None:\n    71→            self._context_widget = context_widget\n    72→        self._idle_text = button.text() or self._idle_text\n    73→        button.clicked.connect(self._on_clicked)\n    74→        self.refresh()\n    75→\n    76→    def set_context_widget(self, widget: QWidget) -> None:\n    77→        self._context_widget = widget or self._owner\n    78→\n    79→    def dispose(self) -> None:\n    80→        if self._disposed:\n    81→            return\n    82→        self._disposed = True\n    83→        if self._cancel_token:\n    84→            self._cancel_token.cancel()\n    85→            self._cancel_token = None\n    86→        self._running = False\n    87→        try:\n    88→            self._result_ready.disconnect(self._handle_result)\n    89→        except Exception:\n    90→            pass\n    91→        try:\n    92→            self._error_ready.disconnect(self._handle_error)\n    93→        except Exception:\n    94→            pass\n    95→        self._button = None\n    96→        self._status_label = None\n    97→        self._record_supplier = lambda: None\n    98→        \n    99→    # ------------------------------------------------------------------\n   100→    # 内部状态工具\n   101→    # ------------------------------------------------------------------\n   102→    @staticmethod\n   103→    def _widget_alive(widget: Optional[QWidget]) -> bool:\n   104→        if widget is None:\n   105→            return False\n   106→        try:\n   107→            widget.objectName()\n   108→            return True\n   109→        except RuntimeError:\n   110→            return False\n   111→\n   112→    def _complete_task(self, token: Optional[CancelToken]) -> None:\n   113→        if token is self._cancel_token:\n   114→            self._cancel_token = None\n   115→        self._running = False\n   116→\n   117→    # ------------------------------------------------------------------\n   118→    # UI 更新\n   119→    # ------------------------------------------------------------------\n   120→    def refresh(self) -> None:\n   121→        if self._disposed:\n   122→            return\n   123→        record_id = self._record_supplier() if self._record_supplier else None\n   124→        if self._widget_alive(self._button):\n   125→            try:\n   126→                self._button.setEnabled(bool(record_id) and not self._running)\n   127→            except RuntimeError:\n   128→                pass\n   129→        if self._widget_alive(self._status_label) and not self._running:\n   130→            if not record_id:\n   131→                try:\n   132→                    self._status_label.setText(\"\")\n   133→                except RuntimeError:\n   134→                    pass\n   135→\n   136→    def _set_running(self, working: bool, hint: str) -> None:\n   137→        if self._disposed:\n   138→            return\n   139→        self._running = working\n   140→        if self._widget_alive(self._button):\n   141→            try:\n   142→                if working:\n   143→                    self._button.setEnabled(False)\n   144→                    self._button.setText(\"导出中…\")\n   145→                else:\n   146→                    self._button.setText(self._idle_text)\n   147→                    self.refresh()\n   148→            except RuntimeError:\n   149→                pass\n   150→        if self._widget_alive(self._status_label):\n   151→            try:\n   152→                self._status_label.setText(hint)\n   153→            except RuntimeError:\n   154→                pass\n   155→\n   156→    def _show_message(self, title: str, message: str, icon_type: str = \"information\") -> None:\n   157→        if self._disposed:\n   158→            return\n   159→        handler = getattr(self._owner, \"show_styled_message\", None)\n   160→        if callable(handler):\n   161→            handler(title, message, icon_type)\n   162→            return\n   163→        icon_map = {\n   164→            \"information\": QMessageBox.Information,\n   165→            \"warning\": QMessageBox.Warning,\n   166→            \"critical\": QMessageBox.Critical,\n   167→        }\n   168→        icon = icon_map.get(icon_type, QMessageBox.Information)\n   169→        QMessageBox(icon, title, message, QMessageBox.Ok, self._owner).exec()\n   170→\n   171→    # ------------------------------------------------------------------\n   172→    # 导出执行\n   173→    # ------------------------------------------------------------------\n   174→    def _on_clicked(self) -> None:\n   175→        if self._disposed or self._running:\n   176→            return\n   177→        record_id = self._record_supplier() if self._record_supplier else None\n   178→        if not record_id:\n   179→            self._show_message(\"导出失败\", \"记录缺少 file_id，无法导出\", \"warning\")\n   180→            return\n   181→        context_widget = self._context_widget or self._owner\n   182→        repo = _resolve_repository_manager(context_widget)\n   183→        if not repo:\n   184→            self._show_message(\"导出失败\", \"未找到仓库管理器实例\", \"warning\")\n   185→            return\n   186→\n   187→        dest_dir = QFileDialog.getExistingDirectory(self._owner, \"选择导出目录\")\n   188→        if not dest_dir:\n   189→            if self._widget_alive(self._status_label):\n   190→                try:\n   191→                    self._status_label.setText(\"已取消\")\n   192→                except RuntimeError:\n   193→                    pass\n   194→            logger.info(\n   195→                \"UI|export_bundle_cancelled record_type=%s record_id=%s\",\n   196→                self._record_type,\n   197→                _mask_record_id(record_id),\n   198→            )\n   199→            return\n   200→\n   201→        masked_record = _mask_record_id(record_id)\n   202→        token = CancelToken()\n   203→        self._cancel_token = token\n   204→        self._set_running(True, \"正在导出，请稍候…\")\n   205→\n   206→        def task():\n   207→            if token.cancelled:\n   208→                return None\n   209→            return repo.export_generation_bundle(\n   210→                [record_id],\n   211→                record_type=self._record_type,\n   212→                destination_dir=dest_dir,\n   213→            )\n   214→\n   215→        def on_done(result: Optional[Dict[str, Any]]):\n   216→            if token.cancelled or self._disposed or self._cancel_token is not token:\n   217→                return\n   218→            self._result_ready.emit(result, masked_record, token)\n   219→\n   220→        def on_error(exc: BaseException):\n   221→            if token.cancelled or self._disposed or self._cancel_token is not token:\n   222→                return\n   223→            self._error_ready.emit(exc, masked_record, token)\n   224→\n   225→        task_runner.submit(\n   226→            task,\n   227→            key=f\"export_bundle:{self._record_type}:{record_id}\",\n   228→            on_done=on_done,\n   229→            on_error=on_error,\n   230→            cancel_token=token,\n   231→        )\n   232→\n   233→    def _handle_result(self, result: Optional[Dict[str, Any]], masked_record: str, token: Optional[CancelToken]) -> None:\n   234→        if self._disposed:\n   235→            return\n   236→        if not result:\n   237→            self._set_running(False, \"导出失败\")\n   238→            self._show_message(\"导出失败\", \"未能生成导出文件，请检查记录状态。\", \"warning\")\n   239→            logger.warning(\n   240→                \"UI|export_bundle_failed record_type=%s record_id=%s reason=%s\",\n   241→                self._record_type,\n   242→                masked_record,\n   243→                \"no_result\",\n   244→            )\n   245→            self._complete_task(token)\n   246→            return\n   247→\n   248→        dest_zip = result.get(\"destination_zip\") or result.get(\"zip_path\")\n   249→        if not dest_zip:\n   250→            self._set_running(False, \"导出失败\")\n   251→            self._show_message(\"导出失败\", \"导出结果缺少 zip 信息\", \"critical\")\n   252→            logger.warning(\n   253→                \"UI|export_bundle_failed record_type=%s record_id=%s reason=%s\",\n   254→                self._record_type,\n   255→                masked_record,\n   256→                \"missing_zip_path\",\n   257→            )\n   258→            self._complete_task(token)\n   259→            return\n   260→\n   261→        ref_ids = result.get(\"reference_ids\") or []\n   262→        ref_count = int(result.get(\"reference_count\", 0))\n   263→        ref_summary = _summarize_masked_ids(ref_ids)\n   264→        status_text = result.get(\"status\") or \"success\"\n   265→        zip_name = Path(dest_zip).name\n   266→        directory_hint = _format_dir_hint(Path(dest_zip).parent)\n   267→        missing_records = result.get(\"missing_records\") or []\n   268→        missing_files = result.get(\"missing_main_files\") or []\n   269→        missing_refs = result.get(\"missing_references\") or []\n   270→\n   271→        detail_parts = [\n   272→            f\"记录{len(missing_records)}\" if missing_records else \"\",\n   273→            f\"主文件{len(missing_files)}\" if missing_files else \"\",\n   274→            f\"参考图{len(missing_refs)}\" if missing_refs else \"\",\n   275→        ]\n   276→        detail_parts = [part for part in detail_parts if part]\n   277→        if status_text != \"success\" and not detail_parts:\n   278→            detail_parts.append(\"状态异常\")\n   279→\n   280→        if detail_parts:\n   281→            status_hint = \"导出完成（部分缺失：\" + \"、\".join(detail_parts) + \")\"\n   282→        else:\n   283→            status_hint = \"导出成功\"\n   284→\n   285→        self._set_running(False, status_hint)\n   286→\n   287→        lines = [\n   288→            f\"Zip：{zip_name}\",\n   289→            f\"目录：{directory_hint}\",\n   290→            f\"参考图：{ref_count} 张 ({ref_summary})\",\n   291→        ]\n   292→        if detail_parts:\n   293→            lines.append(\"部分缺失详情：\" + \"、\".join(detail_parts))\n   294→\n   295→        self._show_message(\"导出完成\", \"\\n\".join(lines), \"information\")\n   296→        logger.info(\n   297→            \"UI|export_bundle_completed record_type=%s record_id=%s zip=%s ref_count=%d missing_records=%d missing_files=%d missing_refs=%d dest=%s status=%s\",\n   298→            self._record_type,\n   299→            masked_record,\n   300→            zip_name,\n   301→            ref_count,\n   302→            len(missing_records),\n   303→            len(missing_files),\n   304→            len(missing_refs),\n   305→            directory_hint,\n   306→            status_text,\n   307→        )\n   308→        self._complete_task(token)\n   309→\n   310→    def _handle_error(self, exc: BaseException, masked_record: str, token: Optional[CancelToken]) -> None:\n   311→        if self._disposed:\n   312→            return\n   313→        reason = \"exception\"\n   314→        message = \"导出失败，请查看日志。\"\n   315→        if isinstance(exc, PermissionError):\n   316→            reason = \"permission_denied\"\n   317→            message = \"导出目录无写入权限，请选择其他位置。\"\n   318→        self._set_running(False, \"导出失败\")\n   319→        self._show_message(\"导出失败\", message, \"critical\")\n   320→        logger.warning(\n   321→            \"UI|export_bundle_failed record_type=%s record_id=%s reason=%s detail=%s\",\n   322→            self._record_type,\n   323→            masked_record,\n   324→            reason,\n   325→            str(exc),\n   326→        )\n   327→        self._complete_task(token)\n   328→\n   329→def _resolve_repository_manager(widget: Optional[Any]) -> Optional[RepositoryManager]:\n   330→    current = widget\n   331→    visited: set[int] = set()\n   332→    while current is not None:\n   333→        identity = id(current)\n   334→        if identity in visited:\n   335→            break\n   336→        visited.add(identity)\n   337→        try:\n   338→            if hasattr(current, 'get_repository_manager'):\n   339→                manager = current.get_repository_manager()\n   340→                if manager:\n   341→                    return manager\n   342→        except Exception as exc:\n   343→            logger.debug(f\"解析仓库管理器失败: {exc}\")\n   344→        try:\n   345→            current = current.parent()\n   346→        except Exception:\n   347→            current = None\n   348→    return None\n   349→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3b28791e-1b51-43db-acfb-74040acf5d1a","timestamp":"2025-12-22T06:08:44.312Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/controllers/export_bundle_controller.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Export bundle controller split from qt_app.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, Optional\n\nfrom PySide6.QtCore import QObject, Signal\nfrom PySide6.QtWidgets import QFileDialog, QLabel, QMessageBox, QPushButton, QWidget\n\nfrom modules.repository.manager import RepositoryManager\nfrom utils.logger import logger\nfrom utils.reference_display import (\n    _format_dir_hint,\n    _mask_record_id,\n    _summarize_masked_ids,\n)\nfrom utils.task_runner import CancelToken, task_runner\n\n__all__ = [\"ExportBundleController\", \"_resolve_repository_manager\"]\n\nclass ExportBundleController(QObject):\n    \"\"\"封装详情页导出逻辑，统一按钮状态与提示信息。\"\"\"\n\n    _result_ready = Signal(object, str, object)\n    _error_ready = Signal(object, str, object)\n\n    def __init__(\n        self,\n        owner: QWidget,\n        record_type: str,\n        *,\n        context_widget: Optional[QWidget] = None,\n    ):\n        super().__init__(owner)\n        normalized_type = (record_type or \"image\").lower()\n        if normalized_type not in {\"image\", \"video\"}:\n            normalized_type = \"image\"\n        self._owner = owner\n        self._context_widget = context_widget or owner\n        self._record_type = normalized_type\n        self._button: Optional[QPushButton] = None\n        self._status_label: Optional[QLabel] = None\n        self._record_supplier: Callable[[], Optional[str]] = lambda: None\n        self._running = False\n        self._idle_text = \"导出记录\"\n        self._cancel_token: Optional[CancelToken] = None\n        self._disposed = False\n        self._result_ready.connect(self._handle_result)\n        self._error_ready.connect(self._handle_error)\n\n    # ------------------------------------------------------------------\n    # Lifecycle helpers\n    # ------------------------------------------------------------------\n    def configure(\n        self,\n        button: QPushButton,\n        status_label: Optional[QLabel],\n        record_supplier: Callable[[], Optional[str]],\n        *,\n        context_widget: Optional[QWidget] = None,\n    ) -> None:\n        if self._disposed:\n            return\n        self._button = button\n        self._status_label = status_label\n        self._record_supplier = record_supplier\n        if context_widget is not None:\n            self._context_widget = context_widget\n        self._idle_text = button.text() or self._idle_text\n        button.clicked.connect(self._on_clicked)\n        self.refresh()\n\n    def set_context_widget(self, widget: QWidget) -> None:\n        self._context_widget = widget or self._owner\n\n    def dispose(self) -> None:\n        if self._disposed:\n            return\n        self._disposed = True\n        if self._cancel_token:\n            self._cancel_token.cancel()\n            self._cancel_token = None\n        self._running = False\n        try:\n            self._result_ready.disconnect(self._handle_result)\n        except Exception:\n            pass\n        try:\n            self._error_ready.disconnect(self._handle_error)\n        except Exception:\n            pass\n        self._button = None\n        self._status_label = None\n        self._record_supplier = lambda: None\n        \n    # ------------------------------------------------------------------\n    # 内部状态工具\n    # ------------------------------------------------------------------\n    @staticmethod\n    def _widget_alive(widget: Optional[QWidget]) -> bool:\n        if widget is None:\n            return False\n        try:\n            widget.objectName()\n            return True\n        except RuntimeError:\n            return False\n\n    def _complete_task(self, token: Optional[CancelToken]) -> None:\n        if token is self._cancel_token:\n            self._cancel_token = None\n        self._running = False\n\n    # ------------------------------------------------------------------\n    # UI 更新\n    # ------------------------------------------------------------------\n    def refresh(self) -> None:\n        if self._disposed:\n            return\n        record_id = self._record_supplier() if self._record_supplier else None\n        if self._widget_alive(self._button):\n            try:\n                self._button.setEnabled(bool(record_id) and not self._running)\n            except RuntimeError:\n                pass\n        if self._widget_alive(self._status_label) and not self._running:\n            if not record_id:\n                try:\n                    self._status_label.setText(\"\")\n                except RuntimeError:\n                    pass\n\n    def _set_running(self, working: bool, hint: str) -> None:\n        if self._disposed:\n            return\n        self._running = working\n        if self._widget_alive(self._button):\n            try:\n                if working:\n                    self._button.setEnabled(False)\n                    self._button.setText(\"导出中…\")\n                else:\n                    self._button.setText(self._idle_text)\n                    self.refresh()\n            except RuntimeError:\n                pass\n        if self._widget_alive(self._status_label):\n            try:\n                self._status_label.setText(hint)\n            except RuntimeError:\n                pass\n\n    def _show_message(self, title: str, message: str, icon_type: str = \"information\") -> None:\n        if self._disposed:\n            return\n        handler = getattr(self._owner, \"show_styled_message\", None)\n        if callable(handler):\n            handler(title, message, icon_type)\n            return\n        icon_map = {\n            \"information\": QMessageBox.Information,\n            \"warning\": QMessageBox.Warning,\n            \"critical\": QMessageBox.Critical,\n        }\n        icon = icon_map.get(icon_type, QMessageBox.Information)\n        QMessageBox(icon, title, message, QMessageBox.Ok, self._owner).exec()\n\n    # ------------------------------------------------------------------\n    # 导出执行\n    # ------------------------------------------------------------------\n    def _on_clicked(self) -> None:\n        if self._disposed or self._running:\n            return\n        record_id = self._record_supplier() if self._record_supplier else None\n        if not record_id:\n            self._show_message(\"导出失败\", \"记录缺少 file_id，无法导出\", \"warning\")\n            return\n        context_widget = self._context_widget or self._owner\n        repo = _resolve_repository_manager(context_widget)\n        if not repo:\n            self._show_message(\"导出失败\", \"未找到仓库管理器实例\", \"warning\")\n            return\n\n        dest_dir = QFileDialog.getExistingDirectory(self._owner, \"选择导出目录\")\n        if not dest_dir:\n            if self._widget_alive(self._status_label):\n                try:\n                    self._status_label.setText(\"已取消\")\n                except RuntimeError:\n                    pass\n            logger.info(\n                \"UI|export_bundle_cancelled record_type=%s record_id=%s\",\n                self._record_type,\n                _mask_record_id(record_id),\n            )\n            return\n\n        masked_record = _mask_record_id(record_id)\n        token = CancelToken()\n        self._cancel_token = token\n        self._set_running(True, \"正在导出，请稍候…\")\n\n        def task():\n            if token.cancelled:\n                return None\n            return repo.export_generation_bundle(\n                [record_id],\n                record_type=self._record_type,\n                destination_dir=dest_dir,\n            )\n\n        def on_done(result: Optional[Dict[str, Any]]):\n            if token.cancelled or self._disposed or self._cancel_token is not token:\n                return\n            self._result_ready.emit(result, masked_record, token)\n\n        def on_error(exc: BaseException):\n            if token.cancelled or self._disposed or self._cancel_token is not token:\n                return\n            self._error_ready.emit(exc, masked_record, token)\n\n        task_runner.submit(\n            task,\n            key=f\"export_bundle:{self._record_type}:{record_id}\",\n            on_done=on_done,\n            on_error=on_error,\n            cancel_token=token,\n        )\n\n    def _handle_result(self, result: Optional[Dict[str, Any]], masked_record: str, token: Optional[CancelToken]) -> None:\n        if self._disposed:\n            return\n        if not result:\n            self._set_running(False, \"导出失败\")\n            self._show_message(\"导出失败\", \"未能生成导出文件，请检查记录状态。\", \"warning\")\n            logger.warning(\n                \"UI|export_bundle_failed record_type=%s record_id=%s reason=%s\",\n                self._record_type,\n                masked_record,\n                \"no_result\",\n            )\n            self._complete_task(token)\n            return\n\n        dest_zip = result.get(\"destination_zip\") or result.get(\"zip_path\")\n        if not dest_zip:\n            self._set_running(False, \"导出失败\")\n            self._show_message(\"导出失败\", \"导出结果缺少 zip 信息\", \"critical\")\n            logger.warning(\n                \"UI|export_bundle_failed record_type=%s record_id=%s reason=%s\",\n                self._record_type,\n                masked_record,\n                \"missing_zip_path\",\n            )\n            self._complete_task(token)\n            return\n\n        ref_ids = result.get(\"reference_ids\") or []\n        ref_count = int(result.get(\"reference_count\", 0))\n        ref_summary = _summarize_masked_ids(ref_ids)\n        status_text = result.get(\"status\") or \"success\"\n        zip_name = Path(dest_zip).name\n        directory_hint = _format_dir_hint(Path(dest_zip).parent)\n        missing_records = result.get(\"missing_records\") or []\n        missing_files = result.get(\"missing_main_files\") or []\n        missing_refs = result.get(\"missing_references\") or []\n\n        detail_parts = [\n            f\"记录{len(missing_records)}\" if missing_records else \"\",\n            f\"主文件{len(missing_files)}\" if missing_files else \"\",\n            f\"参考图{len(missing_refs)}\" if missing_refs else \"\",\n        ]\n        detail_parts = [part for part in detail_parts if part]\n        if status_text != \"success\" and not detail_parts:\n            detail_parts.append(\"状态异常\")\n\n        if detail_parts:\n            status_hint = \"导出完成（部分缺失：\" + \"、\".join(detail_parts) + \")\"\n        else:\n            status_hint = \"导出成功\"\n\n        self._set_running(False, status_hint)\n\n        lines = [\n            f\"Zip：{zip_name}\",\n            f\"目录：{directory_hint}\",\n            f\"参考图：{ref_count} 张 ({ref_summary})\",\n        ]\n        if detail_parts:\n            lines.append(\"部分缺失详情：\" + \"、\".join(detail_parts))\n\n        self._show_message(\"导出完成\", \"\\n\".join(lines), \"information\")\n        logger.info(\n            \"UI|export_bundle_completed record_type=%s record_id=%s zip=%s ref_count=%d missing_records=%d missing_files=%d missing_refs=%d dest=%s status=%s\",\n            self._record_type,\n            masked_record,\n            zip_name,\n            ref_count,\n            len(missing_records),\n            len(missing_files),\n            len(missing_refs),\n            directory_hint,\n            status_text,\n        )\n        self._complete_task(token)\n\n    def _handle_error(self, exc: BaseException, masked_record: str, token: Optional[CancelToken]) -> None:\n        if self._disposed:\n            return\n        reason = \"exception\"\n        message = \"导出失败，请查看日志。\"\n        if isinstance(exc, PermissionError):\n            reason = \"permission_denied\"\n            message = \"导出目录无写入权限，请选择其他位置。\"\n        self._set_running(False, \"导出失败\")\n        self._show_message(\"导出失败\", message, \"critical\")\n        logger.warning(\n            \"UI|export_bundle_failed record_type=%s record_id=%s reason=%s detail=%s\",\n            self._record_type,\n            masked_record,\n            reason,\n            str(exc),\n        )\n        self._complete_task(token)\n\ndef _resolve_repository_manager(widget: Optional[Any]) -> Optional[RepositoryManager]:\n    current = widget\n    visited: set[int] = set()\n    while current is not None:\n        identity = id(current)\n        if identity in visited:\n            break\n        visited.add(identity)\n        try:\n            if hasattr(current, 'get_repository_manager'):\n                manager = current.get_repository_manager()\n                if manager:\n                    return manager\n        except Exception as exc:\n            logger.debug(f\"解析仓库管理器失败: {exc}\")\n        try:\n            current = current.parent()\n        except Exception:\n            current = None\n    return None\n","numLines":349,"startLine":1,"totalLines":349}}}
{"parentUuid":"3b28791e-1b51-43db-acfb-74040acf5d1a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XhHXetgTWiUVHkqnFC1ujX","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"Reference asset actions extracted from qt_app.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import os\n     8→import shutil\n     9→from pathlib import Path\n    10→from typing import Any, Callable, Dict, Optional, Sequence\n    11→\n    12→from PySide6.QtCore import Qt\n    13→from PySide6.QtGui import QKeySequence, QPixmap\n    14→from PySide6.QtWidgets import (\n    15→    QDialog,\n    16→    QFileDialog,\n    17→    QHBoxLayout,\n    18→    QLabel,\n    19→    QMessageBox,\n    20→    QPushButton,\n    21→    QMenu,\n    22→    QVBoxLayout,\n    23→    QWidget,\n    24→)\n    25→from PySide6.QtGui import QShortcut\n    26→from utils.style_system import unified_style_system\n    27→\n    28→from components.reference_assets.gallery import ReferenceGalleryWidget\n    29→from components.widgets.zoomable_image_label import ZoomableImageLabel\n    30→from utils.logger import logger\n    31→from utils.reference_assets import resolve_asset_path\n    32→from utils.reference_display import (\n    33→    _mask_reference_ids,\n    34→    format_reference_display_label,\n    35→)\n    36→\n    37→def _find_reference_asset_index(assets: Sequence[Dict[str, Any]], target: Dict[str, Any]) -> int:\n    38→    for idx, candidate in enumerate(assets):\n    39→        if ReferenceGalleryWidget._is_same_asset(candidate, target):\n    40→            return idx\n    41→    return 0\n    42→\n    43→\n    44→def open_reference_preview(\n    45→    parent: QWidget,\n    46→    asset: Dict[str, Any],\n    47→    *,\n    48→    title_prefix: str = \"参考图\",\n    49→    asset_list: Optional[Sequence[Dict[str, Any]]] = None,\n    50→    start_index: Optional[int] = None,\n    51→    on_asset_changed: Optional[Callable[[Dict[str, Any]], None]] = None,\n    52→):\n    53→    assets = list(asset_list) if asset_list else [asset]\n    54→    if not assets:\n    55→        assets = [asset]\n    56→\n    57→    total = len(assets)\n    58→    index = start_index if (start_index is not None and 0 <= start_index < total) else _find_reference_asset_index(assets, asset)\n    59→\n    60→    dialog = QDialog(parent)\n    61→    dialog.setModal(True)\n    62→    dialog.setWindowModality(Qt.ApplicationModal)\n    63→    dialog.setAttribute(Qt.WA_DeleteOnClose, True)\n    64→    layout = QVBoxLayout(dialog)\n    65→    layout.setContentsMargins(12, 12, 12, 12)\n    66→    layout.setSpacing(10)\n    67→\n    68→    viewer = ZoomableImageLabel()\n    69→    viewer.setFocusPolicy(Qt.StrongFocus)\n    70→    viewer.setMinimumSize(480, 360)\n    71→    layout.addWidget(viewer, 1)\n    72→\n    73→    # 获取主题颜色\n    74→    colors = unified_style_system.get_colors()\n    75→    warning_color = (\n    76→        colors.get('palette.accent.orange')\n    77→        or colors.get('palette.semantic.warning')\n    78→        or colors.get('primary')\n    79→    )\n    80→    secondary_text = (\n    81→        colors.get('palette.text.secondary')\n    82→        or colors.get('text_secondary')\n    83→        or colors.get('palette.text.primary')\n    84→        or colors.get('text')\n    85→    )\n    86→\n    87→    info_label = QLabel(\"\")\n    88→    info_label.setStyleSheet(f\"color: {warning_color};\")\n    89→    info_label.setWordWrap(True)\n    90→    info_label.hide()\n    91→    layout.addWidget(info_label)\n    92→\n    93→    controls = QHBoxLayout()\n    94→    controls.setContentsMargins(0, 0, 0, 0)\n    95→    controls.setSpacing(8)\n    96→\n    97→    prev_btn = QPushButton(\"上一张\")\n    98→    next_btn = QPushButton(\"下一张\")\n    99→    unified_style_system.apply_to_widget(prev_btn)\n   100→    unified_style_system.apply_to_widget(next_btn)\n   101→    index_label = QLabel(\"\")\n   102→    index_label.setStyleSheet(f\"color: {secondary_text};\")\n   103→    hint_label = QLabel(\"Ctrl/⌘+滚轮缩放，双击或点击按钮重置\")\n   104→    hint_label.setStyleSheet(f\"color: {secondary_text};\")\n   105→    reset_btn = QPushButton(\"重置缩放\")\n   106→    close_btn = QPushButton(\"关闭\")\n   107→    unified_style_system.apply_to_widget(reset_btn)\n   108→    unified_style_system.apply_to_widget(close_btn)\n   109→\n   110→    controls.addWidget(prev_btn)\n   111→    controls.addWidget(next_btn)\n   112→    controls.addStretch(1)\n   113→    controls.addWidget(index_label)\n   114→    controls.addStretch(1)\n   115→    controls.addWidget(hint_label)\n   116→    controls.addStretch(1)\n   117→    controls.addWidget(reset_btn)\n   118→    controls.addWidget(close_btn)\n   119→    layout.addLayout(controls)\n   120→\n   121→    esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), dialog)\n   122→    esc_shortcut.activated.connect(dialog.reject)\n   123→\n   124→    prev_shortcut = QShortcut(QKeySequence(Qt.Key_Left), dialog)\n   125→    next_shortcut = QShortcut(QKeySequence(Qt.Key_Right), dialog)\n   126→    prev_shortcut_a = QShortcut(QKeySequence(Qt.Key_A), dialog)\n   127→    next_shortcut_d = QShortcut(QKeySequence(Qt.Key_D), dialog)\n   128→\n   129→    state = {\n   130→        'index': index,\n   131→        'total': total,\n   132→    }\n   133→\n   134→    def update_title(current_asset: Dict[str, Any]):\n   135→        display_label = format_reference_display_label(current_asset, current_asset.get('order') or 0)\n   136→        dialog.setWindowTitle(f\"{title_prefix} {display_label}\")\n   137→\n   138→    def update_nav_buttons():\n   139→        idx = state['index']\n   140→        total_count = state['total']\n   141→        prev_btn.setEnabled(total_count > 1 and idx > 0)\n   142→        next_btn.setEnabled(total_count > 1 and idx < total_count - 1)\n   143→        index_label.setText(f\"{idx + 1}/{total_count}\")\n   144→\n   145→    def load_asset(idx: int):\n   146→        idx = max(0, min(idx, state['total'] - 1))\n   147→        current_asset = assets[idx]\n   148→\n   149→        path = resolve_asset_path(current_asset)\n   150→        available = False\n   151→        pixmap = None\n   152→        if path:\n   153→            pixmap = QPixmap(path)\n   154→            if pixmap and not pixmap.isNull():\n   155→                available = True\n   156→\n   157→        if available:\n   158→            viewer.setPixmap(pixmap)\n   159→            info_label.hide()\n   160→            # 只在成功加载图片时才重置缩放\n   161→            viewer.reset_zoom()\n   162→        else:\n   163→            viewer.original_pixmap = None\n   164→            viewer.setPixmap(QPixmap())\n   165→            info_label.setText(\"参考图暂不可用（文件缺失或无法加载）\")\n   166→            info_label.show()\n   167→\n   168→        state['index'] = idx\n   169→        update_title(current_asset)\n   170→        update_nav_buttons()\n   171→\n   172→        if callable(on_asset_changed):\n   173→            try:\n   174→                on_asset_changed(current_asset)\n   175→            except Exception:\n   176→                pass\n   177→\n   178→    def show_prev():\n   179→        idx = state['index']\n   180→        if idx > 0:\n   181→            load_asset(idx - 1)\n   182→\n   183→    def show_next():\n   184→        idx = state['index']\n   185→        if idx < state['total'] - 1:\n   186→            load_asset(idx + 1)\n   187→\n   188→    prev_btn.clicked.connect(show_prev)\n   189→    next_btn.clicked.connect(show_next)\n   190→    reset_btn.clicked.connect(viewer.reset_zoom)\n   191→    close_btn.clicked.connect(dialog.accept)\n   192→    prev_shortcut.activated.connect(show_prev)\n   193→    prev_shortcut_a.activated.connect(show_prev)\n   194→    next_shortcut.activated.connect(show_next)\n   195→    next_shortcut_d.activated.connect(show_next)\n   196→\n   197→    load_asset(state['index'])\n   198→\n   199→    dialog.resize(720, 560)\n   200→    dialog.exec()\n   201→\n   202→\n   203→def export_reference_asset(parent: QWidget, asset: Dict[str, Any]) -> Optional[str]:\n   204→    path = resolve_asset_path(asset)\n   205→    if not path:\n   206→        QMessageBox.warning(parent, \"导出参考图\", \"参考图暂不可用\")\n   207→        return None\n   208→\n   209→    src_path = Path(path)\n   210→    suffix = src_path.suffix or '.png'\n   211→    base_name = asset.get('id') or src_path.stem\n   212→    if not base_name:\n   213→        base_name = 'reference_image'\n   214→    if not base_name.endswith(suffix):\n   215→        suggested_name = f\"{base_name}{suffix}\"\n   216→    else:\n   217→        suggested_name = base_name\n   218→\n   219→    start_path = os.path.join(os.path.expanduser('~'), suggested_name)\n   220→    dest_path, _ = QFileDialog.getSaveFileName(\n   221→        parent,\n   222→        \"导出参考图\",\n   223→        start_path,\n   224→        \"Images (*.png *.jpg *.jpeg *.webp *.bmp)\"\n   225→    )\n   226→    if not dest_path:\n   227→        return None\n   228→\n   229→    try:\n   230→        shutil.copyfile(str(src_path), dest_path)\n   231→    except Exception as exc:\n   232→        QMessageBox.critical(parent, \"导出失败\", f\"导出失败：{exc}\")\n   233→        try:\n   234→            logger.warning(f\"reference_export_failed|ids={_mask_reference_ids([asset])}\")\n   235→        except Exception:\n   236→            pass\n   237→        return None\n   238→\n   239→    try:\n   240→        masked = _mask_reference_ids([asset])\n   241→        dest_dir_name = Path(dest_path).parent.name or Path(dest_path).parent\n   242→        logger.info(f\"reference_export|count=1 ids={masked} dest={dest_dir_name}\")\n   243→    except Exception:\n   244→        pass\n   245→\n   246→    dest_dir = str(Path(dest_path).parent)\n   247→    QMessageBox.information(parent, \"导出成功\", f\"已导出到目录: {dest_dir}\")\n   248→    return dest_path\n   249→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"04c8e2d0-ff15-4010-ab13-ebe2e022b172","timestamp":"2025-12-22T06:08:44.312Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/actions.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Reference asset actions extracted from qt_app.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport shutil\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, Optional, Sequence\n\nfrom PySide6.QtCore import Qt\nfrom PySide6.QtGui import QKeySequence, QPixmap\nfrom PySide6.QtWidgets import (\n    QDialog,\n    QFileDialog,\n    QHBoxLayout,\n    QLabel,\n    QMessageBox,\n    QPushButton,\n    QMenu,\n    QVBoxLayout,\n    QWidget,\n)\nfrom PySide6.QtGui import QShortcut\nfrom utils.style_system import unified_style_system\n\nfrom components.reference_assets.gallery import ReferenceGalleryWidget\nfrom components.widgets.zoomable_image_label import ZoomableImageLabel\nfrom utils.logger import logger\nfrom utils.reference_assets import resolve_asset_path\nfrom utils.reference_display import (\n    _mask_reference_ids,\n    format_reference_display_label,\n)\n\ndef _find_reference_asset_index(assets: Sequence[Dict[str, Any]], target: Dict[str, Any]) -> int:\n    for idx, candidate in enumerate(assets):\n        if ReferenceGalleryWidget._is_same_asset(candidate, target):\n            return idx\n    return 0\n\n\ndef open_reference_preview(\n    parent: QWidget,\n    asset: Dict[str, Any],\n    *,\n    title_prefix: str = \"参考图\",\n    asset_list: Optional[Sequence[Dict[str, Any]]] = None,\n    start_index: Optional[int] = None,\n    on_asset_changed: Optional[Callable[[Dict[str, Any]], None]] = None,\n):\n    assets = list(asset_list) if asset_list else [asset]\n    if not assets:\n        assets = [asset]\n\n    total = len(assets)\n    index = start_index if (start_index is not None and 0 <= start_index < total) else _find_reference_asset_index(assets, asset)\n\n    dialog = QDialog(parent)\n    dialog.setModal(True)\n    dialog.setWindowModality(Qt.ApplicationModal)\n    dialog.setAttribute(Qt.WA_DeleteOnClose, True)\n    layout = QVBoxLayout(dialog)\n    layout.setContentsMargins(12, 12, 12, 12)\n    layout.setSpacing(10)\n\n    viewer = ZoomableImageLabel()\n    viewer.setFocusPolicy(Qt.StrongFocus)\n    viewer.setMinimumSize(480, 360)\n    layout.addWidget(viewer, 1)\n\n    # 获取主题颜色\n    colors = unified_style_system.get_colors()\n    warning_color = (\n        colors.get('palette.accent.orange')\n        or colors.get('palette.semantic.warning')\n        or colors.get('primary')\n    )\n    secondary_text = (\n        colors.get('palette.text.secondary')\n        or colors.get('text_secondary')\n        or colors.get('palette.text.primary')\n        or colors.get('text')\n    )\n\n    info_label = QLabel(\"\")\n    info_label.setStyleSheet(f\"color: {warning_color};\")\n    info_label.setWordWrap(True)\n    info_label.hide()\n    layout.addWidget(info_label)\n\n    controls = QHBoxLayout()\n    controls.setContentsMargins(0, 0, 0, 0)\n    controls.setSpacing(8)\n\n    prev_btn = QPushButton(\"上一张\")\n    next_btn = QPushButton(\"下一张\")\n    unified_style_system.apply_to_widget(prev_btn)\n    unified_style_system.apply_to_widget(next_btn)\n    index_label = QLabel(\"\")\n    index_label.setStyleSheet(f\"color: {secondary_text};\")\n    hint_label = QLabel(\"Ctrl/⌘+滚轮缩放，双击或点击按钮重置\")\n    hint_label.setStyleSheet(f\"color: {secondary_text};\")\n    reset_btn = QPushButton(\"重置缩放\")\n    close_btn = QPushButton(\"关闭\")\n    unified_style_system.apply_to_widget(reset_btn)\n    unified_style_system.apply_to_widget(close_btn)\n\n    controls.addWidget(prev_btn)\n    controls.addWidget(next_btn)\n    controls.addStretch(1)\n    controls.addWidget(index_label)\n    controls.addStretch(1)\n    controls.addWidget(hint_label)\n    controls.addStretch(1)\n    controls.addWidget(reset_btn)\n    controls.addWidget(close_btn)\n    layout.addLayout(controls)\n\n    esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), dialog)\n    esc_shortcut.activated.connect(dialog.reject)\n\n    prev_shortcut = QShortcut(QKeySequence(Qt.Key_Left), dialog)\n    next_shortcut = QShortcut(QKeySequence(Qt.Key_Right), dialog)\n    prev_shortcut_a = QShortcut(QKeySequence(Qt.Key_A), dialog)\n    next_shortcut_d = QShortcut(QKeySequence(Qt.Key_D), dialog)\n\n    state = {\n        'index': index,\n        'total': total,\n    }\n\n    def update_title(current_asset: Dict[str, Any]):\n        display_label = format_reference_display_label(current_asset, current_asset.get('order') or 0)\n        dialog.setWindowTitle(f\"{title_prefix} {display_label}\")\n\n    def update_nav_buttons():\n        idx = state['index']\n        total_count = state['total']\n        prev_btn.setEnabled(total_count > 1 and idx > 0)\n        next_btn.setEnabled(total_count > 1 and idx < total_count - 1)\n        index_label.setText(f\"{idx + 1}/{total_count}\")\n\n    def load_asset(idx: int):\n        idx = max(0, min(idx, state['total'] - 1))\n        current_asset = assets[idx]\n\n        path = resolve_asset_path(current_asset)\n        available = False\n        pixmap = None\n        if path:\n            pixmap = QPixmap(path)\n            if pixmap and not pixmap.isNull():\n                available = True\n\n        if available:\n            viewer.setPixmap(pixmap)\n            info_label.hide()\n            # 只在成功加载图片时才重置缩放\n            viewer.reset_zoom()\n        else:\n            viewer.original_pixmap = None\n            viewer.setPixmap(QPixmap())\n            info_label.setText(\"参考图暂不可用（文件缺失或无法加载）\")\n            info_label.show()\n\n        state['index'] = idx\n        update_title(current_asset)\n        update_nav_buttons()\n\n        if callable(on_asset_changed):\n            try:\n                on_asset_changed(current_asset)\n            except Exception:\n                pass\n\n    def show_prev():\n        idx = state['index']\n        if idx > 0:\n            load_asset(idx - 1)\n\n    def show_next():\n        idx = state['index']\n        if idx < state['total'] - 1:\n            load_asset(idx + 1)\n\n    prev_btn.clicked.connect(show_prev)\n    next_btn.clicked.connect(show_next)\n    reset_btn.clicked.connect(viewer.reset_zoom)\n    close_btn.clicked.connect(dialog.accept)\n    prev_shortcut.activated.connect(show_prev)\n    prev_shortcut_a.activated.connect(show_prev)\n    next_shortcut.activated.connect(show_next)\n    next_shortcut_d.activated.connect(show_next)\n\n    load_asset(state['index'])\n\n    dialog.resize(720, 560)\n    dialog.exec()\n\n\ndef export_reference_asset(parent: QWidget, asset: Dict[str, Any]) -> Optional[str]:\n    path = resolve_asset_path(asset)\n    if not path:\n        QMessageBox.warning(parent, \"导出参考图\", \"参考图暂不可用\")\n        return None\n\n    src_path = Path(path)\n    suffix = src_path.suffix or '.png'\n    base_name = asset.get('id') or src_path.stem\n    if not base_name:\n        base_name = 'reference_image'\n    if not base_name.endswith(suffix):\n        suggested_name = f\"{base_name}{suffix}\"\n    else:\n        suggested_name = base_name\n\n    start_path = os.path.join(os.path.expanduser('~'), suggested_name)\n    dest_path, _ = QFileDialog.getSaveFileName(\n        parent,\n        \"导出参考图\",\n        start_path,\n        \"Images (*.png *.jpg *.jpeg *.webp *.bmp)\"\n    )\n    if not dest_path:\n        return None\n\n    try:\n        shutil.copyfile(str(src_path), dest_path)\n    except Exception as exc:\n        QMessageBox.critical(parent, \"导出失败\", f\"导出失败：{exc}\")\n        try:\n            logger.warning(f\"reference_export_failed|ids={_mask_reference_ids([asset])}\")\n        except Exception:\n            pass\n        return None\n\n    try:\n        masked = _mask_reference_ids([asset])\n        dest_dir_name = Path(dest_path).parent.name or Path(dest_path).parent\n        logger.info(f\"reference_export|count=1 ids={masked} dest={dest_dir_name}\")\n    except Exception:\n        pass\n\n    dest_dir = str(Path(dest_path).parent)\n    QMessageBox.information(parent, \"导出成功\", f\"已导出到目录: {dest_dir}\")\n    return dest_path\n","numLines":249,"startLine":1,"totalLines":249}}}
{"parentUuid":"04c8e2d0-ff15-4010-ab13-ebe2e022b172","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013XD1shztaFNizgPRHnpm6F","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我检查是否有右键菜单中导出参考图的功能，以及搜索相关的上下文菜单实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8390,"cache_read_input_tokens":57775,"cache_creation":{"ephemeral_5m_input_tokens":8390,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"66742d81-4192-4636-923c-09d7365d9aa1","timestamp":"2025-12-22T06:08:47.939Z"}
{"parentUuid":"66742d81-4192-4636-923c-09d7365d9aa1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013XD1shztaFNizgPRHnpm6F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TwFVbWXtVb216SWpVAY3o6","name":"Grep","input":{"pattern":"export.*reference|export_reference|导出.*参考","path":"/Users/yunchang/Documents/GitHub/gemeng2"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8390,"cache_read_input_tokens":57775,"cache_creation":{"ephemeral_5m_input_tokens":8390,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"018b3b6c-5582-4801-bb01-279cb5748b37","timestamp":"2025-12-22T06:08:48.578Z"}
{"parentUuid":"018b3b6c-5582-4801-bb01-279cb5748b37","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013XD1shztaFNizgPRHnpm6F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CjGhLsxfPzdocQWpFpJH94","name":"Grep","input":{"pattern":"customContextMenu|contextMenu|QMenu","path":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8390,"cache_read_input_tokens":57775,"cache_creation":{"ephemeral_5m_input_tokens":8390,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"0f83dfa7-f7e9-46f8-9e1f-145e8d6a3cff","timestamp":"2025-12-22T06:08:49.158Z"}
{"parentUuid":"0f83dfa7-f7e9-46f8-9e1f-145e8d6a3cff","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CjGhLsxfPzdocQWpFpJH94","type":"tool_result","content":"Found 2 files\ncomponents/reference_assets/actions.py\ncomponents/reference_assets/gallery.py"}]},"uuid":"7b94c90a-8438-4359-8918-b37edc4e53c2","timestamp":"2025-12-22T06:08:49.229Z","toolUseResult":{"mode":"files_with_matches","filenames":["components/reference_assets/actions.py","components/reference_assets/gallery.py"],"numFiles":2}}
{"parentUuid":"7b94c90a-8438-4359-8918-b37edc4e53c2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TwFVbWXtVb216SWpVAY3o6","type":"tool_result","content":"Found 18 files\ncomponents/dialogs/video_detail_dialog.py\ncomponents/dialogs/image_detail_dialog.py\ncomponents/reference_assets/actions.py\ncomponents/reference_assets/gallery.py\ncomponents/reference_assets/__init__.py\nmodules/repository/manager.py\ndocs/release_notes/CHANGELOG.md\ntools/export_bundle.py\ndocs/执行计划_统一存储与UI绑定_20250928.md\ndocs/release_notes/RELEASE_NOTES_v0.8.0.md\ndocs/refactor/qt_app_analysis.md\ndocs/refactor/phase2.2_stage1_report.md\ndocs/refactor/PHASE2.2_EXECUTION_PLAN.md\ndocs/codex 对话记录导出.md\ndocs/PROJECT_AUDIT_AND_CHANGE_PLAN_2025-09-12.md\narchive/refactoring_20250924/qt_app_modified.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py\n.style_backup/qt_app.py"}]},"uuid":"240b72dd-a594-45dc-9e83-d3c7a8be68f5","timestamp":"2025-12-22T06:08:49.249Z","toolUseResult":{"mode":"files_with_matches","filenames":["components/dialogs/video_detail_dialog.py","components/dialogs/image_detail_dialog.py","components/reference_assets/actions.py","components/reference_assets/gallery.py","components/reference_assets/__init__.py","modules/repository/manager.py","docs/release_notes/CHANGELOG.md","tools/export_bundle.py","docs/执行计划_统一存储与UI绑定_20250928.md","docs/release_notes/RELEASE_NOTES_v0.8.0.md","docs/refactor/qt_app_analysis.md","docs/refactor/phase2.2_stage1_report.md","docs/refactor/PHASE2.2_EXECUTION_PLAN.md","docs/codex 对话记录导出.md","docs/PROJECT_AUDIT_AND_CHANGE_PLAN_2025-09-12.md","archive/refactoring_20250924/qt_app_modified.py",".style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py",".style_backup/qt_app.py"],"numFiles":18}}
{"parentUuid":"240b72dd-a594-45dc-9e83-d3c7a8be68f5","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FzTmt8DLoTPujdWwZXCE5Z","type":"message","role":"assistant","content":[{"type":"text","text":"让我检查参考图库的右键菜单实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":56,"cache_creation_input_tokens":939,"cache_read_input_tokens":66165,"cache_creation":{"ephemeral_5m_input_tokens":939,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"d184d0af-c325-4e21-8caa-288bed86a2db","timestamp":"2025-12-22T06:08:51.977Z"}
{"parentUuid":"d184d0af-c325-4e21-8caa-288bed86a2db","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FzTmt8DLoTPujdWwZXCE5Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YTqWX4fQ839mHiFdKEPEmV","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/gallery.py","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":56,"cache_creation_input_tokens":939,"cache_read_input_tokens":66165,"cache_creation":{"ephemeral_5m_input_tokens":939,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"4ad3f666-1f39-4e45-aece-8ecaf36511df","timestamp":"2025-12-22T06:08:52.501Z"}
{"parentUuid":"4ad3f666-1f39-4e45-aece-8ecaf36511df","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FzTmt8DLoTPujdWwZXCE5Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MTzpGFtfuW4qP8vZf5CmdW","name":"Grep","input":{"pattern":"customContextMenu|setContextMenuPolicy|exportRequested","path":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/gallery.py","output_mode":"content","-A":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":56,"cache_creation_input_tokens":939,"cache_read_input_tokens":66165,"cache_creation":{"ephemeral_5m_input_tokens":939,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"44f96c26-5e09-456a-9488-1a6b8a4d416a","timestamp":"2025-12-22T06:08:52.814Z"}
{"parentUuid":"44f96c26-5e09-456a-9488-1a6b8a4d416a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YTqWX4fQ839mHiFdKEPEmV","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"Reference gallery widgets using standard QListWidget.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import os\n     8→import math\n     9→from typing import Any, Dict, List, Optional, Tuple\n    10→\n    11→from PySide6.QtCore import Qt, Signal, QSize, QRect, QPoint\n    12→from PySide6.QtGui import QPixmap, QImageReader, QPainter, QColor, QBrush, QPen, QAction, QMouseEvent\n    13→from PySide6.QtWidgets import (\n    14→    QListWidget,\n    15→    QListWidgetItem,\n    16→    QStyledItemDelegate,\n    17→    QStyle,\n    18→    QMenu,\n    19→    QApplication,\n    20→    QAbstractItemView\n    21→)\n    22→\n    23→from utils.logger import logger\n    24→from utils.reference_assets import resolve_asset_path\n    25→from utils.reference_display import format_reference_display_label\n    26→from utils.style_system import unified_style_system\n    27→\n    28→__all__ = [\"ReferenceGalleryWidget\"]\n    29→\n    30→class ReferenceGalleryDelegate(QStyledItemDelegate):\n    31→    \"\"\"Delegate for rendering reference gallery items.\"\"\"\n    32→    \n    33→    def __init__(self, parent=None):\n    34→        super().__init__(parent)\n    35→        self.padding = 8\n    36→        self.radius = 6\n    37→        self.thumb_height = 100\n    38→        self.spacing = 6\n    39→        self.font_size = 11\n    40→        \n    41→    def sizeHint(self, option, index):\n    42→        # Width is controlled by QListWidget grid size, here we influence height\n    43→        # But for IconMode, sizeHint usually comes from item.setSizeHint\n    44→        size = index.data(Qt.SizeHintRole)\n    45→        if size:\n    46→            return size\n    47→        return QSize(140, 160)\n    48→        \n    49→    def paint(self, painter: QPainter, option, index):\n    50→        if not index.isValid():\n    51→            return\n    52→            \n    53→        data = index.data(Qt.UserRole)\n    54→        if not data:\n    55→            return\n    56→            \n    57→        painter.save()\n    58→        painter.setRenderHint(QPainter.Antialiasing)\n    59→        \n    60→        # Draw background card\n    61→        rect = option.rect\n    62→        # Shrink rect slightly for margin\n    63→        card_rect = rect.adjusted(4, 4, -4, -4)\n    64→        \n    65→        colors = unified_style_system.get_colors()\n    66→        \n    67→        # Determine background color\n    68→        bg_color = QColor(colors.get('palette.neutral.bg_card') or colors.get('surface'))\n    69→        border_color = QColor(colors.get('palette.neutral.border_subtle') or colors.get('border'))\n    70→        \n    71→        if option.state & QStyle.State_Selected:\n    72→            border_color = QColor(colors.get('palette.brand.main') or colors.get('primary'))\n    73→            # Prefer neutral surface for selection background to avoid rgba() parsing issues\n    74→            # (QColor(\"rgba(...)\") is invalid and falls back to black).\n    75→            bg_color = QColor(\n    76→                colors.get('palette.neutral.bg_hover')\n    77→                or colors.get('palette.neutral.bg_input')\n    78→                or colors.get('palette.neutral.bg_card')\n    79→                or colors.get('surface')\n    80→            )\n    81→            # Draw thicker border for selection\n    82→            pen = QPen(border_color, 2)\n    83→        elif option.state & QStyle.State_MouseOver:\n    84→             bg_color = QColor(colors.get('palette.neutral.bg_hover') or colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card'))\n    85→             pen = QPen(border_color, 1)\n    86→        else:\n    87→            pen = QPen(border_color, 1)\n    88→            \n    89→        painter.setPen(pen)\n    90→        painter.setBrush(QBrush(bg_color))\n    91→        painter.drawRoundedRect(card_rect, self.radius, self.radius)\n    92→        \n    93→        # Draw Pixmap\n    94→        pixmap: QPixmap = data.get('pixmap')\n    95→        if pixmap and not pixmap.isNull():\n    96→            # Calculate thumbnail area\n    97→            thumb_rect = QRect(\n    98→                card_rect.left() + self.padding,\n    99→                card_rect.top() + self.padding,\n   100→                card_rect.width() - 2 * self.padding,\n   101→                self.thumb_height\n   102→            )\n   103→            \n   104→            # Scale pixmap to fit\n   105→            scaled = pixmap.scaled(\n   106→                thumb_rect.size(),\n   107→                Qt.KeepAspectRatio,\n   108→                Qt.SmoothTransformation\n   109→            )\n   110→            \n   111→            # Center pixmap in thumb_rect\n   112→            x_off = (thumb_rect.width() - scaled.width()) // 2\n   113→            y_off = (thumb_rect.height() - scaled.height()) // 2\n   114→            \n   115→            target_rect = QRect(\n   116→                thumb_rect.left() + x_off,\n   117→                thumb_rect.top() + y_off,\n   118→                scaled.width(),\n   119→                scaled.height()\n   120→            )\n   121→            \n   122→            painter.drawPixmap(target_rect, scaled)\n   123→        else:\n   124→            # Draw \"Missing\" text\n   125→            thumb_rect = QRect(\n   126→                card_rect.left() + self.padding,\n   127→                card_rect.top() + self.padding,\n   128→                card_rect.width() - 2 * self.padding,\n   129→                self.thumb_height\n   130→            )\n   131→            painter.setPen(QColor(colors.get('palette.text.secondary') or colors.get('text_secondary') or colors.get('palette.text.primary') or colors.get('text')))\n   132→            painter.drawText(thumb_rect, Qt.AlignCenter, \"缺失\")\n   133→            \n   134→        # Draw Caption\n   135→        caption_rect = QRect(\n   136→            card_rect.left() + self.padding,\n   137→            card_rect.top() + self.padding + self.thumb_height + self.spacing,\n   138→            card_rect.width() - 2 * self.padding,\n   139→            card_rect.height() - (self.thumb_height + self.spacing + 2 * self.padding)\n   140→        )\n   141→        \n   142→        label_text = data.get('label', '')\n   143→        painter.setPen(QColor(colors.get('palette.text.primary') or colors.get('text')))\n   144→        \n   145→        # Configure font\n   146→        font = painter.font()\n   147→        font.setPointSize(self.font_size)\n   148→        painter.setFont(font)\n   149→        \n   150→        painter.drawText(caption_rect, Qt.AlignHCenter | Qt.AlignTop | Qt.TextWordWrap, label_text)\n   151→        \n   152→        painter.restore()\n   153→\n   154→class ReferenceGalleryWidget(QListWidget):\n   155→    \"\"\"Gallery widget for reference assets using QListWidget.\"\"\"\n   156→\n   157→    referenceClicked = Signal(dict)\n   158→    exportRequested = Signal(dict)\n   159→    selectionChanged = Signal(dict)\n   160→\n   161→    @staticmethod\n   162→    def _is_same_asset(left: Dict[str, Any], right: Dict[str, Any]) -> bool:\n   163→        \"\"\"判断两个资产是否相同\"\"\"\n   164→        if not isinstance(left, dict) or not isinstance(right, dict):\n   165→            return False\n   166→        left_id = left.get('id')\n   167→        right_id = right.get('id')\n   168→        if left_id and right_id:\n   169→            return left_id == right_id\n   170→        return left.get('order') == right.get('order')\n   171→\n   172→    def __init__(self, parent=None):\n   173→        super().__init__(parent)\n   174→        \n   175→        self.setViewMode(QListWidget.IconMode)\n   176→        self.setResizeMode(QListWidget.Adjust) # Reflow items\n   177→        self.setMovement(QListWidget.Static)   # No drag-drop reordering by default\n   178→        self.setSelectionMode(QListWidget.SingleSelection)\n   179→        self.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)\n   180→        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n   181→        \n   182→        self.delegate = ReferenceGalleryDelegate(self)\n   183→        self.setItemDelegate(self.delegate)\n   184→        \n   185→        self.setSpacing(4)\n   186→        \n   187→        # Connect internal signal\n   188→        self.itemClicked.connect(self._on_item_clicked)\n   189→        # selectionChanged is triggered by itemSelectionChanged\n   190→        self.itemSelectionChanged.connect(self._on_selection_changed)\n   191→        \n   192→        # Subscribe to theme changes\n   193→        unified_style_system.styleChanged.connect(self._update_theme)\n   194→        \n   195→        self._current_asset: Optional[Dict[str, Any]] = None\n   196→        \n   197→        # Initial style\n   198→        self._update_theme()\n   199→\n   200→    def _update_theme(self):\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f15d9ec8-3ee8-40f8-86a5-372ed249fe42","timestamp":"2025-12-22T06:08:52.881Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/gallery.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Reference gallery widgets using standard QListWidget.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport math\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom PySide6.QtCore import Qt, Signal, QSize, QRect, QPoint\nfrom PySide6.QtGui import QPixmap, QImageReader, QPainter, QColor, QBrush, QPen, QAction, QMouseEvent\nfrom PySide6.QtWidgets import (\n    QListWidget,\n    QListWidgetItem,\n    QStyledItemDelegate,\n    QStyle,\n    QMenu,\n    QApplication,\n    QAbstractItemView\n)\n\nfrom utils.logger import logger\nfrom utils.reference_assets import resolve_asset_path\nfrom utils.reference_display import format_reference_display_label\nfrom utils.style_system import unified_style_system\n\n__all__ = [\"ReferenceGalleryWidget\"]\n\nclass ReferenceGalleryDelegate(QStyledItemDelegate):\n    \"\"\"Delegate for rendering reference gallery items.\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.padding = 8\n        self.radius = 6\n        self.thumb_height = 100\n        self.spacing = 6\n        self.font_size = 11\n        \n    def sizeHint(self, option, index):\n        # Width is controlled by QListWidget grid size, here we influence height\n        # But for IconMode, sizeHint usually comes from item.setSizeHint\n        size = index.data(Qt.SizeHintRole)\n        if size:\n            return size\n        return QSize(140, 160)\n        \n    def paint(self, painter: QPainter, option, index):\n        if not index.isValid():\n            return\n            \n        data = index.data(Qt.UserRole)\n        if not data:\n            return\n            \n        painter.save()\n        painter.setRenderHint(QPainter.Antialiasing)\n        \n        # Draw background card\n        rect = option.rect\n        # Shrink rect slightly for margin\n        card_rect = rect.adjusted(4, 4, -4, -4)\n        \n        colors = unified_style_system.get_colors()\n        \n        # Determine background color\n        bg_color = QColor(colors.get('palette.neutral.bg_card') or colors.get('surface'))\n        border_color = QColor(colors.get('palette.neutral.border_subtle') or colors.get('border'))\n        \n        if option.state & QStyle.State_Selected:\n            border_color = QColor(colors.get('palette.brand.main') or colors.get('primary'))\n            # Prefer neutral surface for selection background to avoid rgba() parsing issues\n            # (QColor(\"rgba(...)\") is invalid and falls back to black).\n            bg_color = QColor(\n                colors.get('palette.neutral.bg_hover')\n                or colors.get('palette.neutral.bg_input')\n                or colors.get('palette.neutral.bg_card')\n                or colors.get('surface')\n            )\n            # Draw thicker border for selection\n            pen = QPen(border_color, 2)\n        elif option.state & QStyle.State_MouseOver:\n             bg_color = QColor(colors.get('palette.neutral.bg_hover') or colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card'))\n             pen = QPen(border_color, 1)\n        else:\n            pen = QPen(border_color, 1)\n            \n        painter.setPen(pen)\n        painter.setBrush(QBrush(bg_color))\n        painter.drawRoundedRect(card_rect, self.radius, self.radius)\n        \n        # Draw Pixmap\n        pixmap: QPixmap = data.get('pixmap')\n        if pixmap and not pixmap.isNull():\n            # Calculate thumbnail area\n            thumb_rect = QRect(\n                card_rect.left() + self.padding,\n                card_rect.top() + self.padding,\n                card_rect.width() - 2 * self.padding,\n                self.thumb_height\n            )\n            \n            # Scale pixmap to fit\n            scaled = pixmap.scaled(\n                thumb_rect.size(),\n                Qt.KeepAspectRatio,\n                Qt.SmoothTransformation\n            )\n            \n            # Center pixmap in thumb_rect\n            x_off = (thumb_rect.width() - scaled.width()) // 2\n            y_off = (thumb_rect.height() - scaled.height()) // 2\n            \n            target_rect = QRect(\n                thumb_rect.left() + x_off,\n                thumb_rect.top() + y_off,\n                scaled.width(),\n                scaled.height()\n            )\n            \n            painter.drawPixmap(target_rect, scaled)\n        else:\n            # Draw \"Missing\" text\n            thumb_rect = QRect(\n                card_rect.left() + self.padding,\n                card_rect.top() + self.padding,\n                card_rect.width() - 2 * self.padding,\n                self.thumb_height\n            )\n            painter.setPen(QColor(colors.get('palette.text.secondary') or colors.get('text_secondary') or colors.get('palette.text.primary') or colors.get('text')))\n            painter.drawText(thumb_rect, Qt.AlignCenter, \"缺失\")\n            \n        # Draw Caption\n        caption_rect = QRect(\n            card_rect.left() + self.padding,\n            card_rect.top() + self.padding + self.thumb_height + self.spacing,\n            card_rect.width() - 2 * self.padding,\n            card_rect.height() - (self.thumb_height + self.spacing + 2 * self.padding)\n        )\n        \n        label_text = data.get('label', '')\n        painter.setPen(QColor(colors.get('palette.text.primary') or colors.get('text')))\n        \n        # Configure font\n        font = painter.font()\n        font.setPointSize(self.font_size)\n        painter.setFont(font)\n        \n        painter.drawText(caption_rect, Qt.AlignHCenter | Qt.AlignTop | Qt.TextWordWrap, label_text)\n        \n        painter.restore()\n\nclass ReferenceGalleryWidget(QListWidget):\n    \"\"\"Gallery widget for reference assets using QListWidget.\"\"\"\n\n    referenceClicked = Signal(dict)\n    exportRequested = Signal(dict)\n    selectionChanged = Signal(dict)\n\n    @staticmethod\n    def _is_same_asset(left: Dict[str, Any], right: Dict[str, Any]) -> bool:\n        \"\"\"判断两个资产是否相同\"\"\"\n        if not isinstance(left, dict) or not isinstance(right, dict):\n            return False\n        left_id = left.get('id')\n        right_id = right.get('id')\n        if left_id and right_id:\n            return left_id == right_id\n        return left.get('order') == right.get('order')\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        self.setViewMode(QListWidget.IconMode)\n        self.setResizeMode(QListWidget.Adjust) # Reflow items\n        self.setMovement(QListWidget.Static)   # No drag-drop reordering by default\n        self.setSelectionMode(QListWidget.SingleSelection)\n        self.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        \n        self.delegate = ReferenceGalleryDelegate(self)\n        self.setItemDelegate(self.delegate)\n        \n        self.setSpacing(4)\n        \n        # Connect internal signal\n        self.itemClicked.connect(self._on_item_clicked)\n        # selectionChanged is triggered by itemSelectionChanged\n        self.itemSelectionChanged.connect(self._on_selection_changed)\n        \n        # Subscribe to theme changes\n        unified_style_system.styleChanged.connect(self._update_theme)\n        \n        self._current_asset: Optional[Dict[str, Any]] = None\n        \n        # Initial style\n        self._update_theme()\n\n    def _update_theme(self):","numLines":200,"startLine":1,"totalLines":336}}}
{"parentUuid":"f15d9ec8-3ee8-40f8-86a5-372ed249fe42","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MTzpGFtfuW4qP8vZf5CmdW","type":"tool_result","content":"158:    exportRequested = Signal(dict)\n159-    selectionChanged = Signal(dict)\n160-\n161-    @staticmethod\n162-    def _is_same_asset(left: Dict[str, Any], right: Dict[str, Any]) -> bool:\n163-        \"\"\"判断两个资产是否相同\"\"\"\n--\n306:        export_action.triggered.connect(lambda: self.exportRequested.emit(asset))\n307-        menu.addAction(export_action)\n308-        \n309-        menu.exec(event.globalPos())\n310-        \n311-    def _load_pixmap(self, asset: Dict[str, Any]) -> Optional[QPixmap]:"}]},"uuid":"eaa9e434-37b1-4609-8d0a-fe43f03239c8","timestamp":"2025-12-22T06:08:52.889Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"158:    exportRequested = Signal(dict)\n159-    selectionChanged = Signal(dict)\n160-\n161-    @staticmethod\n162-    def _is_same_asset(left: Dict[str, Any], right: Dict[str, Any]) -> bool:\n163-        \"\"\"判断两个资产是否相同\"\"\"\n--\n306:        export_action.triggered.connect(lambda: self.exportRequested.emit(asset))\n307-        menu.addAction(export_action)\n308-        \n309-        menu.exec(event.globalPos())\n310-        \n311-    def _load_pixmap(self, asset: Dict[str, Any]) -> Optional[QPixmap]:","numLines":13}}
{"parentUuid":"eaa9e434-37b1-4609-8d0a-fe43f03239c8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EnYKyY8SVwo9NvFWWoZznf","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我看一下gallery.py中右键菜单的完整实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3435,"cache_read_input_tokens":67104,"cache_creation":{"ephemeral_5m_input_tokens":3435,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"403307af-df10-484e-87db-d16dafe01a0b","timestamp":"2025-12-22T06:08:56.817Z"}
{"parentUuid":"403307af-df10-484e-87db-d16dafe01a0b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EnYKyY8SVwo9NvFWWoZznf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A5AJsms1uVYE7kmNzNAw6H","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/gallery.py","offset":280,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3435,"cache_read_input_tokens":67104,"cache_creation":{"ephemeral_5m_input_tokens":3435,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"872117b3-5718-4979-a31d-96818727fc89","timestamp":"2025-12-22T06:08:57.225Z"}
{"parentUuid":"872117b3-5718-4979-a31d-96818727fc89","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A5AJsms1uVYE7kmNzNAw6H","type":"tool_result","content":"   280→    def _on_item_clicked(self, item):\n   281→        data = item.data(Qt.UserRole)\n   282→        if data:\n   283→            asset = data.get('asset')\n   284→            self._current_asset = asset\n   285→            self.referenceClicked.emit(asset)\n   286→            \n   287→    def _on_selection_changed(self):\n   288→        items = self.selectedItems()\n   289→        if items:\n   290→            data = items[0].data(Qt.UserRole)\n   291→            asset = data.get('asset')\n   292→            if asset != self._current_asset:\n   293→                self._current_asset = asset\n   294→                self.selectionChanged.emit(self._current_asset)\n   295→        \n   296→    def contextMenuEvent(self, event):\n   297→        item = self.itemAt(event.pos())\n   298→        if not item:\n   299→            return\n   300→            \n   301→        data = item.data(Qt.UserRole)\n   302→        asset = data.get('asset')\n   303→        \n   304→        menu = QMenu(self)\n   305→        export_action = QAction(\"导出参考图\", self)\n   306→        export_action.triggered.connect(lambda: self.exportRequested.emit(asset))\n   307→        menu.addAction(export_action)\n   308→        \n   309→        menu.exec(event.globalPos())\n   310→        \n   311→    def _load_pixmap(self, asset: Dict[str, Any]) -> Optional[QPixmap]:\n   312→        \"\"\"Helper to load pixmap with path resolution logic.\"\"\"\n   313→        path = resolve_asset_path(asset)\n   314→        if not path:\n   315→            return None\n   316→            \n   317→        try:\n   318→             # Use QImageReader for size check\n   319→             reader = QImageReader(path)\n   320→             reader.setAutoTransform(True)\n   321→             \n   322→             size = reader.size()\n   323→             target_width = 300 # Slightly larger for retina\n   324→             if size.width() > target_width:\n   325→                 scale_ratio = target_width / size.width()\n   326→                 target_height = int(size.height() * scale_ratio)\n   327→                 reader.setScaledSize(QSize(target_width, target_height))\n   328→                 \n   329→             pixmap = QPixmap.fromImageReader(reader)\n   330→             if pixmap.isNull():\n   331→                 return None\n   332→             return pixmap\n   333→        except Exception as e:\n   334→            logger.error(f\"Failed to load pixmap: {e}\")\n   335→            return None\n   336→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4558269b-0286-4f52-8dd5-83077957491a","timestamp":"2025-12-22T06:08:57.286Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/reference_assets/gallery.py","content":"    def _on_item_clicked(self, item):\n        data = item.data(Qt.UserRole)\n        if data:\n            asset = data.get('asset')\n            self._current_asset = asset\n            self.referenceClicked.emit(asset)\n            \n    def _on_selection_changed(self):\n        items = self.selectedItems()\n        if items:\n            data = items[0].data(Qt.UserRole)\n            asset = data.get('asset')\n            if asset != self._current_asset:\n                self._current_asset = asset\n                self.selectionChanged.emit(self._current_asset)\n        \n    def contextMenuEvent(self, event):\n        item = self.itemAt(event.pos())\n        if not item:\n            return\n            \n        data = item.data(Qt.UserRole)\n        asset = data.get('asset')\n        \n        menu = QMenu(self)\n        export_action = QAction(\"导出参考图\", self)\n        export_action.triggered.connect(lambda: self.exportRequested.emit(asset))\n        menu.addAction(export_action)\n        \n        menu.exec(event.globalPos())\n        \n    def _load_pixmap(self, asset: Dict[str, Any]) -> Optional[QPixmap]:\n        \"\"\"Helper to load pixmap with path resolution logic.\"\"\"\n        path = resolve_asset_path(asset)\n        if not path:\n            return None\n            \n        try:\n             # Use QImageReader for size check\n             reader = QImageReader(path)\n             reader.setAutoTransform(True)\n             \n             size = reader.size()\n             target_width = 300 # Slightly larger for retina\n             if size.width() > target_width:\n                 scale_ratio = target_width / size.width()\n                 target_height = int(size.height() * scale_ratio)\n                 reader.setScaledSize(QSize(target_width, target_height))\n                 \n             pixmap = QPixmap.fromImageReader(reader)\n             if pixmap.isNull():\n                 return None\n             return pixmap\n        except Exception as e:\n            logger.error(f\"Failed to load pixmap: {e}\")\n            return None\n","numLines":57,"startLine":280,"totalLines":336}}}
{"parentUuid":"4558269b-0286-4f52-8dd5-83077957491a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"af7fbd8","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GYPYGvSWpSYsiS9oGuDJGy","type":"message","role":"assistant","content":[{"type":"text","text":"完美！现在我有了所有需要的信息。让我生成完整的分析报告。\n\n## 导出功能详细分析报告\n\n### 1. 两个导出按钮的功能分析\n\n#### A. \"导出记录\" 按钮 (`export_bundle_btn`)\n\n**位置**：\n- `components/dialogs/image_detail_dialog.py` (第 142-152 行)\n- `components/dialogs/video_detail_dialog.py` (第 294-304 行)\n\n**功能说明**：\n导出**整个记录包**（包括生成的图片/视频 + 所有相关的参考图）为 ZIP 文件。\n\n**调用链路**：\n```\nexport_bundle_btn.clicked \n  ↓\nExportBundleController._on_clicked() \n  ↓\nrepo.export_generation_bundle([record_id], record_type='image'|'video', destination_dir)\n```\n\n**实现文件**：\n`components/controllers/export_bundle_controller.py`\n\n**导出内容**：\n- 主文件（生成的图片或视频）\n- 参考图列表（如果有）\n- 元数据和生成参数\n\n**成功/失败消息显示**（第 233-307 行）：\n- **成功**：显示 `QMessageBox.information()` 包含：\n  - Zip 文件名\n  - 目录提示\n  - 参考图数量和 ID\n  - 部分缺失详情（如有）\n  \n- **失败**：显示 `QMessageBox.critical()` 或 `warning()`\n  - 权限错误、缺失文件等详细信息\n  - 在 status_label 显示\"导出失败\"\n\n---\n\n#### B. \"导出选中参考图\" 按钮 (`reference_export_btn`)\n\n**位置**：\n- `components/dialogs/image_detail_dialog.py` (第 136-140 行)\n- `components/dialogs/video_detail_dialog.py` (第 288-292 行)\n\n**功能说明**：\n导出**单个选中的参考图**为独立文件（PNG/JPG/WEBP 等）。\n\n**调用链路**：\n```\nreference_export_btn.clicked \n  ↓\n_export_selected_reference() \n  ↓\nexport_reference_asset(parent, asset)\n```\n\n**实现文件**：\n`components/reference_assets/actions.py` (第 203-248 行)\n\n**具体逻辑**：\n1. 使用 `QFileDialog.getSaveFileName()` 弹出保存对话框\n2. 复制参考图文件到用户选择位置\n3. 显示成功/失败消息\n\n**成功/失败消息显示**（第 203-248 行）：\n- **成功**：`QMessageBox.information()` 显示 `\"已导出到目录: {dest_dir}\"`\n- **失败**：`QMessageBox.critical()` 显示 `\"导出失败：{exception_message}\"`\n- 日志记录：`logger.info()` 和 `logger.warning()`\n\n---\n\n### 2. ExportBundleController 详解\n\n**文件**：`components/controllers/export_bundle_controller.py`\n\n**导出内容**（第 206-213 行）：\n```python\nrepo.export_generation_bundle(\n    [record_id],\n    record_type=self._record_type,  # 'image' 或 'video'\n    destination_dir=dest_dir\n)\n```\n\n**返回结果结构**（第 233-307 行）：\n```python\nresult = {\n    \"destination_zip\": str,           # ZIP 文件路径\n    \"reference_ids\": List[str],       # 参考图 ID 列表\n    \"reference_count\": int,            # 参考图数量\n    \"status\": str,                     # 'success' 或其他状态\n    \"missing_records\": List,           # 缺失的记录\n    \"missing_main_files\": List,        # 缺失的主文件\n    \"missing_references\": List,        # 缺失的参考图\n}\n```\n\n**消息提示实现**（第 156-169 行）：\n- 首先尝试调用 `self._owner.show_styled_message(title, message, icon_type)`\n- 如果不存在，使用 `QMessageBox()` 显示\n\n**状态标签更新**（第 136-154 行）：\n- 导出中：显示 \"导出中…\"，按钮禁用\n- 成功：显示 \"导出成功\" 或 \"导出完成（部分缺失：...）\"\n- 失败：显示 \"导出失败\"\n\n---\n\n### 3. export_reference_asset 函数详解\n\n**文件**：`components/reference_assets/actions.py` (第 203-248 行)\n\n**核心功能**：\n```python\ndef export_reference_asset(parent: QWidget, asset: Dict[str, Any]) -> Optional[str]:\n    # 1. 解析参考图路径\n    path = resolve_asset_path(asset)\n    \n    # 2. 建议文件名（优先使用 asset['id']）\n    base_name = asset.get('id') or src_path.stem\n    \n    # 3. 弹出保存对话框\n    dest_path, _ = QFileDialog.getSaveFileName(...)\n    \n    # 4. 复制文件\n    shutil.copyfile(str(src_path), dest_path)\n    \n    # 5. 日志记录\n    logger.info(f\"reference_export|count=1 ids={masked} dest={dest_dir_name}\")\n```\n\n**消息显示**（第 203-248 行）：\n- **不可用**：`QMessageBox.warning()` - \"参考图暂不可用\"\n- **成功**：`QMessageBox.information()` - `\"已导出到目录: {dest_dir}\"`\n- **复制失败**：`QMessageBox.critical()` - `\"导出失败：{exc}\"`\n\n---\n\n### 4. 右键菜单导出功能\n\n**位置**：`components/reference_assets/gallery.py` (第 296-309 行)\n\n**实现**：\n```python\ndef contextMenuEvent(self, event):\n    # ... 检查点击位置是否有项目 ...\n    menu = QMenu(self)\n    export_action = QAction(\"导出参考图\", self)\n    export_action.triggered.connect(lambda: self.exportRequested.emit(asset))\n    menu.addAction(export_action)\n    menu.exec(event.globalPos())\n```\n\n**信号链**：\n```\ngallery.contextMenuEvent (右键点击)\n  ↓\nexportRequested.emit(asset)\n  ↓\nimage_detail_dialog._on_reference_export(asset)\n  ↓\nexport_reference_asset(self, asset)\n```\n\n**启用条件**（第 503-507 行 in image_detail_dialog.py）：\n- 当选中参考图时，`reference_export_btn` 启用\n- 也可以通过右键菜单快速导出\n\n---\n\n### 5. 功能重复分析\n\n| 功能 | 位置 | 导出内容 | 触发方式 |\n|------|------|--------|--------|\n| **导出记录** | 详情对话框按钮 | 整个记录 ZIP（含参考图） | 按钮点击 |\n| **导出参考图（按钮）** | 详情对话框按钮 | 单个参考图 | 按钮点击 |\n| **导出参考图（菜单）** | 参考图右键菜单 | 单个参考图 | 右键菜单 |\n\n### 重复分析：\n**轻度重复**存在，但有明确的用途区分：\n\n1. **\"导出参考图\"有两个入口**：\n   - `reference_export_btn`（需先选中参考图）\n   - 右键菜单（更便捷，无需额外操作）\n   - **作用相同**：都调用 `export_reference_asset()` 导出单个参考图\n\n2. **\"导出记录\"是独立功能**：\n   - 导出完整记录包（ZIP）\n   - 包含主文件 + 所有参考图\n   - 与参考图导出互补\n\n---\n\n### 建议\n\n1. **消除参考图导出重复**：\n   - 保留右键菜单入口（更符合用户直觉）\n   - 考虑移除按钮入口，或改为\"批量导出参考图\"\n\n2. **改进消息一致性**：\n   - 所有消息应通过统一的 `show_styled_message()` 显示\n   - 目前 `export_reference_asset()` 直接用 `QMessageBox`，不使用 `show_styled_message()`\n\n3. **增强导出功能**：\n   - 参考图导出支持批量选择\n   - 记录导出支持选择性导出（仅参考图或仅主文件）"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1222,"cache_read_input_tokens":70539,"cache_creation":{"ephemeral_5m_input_tokens":1222,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"d2ea9dfb-1245-489b-a32a-4a0bf575446d","timestamp":"2025-12-22T06:09:20.424Z"}
