{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":"基于以下背景,设计一个支持多模型提供商接入的架构方案:\n\n## 背景信息\n\n### 当前架构状况\n\n**目录结构**:\n```\nmodules/\n├── seedream/         # 火山引擎图像生成 (Client + Manager)\n├── seedance/         # 火山引擎视频生成 (Client + Manager)\n└── provider/         # 参数映射抽象层 (base.py, volc.py, volc_v4.py, volc_v4_5.py)\n\nservices/\n├── image_service.py  # 图像生成业务逻辑\n└── video_service.py  # 视频生成业务逻辑\n\ncomponents/modes/\n├── image_mode_widget.py  # 图像生成 UI\n└── video_mode_widget.py  # 视频生成 UI\n```\n\n**调用链路**:\n```\nUI → GenerationTaskManager → ImageService/VideoService → SeedreamManager/SeedanceManager → SeedreamClient/SeedanceClient → API\n```\n\n**当前 Provider 抽象**:\n- BaseProvider 定义接口: map_t2i(), map_i2i(), map_video()\n- Provider 只做参数映射,不执行 HTTP 调用\n- HTTP 调用仍在 Client 内,Client 需要为每个 Provider 添加特殊逻辑\n\n**数据库设计**:\n- generations 表存储生成记录\n- model 字段存储模型 ID (如 \"doubao-seedream-4-5-251128\")\n- parameters 字段为 JSON,存储所有生成参数\n- **缺少** vendor 字段\n\n### 发现的问题\n\n1. **强耦合点**:\n   - 模型 ID 硬编码 (doubao-* 前缀)\n   - API 端点路径绑定火山引擎\n   - 参数结构与火山引擎绑定\n   - Provider 机制不完整 (只做映射,HTTP 仍在 Client)\n\n2. **架构优势**:\n   - 服务层与模型实现分离良好\n   - 已有 Provider 抽象层基础\n   - 数据库参数存储灵活 (JSON)\n   - 工厂模式注入,便于测试\n\n3. **接入难度评估** (当前架构):\n   - 替换难度: 9/10 (极难)\n   - 需改动: 500+ 行代码 + 50+ 处条件分支\n\n### 用户需求\n\n1. 未来可能接入多家模型提供商 (OpenAI, Stability AI, Midjourney 等)\n2. 降低接入新模型的难度\n3. 是否需要统一脚手架?\n4. 是否独立调用模块?\n5. 数据库结构是否需要改?\n\n## 设计任务\n\n请设计一个支持多模型提供商的架构方案,包括:\n\n1. **目录结构重构建议**\n   - 如何组织不同提供商的代码\n   - 是否需要独立模块\n   - 脚手架的位置和作用\n\n2. **抽象层设计**\n   - Provider 接口如何改进\n   - 是否 Provider 应该负责完整的 HTTP 调用\n   - 如何标准化参数和响应\n\n3. **数据库改进方案**\n   - 是否添加 vendor 字段\n   - 如何存储厂商特定参数\n   - 模型标识体系如何设计\n\n4. **配置管理**\n   - 如何管理不同厂商的 API Key\n   - 如何管理模型列表和别名映射\n\n5. **实施路径**\n   - 分几个阶段实施\n   - 每个阶段的改动范围\n   - 如何保持向后兼容\n\n6. **新模型接入流程**\n   - 接入新提供商需要几个步骤\n   - 每个步骤需要创建/修改哪些文件\n   - 预期代码量\n\n请提供详细的设计方案,包括关键代码示例和文件结构。"},"uuid":"47580f48-18ca-494d-83ea-13b5fa0c1a48","timestamp":"2026-01-05T11:53:29.856Z"}
{"parentUuid":"47580f48-18ca-494d-83ea-13b5fa0c1a48","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FmXkhLCrDSA97AHp3bokSC","type":"message","role":"assistant","content":[{"type":"text","text":"我将深入探索当前架构，然后设计一个支持多模型提供商接入的完整方案。让我先全面了解现有代码结构。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":22468,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":22468,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"eb6e5ad0-a68b-47db-ab32-4cabb35bc653","timestamp":"2026-01-05T11:53:34.683Z"}
{"parentUuid":"eb6e5ad0-a68b-47db-ab32-4cabb35bc653","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FmXkhLCrDSA97AHp3bokSC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QGrc6m4jqxpAcuC9xNPCEz","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":22468,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":22468,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"eec73d25-2bfe-4777-b70a-87e2ea40cc6a","timestamp":"2026-01-05T11:53:35.569Z"}
{"parentUuid":"eec73d25-2bfe-4777-b70a-87e2ea40cc6a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FmXkhLCrDSA97AHp3bokSC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PKXRafKh3hHFzVoX5Ad5B3","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":22468,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":22468,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"57812ff9-9efa-4694-ab0f-3d3e31883e8f","timestamp":"2026-01-05T11:53:36.092Z"}
{"parentUuid":"57812ff9-9efa-4694-ab0f-3d3e31883e8f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FmXkhLCrDSA97AHp3bokSC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BxtM525jbVEdf5yrdTdwFi","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":22468,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":22468,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"72ccb9cf-6f7d-4332-805c-a87f148b369e","timestamp":"2026-01-05T11:53:36.619Z"}
{"parentUuid":"72ccb9cf-6f7d-4332-805c-a87f148b369e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FmXkhLCrDSA97AHp3bokSC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016Z1sQcPYxBJ8myKwnUE4Ze","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":22468,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":22468,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"5d490809-809d-4486-a9c9-4939170ff63f","timestamp":"2026-01-05T11:53:36.994Z"}
{"parentUuid":"5d490809-809d-4486-a9c9-4939170ff63f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FmXkhLCrDSA97AHp3bokSC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019tFzBbpxogGZrpvnYQpadh","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":22468,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":22468,"ephemeral_1h_input_tokens":0},"output_tokens":354,"service_tier":"standard"}},"type":"assistant","uuid":"1eef4aa4-42ae-4dac-a94a-a299162ed597","timestamp":"2026-01-05T11:53:37.416Z"}
{"parentUuid":"1eef4aa4-42ae-4dac-a94a-a299162ed597","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QGrc6m4jqxpAcuC9xNPCEz","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 抽象基类与工厂接口（轻量）。\n     5→\n     6→本阶段目标：仅提供参数映射（map_*）能力，实际 HTTP 调用仍由 Client 完成，降低侵入性。\n     7→\"\"\"\n     8→from typing import Dict, Any, Optional, Tuple\n     9→from .schema import (\n    10→    TextToImageParams, ImageToImageParams, VideoParams,\n    11→    validate_and_normalize_t2i, validate_and_normalize_i2i, validate_and_normalize_video\n    12→)\n    13→\n    14→\n    15→class BaseProvider:\n    16→    name: str = \"base\"\n    17→\n    18→    # 图片：文生图参数映射\n    19→    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    20→        raise NotImplementedError\n    21→\n    22→    # 图片：图生图参数映射\n    23→    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    24→        raise NotImplementedError\n    25→\n    26→    # 视频：参数映射（model+content+flags 摘要）\n    27→    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n    28→        raise NotImplementedError\n    29→\n    30→    # 统一的校验入口（可选）\n    31→    @staticmethod\n    32→    def validate_t2i(p: TextToImageParams):\n    33→        return validate_and_normalize_t2i(p)\n    34→\n    35→    @staticmethod\n    36→    def validate_i2i(p: ImageToImageParams):\n    37→        return validate_and_normalize_i2i(p)\n    38→\n    39→    @staticmethod\n    40→    def validate_video(p: VideoParams):\n    41→        return validate_and_normalize_video(p)\n    42→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"259b192c-3e76-42a0-ba90-eb5b0811c331","timestamp":"2026-01-05T11:53:37.472Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 抽象基类与工厂接口（轻量）。\n\n本阶段目标：仅提供参数映射（map_*）能力，实际 HTTP 调用仍由 Client 完成，降低侵入性。\n\"\"\"\nfrom typing import Dict, Any, Optional, Tuple\nfrom .schema import (\n    TextToImageParams, ImageToImageParams, VideoParams,\n    validate_and_normalize_t2i, validate_and_normalize_i2i, validate_and_normalize_video\n)\n\n\nclass BaseProvider:\n    name: str = \"base\"\n\n    # 图片：文生图参数映射\n    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        raise NotImplementedError\n\n    # 图片：图生图参数映射\n    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        raise NotImplementedError\n\n    # 视频：参数映射（model+content+flags 摘要）\n    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n        raise NotImplementedError\n\n    # 统一的校验入口（可选）\n    @staticmethod\n    def validate_t2i(p: TextToImageParams):\n        return validate_and_normalize_t2i(p)\n\n    @staticmethod\n    def validate_i2i(p: ImageToImageParams):\n        return validate_and_normalize_i2i(p)\n\n    @staticmethod\n    def validate_video(p: VideoParams):\n        return validate_and_normalize_video(p)\n","numLines":42,"startLine":1,"totalLines":42}}}
{"parentUuid":"259b192c-3e76-42a0-ba90-eb5b0811c331","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PKXRafKh3hHFzVoX5Ad5B3","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Volc (Ark) Provider 映射（最小实现）\n     5→\n     6→职责：将统一 Schema 归一化后的参数映射到当前 Ark v3 的请求载荷/文本 flag。\n     7→HTTP 请求仍在各自 Client 内执行。\n     8→\"\"\"\n     9→from typing import Dict, Any, Tuple\n    10→from .base import BaseProvider\n    11→from .schema import TextToImageParams, ImageToImageParams, VideoParams\n    12→try:\n    13→    # 复用现有模型 ID 定义，避免硬编码漂移\n    14→    from modules.seedance.config import SeedanceModels\n    15→except Exception:\n    16→    SeedanceModels = None\n    17→\n    18→\n    19→class VolcProvider(BaseProvider):\n    20→    name = \"volcengine\"\n    21→\n    22→    # Seedream 3.0/3.1 - 文生图\n    23→    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    24→        norm, fb, reason = self.validate_t2i(params)\n    25→        # 与当前实现保持一致：固定 watermark=False，response_format=url\n    26→        data = {\n    27→            \"model\": \"doubao-seedream-3-0-t2i-250415\",\n    28→            \"prompt\": norm.prompt,\n    29→            \"size\": norm.size,\n    30→            \"response_format\": \"url\",\n    31→            \"watermark\": False,\n    32→            \"guidance_scale\": norm.guidance_scale,\n    33→        }\n    34→        if norm.seed is not None:\n    35→            data[\"seed\"] = norm.seed\n    36→        return data, fb, reason, \"/images/generations\"\n    37→\n    38→    # Seedream 3.0/3.1 - 图生图\n    39→    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n    40→        norm, fb, reason = self.validate_i2i(params)\n    41→        data = {\n    42→            \"model\": \"doubao-seededit-3-0-i2i-250628\",\n    43→            \"prompt\": norm.prompt,\n    44→            \"image\": norm.image,\n    45→            \"size\": \"adaptive\",\n    46→            \"response_format\": \"url\",\n    47→            \"watermark\": False,\n    48→            \"guidance_scale\": norm.guidance_scale,\n    49→        }\n    50→        if norm.seed is not None:\n    51→            data[\"seed\"] = norm.seed\n    52→        return data, fb, reason, \"/images/generations\"\n    53→\n    54→    # Seedance pro/pro_fast/lite - 视频\n    55→    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n    56→        norm, fb, reason, used_rs, used_rt = self.validate_video(params)\n    57→\n    58→        # Seedance 1.5 Pro：独立模型，支持有声视频；不支持参考图模式\n    59→        if (norm.model_variant or \"\").strip().lower() == \"seedance_1_5_pro\":\n    60→            if norm.reference_images:\n    61→                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n    62→\n    63→            model = (\n    64→                SeedanceModels.PRO_1_5.value\n    65→                if SeedanceModels\n    66→                else \"doubao-seedance-1-5-pro-251215\"\n    67→            )\n    68→\n    69→            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n    70→            if has_first_last_frame:\n    71→                mode = \"首尾帧视频(1.5 Pro)\"\n    72→            elif norm.image_path:\n    73→                mode = \"图生视频(1.5 Pro)\"\n    74→            else:\n    75→                mode = \"文生视频(1.5 Pro)\"\n    76→        else:\n    77→            # 解析 model_type（优先级高于 use_pro_model）\n    78→            effective_model_type = norm.model_type\n    79→            if not effective_model_type:\n    80→                effective_model_type = \"pro\" if norm.use_pro_model else \"lite\"\n    81→\n    82→            # Pro-fast 不支持首尾帧模式\n    83→            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n    84→            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n    85→                effective_model_type = \"pro\"  # 自动回退\n    86→\n    87→            # 模型选择逻辑\n    88→            if has_first_last_frame:\n    89→                # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面回退）\n    90→                if effective_model_type in (\"pro\", \"pro_fast\"):\n    91→                    model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n    92→                    mode = \"首尾帧视频(Pro)\"\n    93→                else:\n    94→                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n    95→                    mode = \"首尾帧视频(Lite)\"\n    96→            elif effective_model_type == \"pro_fast\":\n    97→                model = SeedanceModels.PRO_FAST.value if SeedanceModels else \"doubao-seedance-1-0-pro-fast-251015\"\n    98→                mode = \"图生视频(Pro-fast)\" if norm.image_path else \"文生视频(Pro-fast)\"\n    99→            elif effective_model_type == \"pro\":\n   100→                model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n   101→                mode = \"图生视频(Pro)\" if norm.image_path else \"文生视频(Pro)\"\n   102→            else:\n   103→                # Lite 模式：检查 image_path 或 reference_images\n   104→                if norm.image_path or norm.reference_images:\n   105→                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n   106→                    if norm.image_path:\n   107→                        mode = \"图生视频(Lite)\"\n   108→                    else:\n   109→                        mode = f\"参考图视频(Lite, {len(norm.reference_images[:4])}张)\"\n   110→                else:\n   111→                    model = SeedanceModels.LITE_T2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-t2v-250428\"\n   112→                    mode = \"文生视频(Lite)\"\n   113→\n   114→        # 参考图场景（所有模型）不支持 1080p，强制降级到 720p\n   115→        has_reference_images = bool(norm.reference_images)\n   116→        if has_reference_images and used_rs == \"1080p\":\n   117→            used_rs = \"720p\"\n   118→            fb = True\n   119→            reason = (reason + \"; \" if reason else \"\") + \"参考图模式不支持1080p，已降级到720p\"\n   120→\n   121→        # 文本 flags（与客户端 _validate_and_build_flags 顺序对齐）\n   122→        parts = [\n   123→            \"--rs\", used_rs,\n   124→            \"--rt\", used_rt,\n   125→            \"--dur\", str(norm.duration),\n   126→            \"--fps\", str(norm.fps),\n   127→            \"--wm\", str(bool(norm.watermark)).lower(),\n   128→        ]\n   129→        if norm.seed is not None:\n   130→            parts += [\"--seed\", str(norm.seed)]\n   131→        parts += [\"--cf\", str(bool(norm.camera_fixed)).lower()]\n   132→        flags_text = \" \".join(parts)\n   133→\n   134→        content = []\n   135→        if norm.first_frame_path and norm.last_frame_path:\n   136→            content.append({\n   137→                \"type\": \"image_url\",\n   138→                \"image_url\": {\"url\": norm.first_frame_path},\n   139→                \"role\": \"first_frame\"\n   140→            })\n   141→            content.append({\n   142→                \"type\": \"image_url\",\n   143→                \"image_url\": {\"url\": norm.last_frame_path},\n   144→                \"role\": \"last_frame\"\n   145→            })\n   146→        elif norm.image_path:\n   147→            content.append({\n   148→                \"type\": \"image_url\",\n   149→                \"image_url\": {\"url\": norm.image_path},\n   150→                \"role\": \"first_frame\"\n   151→            })\n   152→\n   153→        # 参考图支持（仅 Lite-i2v 模型）\n   154→        if norm.reference_images and effective_model_type == \"lite\":\n   155→            for ref_img in norm.reference_images[:4]:  # 最多4张\n   156→                ref_data = ref_img.get('path') if isinstance(ref_img, dict) else ref_img\n   157→                if ref_data:\n   158→                    # 为裸 base64 添加 data URL 前缀\n   159→                    mime = \"image/jpeg\" if ref_data.startswith('/9j/') else \"image/png\"\n   160→                    url = f\"data:{mime};base64,{ref_data}\"\n   161→                    content.append({\n   162→                        \"type\": \"image_url\",\n   163→                        \"image_url\": {\"url\": url},\n   164→                        \"role\": \"reference_image\"\n   165→                    })\n   166→\n   167→        text_prompt = f\"{norm.prompt} {flags_text}\".strip()\n   168→        content.append({\"type\": \"text\", \"text\": text_prompt})\n   169→\n   170→        mapped = {\n   171→            \"model\": model,\n   172→            \"content\": content,\n   173→            \"mode\": mode,\n   174→            \"flags_text\": flags_text,\n   175→        }\n   176→        return mapped, fb, reason, used_rs, used_rt\n   177→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cf25a03c-0173-4e1a-bf99-c10546818ccc","timestamp":"2026-01-05T11:53:37.472Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/volc.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVolc (Ark) Provider 映射（最小实现）\n\n职责：将统一 Schema 归一化后的参数映射到当前 Ark v3 的请求载荷/文本 flag。\nHTTP 请求仍在各自 Client 内执行。\n\"\"\"\nfrom typing import Dict, Any, Tuple\nfrom .base import BaseProvider\nfrom .schema import TextToImageParams, ImageToImageParams, VideoParams\ntry:\n    # 复用现有模型 ID 定义，避免硬编码漂移\n    from modules.seedance.config import SeedanceModels\nexcept Exception:\n    SeedanceModels = None\n\n\nclass VolcProvider(BaseProvider):\n    name = \"volcengine\"\n\n    # Seedream 3.0/3.1 - 文生图\n    def map_t2i(self, params: TextToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_t2i(params)\n        # 与当前实现保持一致：固定 watermark=False，response_format=url\n        data = {\n            \"model\": \"doubao-seedream-3-0-t2i-250415\",\n            \"prompt\": norm.prompt,\n            \"size\": norm.size,\n            \"response_format\": \"url\",\n            \"watermark\": False,\n            \"guidance_scale\": norm.guidance_scale,\n        }\n        if norm.seed is not None:\n            data[\"seed\"] = norm.seed\n        return data, fb, reason, \"/images/generations\"\n\n    # Seedream 3.0/3.1 - 图生图\n    def map_i2i(self, params: ImageToImageParams) -> Tuple[Dict[str, Any], bool, str, str]:\n        norm, fb, reason = self.validate_i2i(params)\n        data = {\n            \"model\": \"doubao-seededit-3-0-i2i-250628\",\n            \"prompt\": norm.prompt,\n            \"image\": norm.image,\n            \"size\": \"adaptive\",\n            \"response_format\": \"url\",\n            \"watermark\": False,\n            \"guidance_scale\": norm.guidance_scale,\n        }\n        if norm.seed is not None:\n            data[\"seed\"] = norm.seed\n        return data, fb, reason, \"/images/generations\"\n\n    # Seedance pro/pro_fast/lite - 视频\n    def map_video(self, params: VideoParams) -> Tuple[Dict[str, Any], bool, str, str, str]:\n        norm, fb, reason, used_rs, used_rt = self.validate_video(params)\n\n        # Seedance 1.5 Pro：独立模型，支持有声视频；不支持参考图模式\n        if (norm.model_variant or \"\").strip().lower() == \"seedance_1_5_pro\":\n            if norm.reference_images:\n                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n            model = (\n                SeedanceModels.PRO_1_5.value\n                if SeedanceModels\n                else \"doubao-seedance-1-5-pro-251215\"\n            )\n\n            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n            if has_first_last_frame:\n                mode = \"首尾帧视频(1.5 Pro)\"\n            elif norm.image_path:\n                mode = \"图生视频(1.5 Pro)\"\n            else:\n                mode = \"文生视频(1.5 Pro)\"\n        else:\n            # 解析 model_type（优先级高于 use_pro_model）\n            effective_model_type = norm.model_type\n            if not effective_model_type:\n                effective_model_type = \"pro\" if norm.use_pro_model else \"lite\"\n\n            # Pro-fast 不支持首尾帧模式\n            has_first_last_frame = bool(norm.first_frame_path and norm.last_frame_path)\n            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n                effective_model_type = \"pro\"  # 自动回退\n\n            # 模型选择逻辑\n            if has_first_last_frame:\n                # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面回退）\n                if effective_model_type in (\"pro\", \"pro_fast\"):\n                    model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n                    mode = \"首尾帧视频(Pro)\"\n                else:\n                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n                    mode = \"首尾帧视频(Lite)\"\n            elif effective_model_type == \"pro_fast\":\n                model = SeedanceModels.PRO_FAST.value if SeedanceModels else \"doubao-seedance-1-0-pro-fast-251015\"\n                mode = \"图生视频(Pro-fast)\" if norm.image_path else \"文生视频(Pro-fast)\"\n            elif effective_model_type == \"pro\":\n                model = SeedanceModels.PRO.value if SeedanceModels else \"doubao-seedance-1-0-pro-250528\"\n                mode = \"图生视频(Pro)\" if norm.image_path else \"文生视频(Pro)\"\n            else:\n                # Lite 模式：检查 image_path 或 reference_images\n                if norm.image_path or norm.reference_images:\n                    model = SeedanceModels.LITE_I2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-i2v-250428\"\n                    if norm.image_path:\n                        mode = \"图生视频(Lite)\"\n                    else:\n                        mode = f\"参考图视频(Lite, {len(norm.reference_images[:4])}张)\"\n                else:\n                    model = SeedanceModels.LITE_T2V.value if SeedanceModels else \"doubao-seedance-1-0-lite-t2v-250428\"\n                    mode = \"文生视频(Lite)\"\n\n        # 参考图场景（所有模型）不支持 1080p，强制降级到 720p\n        has_reference_images = bool(norm.reference_images)\n        if has_reference_images and used_rs == \"1080p\":\n            used_rs = \"720p\"\n            fb = True\n            reason = (reason + \"; \" if reason else \"\") + \"参考图模式不支持1080p，已降级到720p\"\n\n        # 文本 flags（与客户端 _validate_and_build_flags 顺序对齐）\n        parts = [\n            \"--rs\", used_rs,\n            \"--rt\", used_rt,\n            \"--dur\", str(norm.duration),\n            \"--fps\", str(norm.fps),\n            \"--wm\", str(bool(norm.watermark)).lower(),\n        ]\n        if norm.seed is not None:\n            parts += [\"--seed\", str(norm.seed)]\n        parts += [\"--cf\", str(bool(norm.camera_fixed)).lower()]\n        flags_text = \" \".join(parts)\n\n        content = []\n        if norm.first_frame_path and norm.last_frame_path:\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.first_frame_path},\n                \"role\": \"first_frame\"\n            })\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.last_frame_path},\n                \"role\": \"last_frame\"\n            })\n        elif norm.image_path:\n            content.append({\n                \"type\": \"image_url\",\n                \"image_url\": {\"url\": norm.image_path},\n                \"role\": \"first_frame\"\n            })\n\n        # 参考图支持（仅 Lite-i2v 模型）\n        if norm.reference_images and effective_model_type == \"lite\":\n            for ref_img in norm.reference_images[:4]:  # 最多4张\n                ref_data = ref_img.get('path') if isinstance(ref_img, dict) else ref_img\n                if ref_data:\n                    # 为裸 base64 添加 data URL 前缀\n                    mime = \"image/jpeg\" if ref_data.startswith('/9j/') else \"image/png\"\n                    url = f\"data:{mime};base64,{ref_data}\"\n                    content.append({\n                        \"type\": \"image_url\",\n                        \"image_url\": {\"url\": url},\n                        \"role\": \"reference_image\"\n                    })\n\n        text_prompt = f\"{norm.prompt} {flags_text}\".strip()\n        content.append({\"type\": \"text\", \"text\": text_prompt})\n\n        mapped = {\n            \"model\": model,\n            \"content\": content,\n            \"mode\": mode,\n            \"flags_text\": flags_text,\n        }\n        return mapped, fb, reason, used_rs, used_rt\n","numLines":177,"startLine":1,"totalLines":177}}}
{"parentUuid":"cf25a03c-0173-4e1a-bf99-c10546818ccc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019tFzBbpxogGZrpvnYQpadh","type":"tool_result","content":"     1→\"\"\"Seedream image generation service layer.\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import uuid\n     6→from typing import Any, Callable, Dict, List, Optional\n     7→\n     8→from config.unified_config import get_unified_config\n     9→from modules.repository.manager import RepositoryManager\n    10→from modules.seedream.manager import SeedreamManager\n    11→from modules.storage import get_v2_storage_manager\n    12→from utils.logger import logger\n    13→\n    14→ProgressCallback = Optional[Callable[[Optional[float], str], None]]\n    15→CancelCallback = Optional[Callable[[], bool]]\n    16→\n    17→\n    18→class ImageService:\n    19→    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n    20→\n    21→    def __init__(\n    22→        self,\n    23→        storage_manager=None,\n    24→        repository_manager: Optional[RepositoryManager] = None,\n    25→        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    26→    ) -> None:\n    27→        # Use unified config for storage path and API validation\n    28→        self.unified_config = get_unified_config()\n    29→\n    30→        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n    31→        self.repository_manager = repository_manager\n    32→        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n    33→\n    34→    # ------------------------------------------------------------------\n    35→    # Public API\n    36→    # ------------------------------------------------------------------\n    37→    def generate_image(\n    38→        self,\n    39→        params: Dict[str, Any],\n    40→        progress_callback: ProgressCallback = None,\n    41→        should_cancel: CancelCallback = None,\n    42→    ) -> Dict[str, Any]:\n    43→        prompt = (params.get(\"prompt\") or \"\").strip()\n    44→        if not prompt:\n    45→            return self._failure(\"Prompt cannot be empty\")\n    46→\n    47→        if self._is_cancelled(should_cancel):\n    48→            return self._cancelled()\n    49→\n    50→        self._emit_progress(progress_callback, \"Preparing...\")\n    51→\n    52→        try:\n    53→            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n    54→            if not is_valid:\n    55→                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n    56→                detail = message or \"API key not configured\"\n    57→                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n    58→        except Exception as cfg_err:\n    59→            return self._failure(f\"Config validation failed: {cfg_err}\")\n    60→\n    61→        try:\n    62→            api_key = self.unified_config.get_api_key(\"volcengine\")\n    63→        except Exception as key_err:\n    64→            return self._failure(f\"Failed to load API key: {key_err}\")\n    65→\n    66→        if self._is_cancelled(should_cancel):\n    67→            return self._cancelled()\n    68→\n    69→        try:\n    70→            seedream_manager = self._seedream_manager_factory(api_key)\n    71→            self._emit_progress(progress_callback, \"Seedream manager ready\")\n    72→        except Exception as init_err:\n    73→            logger.error(f\"Seedream manager init failed: {init_err}\")\n    74→            return self._failure(f\"Seedream manager init failed: {init_err}\")\n    75→\n    76→        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n    77→        reference_images = params.get(\"reference_images\") or []\n    78→        input_image_path = (\n    79→            params.get(\"input_image_path\")\n    80→            or params.get(\"input_image\")\n    81→            or params.get(\"image_path\")\n    82→            or params.get(\"image\")\n    83→        )\n    84→        base_size = params.get(\"size\", \"1024x1024\")\n    85→        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n    86→        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n    87→        model_variant = params.get(\"model_variant\")\n    88→        generation_id = params.get(\"generation_id\")\n    89→        derived_ids: List[str] = params.get(\"derived_ids\") or []\n    90→        sequential_mode = bool(params.get(\"sequential_mode\", False))\n    91→\n    92→        try:\n    93→            if generation_count == 1:\n    94→                result = self._generate_single(\n    95→                    seedream_manager=seedream_manager,\n    96→                    prompt=prompt,\n    97→                    size=base_size,\n    98→                    guidance_scale=guidance_scale,\n    99→                    seed=seed,\n   100→                    model_variant=model_variant,\n   101→                    input_image_path=input_image_path,\n   102→                    reference_images=reference_images,\n   103→                    generation_id=generation_id,\n   104→                    sequential_mode=sequential_mode,\n   105→                    progress_callback=progress_callback,\n   106→                    should_cancel=should_cancel,\n   107→                )\n   108→            else:\n   109→                result = self._generate_batch(\n   110→                    seedream_manager=seedream_manager,\n   111→                    prompt=prompt,\n   112→                    count=generation_count,\n   113→                    size=base_size,\n   114→                    guidance_scale=guidance_scale,\n   115→                    seed=seed,\n   116→                    input_image_path=input_image_path,\n   117→                    reference_images=reference_images,\n   118→                    model_variant=model_variant,\n   119→                    generation_id=generation_id,\n   120→                    derived_ids=derived_ids,\n   121→                    sequential_mode=sequential_mode,\n   122→                    progress_callback=progress_callback,\n   123→                    should_cancel=should_cancel,\n   124→                )\n   125→        except Exception as api_error:\n   126→            logger.error(f\"Seedream API error: {api_error}\")\n   127→            return self._failure(f\"API error: {api_error}\")\n   128→\n   129→        if self._is_cancelled(should_cancel):\n   130→            return self._cancelled()\n   131→\n   132→        if result.get(\"success\"):\n   133→            summary = \"Generation completed\"\n   134→            if generation_count > 1:\n   135→                success_count = result.get(\"success_count\", 0)\n   136→                summary = f\"Batch completed {success_count}/{result.get('total_count', generation_count)}\"\n   137→            self._emit_progress(progress_callback, summary, percentage=100.0)\n   138→            self._persist_metadata(result)\n   139→        else:\n   140→            error_msg = result.get(\"error\", \"unknown error\")\n   141→            self._emit_progress(progress_callback, f\"Generation failed: {error_msg}\")\n   142→\n   143→        return result\n   144→\n   145→    # ------------------------------------------------------------------\n   146→    # Internal helpers\n   147→    # ------------------------------------------------------------------\n   148→    def _generate_single(\n   149→        self,\n   150→        *,\n   151→        seedream_manager: SeedreamManager,\n   152→        prompt: str,\n   153→        size: str,\n   154→        guidance_scale: float,\n   155→        seed: int,\n   156→        model_variant: Optional[str],\n   157→        input_image_path: Optional[str],\n   158→        reference_images: List[Dict[str, Any]],\n   159→        generation_id: Optional[str],\n   160→        sequential_mode: bool,\n   161→        progress_callback: ProgressCallback,\n   162→        should_cancel: CancelCallback,\n   163→    ) -> Dict[str, Any]:\n   164→        if self._is_cancelled(should_cancel):\n   165→            return self._cancelled()\n   166→\n   167→        if input_image_path:\n   168→            self._emit_progress(progress_callback, \"Generating image-to-image...\")\n   169→            return seedream_manager.generate_image_to_image(\n   170→                prompt=prompt,\n   171→                image=input_image_path,\n   172→                guidance_scale=guidance_scale,\n   173→                seed=seed,\n   174→                save_local=True,\n   175→                reference_images=reference_images or None,\n   176→                generation_id=generation_id,\n   177→            )\n   178→\n   179→        self._emit_progress(progress_callback, \"Generating text-to-image...\")\n   180→        return seedream_manager.generate_text_to_image(\n   181→            prompt=prompt,\n   182→            size=size,\n   183→            guidance_scale=guidance_scale,\n   184→            seed=seed,\n   185→            save_local=True,\n   186→            reference_images=reference_images or None,\n   187→            model_variant=model_variant,\n   188→            generation_id=generation_id,\n   189→            sequential_mode=sequential_mode,\n   190→        )\n   191→\n   192→    def _generate_batch(\n   193→        self,\n   194→        *,\n   195→        seedream_manager: SeedreamManager,\n   196→        prompt: str,\n   197→        count: int,\n   198→        size: str,\n   199→        guidance_scale: float,\n   200→        seed: int,\n   201→        input_image_path: Optional[str],\n   202→        reference_images: List[Dict[str, Any]],\n   203→        model_variant: Optional[str],\n   204→        generation_id: Optional[str],\n   205→        derived_ids: List[str],\n   206→        sequential_mode: bool,\n   207→        progress_callback: ProgressCallback,\n   208→        should_cancel: CancelCallback,\n   209→    ) -> Dict[str, Any]:\n   210→        if self._is_cancelled(should_cancel):\n   211→            return self._cancelled()\n   212→\n   213→        slots = max(1, count)\n   214→        per_image_ids: List[str] = list(derived_ids or [])\n   215→        if len(per_image_ids) < slots:\n   216→            base = generation_id or f\"batch_{uuid.uuid4().hex}\"\n   217→            for idx in range(len(per_image_ids), slots):\n   218→                per_image_ids.append(f\"{base}_{idx + 1}\")\n   219→        per_image_ids = per_image_ids[:slots]\n   220→\n   221→        if reference_images:\n   222→            self._emit_progress(progress_callback, \"Detected reference images; switching to sequential mode...\")\n   223→            aggregated: List[Dict[str, Any]] = []\n   224→            success_count = 0\n   225→            for idx in range(count):\n   226→                if self._is_cancelled(should_cancel):\n   227→                    return self._cancelled()\n   228→                per_id = per_image_ids[idx] if idx < len(per_image_ids) else None\n   229→                if input_image_path:\n   230→                    single_result = seedream_manager.generate_image_to_image(\n   231→                        prompt=prompt,\n   232→                        image=input_image_path,\n   233→                        guidance_scale=guidance_scale,\n   234→                        seed=seed,\n   235→                        save_local=True,\n   236→                        reference_images=reference_images or None,\n   237→                        generation_id=per_id or generation_id,\n   238→                    )\n   239→                else:\n   240→                    single_result = seedream_manager.generate_text_to_image(\n   241→                        prompt=prompt,\n   242→                        size=size,\n   243→                        guidance_scale=guidance_scale,\n   244→                        seed=seed,\n   245→                        save_local=True,\n   246→                        reference_images=reference_images or None,\n   247→                        model_variant=model_variant,\n   248→                        generation_id=per_id or generation_id,\n   249→                    )\n   250→                if per_id:\n   251→                    single_result[\"generation_id\"] = per_id\n   252→                    single_result[\"task_id\"] = per_id\n   253→                    single_result[\"file_id\"] = per_id\n   254→                single_result[\"task_index\"] = idx + 1\n   255→                aggregated.append(single_result)\n   256→                if single_result.get(\"success\"):\n   257→                    success_count += 1\n   258→                pct = ((idx + 1) / count) * 100.0\n   259→                self._emit_progress(progress_callback, f\"Generating {idx + 1}/{count}...\", pct)\n   260→\n   261→            sanitized_refs = self._pick_reference_assets(aggregated)\n   262→            return {\n   263→                \"success\": success_count == count,\n   264→                \"total_count\": count,\n   265→                \"success_count\": success_count,\n   266→                \"derived_ids\": per_image_ids,\n   267→                \"results\": aggregated,\n   268→                \"reference_assets\": sanitized_refs,\n   269→            }\n   270→\n   271→        if input_image_path:\n   272→            self._emit_progress(progress_callback, f\"Generating {count} image-to-image in parallel...\")\n   273→\n   274→            def manager_progress(completed: int, total: int, _result: Dict[str, Any]) -> None:\n   275→                pct = (completed / total) * 100 if total else None\n   276→                self._emit_progress(progress_callback, f\"Generating {completed}/{total}...\", pct)\n   277→\n   278→            return seedream_manager.concurrent_generate_image_to_image(\n   279→                prompt=prompt,\n   280→                image=input_image_path,\n   281→                count=count,\n   282→                guidance_scale=guidance_scale,\n   283→                seed=seed,\n   284→                save_local=True,\n   285→                derived_ids=per_image_ids,\n   286→                generation_id=generation_id,\n   287→                progress_callback=manager_progress,\n   288→            )\n   289→\n   290→        self._emit_progress(progress_callback, f\"Generating {count} text-to-image in parallel...\")\n   291→\n   292→        def manager_progress(completed: int, total: int, _result: Dict[str, Any]) -> None:\n   293→            pct = (completed / total) * 100 if total else None\n   294→            self._emit_progress(progress_callback, f\"Generating {completed}/{total}...\", pct)\n   295→\n   296→        return seedream_manager.concurrent_generate_text_to_image(\n   297→            prompt=prompt,\n   298→            count=count,\n   299→            size=size,\n   300→            guidance_scale=guidance_scale,\n   301→            seed=seed,\n   302→            save_local=True,\n   303→            derived_ids=per_image_ids,\n   304→            generation_id=generation_id,\n   305→            progress_callback=manager_progress,\n   306→            model_variant=model_variant,\n   307→            sequential_mode=sequential_mode,\n   308→        )\n   309→\n   310→    def _persist_metadata(self, result: Dict[str, Any]) -> None:\n   311→        if not self.repository_manager:\n   312→            return\n   313→\n   314→        try:\n   315→            file_id = (\n   316→                result.get(\"file_id\")\n   317→                or result.get(\"generation_id\")\n   318→                or result.get(\"task_id\")\n   319→                or result.get(\"batch_id\")\n   320→            )\n   321→            metadata = (\n   322→                result.get(\"metadata\")\n   323→                or result.get(\"parameters\")\n   324→                or {\"prompt\": result.get(\"prompt\", \"\")}\n   325→            )\n   326→            if not file_id:\n   327→                return\n   328→            self.repository_manager.add_content(str(file_id), \"image\", metadata)\n   329→        except Exception as exc:\n   330→            logger.debug(f\"Persist generation metadata failed: {exc}\")\n   331→\n   332→    # ------------------------------------------------------------------\n   333→    # Utility helpers\n   334→    # ------------------------------------------------------------------\n   335→    @staticmethod\n   336→    def _safe_int(value: Any, default: int) -> int:\n   337→        try:\n   338→            return int(value)\n   339→        except Exception:\n   340→            return default\n   341→\n   342→    @staticmethod\n   343→    def _safe_float(value: Any, default: float) -> float:\n   344→        try:\n   345→            return float(value)\n   346→        except Exception:\n   347→            return default\n   348→\n   349→    @staticmethod\n   350→    def _pick_reference_assets(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   351→        for item in results:\n   352→            if not isinstance(item, dict):\n   353→                continue\n   354→            refs = item.get(\"reference_assets\")\n   355→            if refs:\n   356→                return refs\n   357→            params = item.get(\"parameters\")\n   358→            if isinstance(params, dict):\n   359→                refs = params.get(\"reference_assets\")\n   360→                if refs:\n   361→                    return refs\n   362→        return []\n   363→\n   364→    @staticmethod\n   365→    def _emit_progress(\n   366→        callback: ProgressCallback, message: str, percentage: Optional[float] = None\n   367→    ) -> None:\n   368→        if not callback:\n   369→            return\n   370→        try:\n   371→            callback(percentage, message)\n   372→        except Exception as exc:\n   373→            logger.debug(f\"Progress callback failed: {exc}\")\n   374→\n   375→    @staticmethod\n   376→    def _is_cancelled(callback: CancelCallback) -> bool:\n   377→        if not callback:\n   378→            return False\n   379→        try:\n   380→            return bool(callback())\n   381→        except Exception as exc:\n   382→            logger.debug(f\"Cancel callback failed: {exc}\")\n   383→            return False\n   384→\n   385→    @staticmethod\n   386→    def _failure(message: str) -> Dict[str, Any]:\n   387→        return {\"success\": False, \"error\": message}\n   388→\n   389→    @staticmethod\n   390→    def _cancelled() -> Dict[str, Any]:\n   391→        return {\"success\": False, \"error\": \"Image generation cancelled\"}\n   392→\n   393→\n   394→if __name__ == \"__main__\":\n   395→    print(\"ImageService module validation: import succeeded\")\n   396→    service = ImageService()\n   397→    print(f\"Default storage path: {service.storage_manager.root_path}\")\n   398→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7e6d90d7-5baa-4ec9-87ce-36433b9a6365","timestamp":"2026-01-05T11:53:37.472Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/services/image_service.py","content":"\"\"\"Seedream image generation service layer.\"\"\"\n\nfrom __future__ import annotations\n\nimport uuid\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom config.unified_config import get_unified_config\nfrom modules.repository.manager import RepositoryManager\nfrom modules.seedream.manager import SeedreamManager\nfrom modules.storage import get_v2_storage_manager\nfrom utils.logger import logger\n\nProgressCallback = Optional[Callable[[Optional[float], str], None]]\nCancelCallback = Optional[Callable[[], bool]]\n\n\nclass ImageService:\n    \"\"\"Business logic wrapper for Seedream image generation.\"\"\"\n\n    def __init__(\n        self,\n        storage_manager=None,\n        repository_manager: Optional[RepositoryManager] = None,\n        seedream_manager_factory: Callable[[Optional[str]], SeedreamManager] = SeedreamManager,\n    ) -> None:\n        # Use unified config for storage path and API validation\n        self.unified_config = get_unified_config()\n\n        self.storage_manager = storage_manager or get_v2_storage_manager(self.unified_config.get_storage_dir())\n        self.repository_manager = repository_manager\n        self._seedream_manager_factory = seedream_manager_factory or SeedreamManager\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n    def generate_image(\n        self,\n        params: Dict[str, Any],\n        progress_callback: ProgressCallback = None,\n        should_cancel: CancelCallback = None,\n    ) -> Dict[str, Any]:\n        prompt = (params.get(\"prompt\") or \"\").strip()\n        if not prompt:\n            return self._failure(\"Prompt cannot be empty\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        self._emit_progress(progress_callback, \"Preparing...\")\n\n        try:\n            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n            if not is_valid:\n                missing = f\"Missing: {', '.join(missing_keys)}\" if missing_keys else \"\"\n                detail = message or \"API key not configured\"\n                return self._failure(detail if not missing else f\"{detail} ({missing})\")\n        except Exception as cfg_err:\n            return self._failure(f\"Config validation failed: {cfg_err}\")\n\n        try:\n            api_key = self.unified_config.get_api_key(\"volcengine\")\n        except Exception as key_err:\n            return self._failure(f\"Failed to load API key: {key_err}\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        try:\n            seedream_manager = self._seedream_manager_factory(api_key)\n            self._emit_progress(progress_callback, \"Seedream manager ready\")\n        except Exception as init_err:\n            logger.error(f\"Seedream manager init failed: {init_err}\")\n            return self._failure(f\"Seedream manager init failed: {init_err}\")\n\n        generation_count = self._safe_int(params.get(\"count\", 1), default=1)\n        reference_images = params.get(\"reference_images\") or []\n        input_image_path = (\n            params.get(\"input_image_path\")\n            or params.get(\"input_image\")\n            or params.get(\"image_path\")\n            or params.get(\"image\")\n        )\n        base_size = params.get(\"size\", \"1024x1024\")\n        guidance_scale = self._safe_float(params.get(\"guidance_scale\", 2.5), default=2.5)\n        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n        model_variant = params.get(\"model_variant\")\n        generation_id = params.get(\"generation_id\")\n        derived_ids: List[str] = params.get(\"derived_ids\") or []\n        sequential_mode = bool(params.get(\"sequential_mode\", False))\n\n        try:\n            if generation_count == 1:\n                result = self._generate_single(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    model_variant=model_variant,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    generation_id=generation_id,\n                    sequential_mode=sequential_mode,\n                    progress_callback=progress_callback,\n                    should_cancel=should_cancel,\n                )\n            else:\n                result = self._generate_batch(\n                    seedream_manager=seedream_manager,\n                    prompt=prompt,\n                    count=generation_count,\n                    size=base_size,\n                    guidance_scale=guidance_scale,\n                    seed=seed,\n                    input_image_path=input_image_path,\n                    reference_images=reference_images,\n                    model_variant=model_variant,\n                    generation_id=generation_id,\n                    derived_ids=derived_ids,\n                    sequential_mode=sequential_mode,\n                    progress_callback=progress_callback,\n                    should_cancel=should_cancel,\n                )\n        except Exception as api_error:\n            logger.error(f\"Seedream API error: {api_error}\")\n            return self._failure(f\"API error: {api_error}\")\n\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        if result.get(\"success\"):\n            summary = \"Generation completed\"\n            if generation_count > 1:\n                success_count = result.get(\"success_count\", 0)\n                summary = f\"Batch completed {success_count}/{result.get('total_count', generation_count)}\"\n            self._emit_progress(progress_callback, summary, percentage=100.0)\n            self._persist_metadata(result)\n        else:\n            error_msg = result.get(\"error\", \"unknown error\")\n            self._emit_progress(progress_callback, f\"Generation failed: {error_msg}\")\n\n        return result\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n    def _generate_single(\n        self,\n        *,\n        seedream_manager: SeedreamManager,\n        prompt: str,\n        size: str,\n        guidance_scale: float,\n        seed: int,\n        model_variant: Optional[str],\n        input_image_path: Optional[str],\n        reference_images: List[Dict[str, Any]],\n        generation_id: Optional[str],\n        sequential_mode: bool,\n        progress_callback: ProgressCallback,\n        should_cancel: CancelCallback,\n    ) -> Dict[str, Any]:\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        if input_image_path:\n            self._emit_progress(progress_callback, \"Generating image-to-image...\")\n            return seedream_manager.generate_image_to_image(\n                prompt=prompt,\n                image=input_image_path,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=True,\n                reference_images=reference_images or None,\n                generation_id=generation_id,\n            )\n\n        self._emit_progress(progress_callback, \"Generating text-to-image...\")\n        return seedream_manager.generate_text_to_image(\n            prompt=prompt,\n            size=size,\n            guidance_scale=guidance_scale,\n            seed=seed,\n            save_local=True,\n            reference_images=reference_images or None,\n            model_variant=model_variant,\n            generation_id=generation_id,\n            sequential_mode=sequential_mode,\n        )\n\n    def _generate_batch(\n        self,\n        *,\n        seedream_manager: SeedreamManager,\n        prompt: str,\n        count: int,\n        size: str,\n        guidance_scale: float,\n        seed: int,\n        input_image_path: Optional[str],\n        reference_images: List[Dict[str, Any]],\n        model_variant: Optional[str],\n        generation_id: Optional[str],\n        derived_ids: List[str],\n        sequential_mode: bool,\n        progress_callback: ProgressCallback,\n        should_cancel: CancelCallback,\n    ) -> Dict[str, Any]:\n        if self._is_cancelled(should_cancel):\n            return self._cancelled()\n\n        slots = max(1, count)\n        per_image_ids: List[str] = list(derived_ids or [])\n        if len(per_image_ids) < slots:\n            base = generation_id or f\"batch_{uuid.uuid4().hex}\"\n            for idx in range(len(per_image_ids), slots):\n                per_image_ids.append(f\"{base}_{idx + 1}\")\n        per_image_ids = per_image_ids[:slots]\n\n        if reference_images:\n            self._emit_progress(progress_callback, \"Detected reference images; switching to sequential mode...\")\n            aggregated: List[Dict[str, Any]] = []\n            success_count = 0\n            for idx in range(count):\n                if self._is_cancelled(should_cancel):\n                    return self._cancelled()\n                per_id = per_image_ids[idx] if idx < len(per_image_ids) else None\n                if input_image_path:\n                    single_result = seedream_manager.generate_image_to_image(\n                        prompt=prompt,\n                        image=input_image_path,\n                        guidance_scale=guidance_scale,\n                        seed=seed,\n                        save_local=True,\n                        reference_images=reference_images or None,\n                        generation_id=per_id or generation_id,\n                    )\n                else:\n                    single_result = seedream_manager.generate_text_to_image(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=seed,\n                        save_local=True,\n                        reference_images=reference_images or None,\n                        model_variant=model_variant,\n                        generation_id=per_id or generation_id,\n                    )\n                if per_id:\n                    single_result[\"generation_id\"] = per_id\n                    single_result[\"task_id\"] = per_id\n                    single_result[\"file_id\"] = per_id\n                single_result[\"task_index\"] = idx + 1\n                aggregated.append(single_result)\n                if single_result.get(\"success\"):\n                    success_count += 1\n                pct = ((idx + 1) / count) * 100.0\n                self._emit_progress(progress_callback, f\"Generating {idx + 1}/{count}...\", pct)\n\n            sanitized_refs = self._pick_reference_assets(aggregated)\n            return {\n                \"success\": success_count == count,\n                \"total_count\": count,\n                \"success_count\": success_count,\n                \"derived_ids\": per_image_ids,\n                \"results\": aggregated,\n                \"reference_assets\": sanitized_refs,\n            }\n\n        if input_image_path:\n            self._emit_progress(progress_callback, f\"Generating {count} image-to-image in parallel...\")\n\n            def manager_progress(completed: int, total: int, _result: Dict[str, Any]) -> None:\n                pct = (completed / total) * 100 if total else None\n                self._emit_progress(progress_callback, f\"Generating {completed}/{total}...\", pct)\n\n            return seedream_manager.concurrent_generate_image_to_image(\n                prompt=prompt,\n                image=input_image_path,\n                count=count,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=True,\n                derived_ids=per_image_ids,\n                generation_id=generation_id,\n                progress_callback=manager_progress,\n            )\n\n        self._emit_progress(progress_callback, f\"Generating {count} text-to-image in parallel...\")\n\n        def manager_progress(completed: int, total: int, _result: Dict[str, Any]) -> None:\n            pct = (completed / total) * 100 if total else None\n            self._emit_progress(progress_callback, f\"Generating {completed}/{total}...\", pct)\n\n        return seedream_manager.concurrent_generate_text_to_image(\n            prompt=prompt,\n            count=count,\n            size=size,\n            guidance_scale=guidance_scale,\n            seed=seed,\n            save_local=True,\n            derived_ids=per_image_ids,\n            generation_id=generation_id,\n            progress_callback=manager_progress,\n            model_variant=model_variant,\n            sequential_mode=sequential_mode,\n        )\n\n    def _persist_metadata(self, result: Dict[str, Any]) -> None:\n        if not self.repository_manager:\n            return\n\n        try:\n            file_id = (\n                result.get(\"file_id\")\n                or result.get(\"generation_id\")\n                or result.get(\"task_id\")\n                or result.get(\"batch_id\")\n            )\n            metadata = (\n                result.get(\"metadata\")\n                or result.get(\"parameters\")\n                or {\"prompt\": result.get(\"prompt\", \"\")}\n            )\n            if not file_id:\n                return\n            self.repository_manager.add_content(str(file_id), \"image\", metadata)\n        except Exception as exc:\n            logger.debug(f\"Persist generation metadata failed: {exc}\")\n\n    # ------------------------------------------------------------------\n    # Utility helpers\n    # ------------------------------------------------------------------\n    @staticmethod\n    def _safe_int(value: Any, default: int) -> int:\n        try:\n            return int(value)\n        except Exception:\n            return default\n\n    @staticmethod\n    def _safe_float(value: Any, default: float) -> float:\n        try:\n            return float(value)\n        except Exception:\n            return default\n\n    @staticmethod\n    def _pick_reference_assets(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        for item in results:\n            if not isinstance(item, dict):\n                continue\n            refs = item.get(\"reference_assets\")\n            if refs:\n                return refs\n            params = item.get(\"parameters\")\n            if isinstance(params, dict):\n                refs = params.get(\"reference_assets\")\n                if refs:\n                    return refs\n        return []\n\n    @staticmethod\n    def _emit_progress(\n        callback: ProgressCallback, message: str, percentage: Optional[float] = None\n    ) -> None:\n        if not callback:\n            return\n        try:\n            callback(percentage, message)\n        except Exception as exc:\n            logger.debug(f\"Progress callback failed: {exc}\")\n\n    @staticmethod\n    def _is_cancelled(callback: CancelCallback) -> bool:\n        if not callback:\n            return False\n        try:\n            return bool(callback())\n        except Exception as exc:\n            logger.debug(f\"Cancel callback failed: {exc}\")\n            return False\n\n    @staticmethod\n    def _failure(message: str) -> Dict[str, Any]:\n        return {\"success\": False, \"error\": message}\n\n    @staticmethod\n    def _cancelled() -> Dict[str, Any]:\n        return {\"success\": False, \"error\": \"Image generation cancelled\"}\n\n\nif __name__ == \"__main__\":\n    print(\"ImageService module validation: import succeeded\")\n    service = ImageService()\n    print(f\"Default storage path: {service.storage_manager.root_path}\")\n","numLines":398,"startLine":1,"totalLines":398}}}
{"parentUuid":"7e6d90d7-5baa-4ec9-87ce-36433b9a6365","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BxtM525jbVEdf5yrdTdwFi","type":"tool_result","content":"     1→# Seedream图像生成客户端\n     2→# 封装火山引擎Seedream3.0 API调用\n     3→\n     4→import json\n     5→import os\n     6→import requests\n     7→from requests.exceptions import Timeout, ReadTimeout, ConnectTimeout\n     8→import time\n     9→import random\n    10→from typing import Dict, Any, Optional, List\n    11→from pathlib import Path\n    12→from loguru import logger\n    13→from urllib3.util.retry import Retry\n    14→from requests.adapters import HTTPAdapter\n    15→\n    16→# 导入配置管理器和错误处理\n    17→from config.unified_config import get_unified_config\n    18→from utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n    19→\n    20→\n    21→class SeedreamClient:\n    22→    \"\"\"火山引擎Seedream图片生成客户端\n    23→\n    24→    提供文生图和图生图功能\n    25→    \"\"\"\n    26→\n    27→    def __init__(\n    28→        self,\n    29→        api_key: Optional[str] = None,\n    30→        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n    31→        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n    32→        timeout: int = 60,\n    33→        max_retries: int = 3,\n    34→    ):\n    35→        \"\"\"初始化Seedream客户端\n    36→\n    37→        Args:\n    38→            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n    39→            base_url: API基础URL\n    40→            timeout: 请求超时时间（秒）\n    41→            max_retries: 最大重试次数\n    42→        \"\"\"\n    43→        # 获取API密钥\n    44→        if api_key is None:\n    45→            try:\n    46→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    47→            except Exception as exc:\n    48→                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n    49→\n    50→        self.api_key = api_key\n    51→        self.base_url = base_url.rstrip(\"/\")\n    52→        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n    53→        self.timeout = timeout\n    54→        self.max_retries = max_retries\n    55→\n    56→        # 配置会话\n    57→        self.session = requests.Session()\n    58→\n    59→        # 配置重试策略\n    60→        retry_strategy = Retry(\n    61→            total=max_retries,\n    62→            status_forcelist=[429, 500, 502, 503, 504],\n    63→            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n    64→            backoff_factor=1\n    65→        )\n    66→\n    67→        adapter = HTTPAdapter(max_retries=retry_strategy)\n    68→        self.session.mount(\"http://\", adapter)\n    69→        self.session.mount(\"https://\", adapter)\n    70→\n    71→        logger.info(\"Seedream客户端初始化完成\")\n    72→\n    73→        # 初始化性能监控与错误缓存（统一结构）\n    74→        self._performance_stats = {\n    75→            \"total_requests\": 0,\n    76→            \"successful_requests\": 0,\n    77→            \"failed_requests\": 0,\n    78→            \"total_response_time\": 0.0,\n    79→            \"last_request_time\": None,\n    80→        }\n    81→        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n    82→        self._last_provider: Optional[str] = None\n    83→        self._last_endpoint: Optional[str] = None\n    84→\n    85→    def _encode_image(self, image_path: str) -> str:\n    86→        \"\"\"将图像文件编码为base64字符串\n    87→        \n    88→        Args:\n    89→            image_path: 图像文件路径\n    90→            \n    91→        Returns:\n    92→            base64编码的图像字符串\n    93→        \"\"\"\n    94→        import base64\n    95→        \n    96→        try:\n    97→            with open(image_path, 'rb') as image_file:\n    98→                image_data = image_file.read()\n    99→                base64_string = base64.b64encode(image_data).decode('utf-8')\n   100→                return base64_string\n   101→        except Exception as e:\n   102→            # 避免在日志中显示可能包含base64数据的异常信息\n   103→            error_msg = str(e)\n   104→            if len(error_msg) > 200:\n   105→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   106→            logger.error(f\"图像编码失败: {error_msg}\")\n   107→            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n   108→\n   109→    def _get_headers(self) -> Dict[str, str]:\n   110→        \"\"\"获取请求头\"\"\"\n   111→        # 验证API密钥，防止尺寸配置被错误使用\n   112→        api_key = str(self.api_key).strip()\n   113→\n   114→        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n   115→        try:\n   116→            api_key.encode('ascii')\n   117→        except UnicodeEncodeError:\n   118→            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n   119→\n   120→        # 检查是否包含尺寸信息或换行符\n   121→        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n   122→            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n   123→\n   124→        # 检查API密钥长度\n   125→        if len(api_key) < 10 or len(api_key) > 200:\n   126→            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n   127→        \n   128→        return {\n   129→            \"Authorization\": f\"Bearer {api_key}\",\n   130→            \"Content-Type\": \"application/json; charset=utf-8\",\n   131→            \"User-Agent\": \"Seedream-Client/1.0.0\",\n   132→        }\n   133→\n   134→    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n   135→        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\n   136→\n   137→        注意：当 timeout > 120 时，使用独立的 requests.post() 而不是 session.post()。\n   138→        这是因为 Session 配置了 Retry 策略，会在超时后自动重试，导致：\n   139→        1. 实际等待时间 = timeout × (1 + retry_count)，可能长达数十分钟\n   140→        2. 重试期间没有日志输出，用户看起来像\"卡住\"\n   141→\n   142→        对于组图等长时间请求，我们需要精确控制超时，不希望自动重试。\n   143→        \"\"\"\n   144→        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   145→        start = time.time()\n   146→\n   147→        # 长超时请求（组图模式）：绕过 Session 重试机制\n   148→        if timeout > 120:\n   149→            logger.info(f\"[HTTP POST] 长时间请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s (无重试)\")\n   150→            try:\n   151→                # 直接使用 requests.post，不经过 session 的重试策略\n   152→                resp = requests.post(url, headers=headers, data=body, timeout=(30, timeout))\n   153→                elapsed = time.time() - start\n   154→                logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n   155→                return resp\n   156→            except Exception as e:\n   157→                elapsed = time.time() - start\n   158→                logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n   159→                raise\n   160→\n   161→        # 普通请求：使用 session（带重试机制）\n   162→        logger.info(f\"[HTTP POST] 开始请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s\")\n   163→        try:\n   164→            resp = self.session.post(url, headers=headers, data=body, timeout=(30, timeout))\n   165→            elapsed = time.time() - start\n   166→            logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n   167→            return resp\n   168→        except Exception as e:\n   169→            elapsed = time.time() - start\n   170→            logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n   171→            raise\n   172→\n   173→    def _is_large_size(self, size: str) -> bool:\n   174→        \"\"\"判断是否是 v4.5 大尺寸（超过 v3 的 2048 限制）\"\"\"\n   175→        if not size:\n   176→            return False\n   177→        try:\n   178→            if \"x\" in size.lower():\n   179→                w, h = size.lower().split(\"x\")\n   180→                return int(w) > 2048 or int(h) > 2048\n   181→            # 处理 2K/4K 格式\n   182→            if size.upper() in (\"2K\", \"4K\"):\n   183→                return True\n   184→        except Exception:\n   185→            pass\n   186→        return False\n   187→\n   188→    def _provider_enabled(self) -> bool:\n   189→        try:\n   190→            import os\n   191→            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n   192→            return v not in {\"0\", \"false\", \"no\"}\n   193→        except Exception:\n   194→            return True\n   195→\n   196→    def _get_seedream_provider_order(self, preferred_provider: Optional[str] = None) -> List[str]:\n   197→        \"\"\"计算 Seedream provider 调用顺序。\n   198→\n   199→        规则：\n   200→        - 优先使用调用方传入的 preferred_provider（并发安全）\n   201→        - 其次允许通过环境变量 GEMENG_SEEDREAM_PROVIDER 启动覆盖（只读）\n   202→        - 最后兜底 volc_v3\n   203→        \"\"\"\n   204→        order: List[str] = []\n   205→\n   206→        candidates: List[Optional[str]] = []\n   207→        if preferred_provider:\n   208→            candidates.append(preferred_provider)\n   209→        try:\n   210→            candidates.append(os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\"))\n   211→        except Exception:\n   212→            candidates.append(None)\n   213→\n   214→        for candidate in candidates:\n   215→            if not candidate:\n   216→                continue\n   217→            name = candidate.strip().lower()\n   218→            if not name:\n   219→                continue\n   220→            if name not in order:\n   221→                order.append(name)\n   222→\n   223→        if \"volc_v3\" not in order:\n   224→            order.append(\"volc_v3\")\n   225→        return order\n   226→\n   227→    def _call_seedream_provider(\n   228→        self,\n   229→        headers: Dict[str, str],\n   230→        mapper,\n   231→        operation: str,\n   232→        preferred_provider: Optional[str] = None,\n   233→    ):\n   234→        from modules.provider.factory import get_default_provider\n   235→        default_endpoint = \"/images/generations\"\n   236→        base_url = self.base_url.rstrip(\"/\")\n   237→        first_choice = None\n   238→        last_error: Optional[BaseException] = None\n   239→        order = self._get_seedream_provider_order(preferred_provider)\n   240→        if order:\n   241→            first_choice = order[0]\n   242→        for idx, name in enumerate(order):\n   243→            try:\n   244→                provider = get_default_provider(name)\n   245→            except Exception as e:\n   246→                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n   247→                last_error = e\n   248→                continue\n   249→            try:\n   250→                mapped = mapper(provider)\n   251→                if not isinstance(mapped, tuple):\n   252→                    raise ValueError(\"provider mapper 返回值异常\")\n   253→                if len(mapped) == 4:\n   254→                    payload, fb, reason, endpoint = mapped\n   255→                elif len(mapped) == 3:\n   256→                    payload, fb, reason = mapped\n   257→                    endpoint = default_endpoint\n   258→                else:\n   259→                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n   260→            except Exception as e:\n   261→                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n   262→                last_error = e\n   263→                continue\n   264→            start_time = time.time()\n   265→            try:\n   266→                endpoint_path = endpoint or default_endpoint\n   267→                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n   268→                    request_url = endpoint_path\n   269→                else:\n   270→                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   271→                    if not normalized.startswith(\"/\"):\n   272→                        normalized = f\"/{normalized}\"\n   273→                    request_url = f\"{base_url}{normalized}\"\n   274→\n   275→                # 动态超时：组图模式需要更长时间\n   276→                # 实测：5 张 4096x4096 约需 8 分钟（458 秒）\n   277→                timeout = 120\n   278→                seq_options = payload.get(\"sequential_image_generation_options\")\n   279→                max_images = seq_options.get(\"max_images\", 1) if seq_options else 1\n   280→                if max_images > 1:\n   281→                    # 组图模式：基础 120 秒 + 每张图 60 秒，最大 20 分钟\n   282→                    # 实测：15 张 4096x4096 约需 14.5 分钟（869 秒）\n   283→                    timeout = min(120 + max_images * 60, 1200)\n   284→                    logger.info(f\"组图模式: {max_images} 张图，超时设置为 {timeout} 秒\")\n   285→\n   286→                response = self._safe_json_post(request_url, headers, payload, timeout=timeout)\n   287→                result = self._handle_response(response)\n   288→                elapsed = time.time() - start_time\n   289→                if idx > 0 and first_choice:\n   290→                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n   291→                if fb and reason:\n   292→                    logger.warning(f\"参数回退: {reason}\")\n   293→                logger.info(\n   294→                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n   295→                )\n   296→                self._last_provider = name\n   297→                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n   298→                return result, payload, endpoint_path, name, fb, reason, elapsed\n   299→            except AppError as e:\n   300→                last_error = e\n   301→                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n   302→                # v4.5 特有功能失败时不回退到 v3（参数不兼容）\n   303→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   304→                    is_v45_feature = (\n   305→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   306→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   307→                    )\n   308→                    if is_v45_feature:\n   309→                        logger.error(f\"v4.5 特有功能失败，不回退: {e.message}\")\n   310→                        raise\n   311→                continue\n   312→            except (Timeout, ReadTimeout, ConnectTimeout) as e:\n   313→                elapsed = time.time() - start_time\n   314→                last_error = e\n   315→                logger.error(f\"Seedream provider {name} 请求超时 ({elapsed:.1f}s): {e}\")\n   316→                # v4.5 特有功能超时时直接报错，不回退\n   317→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   318→                    is_v45_feature = (\n   319→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   320→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   321→                    )\n   322→                    if is_v45_feature:\n   323→                        raise AppError(\n   324→                            f\"组图生成超时 ({elapsed:.0f}秒)，请减少生成数量或稍后重试\",\n   325→                            ErrorType.NETWORK_ERROR\n   326→                        )\n   327→                continue\n   328→            except Exception as e:\n   329→                last_error = e\n   330→                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n   331→                # v4.5 特有功能异常时也不回退\n   332→                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n   333→                    is_v45_feature = (\n   334→                        payload.get(\"sequential_image_generation\") == \"auto\"\n   335→                        or self._is_large_size(payload.get(\"size\", \"\"))\n   336→                    )\n   337→                    if is_v45_feature:\n   338→                        logger.error(f\"v4.5 特有功能异常，不回退: {e}\")\n   339→                        raise\n   340→                continue\n   341→        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n   342→\n   343→    def _log_seedream_event(\n   344→        self,\n   345→        operation: str,\n   346→        status: str,\n   347→        provider: Optional[str],\n   348→        endpoint: Optional[str],\n   349→        elapsed: float,\n   350→        fallback_applied: bool,\n   351→        fallback_reason: Optional[str] = None,\n   352→        extra: Optional[Dict[str, Any]] = None,\n   353→    ) -> None:\n   354→        try:\n   355→            provider_name = provider or \"unknown\"\n   356→            endpoint_text = endpoint or \"/images/generations\"\n   357→            parts = [\n   358→                f\"operation={operation}\",\n   359→                f\"status={status}\",\n   360→                f\"provider={provider_name}\",\n   361→                f\"endpoint={endpoint_text}\",\n   362→                f\"elapsed={elapsed:.2f}s\",\n   363→                f\"fallback={'yes' if fallback_applied else 'no'}\",\n   364→            ]\n   365→            if fallback_applied and fallback_reason:\n   366→                safe_reason = str(fallback_reason)\n   367→                if len(safe_reason) > 120:\n   368→                    safe_reason = safe_reason[:120] + \"...\"\n   369→                parts.append(f\"fallback_reason={safe_reason}\")\n   370→            if extra:\n   371→                for key, value in extra.items():\n   372→                    if value is None:\n   373→                        continue\n   374→                    parts.append(f\"{key}={value}\")\n   375→            logger.info(\"摘要|\" + \" \".join(parts))\n   376→        except Exception:\n   377→            # 保证日志逻辑不会影响主流程\n   378→            pass\n   379→\n   380→    @staticmethod\n   381→    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n   382→        mime = \"image/png\"\n   383→        try:\n   384→            if path_hint:\n   385→                suffix = Path(path_hint).suffix.lower()\n   386→                if suffix in {\".jpg\", \".jpeg\"}:\n   387→                    mime = \"image/jpeg\"\n   388→                elif suffix == \".webp\":\n   389→                    mime = \"image/webp\"\n   390→                elif suffix == \".bmp\":\n   391→                    mime = \"image/bmp\"\n   392→                elif suffix == \".gif\":\n   393→                    mime = \"image/gif\"\n   394→        except Exception:\n   395→            pass\n   396→        return f\"data:{mime};base64,{b64_data}\"\n   397→\n   398→    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n   399→        \"\"\"处理API响应\n   400→\n   401→        Args:\n   402→            response: HTTP响应对象\n   403→\n   404→        Returns:\n   405→            解析后的响应数据\n   406→\n   407→        Raises:\n   408→            AppError: 当API返回错误时\n   409→        \"\"\"\n   410→        try:\n   411→            if not response.ok:\n   412→                try:\n   413→                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n   414→                except Exception:\n   415→                    error_text = str(response.content[:500])\n   416→                # 避免在日志中显示可能包含base64数据的完整响应\n   417→                if len(error_text) > 500:\n   418→                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n   419→                else:\n   420→                    error_summary = error_text\n   421→                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n   422→                raise AppError(\n   423→                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n   424→                    ErrorType.API_ERROR,\n   425→                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n   426→                )\n   427→\n   428→            # 解析响应（增强容错：包括编码问题回退）\n   429→            try:\n   430→                result = response.json()\n   431→            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n   432→                raw = response.content or b\"\"\n   433→                tried = set()\n   434→                result = None\n   435→                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n   436→                    if not enc or enc in tried:\n   437→                        continue\n   438→                    tried.add(enc)\n   439→                    try:\n   440→                        text = raw.decode(enc, errors=\"strict\")\n   441→                        result = json.loads(text)\n   442→                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n   443→                        break\n   444→                    except Exception:\n   445→                        continue\n   446→                if result is None:\n   447→                    try:\n   448→                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n   449→                    except Exception:\n   450→                        preview = str(raw[:200])\n   451→                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n   452→                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n   453→\n   454→            # OpenAI格式的响应检查\n   455→            if \"data\" not in result:\n   456→                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n   457→                logger.error(f\"Seedream API错误: {error_msg}\")\n   458→                raise AppError(\n   459→                    f\"API错误: {error_msg}\",\n   460→                    ErrorType.API_ERROR,\n   461→                    {\"response_data\": result},\n   462→                )\n   463→\n   464→            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n   465→            images = []\n   466→            for item in result[\"data\"]:\n   467→                if \"url\" in item:\n   468→                    images.append({\n   469→                        \"url\": item[\"url\"]\n   470→                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n   471→                    })\n   472→\n   473→            # 调试日志：输出组图返回的图片数量\n   474→            logger.debug(f\"API 返回 {len(images)} 张图片\")\n   475→\n   476→            return {\n   477→                \"code\": 200,\n   478→                \"message\": \"success\",\n   479→                \"data\": {\n   480→                    \"images\": images\n   481→                },\n   482→                \"created\": result.get(\"created\"),\n   483→                \"usage\": result.get(\"usage\", {})\n   484→            }\n   485→\n   486→        except requests.exceptions.RequestException as e:\n   487→            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n   488→        except json.JSONDecodeError as e:\n   489→            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n   490→\n   491→    def _record_request_stats(\n   492→        self,\n   493→        operation: str,\n   494→        success: bool,\n   495→        response_time: float,\n   496→        error_code: Optional[str] = None,\n   497→        error_message: Optional[str] = None,\n   498→    ) -> None:\n   499→        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n   500→        try:\n   501→            self._performance_stats[\"total_requests\"] += 1\n   502→            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n   503→            self._performance_stats[\"last_request_time\"] = time.time()\n   504→            if success:\n   505→                self._performance_stats[\"successful_requests\"] += 1\n   506→            else:\n   507→                self._performance_stats[\"failed_requests\"] += 1\n   508→                if error_code or error_message:\n   509→                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n   510→\n   511→            # 调试日志（安全版）\n   512→            total = max(1, self._performance_stats[\"total_requests\"])\n   513→            avg = self._performance_stats[\"total_response_time\"] / total\n   514→            succ = self._performance_stats[\"successful_requests\"]\n   515→            success_rate = (succ / total) * 100.0\n   516→            logger.debug(\n   517→                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n   518→            )\n   519→        except Exception:\n   520→            # 统计不应影响业务流程\n   521→            pass\n   522→\n   523→    def get_performance_stats(self) -> Dict[str, Any]:\n   524→        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n   525→        stats = dict(self._performance_stats)\n   526→        total = stats.get(\"total_requests\", 0) or 0\n   527→        if total > 0:\n   528→            avg = stats.get(\"total_response_time\", 0.0) / total\n   529→            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n   530→        else:\n   531→            avg = 0.0\n   532→            success_rate = 0.0\n   533→        return {\n   534→            \"total_requests\": total,\n   535→            \"successful_requests\": stats.get(\"successful_requests\", 0),\n   536→            \"failed_requests\": stats.get(\"failed_requests\", 0),\n   537→            \"avg_response_time\": avg,\n   538→            \"success_rate\": success_rate,\n   539→            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n   540→        }\n   541→\n   542→    def dump_metrics(self) -> Dict[str, Any]:\n   543→        \"\"\"导出诊断可读的统一指标。\"\"\"\n   544→        m = self.get_performance_stats()\n   545→        m.update({\n   546→            \"client\": \"Seedream\",\n   547→            \"model\": self.model_id,\n   548→            \"base_url\": self.base_url,\n   549→        })\n   550→        return m\n   551→\n   552→    def last_provider(self) -> Optional[str]:\n   553→        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n   554→        return self._last_provider\n   555→\n   556→    def last_endpoint(self) -> Optional[str]:\n   557→        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n   558→        return self._last_endpoint\n   559→\n   560→    @error_handler(\"Seedream文生图\")\n   561→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   562→    def text_to_image(\n   563→        self,\n   564→        prompt: str,\n   565→        size: str = \"1024x1024\",\n   566→        guidance_scale: float = 2.5,\n   567→        seed: Optional[int] = None,\n   568→        reference_images: Optional[List[Any]] = None,\n   569→        n: int = 1,\n   570→        sequential_mode: bool = False,\n   571→        seedream_provider: Optional[str] = None,\n   572→    ) -> Dict[str, Any]:\n   573→        \"\"\"\n   574→        文生图API调用\n   575→\n   576→        Args:\n   577→            prompt: 图片描述提示词\n   578→            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n   579→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   580→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   581→            reference_images: 参考图列表（路径或URL），最多10张\n   582→            n: 生成图片数量，组图模式下生效（1-15）\n   583→            sequential_mode: 是否启用组图模式\n   584→            response_format: 返回格式，\"url\"或\"b64_json\"\n   585→\n   586→        Returns:\n   587→            API响应结果\n   588→\n   589→        Raises:\n   590→            AppError: 当API调用失败时\n   591→        \"\"\"\n   592→        headers = self._get_headers()\n   593→\n   594→        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n   595→\n   596→        if self._provider_enabled():\n   597→            try:\n   598→                from modules.provider.schema import TextToImageParams\n   599→\n   600→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   601→                    headers,\n   602→                    lambda provider: provider.map_t2i(TextToImageParams(\n   603→                        prompt=prompt,\n   604→                        size=size,\n   605→                        guidance_scale=guidance_scale,\n   606→                        seed=(None if (seed is None or seed == -1) else seed),\n   607→                        reference_images=reference_images or [],\n   608→                        sequential_mode=sequential_mode,\n   609→                        count=n\n   610→                    )),\n   611→                    \"text_to_image\",\n   612→                    preferred_provider=seedream_provider,\n   613→                )\n   614→                self._log_seedream_event(\n   615→                    \"text_to_image\",\n   616→                    \"success\",\n   617→                    provider_used,\n   618→                    endpoint_used,\n   619→                    response_time,\n   620→                    fallback_applied,\n   621→                    fallback_reason,\n   622→                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   623→                )\n   624→                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n   625→                return result\n   626→            except Exception as provider_exc:\n   627→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   628→\n   629→        success = False\n   630→        err_code: Optional[str] = None\n   631→        err_msg: Optional[str] = None\n   632→        start_time = time.time()\n   633→        try:\n   634→            if not self.validate_image_size(size):\n   635→                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n   636→            if not (1.0 <= guidance_scale <= 10.0):\n   637→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   638→            if seed is not None and not (-1 <= seed <= 2147483647):\n   639→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   640→\n   641→            data = {\n   642→                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n   643→                \"prompt\": prompt,\n   644→                \"size\": size,\n   645→                \"response_format\": \"url\",\n   646→                \"watermark\": False,  # 正式版固定禁用水印\n   647→                \"guidance_scale\": guidance_scale,\n   648→            }\n   649→            if seed is not None:\n   650→                data[\"seed\"] = seed\n   651→\n   652→            if reference_images:\n   653→                images_payload = []\n   654→                for item in reference_images:\n   655→                    try:\n   656→                        if isinstance(item, str):\n   657→                            if item.startswith(\"data:image/\"):\n   658→                                images_payload.append(item)\n   659→                                continue\n   660→                            p = Path(item)\n   661→                            if p.exists():\n   662→                                encoded = self._encode_image(str(p))\n   663→                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   664→                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n   665→                                images_payload.append(item)\n   666→                        elif isinstance(item, dict):\n   667→                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n   668→                            path_hint = item.get('path') or item.get('source')\n   669→                            if payload:\n   670→                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n   671→                            else:\n   672→                                path_val = item.get('path')\n   673→                                if path_val:\n   674→                                    p = Path(path_val)\n   675→                                    if p.exists():\n   676→                                        encoded = self._encode_image(str(p))\n   677→                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n   678→                    except Exception as exc:\n   679→                        logger.warning(f\"参考图处理失败: {exc}\")\n   680→                if images_payload:\n   681→                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n   682→                    data[\"sequential_image_generation\"] = \"disabled\"\n   683→\n   684→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   685→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   686→            result = self._handle_response(response)\n   687→            success = True\n   688→            elapsed = time.time() - start_time\n   689→            self._last_provider = \"legacy_v3\"\n   690→            self._last_endpoint = \"/images/generations\"\n   691→            self._log_seedream_event(\n   692→                \"text_to_image\",\n   693→                \"success\",\n   694→                \"legacy_v3\",\n   695→                \"/images/generations\",\n   696→                elapsed,\n   697→                False,\n   698→                None,\n   699→                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n   700→            )\n   701→            return result\n   702→        except AppError as e:\n   703→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   704→            err_msg = e.message\n   705→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   706→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   707→            raise\n   708→        except Exception as e:\n   709→            err_code = \"UNKNOWN_ERROR\"\n   710→            err_msg = str(e)\n   711→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   712→            logger.error(f\"文生图请求失败: {safe_msg}\")\n   713→            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n   714→        finally:\n   715→            elapsed = time.time() - start_time\n   716→            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n   717→\n   718→    @error_handler(\"Seedream图生图\")\n   719→    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n   720→    def image_to_image(\n   721→        self,\n   722→        prompt: str,\n   723→        image: str,\n   724→        guidance_scale: float = 5.5,\n   725→        seed: Optional[int] = None,\n   726→        reference_images: Optional[List[str]] = None,\n   727→        seedream_provider: Optional[str] = None,\n   728→    ) -> Dict[str, Any]:\n   729→        \"\"\"\n   730→        图生图API调用\n   731→\n   732→        Args:\n   733→            prompt: 图片编辑提示词\n   734→            image: 输入图像URL或Base64编码\n   735→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   736→            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n   737→            reference_images: 参考图列表（路径或URL），最多10张\n   738→            response_format: 返回格式，\"url\"或\"b64_json\"\n   739→            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n   740→\n   741→        Returns:\n   742→            API响应结果\n   743→\n   744→        Raises:\n   745→            AppError: 当API调用失败时\n   746→        \"\"\"\n   747→        headers = self._get_headers()\n   748→\n   749→        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n   750→\n   751→        if self._provider_enabled():\n   752→            try:\n   753→                from modules.provider.schema import ImageToImageParams\n   754→\n   755→                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n   756→                    headers,\n   757→                    lambda provider: provider.map_i2i(ImageToImageParams(\n   758→                        prompt=prompt,\n   759→                        image=image,\n   760→                        guidance_scale=guidance_scale,\n   761→                        seed=(None if (seed is None or seed == -1) else seed),\n   762→                        reference_images=(reference_images or []),\n   763→                    )),\n   764→                    \"image_to_image\",\n   765→                    preferred_provider=seedream_provider,\n   766→                )\n   767→                self._log_seedream_event(\n   768→                    \"image_to_image\",\n   769→                    \"success\",\n   770→                    provider_used,\n   771→                    endpoint_used,\n   772→                    response_time,\n   773→                    fallback_applied,\n   774→                    fallback_reason,\n   775→                    {\"seed\": data.get(\"seed\")},\n   776→                )\n   777→                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n   778→                return result\n   779→            except Exception as provider_exc:\n   780→                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n   781→\n   782→        success = False\n   783→        err_code: Optional[str] = None\n   784→        err_msg: Optional[str] = None\n   785→        start_time = time.time()\n   786→        try:\n   787→            if not (1.0 <= guidance_scale <= 10.0):\n   788→                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n   789→            if seed is not None and not (-1 <= seed <= 2147483647):\n   790→                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n   791→\n   792→            data = {\n   793→                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n   794→                \"prompt\": prompt,\n   795→                \"image\": image,\n   796→                \"size\": \"adaptive\",\n   797→                \"response_format\": \"url\",\n   798→                \"watermark\": False,  # 正式版固定禁用水印\n   799→                \"guidance_scale\": guidance_scale,\n   800→            }\n   801→            if seed is not None:\n   802→                data[\"seed\"] = seed\n   803→            if reference_images:\n   804→                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n   805→\n   806→            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n   807→            response = self._safe_json_post(request_url, headers, data, timeout=60)\n   808→            result = self._handle_response(response)\n   809→            success = True\n   810→            elapsed = time.time() - start_time\n   811→            self._last_provider = \"legacy_v3\"\n   812→            self._last_endpoint = \"/images/generations\"\n   813→            self._log_seedream_event(\n   814→                \"image_to_image\",\n   815→                \"success\",\n   816→                \"legacy_v3\",\n   817→                \"/images/generations\",\n   818→                elapsed,\n   819→                False,\n   820→                None,\n   821→                {\"seed\": data.get(\"seed\")},\n   822→            )\n   823→            return result\n   824→        except AppError as e:\n   825→            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n   826→            err_msg = e.message\n   827→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   828→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   829→            raise\n   830→        except Exception as e:\n   831→            err_code = \"UNKNOWN_ERROR\"\n   832→            err_msg = str(e)\n   833→            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n   834→            logger.error(f\"图生图请求失败: {safe_msg}\")\n   835→            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n   836→        finally:\n   837→            elapsed = time.time() - start_time\n   838→            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n   839→\n   840→    def batch_text_to_image(\n   841→        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n   842→    ) -> List[Dict[str, Any]]:\n   843→        \"\"\"\n   844→        批量文生图：同时生成多张图片\n   845→\n   846→        Args:\n   847→            prompts: 提示词列表\n   848→            width: 图像宽度\n   849→            height: 图像高度\n   850→            guidance_scale: 提示词一致性\n   851→\n   852→        Returns:\n   853→            List[Dict]: 生成结果列表\n   854→        \"\"\"\n   855→        results = []\n   856→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   857→\n   858→        for i, prompt in enumerate(prompts, 1):\n   859→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   860→\n   861→            try:\n   862→                # 为每个任务生成不同的随机种子\n   863→                seed = random.randint(1, 2147483647)\n   864→\n   865→                result = self.text_to_image(\n   866→                    prompt=prompt, \n   867→                    width=width, \n   868→                    height=height, \n   869→                    guidance_scale=guidance_scale, \n   870→                    seed=seed\n   871→                )\n   872→\n   873→                results.append({\n   874→                    \"success\": True,\n   875→                    \"result\": result,\n   876→                    \"prompt\": prompt\n   877→                })\n   878→\n   879→            except Exception as e:\n   880→                # 避免在日志中显示过长的异常信息\n   881→                error_msg = str(e)\n   882→                if len(error_msg) > 200:\n   883→                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   884→                logger.error(f\"第{i}个任务失败: {error_msg}\")\n   885→                results.append({\n   886→                    \"success\": False,\n   887→                    \"error\": error_msg,\n   888→                    \"prompt\": prompt\n   889→                })\n   890→\n   891→            # 避免请求过于频繁\n   892→            if i < len(prompts):\n   893→                time.sleep(0.5)\n   894→\n   895→        success_count = sum(1 for r in results if r[\"success\"])\n   896→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   897→        return results\n   898→\n   899→    def validate_image_size(self, size: str) -> bool:\n   900→        \"\"\"\n   901→        验证图像尺寸是否支持\n   902→\n   903→        Args:\n   904→            size: 图像尺寸字符串，如 \"1024x1024\"\n   905→\n   906→        Returns:\n   907→            bool: 是否支持该尺寸\n   908→        \"\"\"\n   909→        try:\n   910→            # 解析尺寸字符串\n   911→            if 'x' not in size:\n   912→                return False\n   913→                \n   914→            width_str, height_str = size.split('x', 1)\n   915→            width = int(width_str)\n   916→            height = int(height_str)\n   917→            \n   918→            # 验证范围：Seedream 4.0 支持 512-4096像素\n   919→            return (512 <= width <= 4096) and (512 <= height <= 4096)\n   920→            \n   921→        except (ValueError, AttributeError):\n   922→            return False\n   923→\n   924→    def get_supported_sizes(self) -> List[str]:\n   925→        \"\"\"\n   926→        获取常用的图像尺寸列表\n   927→        \n   928→        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n   929→\n   930→        Returns:\n   931→            List[str]: 常用尺寸列表，包含官方推荐尺寸\n   932→        \"\"\"\n   933→        return [\n   934→            # 官方推荐尺寸 (Seedream 4.0)\n   935→            \"2048x2048\",   # 1:1 官方推荐\n   936→            \"2304x1728\",   # 4:3 官方推荐\n   937→            \"1728x2304\",   # 3:4 官方推荐\n   938→            \"2560x1440\",   # 16:9 官方推荐\n   939→            \"1440x2560\",   # 9:16 官方推荐\n   940→            \"2496x1664\",   # 3:2 官方推荐\n   941→            \"1664x2496\",   # 2:3 官方推荐\n   942→            \"3024x1296\",   # 21:9 官方推荐\n   943→            \n   944→            # 兼容性尺寸\n   945→            \"1920x1080\",   # 16:9 兼容\n   946→            \"1080x1920\",   # 9:16 兼容\n   947→            \"1536x1024\",   # 3:2 兼容\n   948→            \"1024x1536\",   # 2:3 兼容\n   949→            \"1512x648\",    # 21:9 兼容\n   950→            \"1280x720\",    # 16:9 小尺寸\n   951→            \"720x1280\",    # 9:16 小尺寸\n   952→            \"1024x1024\",   # 1:1 兼容\n   953→            \"768x768\",     # 1:1 小尺寸\n   954→            \"512x512\",     # 1:1 最小尺寸\n   955→        ]\n   956→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cdbd794e-ecc9-44e3-9ce8-18dbc77e4b35","timestamp":"2026-01-05T11:53:38.611Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py","content":"# Seedream图像生成客户端\n# 封装火山引擎Seedream3.0 API调用\n\nimport json\nimport os\nimport requests\nfrom requests.exceptions import Timeout, ReadTimeout, ConnectTimeout\nimport time\nimport random\nfrom typing import Dict, Any, Optional, List\nfrom pathlib import Path\nfrom loguru import logger\nfrom urllib3.util.retry import Retry\nfrom requests.adapters import HTTPAdapter\n\n# 导入配置管理器和错误处理\nfrom config.unified_config import get_unified_config\nfrom utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler, ErrorType\n\n\nclass SeedreamClient:\n    \"\"\"火山引擎Seedream图片生成客户端\n\n    提供文生图和图生图功能\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n        model_id: str = \"doubao-seedream-3-0-t2i-250415\",\n        timeout: int = 60,\n        max_retries: int = 3,\n    ):\n        \"\"\"初始化Seedream客户端\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n            base_url: API基础URL\n            timeout: 请求超时时间（秒）\n            max_retries: 最大重试次数\n        \"\"\"\n        # 获取API密钥\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise AppError(str(exc), ErrorType.AUTH_ERROR) from exc\n\n        self.api_key = api_key\n        self.base_url = base_url.rstrip(\"/\")\n        self.model_id = model_id or \"doubao-seedream-3-0-t2i-250415\"\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n        # 配置会话\n        self.session = requests.Session()\n\n        # 配置重试策略\n        retry_strategy = Retry(\n            total=max_retries,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n            backoff_factor=1\n        )\n\n        adapter = HTTPAdapter(max_retries=retry_strategy)\n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        logger.info(\"Seedream客户端初始化完成\")\n\n        # 初始化性能监控与错误缓存（统一结构）\n        self._performance_stats = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"total_response_time\": 0.0,\n            \"last_request_time\": None,\n        }\n        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n        self._last_provider: Optional[str] = None\n        self._last_endpoint: Optional[str] = None\n\n    def _encode_image(self, image_path: str) -> str:\n        \"\"\"将图像文件编码为base64字符串\n        \n        Args:\n            image_path: 图像文件路径\n            \n        Returns:\n            base64编码的图像字符串\n        \"\"\"\n        import base64\n        \n        try:\n            with open(image_path, 'rb') as image_file:\n                image_data = image_file.read()\n                base64_string = base64.b64encode(image_data).decode('utf-8')\n                return base64_string\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图像编码失败: {error_msg}\")\n            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorType.FILE_ERROR)\n\n    def _get_headers(self) -> Dict[str, str]:\n        \"\"\"获取请求头\"\"\"\n        # 验证API密钥，防止尺寸配置被错误使用\n        api_key = str(self.api_key).strip()\n\n        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n        try:\n            api_key.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n\n        # 检查是否包含尺寸信息或换行符\n        if any(indicator in api_key for indicator in [\"x\", \":\", \"\\n\", \"2048\", \"1024\", \"1:1\", \"4:3\", \"16:9\"]):\n            raise ValueError(f\"API密钥格式错误，包含尺寸配置信息: {api_key[:50]}...\")\n\n        # 检查API密钥长度\n        if len(api_key) < 10 or len(api_key) > 200:\n            raise ValueError(f\"API密钥长度异常: {len(api_key)} 字符\")\n        \n        return {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"User-Agent\": \"Seedream-Client/1.0.0\",\n        }\n\n    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout: int = 60):\n        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\n\n        注意：当 timeout > 120 时，使用独立的 requests.post() 而不是 session.post()。\n        这是因为 Session 配置了 Retry 策略，会在超时后自动重试，导致：\n        1. 实际等待时间 = timeout × (1 + retry_count)，可能长达数十分钟\n        2. 重试期间没有日志输出，用户看起来像\"卡住\"\n\n        对于组图等长时间请求，我们需要精确控制超时，不希望自动重试。\n        \"\"\"\n        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n        start = time.time()\n\n        # 长超时请求（组图模式）：绕过 Session 重试机制\n        if timeout > 120:\n            logger.info(f\"[HTTP POST] 长时间请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s (无重试)\")\n            try:\n                # 直接使用 requests.post，不经过 session 的重试策略\n                resp = requests.post(url, headers=headers, data=body, timeout=(30, timeout))\n                elapsed = time.time() - start\n                logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n                return resp\n            except Exception as e:\n                elapsed = time.time() - start\n                logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n                raise\n\n        # 普通请求：使用 session（带重试机制）\n        logger.info(f\"[HTTP POST] 开始请求 size={len(body)/1024/1024:.2f}MB timeout={timeout}s\")\n        try:\n            resp = self.session.post(url, headers=headers, data=body, timeout=(30, timeout))\n            elapsed = time.time() - start\n            logger.info(f\"[HTTP POST] 请求完成 elapsed={elapsed:.1f}s status={resp.status_code}\")\n            return resp\n        except Exception as e:\n            elapsed = time.time() - start\n            logger.error(f\"[HTTP POST] 请求异常 elapsed={elapsed:.1f}s error={type(e).__name__}: {e}\")\n            raise\n\n    def _is_large_size(self, size: str) -> bool:\n        \"\"\"判断是否是 v4.5 大尺寸（超过 v3 的 2048 限制）\"\"\"\n        if not size:\n            return False\n        try:\n            if \"x\" in size.lower():\n                w, h = size.lower().split(\"x\")\n                return int(w) > 2048 or int(h) > 2048\n            # 处理 2K/4K 格式\n            if size.upper() in (\"2K\", \"4K\"):\n                return True\n        except Exception:\n            pass\n        return False\n\n    def _provider_enabled(self) -> bool:\n        try:\n            import os\n            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n            return v not in {\"0\", \"false\", \"no\"}\n        except Exception:\n            return True\n\n    def _get_seedream_provider_order(self, preferred_provider: Optional[str] = None) -> List[str]:\n        \"\"\"计算 Seedream provider 调用顺序。\n\n        规则：\n        - 优先使用调用方传入的 preferred_provider（并发安全）\n        - 其次允许通过环境变量 GEMENG_SEEDREAM_PROVIDER 启动覆盖（只读）\n        - 最后兜底 volc_v3\n        \"\"\"\n        order: List[str] = []\n\n        candidates: List[Optional[str]] = []\n        if preferred_provider:\n            candidates.append(preferred_provider)\n        try:\n            candidates.append(os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\"))\n        except Exception:\n            candidates.append(None)\n\n        for candidate in candidates:\n            if not candidate:\n                continue\n            name = candidate.strip().lower()\n            if not name:\n                continue\n            if name not in order:\n                order.append(name)\n\n        if \"volc_v3\" not in order:\n            order.append(\"volc_v3\")\n        return order\n\n    def _call_seedream_provider(\n        self,\n        headers: Dict[str, str],\n        mapper,\n        operation: str,\n        preferred_provider: Optional[str] = None,\n    ):\n        from modules.provider.factory import get_default_provider\n        default_endpoint = \"/images/generations\"\n        base_url = self.base_url.rstrip(\"/\")\n        first_choice = None\n        last_error: Optional[BaseException] = None\n        order = self._get_seedream_provider_order(preferred_provider)\n        if order:\n            first_choice = order[0]\n        for idx, name in enumerate(order):\n            try:\n                provider = get_default_provider(name)\n            except Exception as e:\n                logger.warning(f\"Seedream provider加载失败: {name} ({e})\")\n                last_error = e\n                continue\n            try:\n                mapped = mapper(provider)\n                if not isinstance(mapped, tuple):\n                    raise ValueError(\"provider mapper 返回值异常\")\n                if len(mapped) == 4:\n                    payload, fb, reason, endpoint = mapped\n                elif len(mapped) == 3:\n                    payload, fb, reason = mapped\n                    endpoint = default_endpoint\n                else:\n                    raise ValueError(\"provider mapper 返回值长度不受支持\")\n            except Exception as e:\n                logger.warning(f\"Seedream provider参数映射失败: {name} ({e})\")\n                last_error = e\n                continue\n            start_time = time.time()\n            try:\n                endpoint_path = endpoint or default_endpoint\n                if isinstance(endpoint_path, str) and endpoint_path.startswith(\"http\"):\n                    request_url = endpoint_path\n                else:\n                    normalized = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                    if not normalized.startswith(\"/\"):\n                        normalized = f\"/{normalized}\"\n                    request_url = f\"{base_url}{normalized}\"\n\n                # 动态超时：组图模式需要更长时间\n                # 实测：5 张 4096x4096 约需 8 分钟（458 秒）\n                timeout = 120\n                seq_options = payload.get(\"sequential_image_generation_options\")\n                max_images = seq_options.get(\"max_images\", 1) if seq_options else 1\n                if max_images > 1:\n                    # 组图模式：基础 120 秒 + 每张图 60 秒，最大 20 分钟\n                    # 实测：15 张 4096x4096 约需 14.5 分钟（869 秒）\n                    timeout = min(120 + max_images * 60, 1200)\n                    logger.info(f\"组图模式: {max_images} 张图，超时设置为 {timeout} 秒\")\n\n                response = self._safe_json_post(request_url, headers, payload, timeout=timeout)\n                result = self._handle_response(response)\n                elapsed = time.time() - start_time\n                if idx > 0 and first_choice:\n                    logger.warning(f\"Seedream provider {first_choice} 回退至 {name}\")\n                if fb and reason:\n                    logger.warning(f\"参数回退: {reason}\")\n                logger.info(\n                    f\"摘要|operation={operation}_provider provider={name} endpoint={endpoint_path} elapsed={elapsed:.2f}s fallback={'yes' if fb else 'no'}\"\n                )\n                self._last_provider = name\n                self._last_endpoint = endpoint_path if isinstance(endpoint_path, str) else default_endpoint\n                return result, payload, endpoint_path, name, fb, reason, elapsed\n            except AppError as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求失败: {e.message}\")\n                # v4.5 特有功能失败时不回退到 v3（参数不兼容）\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        logger.error(f\"v4.5 特有功能失败，不回退: {e.message}\")\n                        raise\n                continue\n            except (Timeout, ReadTimeout, ConnectTimeout) as e:\n                elapsed = time.time() - start_time\n                last_error = e\n                logger.error(f\"Seedream provider {name} 请求超时 ({elapsed:.1f}s): {e}\")\n                # v4.5 特有功能超时时直接报错，不回退\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        raise AppError(\n                            f\"组图生成超时 ({elapsed:.0f}秒)，请减少生成数量或稍后重试\",\n                            ErrorType.NETWORK_ERROR\n                        )\n                continue\n            except Exception as e:\n                last_error = e\n                logger.warning(f\"Seedream provider {name} 请求异常: {e}\")\n                # v4.5 特有功能异常时也不回退\n                if name in (\"volc_v4_5\", \"volcengine_v4_5\"):\n                    is_v45_feature = (\n                        payload.get(\"sequential_image_generation\") == \"auto\"\n                        or self._is_large_size(payload.get(\"size\", \"\"))\n                    )\n                    if is_v45_feature:\n                        logger.error(f\"v4.5 特有功能异常，不回退: {e}\")\n                        raise\n                continue\n        raise last_error or RuntimeError(\"Seedream provider 调用失败\")\n\n    def _log_seedream_event(\n        self,\n        operation: str,\n        status: str,\n        provider: Optional[str],\n        endpoint: Optional[str],\n        elapsed: float,\n        fallback_applied: bool,\n        fallback_reason: Optional[str] = None,\n        extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        try:\n            provider_name = provider or \"unknown\"\n            endpoint_text = endpoint or \"/images/generations\"\n            parts = [\n                f\"operation={operation}\",\n                f\"status={status}\",\n                f\"provider={provider_name}\",\n                f\"endpoint={endpoint_text}\",\n                f\"elapsed={elapsed:.2f}s\",\n                f\"fallback={'yes' if fallback_applied else 'no'}\",\n            ]\n            if fallback_applied and fallback_reason:\n                safe_reason = str(fallback_reason)\n                if len(safe_reason) > 120:\n                    safe_reason = safe_reason[:120] + \"...\"\n                parts.append(f\"fallback_reason={safe_reason}\")\n            if extra:\n                for key, value in extra.items():\n                    if value is None:\n                        continue\n                    parts.append(f\"{key}={value}\")\n            logger.info(\"摘要|\" + \" \".join(parts))\n        except Exception:\n            # 保证日志逻辑不会影响主流程\n            pass\n\n    @staticmethod\n    def _wrap_base64_as_data_url(b64_data: str, path_hint: Optional[str] = None) -> str:\n        mime = \"image/png\"\n        try:\n            if path_hint:\n                suffix = Path(path_hint).suffix.lower()\n                if suffix in {\".jpg\", \".jpeg\"}:\n                    mime = \"image/jpeg\"\n                elif suffix == \".webp\":\n                    mime = \"image/webp\"\n                elif suffix == \".bmp\":\n                    mime = \"image/bmp\"\n                elif suffix == \".gif\":\n                    mime = \"image/gif\"\n        except Exception:\n            pass\n        return f\"data:{mime};base64,{b64_data}\"\n\n    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:\n        \"\"\"处理API响应\n\n        Args:\n            response: HTTP响应对象\n\n        Returns:\n            解析后的响应数据\n\n        Raises:\n            AppError: 当API返回错误时\n        \"\"\"\n        try:\n            if not response.ok:\n                try:\n                    error_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n                except Exception:\n                    error_text = str(response.content[:500])\n                # 避免在日志中显示可能包含base64数据的完整响应\n                if len(error_text) > 500:\n                    error_summary = error_text[:500] + \"...[响应过长，已截断]\"\n                else:\n                    error_summary = error_text\n                logger.error(f\"API请求失败 - 状态码: {response.status_code}, 响应: {error_summary}\")\n                raise AppError(\n                    f\"API请求失败 (状态码: {response.status_code}): {error_summary}\",\n                    ErrorType.API_ERROR,\n                    {\"status_code\": response.status_code, \"response_text\": error_summary}\n                )\n\n            # 解析响应（增强容错：包括编码问题回退）\n            try:\n                result = response.json()\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                raw = response.content or b\"\"\n                tried = set()\n                result = None\n                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                    if not enc or enc in tried:\n                        continue\n                    tried.add(enc)\n                    try:\n                        text = raw.decode(enc, errors=\"strict\")\n                        result = json.loads(text)\n                        logger.debug(f\"Seedream _handle_response - 通过备用编码解析成功: {enc}\")\n                        break\n                    except Exception:\n                        continue\n                if result is None:\n                    try:\n                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                    except Exception:\n                        preview = str(raw[:200])\n                    logger.error(f\"Seedream _handle_response - JSON解析失败(编码问题): {preview}\")\n                    raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n\n            # OpenAI格式的响应检查\n            if \"data\" not in result:\n                error_msg = result.get(\"error\", {}).get(\"message\", \"未知错误\")\n                logger.error(f\"Seedream API错误: {error_msg}\")\n                raise AppError(\n                    f\"API错误: {error_msg}\",\n                    ErrorType.API_ERROR,\n                    {\"response_data\": result},\n                )\n\n            # 转换为统一格式，只保留URL数据，避免base64数据造成终端乱码\n            images = []\n            for item in result[\"data\"]:\n                if \"url\" in item:\n                    images.append({\n                        \"url\": item[\"url\"]\n                        # 注意：不再包含b64_json字段，避免base64数据在日志中显示造成乱码\n                    })\n\n            # 调试日志：输出组图返回的图片数量\n            logger.debug(f\"API 返回 {len(images)} 张图片\")\n\n            return {\n                \"code\": 200,\n                \"message\": \"success\",\n                \"data\": {\n                    \"images\": images\n                },\n                \"created\": result.get(\"created\"),\n                \"usage\": result.get(\"usage\", {})\n            }\n\n        except requests.exceptions.RequestException as e:\n            raise ErrorHandler.handle_network_error(e, \"火山引擎Seedream\")\n        except json.JSONDecodeError as e:\n            raise ErrorHandler.handle_unknown_error(e, \"火山引擎Seedream响应解析\")\n\n    def _record_request_stats(\n        self,\n        operation: str,\n        success: bool,\n        response_time: float,\n        error_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n    ) -> None:\n        \"\"\"记录统一性能统计并缓存最近错误摘要（不含敏感详情）。\"\"\"\n        try:\n            self._performance_stats[\"total_requests\"] += 1\n            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n            self._performance_stats[\"last_request_time\"] = time.time()\n            if success:\n                self._performance_stats[\"successful_requests\"] += 1\n            else:\n                self._performance_stats[\"failed_requests\"] += 1\n                if error_code or error_message:\n                    self._last_error = {\"code\": error_code, \"message\": str(error_message)[:200]}\n\n            # 调试日志（安全版）\n            total = max(1, self._performance_stats[\"total_requests\"])\n            avg = self._performance_stats[\"total_response_time\"] / total\n            succ = self._performance_stats[\"successful_requests\"]\n            success_rate = (succ / total) * 100.0\n            logger.debug(\n                f\"{operation} 统计: 响应时间={response_time:.2f}s, 平均={avg:.2f}s, 成功率={success_rate:.1f}%\"\n            )\n        except Exception:\n            # 统计不应影响业务流程\n            pass\n\n    def get_performance_stats(self) -> Dict[str, Any]:\n        \"\"\"获取统一性能统计（字段统一）。\"\"\"\n        stats = dict(self._performance_stats)\n        total = stats.get(\"total_requests\", 0) or 0\n        if total > 0:\n            avg = stats.get(\"total_response_time\", 0.0) / total\n            success_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n        else:\n            avg = 0.0\n            success_rate = 0.0\n        return {\n            \"total_requests\": total,\n            \"successful_requests\": stats.get(\"successful_requests\", 0),\n            \"failed_requests\": stats.get(\"failed_requests\", 0),\n            \"avg_response_time\": avg,\n            \"success_rate\": success_rate,\n            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n        }\n\n    def dump_metrics(self) -> Dict[str, Any]:\n        \"\"\"导出诊断可读的统一指标。\"\"\"\n        m = self.get_performance_stats()\n        m.update({\n            \"client\": \"Seedream\",\n            \"model\": self.model_id,\n            \"base_url\": self.base_url,\n        })\n        return m\n\n    def last_provider(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 provider 名称。\"\"\"\n        return self._last_provider\n\n    def last_endpoint(self) -> Optional[str]:\n        \"\"\"返回最近一次成功调用所使用的 endpoint。\"\"\"\n        return self._last_endpoint\n\n    @error_handler(\"Seedream文生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[Any]] = None,\n        n: int = 1,\n        sequential_mode: bool = False,\n        seedream_provider: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        文生图API调用\n\n        Args:\n            prompt: 图片描述提示词\n            size: 图像尺寸，支持的尺寸见get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            n: 生成图片数量，组图模式下生效（1-15）\n            sequential_mode: 是否启用组图模式\n            response_format: 返回格式，\"url\"或\"b64_json\"\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送文生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import TextToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_t2i(TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=reference_images or [],\n                        sequential_mode=sequential_mode,\n                        count=n\n                    )),\n                    \"text_to_image\",\n                    preferred_provider=seedream_provider,\n                )\n                self._log_seedream_event(\n                    \"text_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"text_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not self.validate_image_size(size):\n                raise AppError(f\"不支持的图像尺寸: {size}\", ErrorType.VALIDATION_ERROR)\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seedream-3-0-t2i-250415\",\n                \"prompt\": prompt,\n                \"size\": size,\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n\n            if reference_images:\n                images_payload = []\n                for item in reference_images:\n                    try:\n                        if isinstance(item, str):\n                            if item.startswith(\"data:image/\"):\n                                images_payload.append(item)\n                                continue\n                            p = Path(item)\n                            if p.exists():\n                                encoded = self._encode_image(str(p))\n                                images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                            elif item.startswith(\"http://\") or item.startswith(\"https://\"):\n                                images_payload.append(item)\n                        elif isinstance(item, dict):\n                            payload = item.get('_payload_b64') or item.get('data') or item.get('value')\n                            path_hint = item.get('path') or item.get('source')\n                            if payload:\n                                images_payload.append(self._wrap_base64_as_data_url(payload, path_hint))\n                            else:\n                                path_val = item.get('path')\n                                if path_val:\n                                    p = Path(path_val)\n                                    if p.exists():\n                                        encoded = self._encode_image(str(p))\n                                        images_payload.append(self._wrap_base64_as_data_url(encoded, str(p)))\n                    except Exception as exc:\n                        logger.warning(f\"参考图处理失败: {exc}\")\n                if images_payload:\n                    data[\"image\"] = images_payload if len(images_payload) > 1 else images_payload[0]\n                    data[\"sequential_image_generation\"] = \"disabled\"\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"text_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"size\": data.get(\"size\"), \"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"文生图请求失败: {safe_msg}\")\n            raise Exception(f\"文生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"text_to_image\", success, elapsed, err_code, err_msg)\n\n    @error_handler(\"Seedream图生图\")\n    @RetryHandler.retry_on_error(max_retries=3, delay=1.0)\n    def image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n        seedream_provider: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        图生图API调用\n\n        Args:\n            prompt: 图片编辑提示词\n            image: 输入图像URL或Base64编码\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，-1表示随机\n            reference_images: 参考图列表（路径或URL），最多10张\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            reference_images: 额外参考图（base64/url），Seedream 4.0 多参考图\n\n        Returns:\n            API响应结果\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        headers = self._get_headers()\n\n        logger.info(f\"发送图生图请求: {prompt[:50]}...\")\n\n        if self._provider_enabled():\n            try:\n                from modules.provider.schema import ImageToImageParams\n\n                result, data, endpoint_used, provider_used, fallback_applied, fallback_reason, response_time = self._call_seedream_provider(\n                    headers,\n                    lambda provider: provider.map_i2i(ImageToImageParams(\n                        prompt=prompt,\n                        image=image,\n                        guidance_scale=guidance_scale,\n                        seed=(None if (seed is None or seed == -1) else seed),\n                        reference_images=(reference_images or []),\n                    )),\n                    \"image_to_image\",\n                    preferred_provider=seedream_provider,\n                )\n                self._log_seedream_event(\n                    \"image_to_image\",\n                    \"success\",\n                    provider_used,\n                    endpoint_used,\n                    response_time,\n                    fallback_applied,\n                    fallback_reason,\n                    {\"seed\": data.get(\"seed\")},\n                )\n                self._record_request_stats(\"image_to_image\", True, response_time, None, None)\n                return result\n            except Exception as provider_exc:\n                logger.warning(f\"Seedream provider 路径失败，回退旧逻辑: {provider_exc}\")\n\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        start_time = time.time()\n        try:\n            if not (1.0 <= guidance_scale <= 10.0):\n                raise AppError(f\"guidance_scale必须在1.0-10.0范围内，当前值: {guidance_scale}\", ErrorType.VALIDATION_ERROR)\n            if seed is not None and not (-1 <= seed <= 2147483647):\n                raise AppError(f\"seed必须在-1到2147483647范围内，当前值: {seed}\", ErrorType.VALIDATION_ERROR)\n\n            data = {\n                \"model\": \"doubao-seededit-3-0-i2i-250628\",\n                \"prompt\": prompt,\n                \"image\": image,\n                \"size\": \"adaptive\",\n                \"response_format\": \"url\",\n                \"watermark\": False,  # 正式版固定禁用水印\n                \"guidance_scale\": guidance_scale,\n            }\n            if seed is not None:\n                data[\"seed\"] = seed\n            if reference_images:\n                logger.warning(\"Seedream 3.x 路径不支持多参考图，已忽略 reference_images\")\n\n            request_url = f\"{self.base_url.rstrip('/')}/images/generations\"\n            response = self._safe_json_post(request_url, headers, data, timeout=60)\n            result = self._handle_response(response)\n            success = True\n            elapsed = time.time() - start_time\n            self._last_provider = \"legacy_v3\"\n            self._last_endpoint = \"/images/generations\"\n            self._log_seedream_event(\n                \"image_to_image\",\n                \"success\",\n                \"legacy_v3\",\n                \"/images/generations\",\n                elapsed,\n                False,\n                None,\n                {\"seed\": data.get(\"seed\")},\n            )\n            return result\n        except AppError as e:\n            err_code = getattr(e, \"error_type\", ErrorType.API_ERROR).value\n            err_msg = e.message\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise\n        except Exception as e:\n            err_code = \"UNKNOWN_ERROR\"\n            err_msg = str(e)\n            safe_msg = (err_msg[:200] + \"...[错误信息过长，已截断]\") if err_msg and len(err_msg) > 200 else err_msg\n            logger.error(f\"图生图请求失败: {safe_msg}\")\n            raise Exception(f\"图生图API调用失败: {safe_msg}\")\n        finally:\n            elapsed = time.time() - start_time\n            self._record_request_stats(\"image_to_image\", success, elapsed, err_code, err_msg)\n\n    def batch_text_to_image(\n        self, prompts: List[str], width: int = 1024, height: int = 1024, guidance_scale: float = 2.5\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量文生图：同时生成多张图片\n\n        Args:\n            prompts: 提示词列表\n            width: 图像宽度\n            height: 图像高度\n            guidance_scale: 提示词一致性\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        results = []\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            try:\n                # 为每个任务生成不同的随机种子\n                seed = random.randint(1, 2147483647)\n\n                result = self.text_to_image(\n                    prompt=prompt, \n                    width=width, \n                    height=height, \n                    guidance_scale=guidance_scale, \n                    seed=seed\n                )\n\n                results.append({\n                    \"success\": True,\n                    \"result\": result,\n                    \"prompt\": prompt\n                })\n\n            except Exception as e:\n                # 避免在日志中显示过长的异常信息\n                error_msg = str(e)\n                if len(error_msg) > 200:\n                    error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                logger.error(f\"第{i}个任务失败: {error_msg}\")\n                results.append({\n                    \"success\": False,\n                    \"error\": error_msg,\n                    \"prompt\": prompt\n                })\n\n            # 避免请求过于频繁\n            if i < len(prompts):\n                time.sleep(0.5)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n        return results\n\n    def validate_image_size(self, size: str) -> bool:\n        \"\"\"\n        验证图像尺寸是否支持\n\n        Args:\n            size: 图像尺寸字符串，如 \"1024x1024\"\n\n        Returns:\n            bool: 是否支持该尺寸\n        \"\"\"\n        try:\n            # 解析尺寸字符串\n            if 'x' not in size:\n                return False\n                \n            width_str, height_str = size.split('x', 1)\n            width = int(width_str)\n            height = int(height_str)\n            \n            # 验证范围：Seedream 4.0 支持 512-4096像素\n            return (512 <= width <= 4096) and (512 <= height <= 4096)\n            \n        except (ValueError, AttributeError):\n            return False\n\n    def get_supported_sizes(self) -> List[str]:\n        \"\"\"\n        获取常用的图像尺寸列表\n        \n        注意：Seedream 4.0 支持更大尺寸范围，实际支持512x512到4096x4096范围内的所有尺寸\n\n        Returns:\n            List[str]: 常用尺寸列表，包含官方推荐尺寸\n        \"\"\"\n        return [\n            # 官方推荐尺寸 (Seedream 4.0)\n            \"2048x2048\",   # 1:1 官方推荐\n            \"2304x1728\",   # 4:3 官方推荐\n            \"1728x2304\",   # 3:4 官方推荐\n            \"2560x1440\",   # 16:9 官方推荐\n            \"1440x2560\",   # 9:16 官方推荐\n            \"2496x1664\",   # 3:2 官方推荐\n            \"1664x2496\",   # 2:3 官方推荐\n            \"3024x1296\",   # 21:9 官方推荐\n            \n            # 兼容性尺寸\n            \"1920x1080\",   # 16:9 兼容\n            \"1080x1920\",   # 9:16 兼容\n            \"1536x1024\",   # 3:2 兼容\n            \"1024x1536\",   # 2:3 兼容\n            \"1512x648\",    # 21:9 兼容\n            \"1280x720\",    # 16:9 小尺寸\n            \"720x1280\",    # 9:16 小尺寸\n            \"1024x1024\",   # 1:1 兼容\n            \"768x768\",     # 1:1 小尺寸\n            \"512x512\",     # 1:1 最小尺寸\n        ]\n","numLines":956,"startLine":1,"totalLines":956}}}
{"parentUuid":"cdbd794e-ecc9-44e3-9ce8-18dbc77e4b35","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016Z1sQcPYxBJ8myKwnUE4Ze","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config.unified_config import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        storage_dir = get_storage_dir()\n    59→        if not storage_dir:\n    60→            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n    61→        self.storage_manager = get_v2_storage_manager(storage_dir)\n    62→        \n    63→        # 保持兼容性别名\n    64→        self.file_manager = self.storage_manager\n    65→        self.metadata_manager = self.storage_manager\n    66→        self.image_storage_manager = self.storage_manager\n    67→        \n    68→        # 保留原有的目录属性以保持兼容性\n    69→        self.data_dir = Path(self.storage_manager.root_path)\n    70→        self.images_dir = self.data_dir / \"images\"\n    71→        self.metadata_dir = self.data_dir / \"metadata\"\n    72→\n    73→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    74→\n    75→    def generate_text_to_image(\n    76→        self,\n    77→        prompt: str,\n    78→        size: str = \"1024x1024\",\n    79→        guidance_scale: float = 2.5,\n    80→        seed: int = -1,\n    81→        save_local: bool = True,\n    82→        reference_images: Optional[List[Any]] = None,\n    83→        model_variant: Optional[str] = None,\n    84→        generation_id: Optional[str] = None,\n    85→        count: int = 1,\n    86→        sequential_mode: bool = False,\n    87→        derived_ids: Optional[List[str]] = None,\n    88→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    89→    ) -> Dict[str, Any]:\n    90→        \"\"\"\n    91→        生成文生图并保存到本地\n    92→\n    93→        Args:\n    94→            prompt: 图像生成提示词\n    95→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    96→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    97→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    98→            response_format: 返回格式，\"url\"或\"b64_json\"\n    99→            save_local: 是否保存到本地\n   100→            reference_images: 参考图列表\n   101→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   102→            count: 生成图片数量（组图模式下生效）\n   103→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   104→            derived_ids: 组图生成的ID列表（用于关联）\n   105→\n   106→        Returns:\n   107→            Dict: 生成结果，包含本地文件路径\n   108→\n   109→        Note:\n   110→            model和watermark参数已固定，不再需要前端控制\n   111→        \"\"\"\n   112→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   113→\n   114→        # 根据 model_variant 选择 provider（并发安全：不写 env）\n   115→        seedream_provider: Optional[str] = None\n   116→        try:\n   117→            mv = (model_variant or \"\").strip().lower()\n   118→            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n   119→                seedream_provider = \"volc_v4\"\n   120→            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n   121→                seedream_provider = \"volc_v4_5\"\n   122→            elif mv.startswith(\"volc_\"):\n   123→                seedream_provider = mv\n   124→        except Exception:\n   125→            seedream_provider = None\n   126→\n   127→        # 生成唯一ID，优先使用外部传入的generation_id\n   128→        task_id = generation_id or str(uuid.uuid4())\n   129→\n   130→        ref_assets: List[Dict[str, Any]] = []\n   131→        ref_paths: List[str] = []\n   132→        ref_summary: Dict[str, Any] = {}\n   133→        ref_payloads: List[str] = []\n   134→\n   135→        try:\n   136→            if reference_images:\n   137→                ref_summary = self._process_reference_assets(\n   138→                    reference_images,\n   139→                    max_refs=MAX_REFERENCE_IMAGES,\n   140→                    expected_outputs=1,\n   141→                )\n   142→                ref_assets = list(ref_summary.get('assets', []))\n   143→                ref_paths = list(ref_summary.get('paths', []))\n   144→                ref_payloads = self._build_reference_payloads(ref_assets)\n   145→\n   146→                if ref_summary.get('errors'):\n   147→                    logger.warning(\n   148→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   149→                    )\n   150→                if ref_summary.get('warnings'):\n   151→                    for warn in ref_summary['warnings']:\n   152→                        logger.warning(f\"参考图提示: {warn}\")\n   153→\n   154→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   155→            try:\n   156→                norm, fb, reason = validate_and_normalize_t2i(\n   157→                    TextToImageParams(\n   158→                        prompt=prompt,\n   159→                        size=size,\n   160→                        guidance_scale=guidance_scale,\n   161→                        seed=(None if seed == -1 else seed),\n   162→                    )\n   163→                )\n   164→                logger.info(\n   165→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   166→                )\n   167→                if fb:\n   168→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   169→            except Exception as _e:\n   170→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   171→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   172→            actual_count = max(1, count)\n   173→            use_group_mode = bool(sequential_mode and actual_count > 1)\n   174→\n   175→            api_result = self.client.text_to_image(\n   176→                prompt=prompt,\n   177→                size=size,\n   178→                guidance_scale=guidance_scale,\n   179→                seed=seed,\n   180→                reference_images=ref_payloads or None,\n   181→                n=actual_count if use_group_mode else 1,\n   182→                sequential_mode=sequential_mode,\n   183→                seedream_provider=seedream_provider,\n   184→            )\n   185→\n   186→            # 组图模式：API 返回多张图，需要逐一保存\n   187→            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n   188→            images_count = len(images_list)\n   189→            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n   190→\n   191→            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n   192→            if use_group_mode and images_count < actual_count:\n   193→                logger.warning(\n   194→                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n   195→                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n   196→                )\n   197→\n   198→            if use_group_mode and images_count > 1:\n   199→                results_batch = []\n   200→                success_count = 0\n   201→                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n   202→                total_images = len(images_list)\n   203→\n   204→                for idx, img_data in enumerate(images_list):\n   205→                    # 发送下载进度（每张图开始下载时）\n   206→                    if progress_callback:\n   207→                        try:\n   208→                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n   209→                        except Exception:\n   210→                            pass\n   211→\n   212→                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n   213→                    per_result = {\n   214→                        \"task_id\": per_id,\n   215→                        \"success\": True,\n   216→                        \"type\": \"text_to_image\",\n   217→                        \"prompt\": prompt,\n   218→                        \"image_url\": img_data[\"url\"],\n   219→                        \"parameters\": {\n   220→                            \"size\": size,\n   221→                            \"guidance_scale\": guidance_scale,\n   222→                            \"seed\": seed,\n   223→                            \"response_format\": \"url\",\n   224→                            \"watermark\": False,\n   225→                            \"model\": self._resolve_model_id(\n   226→                                \"doubao-seedream-3-0-t2i-250415\",\n   227→                                \"doubao-seedream-4-0-250828\",\n   228→                                \"doubao-seedream-4-5-251128\",\n   229→                            ),\n   230→                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   231→                            \"sequential_mode\": True,\n   232→                            \"group_index\": idx + 1,\n   233→                            \"group_total\": total_images,\n   234→                        },\n   235→                        \"created_at\": datetime.now().isoformat(),\n   236→                        \"usage\": api_result.get(\"usage\", {}),\n   237→                    }\n   238→\n   239→                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   240→                    if sanitized_refs:\n   241→                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   242→                        per_result[\"reference_assets\"] = sanitized_refs\n   243→\n   244→                    if save_local and per_result.get(\"image_url\"):\n   245→                        local_result = self._save_image_locally(per_result)\n   246→                        per_result.update(local_result)\n   247→                        if not local_result.get('local_save_error'):\n   248→                            success_count += 1\n   249→\n   250→                    results_batch.append(per_result)\n   251→\n   252→                    # 发送下载完成进度\n   253→                    if progress_callback:\n   254→                        try:\n   255→                            progress_callback(idx + 1, total_images, per_result)\n   256→                        except Exception:\n   257→                            pass\n   258→\n   259→                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n   260→                return {\n   261→                    \"batch\": True,\n   262→                    \"results\": results_batch,\n   263→                    \"success_count\": success_count,\n   264→                    \"total_count\": len(results_batch),\n   265→                    \"derived_ids\": group_ids,\n   266→                }\n   267→\n   268→            # 单图模式（默认）\n   269→            result = {\n   270→                \"task_id\": task_id,\n   271→                \"success\": True,\n   272→                \"type\": \"text_to_image\",\n   273→                \"prompt\": prompt,\n   274→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   275→                \"parameters\": {\n   276→                    \"size\": size,\n   277→                    \"guidance_scale\": guidance_scale,\n   278→                    \"seed\": seed,\n   279→                    \"response_format\": \"url\",  # 固定值\n   280→                    \"watermark\": False,  # 固定值\n   281→                    \"model\": self._resolve_model_id(\n   282→                        \"doubao-seedream-3-0-t2i-250415\",\n   283→                        \"doubao-seedream-4-0-250828\",\n   284→                        \"doubao-seedream-4-5-251128\",\n   285→                    ),\n   286→                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n   287→                },\n   288→                \"created_at\": datetime.now().isoformat(),\n   289→                \"usage\": api_result.get(\"usage\", {}),\n   290→            }\n   291→\n   292→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   293→            if sanitized_refs:\n   294→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   295→                result[\"reference_assets\"] = sanitized_refs\n   296→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   297→                logger.info(\n   298→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   299→                    len(sanitized_refs),\n   300→                    masked_ids or \"-\",\n   301→                    self._provider_used(),\n   302→                )\n   303→            else:\n   304→                result[\"parameters\"][\"reference_assets\"] = []\n   305→                result[\"reference_assets\"] = []\n   306→\n   307→            # 保存到本地\n   308→            if save_local and result.get(\"image_url\"):\n   309→                local_result = self._save_image_locally(result)\n   310→                result.update(local_result)\n   311→                if local_result.get('local_save_error') and sanitized_refs:\n   312→                    self._cleanup_reference_paths(ref_paths)\n   313→                    result[\"parameters\"][\"reference_assets\"] = []\n   314→                    result[\"reference_assets\"] = []\n   315→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   316→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   317→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   318→\n   319→            logger.success(f\"文生图任务完成: {task_id}\")\n   320→            return result\n   321→\n   322→        except Exception as e:\n   323→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   324→            self._cleanup_reference_paths(ref_paths)\n   325→            return {\n   326→                \"task_id\": task_id,\n   327→                \"success\": False,\n   328→                \"error\": str(e),\n   329→                \"type\": \"text_to_image\"\n   330→            }\n   331→\n   332→    def generate_image_to_image(\n   333→        self,\n   334→        prompt: str,\n   335→        image: str,\n   336→        guidance_scale: float = 5.5,\n   337→        seed: int = -1,\n   338→        save_local: bool = True,\n   339→        reference_images: Optional[List[Any]] = None,\n   340→        generation_id: Optional[str] = None,\n   341→    ) -> Dict[str, Any]:\n   342→        \"\"\"\n   343→        生成图生图并保存到本地\n   344→\n   345→        Args:\n   346→            prompt: 编辑提示词\n   347→            image_path: 原始图像路径（本地路径或URL）\n   348→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   349→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   350→            response_format: 返回格式，\"url\"或\"b64_json\"\n   351→            save_local: 是否保存到本地\n   352→\n   353→        Returns:\n   354→            Dict: 生成结果\n   355→        \n   356→        Note:\n   357→            model、size、watermark参数已固定，不再需要前端控制\n   358→        \"\"\"\n   359→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   360→\n   361→        # 生成唯一ID，优先使用外部传入的generation_id\n   362→        task_id = generation_id or str(uuid.uuid4())\n   363→\n   364→        ref_paths: List[str] = []\n   365→\n   366→        try:\n   367→            # 处理输入图像\n   368→            image_data = self._prepare_input_image(image)\n   369→            if not image_data:\n   370→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   371→\n   372→            # 处理参考图（复制到 references 并准备 API 载荷）\n   373→            ref_summary = self._process_reference_assets(\n   374→                reference_images,\n   375→                max_refs=MAX_REFERENCE_IMAGES,\n   376→                expected_outputs=1,\n   377→            )\n   378→            ref_assets = ref_summary.get('assets', [])\n   379→            ref_paths = list(ref_summary.get('paths', []))\n   380→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   381→            if ref_summary.get('errors'):\n   382→                logger.warning(\n   383→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   384→                )\n   385→            if ref_summary.get('warnings'):\n   386→                for warn in ref_summary['warnings']:\n   387→                    logger.warning(f\"参考图提示: {warn}\")\n   388→\n   389→            # 前置参数校验（不改变流程，仅记录摘要）\n   390→            fb = False\n   391→            reason = \"\"\n   392→            try:\n   393→                norm, fb, reason = validate_and_normalize_i2i(\n   394→                    ImageToImageParams(\n   395→                        prompt=prompt,\n   396→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   397→                        guidance_scale=guidance_scale,\n   398→                        seed=(None if seed == -1 else seed),\n   399→                        reference_images=ref_payloads,\n   400→                    )\n   401→                )\n   402→                logger.info(\n   403→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   404→                )\n   405→                if fb:\n   406→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   407→            except Exception as _e:\n   408→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   409→\n   410→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   411→            api_result = self.client.image_to_image(\n   412→                prompt=prompt,\n   413→                image=image_data,\n   414→                guidance_scale=guidance_scale,\n   415→                seed=seed,\n   416→                reference_images=(ref_payloads or None),\n   417→            )\n   418→\n   419→            # 处理input_image字段，避免在日志中输出大量base64数据\n   420→            input_image_info = \"[图像数据]\"\n   421→            if image:\n   422→                if image.startswith(\"data:image/\"):\n   423→                    # 如果是base64数据，只保留格式信息\n   424→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   425→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   426→                elif image.startswith((\"http://\", \"https://\")):\n   427→                    # 如果是URL，保留URL\n   428→                    input_image_info = image\n   429→                else:\n   430→                    # 如果是文件路径，只保留文件名\n   431→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   432→            \n   433→            result = {\n   434→                \"task_id\": task_id,\n   435→                \"success\": True,\n   436→                \"type\": \"image_to_image\",\n   437→                \"prompt\": prompt,\n   438→                \"input_image\": input_image_info,\n   439→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   440→                \"parameters\": {\n   441→                    \"guidance_scale\": guidance_scale, \n   442→                    \"seed\": seed, \n   443→                    \"response_format\": \"url\",  # 固定值\n   444→                    \"watermark\": False,  # 固定值\n   445→                    \"size\": \"adaptive\",  # 固定值\n   446→                    \"model\": self._resolve_model_id(\n   447→                        \"doubao-seededit-3-0-i2i-250628\",\n   448→                        \"doubao-seedream-4-0-250828\",\n   449→                        \"doubao-seedream-4-5-251128\",\n   450→                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n   451→                },\n   452→                \"created_at\": datetime.now().isoformat(),\n   453→                \"usage\": api_result.get(\"usage\", {}),\n   454→            }\n   455→\n   456→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   457→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   458→            result[\"reference_assets\"] = sanitized_refs\n   459→            if ref_summary.get('errors'):\n   460→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   461→            if ref_summary.get('warnings'):\n   462→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   463→            if fb and reason:\n   464→                result[\"fallback_applied\"] = True\n   465→                result[\"fallback_reason\"] = reason\n   466→\n   467→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   468→            logger.info(\n   469→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   470→                len(sanitized_refs),\n   471→                masked_ids or \"-\",\n   472→                self._provider_used(),\n   473→            )\n   474→\n   475→            # 保存到本地\n   476→            if save_local and result.get(\"image_url\"):\n   477→                local_result = self._save_image_locally(result)\n   478→                result.update(local_result)\n   479→                if local_result.get('local_save_error'):\n   480→                    self._cleanup_reference_paths(ref_paths)\n   481→                    result[\"parameters\"][\"reference_assets\"] = []\n   482→                    result[\"reference_assets\"] = []\n   483→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   484→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   485→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   486→\n   487→            logger.success(f\"图生图任务完成: {task_id}\")\n   488→            return result\n   489→\n   490→        except Exception as e:\n   491→            # 避免在日志中显示可能包含base64数据的异常信息\n   492→            error_msg = str(e)\n   493→            if len(error_msg) > 200:\n   494→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   495→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   496→            self._cleanup_reference_paths(ref_paths)\n   497→            return {\n   498→                \"task_id\": task_id,\n   499→                \"success\": False,\n   500→                \"error\": error_msg,\n   501→                \"type\": \"image_to_image\"\n   502→            }\n   503→\n   504→    def batch_generate_text_to_image(\n   505→        self,\n   506→        prompts: List[str],\n   507→        size: str = \"1024x1024\",\n   508→        guidance_scale: float = 2.5,\n   509→        save_local: bool = True,\n   510→    ) -> List[Dict[str, Any]]:\n   511→        \"\"\"\n   512→        批量生成文生图（顺序执行，保持向后兼容）\n   513→\n   514→        Args:\n   515→            prompts: 提示词列表\n   516→            size: 图像尺寸\n   517→            guidance_scale: 提示词一致性\n   518→            save_local: 是否保存到本地\n   519→\n   520→        Returns:\n   521→            List[Dict]: 生成结果列表\n   522→        \n   523→        Note:\n   524→            水印参数已固定为False，不再需要前端控制\n   525→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   526→        \"\"\"\n   527→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   528→\n   529→        results = []\n   530→        for i, prompt in enumerate(prompts, 1):\n   531→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   532→\n   533→            result = self.generate_text_to_image(\n   534→                prompt=prompt,\n   535→                size=size,\n   536→                guidance_scale=guidance_scale,\n   537→                save_local=save_local,\n   538→                generation_id=None,\n   539→            )\n   540→\n   541→            results.append(result)\n   542→\n   543→        success_count = sum(1 for r in results if r[\"success\"])\n   544→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   545→\n   546→        return results\n   547→\n   548→    def concurrent_generate_text_to_image(\n   549→        self,\n   550→        prompt: str,\n   551→        count: int = 4,\n   552→        size: str = \"1024x1024\",\n   553→        guidance_scale: float = 2.5,\n   554→        seed: int = -1,\n   555→        save_local: bool = True,\n   556→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   557→        max_workers: int = 5,\n   558→        derived_ids: Optional[List[str]] = None,\n   559→        generation_id: Optional[str] = None,\n   560→        model_variant: Optional[str] = None,\n   561→        sequential_mode: bool = False,\n   562→    ) -> Dict[str, Any]:\n   563→        \"\"\"\n   564→        并发生成多张文生图\n   565→\n   566→        Args:\n   567→            prompt: 图像生成提示词\n   568→            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n   569→            size: 图像尺寸\n   570→            guidance_scale: 引导强度\n   571→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   572→            save_local: 是否保存到本地\n   573→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   574→            max_workers: 最大并发数\n   575→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   576→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   577→\n   578→        Returns:\n   579→            Dict: 包含所有任务结果的字典\n   580→        \"\"\"\n   581→        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n   582→        max_allowed = 15 if sequential_mode else 10\n   583→        if count < 1 or count > max_allowed:\n   584→            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n   585→\n   586→        # 组图模式：单次 API 调用返回多张图\n   587→        if sequential_mode:\n   588→            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n   589→            return self.generate_text_to_image(\n   590→                prompt=prompt,\n   591→                size=size,\n   592→                guidance_scale=guidance_scale,\n   593→                seed=seed,\n   594→                save_local=save_local,\n   595→                model_variant=model_variant,\n   596→                generation_id=generation_id,\n   597→                count=count,\n   598→                sequential_mode=True,\n   599→                derived_ids=derived_ids,\n   600→                progress_callback=progress_callback,\n   601→            )\n   602→        \n   603→        if max_workers > count:\n   604→            max_workers = count\n   605→        \n   606→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   607→        \n   608→        # 生成批次ID\n   609→        batch_id = str(uuid.uuid4())\n   610→        start_time = time.time()\n   611→\n   612→        slots = max(1, count)\n   613→        per_ids: List[str] = list(derived_ids or [])\n   614→        if len(per_ids) < slots:\n   615→            base = generation_id or batch_id\n   616→            for idx in range(len(per_ids), slots):\n   617→                per_ids.append(f\"{base}_{idx + 1}\")\n   618→        \n   619→        # 准备任务参数\n   620→        tasks = []\n   621→        for i in range(count):\n   622→            # 为每个任务生成不同的种子（如果seed为-1）\n   623→            task_seed = seed if seed != -1 else None\n   624→            gen_id = per_ids[i] if i < len(per_ids) else None\n   625→            tasks.append({\n   626→                'prompt': prompt,\n   627→                'size': size,\n   628→                'guidance_scale': guidance_scale,\n   629→                'seed': task_seed,\n   630→                'save_local': save_local,\n   631→                'task_index': i + 1,\n   632→                'generation_id': gen_id,\n   633→                'model_variant': model_variant,\n   634→            })\n   635→        \n   636→        # 使用线程池并发执行\n   637→        results = []\n   638→        completed_count = 0\n   639→        \n   640→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   641→            # 提交所有任务\n   642→            future_to_task = {\n   643→                executor.submit(self._execute_single_text_to_image_task, task): task \n   644→                for task in tasks\n   645→            }\n   646→            \n   647→            # 收集结果\n   648→            for future in as_completed(future_to_task):\n   649→                task = future_to_task[future]\n   650→                try:\n   651→                    result = future.result()\n   652→                    result['task_index'] = task['task_index']\n   653→                    result['batch_id'] = batch_id\n   654→                    results.append(result)\n   655→                    \n   656→                    completed_count += 1\n   657→                    \n   658→                    # 调用进度回调\n   659→                    if progress_callback:\n   660→                        try:\n   661→                            progress_callback(completed_count, count, result)\n   662→                        except Exception as e:\n   663→                            logger.warning(f\"进度回调执行失败: {e}\")\n   664→                    \n   665→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   666→                    \n   667→                except Exception as e:\n   668→                    error_result = {\n   669→                        'task_index': task['task_index'],\n   670→                        'batch_id': batch_id,\n   671→                        'success': False,\n   672→                        'error': str(e),\n   673→                        'type': 'text_to_image'\n   674→                    }\n   675→                    results.append(error_result)\n   676→                    completed_count += 1\n   677→                    \n   678→                    if progress_callback:\n   679→                        try:\n   680→                            progress_callback(completed_count, count, error_result)\n   681→                        except Exception as e:\n   682→                            logger.warning(f\"进度回调执行失败: {e}\")\n   683→                    \n   684→                    # 避免在日志中显示可能包含base64数据的异常信息\n   685→                    error_msg = str(e)\n   686→                    if len(error_msg) > 200:\n   687→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   688→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   689→        \n   690→        # 按task_index排序\n   691→        results.sort(key=lambda x: x.get('task_index', 0))\n   692→        \n   693→        # 统计结果\n   694→        success_count = sum(1 for r in results if r.get('success', False))\n   695→        total_time = time.time() - start_time\n   696→        \n   697→        batch_result = {\n   698→            'batch_id': batch_id,\n   699→            'success': True,\n   700→            'prompt': prompt,\n   701→            'total_count': count,\n   702→            'success_count': success_count,\n   703→            'failed_count': count - success_count,\n   704→            'total_time': round(total_time, 2),\n   705→            'average_time': round(total_time / count, 2),\n   706→            'results': results,\n   707→            'parameters': {\n   708→                'size': size,\n   709→                'guidance_scale': guidance_scale,\n   710→                'seed': seed,\n   711→                'max_workers': max_workers\n   712→            },\n   713→            'derived_ids': per_ids,\n   714→            'created_at': datetime.now().isoformat()\n   715→        }\n   716→        \n   717→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   718→        return batch_result\n   719→\n   720→    def concurrent_generate_image_to_image(\n   721→        self,\n   722→        prompt: str,\n   723→        image: str,\n   724→        count: int = 4,\n   725→        guidance_scale: float = 5.5,\n   726→        seed: int = -1,\n   727→        save_local: bool = True,\n   728→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   729→        max_workers: int = 5,\n   730→        derived_ids: Optional[List[str]] = None,\n   731→        generation_id: Optional[str] = None,\n   732→    ) -> Dict[str, Any]:\n   733→        \"\"\"\n   734→        并发生成多张图生图\n   735→\n   736→        Args:\n   737→            prompt: 编辑提示词\n   738→            image: 输入图像路径或URL\n   739→            count: 生成图片数量，默认4张，最多10张\n   740→            guidance_scale: 引导强度\n   741→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   742→            save_local: 是否保存到本地\n   743→            progress_callback: 进度回调函数\n   744→            max_workers: 最大并发数\n   745→\n   746→        Returns:\n   747→            Dict: 包含所有任务结果的字典\n   748→        \"\"\"\n   749→        # 验证参数\n   750→        if count < 1 or count > 10:\n   751→            raise ValueError(\"生成数量必须在1-10之间\")\n   752→        \n   753→        if max_workers > count:\n   754→            max_workers = count\n   755→        \n   756→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   757→        \n   758→        # 生成批次ID\n   759→        batch_id = str(uuid.uuid4())\n   760→        start_time = time.time()\n   761→        \n   762→        slots = max(1, count)\n   763→        per_ids: List[str] = list(derived_ids or [])\n   764→        if len(per_ids) < slots:\n   765→            base = generation_id or batch_id\n   766→            for idx in range(len(per_ids), slots):\n   767→                per_ids.append(f\"{base}_{idx + 1}\")\n   768→        \n   769→        # 准备输入图像\n   770→        image_data = self._prepare_input_image(image)\n   771→        if not image_data:\n   772→            return {\n   773→                'batch_id': batch_id,\n   774→                'success': False,\n   775→                'error': '无法处理输入图像',\n   776→                'type': 'image_to_image'\n   777→            }\n   778→        \n   779→        # 准备任务参数\n   780→        tasks = []\n   781→        for i in range(count):\n   782→            task_seed = seed if seed != -1 else None\n   783→            gen_id = per_ids[i] if i < len(per_ids) else None\n   784→            tasks.append({\n   785→                'prompt': prompt,\n   786→                'image': image_data,\n   787→                'guidance_scale': guidance_scale,\n   788→                'seed': task_seed,\n   789→                'save_local': save_local,\n   790→                'task_index': i + 1,\n   791→                'generation_id': gen_id\n   792→            })\n   793→        \n   794→        # 使用线程池并发执行\n   795→        results = []\n   796→        completed_count = 0\n   797→        \n   798→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   799→            # 提交所有任务\n   800→            future_to_task = {\n   801→                executor.submit(self._execute_single_image_to_image_task, task): task \n   802→                for task in tasks\n   803→            }\n   804→            \n   805→            # 收集结果\n   806→            for future in as_completed(future_to_task):\n   807→                task = future_to_task[future]\n   808→                try:\n   809→                    result = future.result()\n   810→                    result['task_index'] = task['task_index']\n   811→                    result['batch_id'] = batch_id\n   812→                    results.append(result)\n   813→                    \n   814→                    completed_count += 1\n   815→                    \n   816→                    # 调用进度回调\n   817→                    if progress_callback:\n   818→                        try:\n   819→                            progress_callback(completed_count, count, result)\n   820→                        except Exception as e:\n   821→                            logger.warning(f\"进度回调执行失败: {e}\")\n   822→                    \n   823→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   824→                    \n   825→                except Exception as e:\n   826→                    error_result = {\n   827→                        'task_index': task['task_index'],\n   828→                        'batch_id': batch_id,\n   829→                        'success': False,\n   830→                        'error': str(e),\n   831→                        'type': 'image_to_image'\n   832→                    }\n   833→                    results.append(error_result)\n   834→                    completed_count += 1\n   835→                    \n   836→                    if progress_callback:\n   837→                        try:\n   838→                            progress_callback(completed_count, count, error_result)\n   839→                        except Exception as e:\n   840→                            logger.warning(f\"进度回调执行失败: {e}\")\n   841→                    \n   842→                    # 避免在日志中显示可能包含base64数据的异常信息\n   843→                    error_msg = str(e)\n   844→                    if len(error_msg) > 200:\n   845→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   846→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   847→        \n   848→        # 按task_index排序\n   849→        results.sort(key=lambda x: x.get('task_index', 0))\n   850→        \n   851→        # 统计结果\n   852→        success_count = sum(1 for r in results if r.get('success', False))\n   853→        total_time = time.time() - start_time\n   854→        \n   855→        # 处理input_image字段，避免在日志中输出大量base64数据\n   856→        input_image_info = \"[图像数据]\"\n   857→        if image:\n   858→            if image.startswith(\"data:image/\"):\n   859→                # 如果是base64数据，只保留格式信息\n   860→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   861→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   862→            elif image.startswith((\"http://\", \"https://\")):\n   863→                # 如果是URL，保留URL\n   864→                input_image_info = image\n   865→            else:\n   866→                # 如果是文件路径，只保留文件名\n   867→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   868→        \n   869→        batch_result = {\n   870→            'batch_id': batch_id,\n   871→            'success': True,\n   872→            'prompt': prompt,\n   873→            'input_image': input_image_info,\n   874→            'total_count': count,\n   875→            'success_count': success_count,\n   876→            'failed_count': count - success_count,\n   877→            'total_time': round(total_time, 2),\n   878→            'average_time': round(total_time / count, 2),\n   879→            'results': results,\n   880→            'parameters': {\n   881→                'guidance_scale': guidance_scale,\n   882→                'seed': seed,\n   883→                'max_workers': max_workers\n   884→            },\n   885→            'derived_ids': per_ids,\n   886→            'created_at': datetime.now().isoformat()\n   887→        }\n   888→        \n   889→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   890→        return batch_result\n   891→\n   892→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   893→        \"\"\"\n   894→        执行单个文生图任务\n   895→        \n   896→        Args:\n   897→            task: 任务参数字典\n   898→            \n   899→        Returns:\n   900→            Dict: 任务执行结果\n   901→        \"\"\"\n   902→        return self.generate_text_to_image(\n   903→            prompt=task['prompt'],\n   904→            size=task['size'],\n   905→            guidance_scale=task['guidance_scale'],\n   906→            seed=task['seed'],\n   907→            save_local=task['save_local'],\n   908→            generation_id=task.get('generation_id'),\n   909→            model_variant=task.get('model_variant'),\n   910→        )\n   911→    \n   912→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   913→        \"\"\"\n   914→        执行单个图生图任务\n   915→        \n   916→        Args:\n   917→            task: 任务参数字典\n   918→            \n   919→        Returns:\n   920→            Dict: 任务执行结果\n   921→        \"\"\"\n   922→        # 生成唯一ID，优先使用外部传入的generation_id\n   923→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   924→        \n   925→        try:\n   926→            # 直接使用已经处理好的图片数据，避免重复处理\n   927→            image_data = task['image']\n   928→            \n   929→            # 调用API生成图像\n   930→            api_result = self.client.image_to_image(\n   931→                prompt=task['prompt'], \n   932→                image=image_data, \n   933→                guidance_scale=task['guidance_scale'], \n   934→                seed=task['seed']\n   935→            )\n   936→            \n   937→            result = {\n   938→                \"task_id\": task_id,\n   939→                \"success\": True,\n   940→                \"type\": \"image_to_image\",\n   941→                \"prompt\": task['prompt'],\n   942→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   943→                \"parameters\": {\n   944→                    \"guidance_scale\": task['guidance_scale'], \n   945→                    \"seed\": task['seed'], \n   946→                    \"response_format\": \"url\",\n   947→                    \"watermark\": False,\n   948→                    \"size\": \"adaptive\",\n   949→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   950→                },\n   951→                \"created_at\": datetime.now().isoformat(),\n   952→                \"usage\": api_result.get(\"usage\", {}),\n   953→            }\n   954→            \n   955→            # 保存到本地\n   956→            if task['save_local'] and result.get(\"image_url\"):\n   957→                local_result = self._save_image_locally(result)\n   958→                result.update(local_result)\n   959→            \n   960→            return result\n   961→            \n   962→        except Exception as e:\n   963→            # 避免在日志中显示可能包含base64数据的异常信息\n   964→            error_msg = str(e)\n   965→            if len(error_msg) > 200:\n   966→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   967→            return {\n   968→                \"task_id\": task_id,\n   969→                \"success\": False,\n   970→                \"error\": error_msg,\n   971→                \"type\": \"image_to_image\"\n   972→            }\n   973→\n   974→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   975→        \"\"\"\n   976→        保存图像到本地并记录元数据\n   977→\n   978→        Args:\n   979→            result: API生成结果\n   980→\n   981→        Returns:\n   982→            Dict: 包含本地文件信息的字典\n   983→        \"\"\"\n   984→        try:\n   985→            # 下载图像\n   986→            image_url = result[\"image_url\"]\n   987→            response = safe_requests_get(image_url, timeout=30)\n   988→\n   989→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   990→            from io import BytesIO\n   991→            real_w, real_h = None, None\n   992→            try:\n   993→                with Image.open(BytesIO(response.content)) as img:\n   994→                    real_w, real_h = int(img.width), int(img.height)\n   995→            except Exception as _e:\n   996→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n   997→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   998→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   999→\n  1000→            # 组装元数据（适配UnifiedStorageManager的格式）\n  1001→            params = result.get(\"parameters\", {}) or {}\n  1002→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n  1003→            try:\n  1004→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n  1005→                    from math import gcd\n  1006→                    g = gcd(real_w, real_h)\n  1007→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n  1008→            except Exception:\n  1009→                pass\n  1010→\n  1011→            metadata = {\n  1012→                'generation_id': result.get(\"task_id\", \"\"),\n  1013→                'prompt': result.get(\"prompt\", \"\"),\n  1014→                'parameters': params,\n  1015→                'model': params.get(\"model\", \"seedream\"),\n  1016→                'width': real_w,\n  1017→                'height': real_h,\n  1018→                'generation_time': result.get(\"generation_time\", 0),\n  1019→                'batch_id': result.get(\"batch_id\", \"\"),\n  1020→                'status': 'completed'\n  1021→            }\n  1022→            \n  1023→            # 使用统一存储管理器保存文件\n  1024→            save_result = self.storage_manager.save_content_file(\n  1025→                content_type='images',\n  1026→                file_data=response.content,\n  1027→                url=image_url,\n  1028→                metadata=metadata\n  1029→            )\n  1030→\n  1031→            # 获取图像信息（再次确认像素尺寸）\n  1032→            image_info = self._get_image_info(Path(save_result['local_path']))\n  1033→            file_size = Path(save_result['local_path']).stat().st_size\n  1034→\n  1035→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n  1036→\n  1037→            result_obj = {\n  1038→                \"local_path\": save_result['local_path'],\n  1039→                \"filename\": Path(save_result['local_path']).name,\n  1040→                \"file_size\": file_size,\n  1041→                \"image_info\": image_info,\n  1042→                \"file_path\": save_result['local_path'],  # 保持兼容性\n  1043→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n  1044→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n  1045→                \"file_id\": save_result.get('file_id'),\n  1046→                \"relative_path\": save_result.get('relative_path'),\n  1047→            }\n  1048→            try:\n  1049→                w = image_info.get('width') if isinstance(image_info, dict) else None\n  1050→                h = image_info.get('height') if isinstance(image_info, dict) else None\n  1051→                logger.info(\n  1052→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n  1053→                )\n  1054→            except Exception:\n  1055→                pass\n  1056→\n  1057→            # 体验版本地图片水印（使用统一水印服务）\n  1058→            if should_add_watermark():\n  1059→                try:\n  1060→                    from edition.watermark_service import WatermarkService\n  1061→\n  1062→                    watermark_text = get_watermark_text() or \"PIGEON\"\n  1063→                    try:\n  1064→                        opacity = get_watermark_opacity()\n  1065→                    except Exception:\n  1066→                        opacity = 0.3\n  1067→                    opacity = max(0.0, min(opacity, 1.0))\n  1068→\n  1069→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n  1070→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n  1071→                    if watermark_applied:\n  1072→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n  1073→                        result_obj[\"watermark_applied\"] = True\n  1074→                    else:\n  1075→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n  1076→                        result_obj[\"watermark_applied\"] = False\n  1077→                except Exception as e:\n  1078→                    logger.warning(f\"添加图片水印时出错: {e}\")\n  1079→                    result_obj[\"watermark_applied\"] = False\n  1080→\n  1081→            return result_obj\n  1082→\n  1083→        except Exception as e:\n  1084→            logger.error(f\"保存图像到本地失败: {e}\")\n  1085→            try:\n  1086→                logger.info(\"摘要|operation=save_image status=failed\")\n  1087→            except Exception:\n  1088→                pass\n  1089→            return {\"local_save_error\": str(e)}\n  1090→\n  1091→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1092→        checksum = hashlib.sha1(file_data).hexdigest()\n  1093→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1094→        return f\"ref_{ts}_{checksum[:8]}\"\n  1095→\n  1096→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1097→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1098→        source_meta: Dict[str, Any] = {}\n  1099→        raw = ref\n  1100→        if isinstance(ref, dict):\n  1101→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1102→                if ref.get(key) is not None:\n  1103→                    source_meta[key] = ref.get(key)\n  1104→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1105→        if raw is None:\n  1106→            return None\n  1107→\n  1108→        extension = source_meta.get('extension')\n  1109→        data = None\n  1110→        source_repr = source_meta.get('source')\n  1111→\n  1112→        try:\n  1113→            if isinstance(raw, bytes):\n  1114→                data = raw\n  1115→            elif isinstance(raw, str):\n  1116→                stripped = raw.strip()\n  1117→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1118→                    header, payload = stripped.split(';base64,', 1)\n  1119→                    mime_part = header[5:]\n  1120→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n  1121→                    data = base64.b64decode(payload)\n  1122→                    source_repr = source_repr or mime_part\n  1123→                    source_meta.setdefault('type', 'image')\n  1124→                elif stripped.startswith(('http://', 'https://')):\n  1125→                    resp = safe_requests_get(stripped, timeout=15)\n  1126→                    data = resp.content\n  1127→                    parsed = urlparse(stripped)\n  1128→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1129→                    source_repr = source_repr or stripped\n  1130→                    source_meta.setdefault('source_url', stripped)\n  1131→                else:\n  1132→                    path = Path(stripped)\n  1133→                    if not path.exists():\n  1134→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1135→                        return None\n  1136→                    data = path.read_bytes()\n  1137→                    extension = extension or path.suffix or '.png'\n  1138→                    source_repr = source_repr or path.name\n  1139→                    source_meta.setdefault('source_path', str(path))\n  1140→            else:\n  1141→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1142→                return None\n  1143→        except Exception as exc:\n  1144→            logger.warning(f\"加载参考图失败: {exc}\")\n  1145→            return None\n  1146→\n  1147→        if data is None:\n  1148→            return None\n  1149→\n  1150→        width = source_meta.get('width')\n  1151→        height = source_meta.get('height')\n  1152→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1153→            try:\n  1154→                from io import BytesIO\n  1155→\n  1156→                with Image.open(BytesIO(data)) as img:\n  1157→                    width = img.width\n  1158→                    height = img.height\n  1159→            except Exception:\n  1160→                pass\n  1161→\n  1162→        source_meta['width'] = width\n  1163→        source_meta['height'] = height\n  1164→        source_meta.setdefault('type', 'image')\n  1165→        source_meta['source'] = source_repr or source_meta.get('source')\n  1166→\n  1167→        return data, extension, source_meta\n  1168→\n  1169→    def _process_reference_assets(\n  1170→        self,\n  1171→        references: Optional[List[Any]],\n  1172→        *,\n  1173→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1174→        expected_outputs: int = 1,\n  1175→    ) -> Dict[str, Any]:\n  1176→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1177→        stored: List[Dict[str, Any]] = []\n  1178→        absolute_paths: List[str] = []\n  1179→        errors: List[str] = []\n  1180→        warnings: List[str] = []\n  1181→\n  1182→        if not references:\n  1183→            return {\n  1184→                'assets': stored,\n  1185→                'paths': absolute_paths,\n  1186→                'errors': errors,\n  1187→                'warnings': warnings,\n  1188→            }\n  1189→\n  1190→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1191→            warnings.append(\n  1192→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1193→            )\n  1194→            references = references[:max_refs]\n  1195→\n  1196→        for order, item in enumerate(references):\n  1197→            load_result = self._load_reference_source(item)\n  1198→            if not load_result:\n  1199→                errors.append(f\"ref[{order}] 加载失败\")\n  1200→                continue\n  1201→\n  1202→            file_data, extension, meta = load_result\n  1203→            meta.setdefault('order', order)\n  1204→            meta.setdefault('kind', meta.get('type', 'image'))\n  1205→\n  1206→            try:\n  1207→                asset_id = self._generate_reference_asset_id(file_data)\n  1208→                record = self.storage_manager.save_reference_asset(\n  1209→                    'images',\n  1210→                    file_data,\n  1211→                    asset_id=asset_id,\n  1212→                    extension=extension,\n  1213→                    metadata=meta,\n  1214→                )\n  1215→                try:\n  1216→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1217→                except Exception:\n  1218→                    record['_payload_b64'] = None\n  1219→                record['_source_meta'] = meta\n  1220→                stored.append(record)\n  1221→                if record.get('absolute_path'):\n  1222→                    absolute_paths.append(record['absolute_path'])\n  1223→            except Exception as exc:\n  1224→                logger.warning(f\"保存参考图失败: {exc}\")\n  1225→                errors.append(f\"ref[{order}] 保存失败\")\n  1226→\n  1227→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1228→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1229→            if len(stored) > allowed:\n  1230→                warnings.append(\n  1231→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1232→                )\n  1233→                stored = stored[:allowed]\n  1234→                absolute_paths = absolute_paths[:allowed]\n  1235→\n  1236→        return {\n  1237→            'assets': stored,\n  1238→            'paths': absolute_paths,\n  1239→            'errors': errors,\n  1240→            'warnings': warnings,\n  1241→        }\n  1242→\n  1243→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1244→        payloads: List[str] = []\n  1245→        for asset in assets or []:\n  1246→            payload = asset.get('_payload_b64')\n  1247→            if not payload:\n  1248→                continue\n  1249→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1250→            mime = 'image/png'\n  1251→            try:\n  1252→                if path_hint:\n  1253→                    suffix = Path(path_hint).suffix.lower()\n  1254→                    if suffix in {'.jpg', '.jpeg'}:\n  1255→                        mime = 'image/jpeg'\n  1256→                    elif suffix == '.webp':\n  1257→                        mime = 'image/webp'\n  1258→                    elif suffix == '.bmp':\n  1259→                        mime = 'image/bmp'\n  1260→                    elif suffix == '.gif':\n  1261→                        mime = 'image/gif'\n  1262→            except Exception:\n  1263→                pass\n  1264→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1265→        return payloads\n  1266→\n  1267→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1268→        provider = (self.client.last_provider() or \"\").lower()\n  1269→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1270→            return v4_5_model or v4_model\n  1271→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1272→            return v4_model\n  1273→        return default_model\n  1274→\n  1275→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1276→        cleaned: List[Dict[str, Any]] = []\n  1277→        for rec in assets or []:\n  1278→            rec.pop('_payload_b64', None)\n  1279→            rec.pop('_source_meta', None)\n  1280→            rec.pop('absolute_path', None)\n  1281→            cleaned.append({\n  1282→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1283→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1284→                'type': rec.get('type'),\n  1285→                'kind': rec.get('kind'),\n  1286→                'source': rec.get('source'),\n  1287→                'order': rec.get('order'),\n  1288→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1289→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1290→                'width': rec.get('width'),\n  1291→                'height': rec.get('height'),\n  1292→                'created_at': rec.get('created_at'),\n  1293→            })\n  1294→        return cleaned\n  1295→\n  1296→    @staticmethod\n  1297→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1298→        masked: List[str] = []\n  1299→        for rec in assets or []:\n  1300→            rid = rec.get('id') or ''\n  1301→            if not rid:\n  1302→                continue\n  1303→            masked.append(f\"{rid[:6]}***\")\n  1304→        return \",\".join(masked)\n  1305→\n  1306→    @staticmethod\n  1307→    def _provider_hint() -> str:\n  1308→        try:\n  1309→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1310→        except Exception:\n  1311→            return \"unknown\"\n  1312→\n  1313→    def _provider_used(self) -> str:\n  1314→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1315→        if provider:\n  1316→            return provider\n  1317→        return self._provider_hint()\n  1318→\n  1319→    @staticmethod\n  1320→    def _cleanup_reference_paths(paths: List[str]):\n  1321→        for path in paths or []:\n  1322→            try:\n  1323→                if path and Path(path).exists():\n  1324→                    Path(path).unlink(missing_ok=True)\n  1325→            except Exception as exc:\n  1326→                logger.debug(f\"参考图清理失败: {exc}\")\n  1327→\n  1328→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1329→        \"\"\"\n  1330→        准备输入图像，支持本地文件和URL\n  1331→        \n  1332→        Args:\n  1333→            image_path: 图像路径（本地路径或URL）\n  1334→            \n  1335→        Returns:\n  1336→            str: 图像URL、base64数据或None\n  1337→        \"\"\"\n  1338→        try:\n  1339→            # 如果是URL，直接返回\n  1340→            if image_path.startswith((\"http://\", \"https://\")):\n  1341→                return image_path\n  1342→\n  1343→            # 如果是本地文件，转换为Base64\n  1344→            local_path = Path(image_path)\n  1345→            if local_path.exists():\n  1346→                with open(local_path, \"rb\") as f:\n  1347→                    image_data = f.read()\n  1348→\n  1349→                # 检测图像格式\n  1350→                image = Image.open(local_path)\n  1351→                format_name = image.format.lower()\n  1352→\n  1353→                # 转换为Base64\n  1354→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1355→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1356→\n  1357→            logger.error(f\"图像文件不存在: {image_path}\")\n  1358→            return None\n  1359→\n  1360→        except Exception as e:\n  1361→            logger.error(f\"处理输入图像失败: {e}\")\n  1362→            return None\n  1363→\n  1364→    def _extract_width_from_size(self, size: str) -> int:\n  1365→        \"\"\"\n  1366→        从尺寸字符串中提取宽度\n  1367→        \n  1368→        Args:\n  1369→            size: 尺寸字符串，如 \"1024x1024\"\n  1370→            \n  1371→        Returns:\n  1372→            int: 宽度值\n  1373→        \"\"\"\n  1374→        try:\n  1375→            return int(size.split('x')[0])\n  1376→        except (ValueError, IndexError):\n  1377→            return 1024  # 默认值\n  1378→    \n  1379→    def _extract_height_from_size(self, size: str) -> int:\n  1380→        \"\"\"\n  1381→        从尺寸字符串中提取高度\n  1382→        \n  1383→        Args:\n  1384→            size: 尺寸字符串，如 \"1024x1024\"\n  1385→            \n  1386→        Returns:\n  1387→            int: 高度值\n  1388→        \"\"\"\n  1389→        try:\n  1390→            return int(size.split('x')[1])\n  1391→        except (ValueError, IndexError):\n  1392→            return 1024  # 默认值\n  1393→\n  1394→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1395→        \"\"\"\n  1396→        获取图像信息\n  1397→\n  1398→        Args:\n  1399→            image_path: 图像文件路径\n  1400→\n  1401→        Returns:\n  1402→            Dict: 图像信息\n  1403→        \"\"\"\n  1404→        try:\n  1405→            with Image.open(image_path) as img:\n  1406→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1407→        except Exception as e:\n  1408→            logger.error(f\"获取图像信息失败: {e}\")\n  1409→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1410→\n  1411→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1412→        \"\"\"\n  1413→        获取图像生成历史记录\n  1414→\n  1415→        Args:\n  1416→            limit: 返回记录数量限制\n  1417→\n  1418→        Returns:\n  1419→            List[Dict]: 历史记录列表\n  1420→        \"\"\"\n  1421→        return self.storage_manager.load_history('images', limit=limit)\n  1422→\n  1423→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1424→        \"\"\"\n  1425→        根据提示词关键字搜索历史记录\n  1426→\n  1427→        Args:\n  1428→            keyword: 搜索关键字\n  1429→\n  1430→        Returns:\n  1431→            List[Dict]: 匹配的记录列表\n  1432→        \"\"\"\n  1433→        # 获取所有历史记录并在内存中过滤\n  1434→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1435→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1436→\n  1437→    def get_statistics(self) -> Dict[str, Any]:\n  1438→        \"\"\"\n  1439→        获取生成统计信息\n  1440→\n  1441→        Returns:\n  1442→            Dict: 统计信息\n  1443→        \"\"\"\n  1444→        try:\n  1445→            # 使用统一存储管理器获取存储统计\n  1446→            storage_stats = self.storage_manager.get_storage_stats()\n  1447→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1448→            \n  1449→            # 获取历史记录进行详细统计\n  1450→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1451→            \n  1452→            if not all_records:\n  1453→                return {\n  1454→                    \"total_images\": 0,\n  1455→                    \"text_to_image_count\": 0,\n  1456→                    \"image_to_image_count\": 0,\n  1457→                    \"total_file_size\": 0,\n  1458→                    \"average_file_size\": 0,\n  1459→                    \"most_common_size\": \"unknown\"\n  1460→                }\n  1461→\n  1462→            # 统计不同类型的图片数量\n  1463→            text_to_image_count = 0\n  1464→            image_to_image_count = 0\n  1465→            total_file_size = 0\n  1466→            sizes = []\n  1467→            \n  1468→            for record in all_records:\n  1469→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1470→                if 'input_image' in record.get('parameters', {}):\n  1471→                    image_to_image_count += 1\n  1472→                else:\n  1473→                    text_to_image_count += 1\n  1474→                \n  1475→                # 计算文件大小\n  1476→                file_size = record.get('file_size', 0)\n  1477→                if isinstance(file_size, str) and file_size.isdigit():\n  1478→                    file_size = int(file_size)\n  1479→                elif not isinstance(file_size, (int, float)):\n  1480→                    file_size = 0\n  1481→                total_file_size += file_size\n  1482→                \n  1483→                # 收集尺寸信息\n  1484→                width = record.get('width', 0)\n  1485→                height = record.get('height', 0)\n  1486→                if width and height:\n  1487→                    sizes.append(f\"{width}x{height}\")\n  1488→\n  1489→            stats = {\n  1490→                \"total_images\": len(all_records),\n  1491→                \"text_to_image_count\": text_to_image_count,\n  1492→                \"image_to_image_count\": image_to_image_count,\n  1493→                \"total_file_size\": total_file_size,\n  1494→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1495→                \"most_common_size\": \"unknown\",\n  1496→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1497→            }\n  1498→\n  1499→            # 最常用的尺寸\n  1500→            if sizes:\n  1501→                from collections import Counter\n  1502→                size_counts = Counter(sizes)\n  1503→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1504→\n  1505→            return stats\n  1506→\n  1507→        except Exception as e:\n  1508→            logger.error(f\"获取统计信息失败: {e}\")\n  1509→            return {\n  1510→                \"total_images\": 0,\n  1511→                \"text_to_image_count\": 0,\n  1512→                \"image_to_image_count\": 0,\n  1513→                \"total_file_size\": 0,\n  1514→                \"average_file_size\": 0,\n  1515→                \"most_common_size\": \"unknown\"\n  1516→            }\n  1517→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8f62eeb2-b2e4-4dca-9b45-63315bf6e846","timestamp":"2026-01-05T11:53:38.756Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 unified_config.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config.unified_config import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        storage_dir = get_storage_dir()\n        if not storage_dir:\n            raise ValueError(\"未配置存储路径，请先在设置中完成配置\")\n        self.storage_manager = get_v2_storage_manager(storage_dir)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n        count: int = 1,\n        sequential_mode: bool = False,\n        derived_ids: Optional[List[str]] = None,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            count: 生成图片数量（组图模式下生效）\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n            derived_ids: 组图生成的ID列表（用于关联）\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n\n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n\n        # 根据 model_variant 选择 provider（并发安全：不写 env）\n        seedream_provider: Optional[str] = None\n        try:\n            mv = (model_variant or \"\").strip().lower()\n            if mv in {\"seedream_v4\", \"v4\", \"seedream4\", \"seedream_4\"}:\n                seedream_provider = \"volc_v4\"\n            elif mv in {\"seedream_v4_5\", \"v4_5\", \"v4.5\", \"seedream4_5\", \"seedream_4_5\"}:\n                seedream_provider = \"volc_v4_5\"\n            elif mv.startswith(\"volc_\"):\n                seedream_provider = mv\n        except Exception:\n            seedream_provider = None\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            actual_count = max(1, count)\n            use_group_mode = bool(sequential_mode and actual_count > 1)\n\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n                n=actual_count if use_group_mode else 1,\n                sequential_mode=sequential_mode,\n                seedream_provider=seedream_provider,\n            )\n\n            # 组图模式：API 返回多张图，需要逐一保存\n            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n            images_count = len(images_list)\n            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n\n            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n            if use_group_mode and images_count < actual_count:\n                logger.warning(\n                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n                )\n\n            if use_group_mode and images_count > 1:\n                results_batch = []\n                success_count = 0\n                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n                total_images = len(images_list)\n\n                for idx, img_data in enumerate(images_list):\n                    # 发送下载进度（每张图开始下载时）\n                    if progress_callback:\n                        try:\n                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n                        except Exception:\n                            pass\n\n                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n                    per_result = {\n                        \"task_id\": per_id,\n                        \"success\": True,\n                        \"type\": \"text_to_image\",\n                        \"prompt\": prompt,\n                        \"image_url\": img_data[\"url\"],\n                        \"parameters\": {\n                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            \"seed\": seed,\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,\n                        },\n                        \"created_at\": datetime.now().isoformat(),\n                        \"usage\": api_result.get(\"usage\", {}),\n                    }\n\n                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n                    if sanitized_refs:\n                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                        per_result[\"reference_assets\"] = sanitized_refs\n\n                    if save_local and per_result.get(\"image_url\"):\n                        local_result = self._save_image_locally(per_result)\n                        per_result.update(local_result)\n                        if not local_result.get('local_save_error'):\n                            success_count += 1\n\n                    results_batch.append(per_result)\n\n                    # 发送下载完成进度\n                    if progress_callback:\n                        try:\n                            progress_callback(idx + 1, total_images, per_result)\n                        except Exception:\n                            pass\n\n                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n                return {\n                    \"batch\": True,\n                    \"results\": results_batch,\n                    \"success_count\": success_count,\n                    \"total_count\": len(results_batch),\n                    \"derived_ids\": group_ids,\n                }\n\n            # 单图模式（默认）\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    \"seed\": seed,\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    ),\n                    \"model_variant\": model_variant,  # 保存模型变体名称，用于复用参数\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale, \n                    \"seed\": seed, \n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        sequential_mode: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n        max_allowed = 15 if sequential_mode else 10\n        if count < 1 or count > max_allowed:\n            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n\n        # 组图模式：单次 API 调用返回多张图\n        if sequential_mode:\n            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n            return self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=save_local,\n                model_variant=model_variant,\n                generation_id=generation_id,\n                count=count,\n                sequential_mode=True,\n                derived_ids=derived_ids,\n                progress_callback=progress_callback,\n            )\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1517,"startLine":1,"totalLines":1517}}}
{"parentUuid":"8f62eeb2-b2e4-4dca-9b45-63315bf6e846","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BpokzFYm5v4TLXQH9hs1uV","type":"message","role":"assistant","content":[{"type":"text","text":"让我继续探索数据库结构和配置管理部分："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5202,"cache_creation_input_tokens":41235,"cache_read_input_tokens":22468,"cache_creation":{"ephemeral_5m_input_tokens":41235,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"7fa5ca35-560e-4138-9af5-c5e3d7740573","timestamp":"2026-01-05T11:53:45.276Z"}
{"parentUuid":"7fa5ca35-560e-4138-9af5-c5e3d7740573","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BpokzFYm5v4TLXQH9hs1uV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DE7qk7NyZDUvMFJuUJ97Ef","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5202,"cache_creation_input_tokens":41235,"cache_read_input_tokens":22468,"cache_creation":{"ephemeral_5m_input_tokens":41235,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5832c309-d989-4e4a-9435-0e76304149fc","timestamp":"2026-01-05T11:53:46.580Z"}
{"parentUuid":"5832c309-d989-4e4a-9435-0e76304149fc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BpokzFYm5v4TLXQH9hs1uV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BVMNE8xXyB6Duv34n1xhRW","name":"Glob","input":{"pattern":"**/config*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5202,"cache_creation_input_tokens":41235,"cache_read_input_tokens":22468,"cache_creation":{"ephemeral_5m_input_tokens":41235,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f7dcdff8-a54e-46c1-b2c0-f2721bd6628e","timestamp":"2026-01-05T11:53:47.104Z"}
{"parentUuid":"f7dcdff8-a54e-46c1-b2c0-f2721bd6628e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BpokzFYm5v4TLXQH9hs1uV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NCQNW2JYddcTNjdsXNNi1w","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/config/unified_config.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5202,"cache_creation_input_tokens":41235,"cache_read_input_tokens":22468,"cache_creation":{"ephemeral_5m_input_tokens":41235,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2a46c980-a047-4aa3-8daa-d96fbf6a07b0","timestamp":"2026-01-05T11:53:47.657Z"}
{"parentUuid":"2a46c980-a047-4aa3-8daa-d96fbf6a07b0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BpokzFYm5v4TLXQH9hs1uV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GHpSFaJe7QzwoquTdGCWaN","name":"Bash","input":{"command":"sqlite3 ~/.pigeon_dream/data/generations.db \".schema generations\" 2>/dev/null | head -50","description":"Check database schema for generations table"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5202,"cache_creation_input_tokens":41235,"cache_read_input_tokens":22468,"cache_creation":{"ephemeral_5m_input_tokens":41235,"ephemeral_1h_input_tokens":0},"output_tokens":291,"service_tier":"standard"}},"type":"assistant","uuid":"51de54ee-aadd-4141-8980-7cc68a20f1ca","timestamp":"2026-01-05T11:53:49.326Z"}
{"parentUuid":"51de54ee-aadd-4141-8980-7cc68a20f1ca","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NCQNW2JYddcTNjdsXNNi1w","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"统一配置门面，使用新的 config.sources 模块作为单一真源。\"\"\"\n     4→\n     5→from typing import Any, Dict, Optional\n     6→import logging\n     7→import warnings\n     8→\n     9→logger = logging.getLogger(__name__)\n    10→\n    11→_STORAGE_KEYS = {\"storage_dir\", \"gemeng_storage_dir\", \"storage_root_path\"}\n    12→\n    13→\n    14→class UnifiedConfig:\n    15→    \"\"\"提供统一的配置访问入口，封装所有底层配置实现。\"\"\"\n    16→\n    17→    _instance = None\n    18→    _initialized = False\n    19→\n    20→    def __new__(cls):\n    21→        if cls._instance is None:\n    22→            cls._instance = super().__new__(cls)\n    23→        return cls._instance\n    24→\n    25→    def __init__(self):\n    26→        if self._initialized:\n    27→            return\n    28→        self._initialized = True\n    29→        logger.debug(\"UnifiedConfig initialized\")\n    30→\n    31→    # =========================================================================\n    32→    # API 密钥管理\n    33→    # =========================================================================\n    34→\n    35→    def get_api_key(self, service: str) -> str:\n    36→        \"\"\"获取指定服务的 API 密钥。\"\"\"\n    37→        from config.sources.api_config import get_api_key\n    38→        return get_api_key(service)\n    39→\n    40→    def validate_api_keys(self) -> tuple[bool, list[str], str]:\n    41→        \"\"\"验证 API 密钥配置情况。\"\"\"\n    42→        from config.sources.api_config import validate_api_keys\n    43→        return validate_api_keys()\n    44→\n    45→    def update_api_key(self, service: str, api_key: str) -> None:\n    46→        \"\"\"更新指定服务的 API 密钥。\"\"\"\n    47→        from config.sources.api_config import update_api_key\n    48→        update_api_key(service, api_key)\n    49→\n    50→    # =========================================================================\n    51→    # 水印配置\n    52→    # =========================================================================\n    53→\n    54→    def get_watermark_config(self) -> Dict[str, Any]:\n    55→        \"\"\"返回当前水印配置。\"\"\"\n    56→        from config.sources.watermark_config import get_watermark_config\n    57→        return get_watermark_config()\n    58→\n    59→    def is_watermark_enabled(self) -> bool:\n    60→        \"\"\"判断水印是否启用。\"\"\"\n    61→        from config.sources.watermark_config import is_watermark_enabled\n    62→        return is_watermark_enabled()\n    63→\n    64→    # =========================================================================\n    65→    # 存储配置\n    66→    # =========================================================================\n    67→\n    68→    def get_storage_dir(self) -> str:\n    69→        \"\"\"获取存储目录路径，若未设置返回空字符串。\"\"\"\n    70→        from config.sources.storage_config import get_storage_dir\n    71→        return get_storage_dir()\n    72→\n    73→    # =========================================================================\n    74→    # 生成配置\n    75→    # =========================================================================\n    76→\n    77→    def get_image_defaults(self) -> Dict[str, Any]:\n    78→        \"\"\"获取图像生成默认参数。\"\"\"\n    79→        from config.sources.generation_config import get_image_defaults\n    80→        return get_image_defaults()\n    81→\n    82→    def get_video_defaults(self) -> Dict[str, Any]:\n    83→        \"\"\"获取视频生成默认参数。\"\"\"\n    84→        from config.sources.generation_config import get_video_defaults\n    85→        return get_video_defaults()\n    86→\n    87→    # =========================================================================\n    88→    # AppConfig 兼容\n    89→    # =========================================================================\n    90→\n    91→    def get_app_config_instance(self):\n    92→        \"\"\"提供 AppConfig 实例，供旧代码直接访问。\"\"\"\n    93→        try:\n    94→            from config.app_config import AppConfig\n    95→            return AppConfig()\n    96→        except Exception as exc:  # pragma: no cover - 仅日志记录\n    97→            logger.warning(\"Failed to load AppConfig: %s\", exc)\n    98→            return None\n    99→\n   100→    # =========================================================================\n   101→    # App Meta（可追踪真源）\n   102→    # =========================================================================\n   103→\n   104→    def get_app_meta(self) -> Dict[str, Any]:\n   105→        \"\"\"获取应用元信息（版本号真源为 version.py）。\"\"\"\n   106→        from config.sources.app_meta import get_app_meta\n   107→        return get_app_meta()\n   108→\n   109→    # =========================================================================\n   110→    # Edition / Trial 标识（启动注入只读）\n   111→    # =========================================================================\n   112→\n   113→    def get_edition(self) -> str:\n   114→        \"\"\"获取发行渠道标识：trial/prod（只读）。\"\"\"\n   115→        from config.sources.edition_config import get_edition\n   116→        return get_edition()\n   117→\n   118→    def is_trial(self) -> bool:\n   119→        \"\"\"是否为体验版（只读）。\"\"\"\n   120→        from config.sources.edition_config import is_trial\n   121→        return bool(is_trial())\n   122→\n   123→    # =========================================================================\n   124→    # 通用访问（向后兼容）\n   125→    # =========================================================================\n   126→\n   127→    def get(self, key: str, default: Any = None) -> Any:\n   128→        \"\"\"通用配置访问，已废弃，优先使用专用方法。\"\"\"\n   129→        warnings.warn(\n   130→            \"UnifiedConfig.get() 已废弃，请使用专用方法\",\n   131→            DeprecationWarning,\n   132→            stacklevel=2,\n   133→        )\n   134→\n   135→        if not key:\n   136→            return default\n   137→\n   138→        normalized = key.strip()\n   139→        if not normalized:\n   140→            return default\n   141→\n   142→        canonical = normalized.upper()\n   143→        normalized_lower = normalized.lower()\n   144→\n   145→        if canonical == \"VOLCENGINE_API_KEY\":\n   146→            try:\n   147→                from config.sources.api_config import get_api_key\n   148→\n   149→                return get_api_key(\"volcengine\")\n   150→            except Exception:\n   151→                logger.debug(\"api_config.get_api_key fallback\", exc_info=True)\n   152→\n   153→        if canonical in {\"STORAGE_DIR\", \"GEMENG_STORAGE_DIR\"} or normalized_lower in _STORAGE_KEYS:\n   154→            try:\n   155→                from config.sources.storage_config import get_storage_dir\n   156→\n   157→                return get_storage_dir()\n   158→            except Exception:\n   159→                logger.debug(\"storage_config.get_storage_dir fallback\", exc_info=True)\n   160→\n   161→        try:\n   162→            from modules.config.config_manager import config_manager\n   163→\n   164→            value = config_manager.get(normalized)\n   165→            if value is not None:\n   166→                return value\n   167→        except Exception:\n   168→            logger.debug(\"Legacy config_manager lookup failed\", exc_info=True)\n   169→\n   170→        return default\n   171→\n   172→    # =========================================================================\n   173→    # 配置更新\n   174→    # =========================================================================\n   175→\n   176→    def set_value(self, key: str, value: Any) -> None:\n   177→        \"\"\"设置配置值，优先支持新的存储目录接口。\"\"\"\n   178→        normalized_key = (key or \"\").strip().lower()\n   179→        if normalized_key in _STORAGE_KEYS:\n   180→            from config.sources.storage_config import set_storage_dir\n   181→            success = set_storage_dir(str(value))\n   182→            if not success:\n   183→                raise RuntimeError(\"存储目录更新失败\")\n   184→            return\n   185→\n   186→        try:\n   187→            from modules.config.config_manager import config_manager\n   188→        except Exception as exc:\n   189→            raise RuntimeError(\"ConfigManager 未初始化，无法写入配置\") from exc\n   190→\n   191→        config_manager.set(key, str(value))\n   192→\n   193→    # =========================================================================\n   194→    # 工具方法\n   195→    # =========================================================================\n   196→\n   197→    def reload(self) -> None:\n   198→        \"\"\"重新加载配置源模块。\"\"\"\n   199→        import importlib\n   200→        modules = (\n   201→            \"config.sources.api_config\",\n   202→            \"config.sources.storage_config\",\n   203→            \"config.sources.generation_config\",\n   204→            \"config.sources.watermark_config\",\n   205→            \"modules.config.config_manager\",\n   206→        )\n   207→        for module_name in modules:\n   208→            try:\n   209→                importlib.reload(importlib.import_module(module_name))\n   210→            except Exception:\n   211→                logger.debug(\"Reload failed for %s\", module_name, exc_info=True)\n   212→        logger.info(\"Configuration reloaded\")\n   213→\n   214→\n   215→_unified_config_instance: Optional[UnifiedConfig] = None\n   216→\n   217→\n   218→def get_unified_config() -> UnifiedConfig:\n   219→    \"\"\"返回 UnifiedConfig 单例。\"\"\"\n   220→    global _unified_config_instance\n   221→    if _unified_config_instance is None:\n   222→        _unified_config_instance = UnifiedConfig()\n   223→    return _unified_config_instance\n   224→\n   225→\n   226→def get_api_key(service: str = \"volcengine\") -> str:\n   227→    \"\"\"快捷函数：获取 API 密钥。\"\"\"\n   228→    return get_unified_config().get_api_key(service)\n   229→\n   230→\n   231→def get_watermark_config() -> Dict[str, Any]:\n   232→    \"\"\"快捷函数：获取水印配置。\"\"\"\n   233→    return get_unified_config().get_watermark_config()\n   234→\n   235→\n   236→def get_storage_dir() -> str:\n   237→    \"\"\"快捷函数：获取存储目录。\"\"\"\n   238→    return get_unified_config().get_storage_dir()\n   239→\n   240→\n   241→def get_image_defaults() -> Dict[str, Any]:\n   242→    \"\"\"快捷函数：获取图像生成默认参数。\"\"\"\n   243→    return get_unified_config().get_image_defaults()\n   244→\n   245→\n   246→def get_video_defaults() -> Dict[str, Any]:\n   247→    \"\"\"快捷函数：获取视频生成默认参数。\"\"\"\n   248→    return get_unified_config().get_video_defaults()\n   249→\n   250→\n   251→def get_app_meta() -> Dict[str, Any]:\n   252→    \"\"\"快捷函数：获取应用元信息。\"\"\"\n   253→    return get_unified_config().get_app_meta()\n   254→\n   255→\n   256→def get_edition() -> str:\n   257→    \"\"\"快捷函数：获取发行渠道标识。\"\"\"\n   258→    return get_unified_config().get_edition()\n   259→\n   260→\n   261→def is_trial() -> bool:\n   262→    \"\"\"快捷函数：是否为体验版。\"\"\"\n   263→    return get_unified_config().is_trial()\n   264→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1f97b537-4574-4395-be11-aaf1438b4f86","timestamp":"2026-01-05T11:53:49.382Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/config/unified_config.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"统一配置门面，使用新的 config.sources 模块作为单一真源。\"\"\"\n\nfrom typing import Any, Dict, Optional\nimport logging\nimport warnings\n\nlogger = logging.getLogger(__name__)\n\n_STORAGE_KEYS = {\"storage_dir\", \"gemeng_storage_dir\", \"storage_root_path\"}\n\n\nclass UnifiedConfig:\n    \"\"\"提供统一的配置访问入口，封装所有底层配置实现。\"\"\"\n\n    _instance = None\n    _initialized = False\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if self._initialized:\n            return\n        self._initialized = True\n        logger.debug(\"UnifiedConfig initialized\")\n\n    # =========================================================================\n    # API 密钥管理\n    # =========================================================================\n\n    def get_api_key(self, service: str) -> str:\n        \"\"\"获取指定服务的 API 密钥。\"\"\"\n        from config.sources.api_config import get_api_key\n        return get_api_key(service)\n\n    def validate_api_keys(self) -> tuple[bool, list[str], str]:\n        \"\"\"验证 API 密钥配置情况。\"\"\"\n        from config.sources.api_config import validate_api_keys\n        return validate_api_keys()\n\n    def update_api_key(self, service: str, api_key: str) -> None:\n        \"\"\"更新指定服务的 API 密钥。\"\"\"\n        from config.sources.api_config import update_api_key\n        update_api_key(service, api_key)\n\n    # =========================================================================\n    # 水印配置\n    # =========================================================================\n\n    def get_watermark_config(self) -> Dict[str, Any]:\n        \"\"\"返回当前水印配置。\"\"\"\n        from config.sources.watermark_config import get_watermark_config\n        return get_watermark_config()\n\n    def is_watermark_enabled(self) -> bool:\n        \"\"\"判断水印是否启用。\"\"\"\n        from config.sources.watermark_config import is_watermark_enabled\n        return is_watermark_enabled()\n\n    # =========================================================================\n    # 存储配置\n    # =========================================================================\n\n    def get_storage_dir(self) -> str:\n        \"\"\"获取存储目录路径，若未设置返回空字符串。\"\"\"\n        from config.sources.storage_config import get_storage_dir\n        return get_storage_dir()\n\n    # =========================================================================\n    # 生成配置\n    # =========================================================================\n\n    def get_image_defaults(self) -> Dict[str, Any]:\n        \"\"\"获取图像生成默认参数。\"\"\"\n        from config.sources.generation_config import get_image_defaults\n        return get_image_defaults()\n\n    def get_video_defaults(self) -> Dict[str, Any]:\n        \"\"\"获取视频生成默认参数。\"\"\"\n        from config.sources.generation_config import get_video_defaults\n        return get_video_defaults()\n\n    # =========================================================================\n    # AppConfig 兼容\n    # =========================================================================\n\n    def get_app_config_instance(self):\n        \"\"\"提供 AppConfig 实例，供旧代码直接访问。\"\"\"\n        try:\n            from config.app_config import AppConfig\n            return AppConfig()\n        except Exception as exc:  # pragma: no cover - 仅日志记录\n            logger.warning(\"Failed to load AppConfig: %s\", exc)\n            return None\n\n    # =========================================================================\n    # App Meta（可追踪真源）\n    # =========================================================================\n\n    def get_app_meta(self) -> Dict[str, Any]:\n        \"\"\"获取应用元信息（版本号真源为 version.py）。\"\"\"\n        from config.sources.app_meta import get_app_meta\n        return get_app_meta()\n\n    # =========================================================================\n    # Edition / Trial 标识（启动注入只读）\n    # =========================================================================\n\n    def get_edition(self) -> str:\n        \"\"\"获取发行渠道标识：trial/prod（只读）。\"\"\"\n        from config.sources.edition_config import get_edition\n        return get_edition()\n\n    def is_trial(self) -> bool:\n        \"\"\"是否为体验版（只读）。\"\"\"\n        from config.sources.edition_config import is_trial\n        return bool(is_trial())\n\n    # =========================================================================\n    # 通用访问（向后兼容）\n    # =========================================================================\n\n    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"通用配置访问，已废弃，优先使用专用方法。\"\"\"\n        warnings.warn(\n            \"UnifiedConfig.get() 已废弃，请使用专用方法\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        if not key:\n            return default\n\n        normalized = key.strip()\n        if not normalized:\n            return default\n\n        canonical = normalized.upper()\n        normalized_lower = normalized.lower()\n\n        if canonical == \"VOLCENGINE_API_KEY\":\n            try:\n                from config.sources.api_config import get_api_key\n\n                return get_api_key(\"volcengine\")\n            except Exception:\n                logger.debug(\"api_config.get_api_key fallback\", exc_info=True)\n\n        if canonical in {\"STORAGE_DIR\", \"GEMENG_STORAGE_DIR\"} or normalized_lower in _STORAGE_KEYS:\n            try:\n                from config.sources.storage_config import get_storage_dir\n\n                return get_storage_dir()\n            except Exception:\n                logger.debug(\"storage_config.get_storage_dir fallback\", exc_info=True)\n\n        try:\n            from modules.config.config_manager import config_manager\n\n            value = config_manager.get(normalized)\n            if value is not None:\n                return value\n        except Exception:\n            logger.debug(\"Legacy config_manager lookup failed\", exc_info=True)\n\n        return default\n\n    # =========================================================================\n    # 配置更新\n    # =========================================================================\n\n    def set_value(self, key: str, value: Any) -> None:\n        \"\"\"设置配置值，优先支持新的存储目录接口。\"\"\"\n        normalized_key = (key or \"\").strip().lower()\n        if normalized_key in _STORAGE_KEYS:\n            from config.sources.storage_config import set_storage_dir\n            success = set_storage_dir(str(value))\n            if not success:\n                raise RuntimeError(\"存储目录更新失败\")\n            return\n\n        try:\n            from modules.config.config_manager import config_manager\n        except Exception as exc:\n            raise RuntimeError(\"ConfigManager 未初始化，无法写入配置\") from exc\n\n        config_manager.set(key, str(value))\n\n    # =========================================================================\n    # 工具方法\n    # =========================================================================\n\n    def reload(self) -> None:\n        \"\"\"重新加载配置源模块。\"\"\"\n        import importlib\n        modules = (\n            \"config.sources.api_config\",\n            \"config.sources.storage_config\",\n            \"config.sources.generation_config\",\n            \"config.sources.watermark_config\",\n            \"modules.config.config_manager\",\n        )\n        for module_name in modules:\n            try:\n                importlib.reload(importlib.import_module(module_name))\n            except Exception:\n                logger.debug(\"Reload failed for %s\", module_name, exc_info=True)\n        logger.info(\"Configuration reloaded\")\n\n\n_unified_config_instance: Optional[UnifiedConfig] = None\n\n\ndef get_unified_config() -> UnifiedConfig:\n    \"\"\"返回 UnifiedConfig 单例。\"\"\"\n    global _unified_config_instance\n    if _unified_config_instance is None:\n        _unified_config_instance = UnifiedConfig()\n    return _unified_config_instance\n\n\ndef get_api_key(service: str = \"volcengine\") -> str:\n    \"\"\"快捷函数：获取 API 密钥。\"\"\"\n    return get_unified_config().get_api_key(service)\n\n\ndef get_watermark_config() -> Dict[str, Any]:\n    \"\"\"快捷函数：获取水印配置。\"\"\"\n    return get_unified_config().get_watermark_config()\n\n\ndef get_storage_dir() -> str:\n    \"\"\"快捷函数：获取存储目录。\"\"\"\n    return get_unified_config().get_storage_dir()\n\n\ndef get_image_defaults() -> Dict[str, Any]:\n    \"\"\"快捷函数：获取图像生成默认参数。\"\"\"\n    return get_unified_config().get_image_defaults()\n\n\ndef get_video_defaults() -> Dict[str, Any]:\n    \"\"\"快捷函数：获取视频生成默认参数。\"\"\"\n    return get_unified_config().get_video_defaults()\n\n\ndef get_app_meta() -> Dict[str, Any]:\n    \"\"\"快捷函数：获取应用元信息。\"\"\"\n    return get_unified_config().get_app_meta()\n\n\ndef get_edition() -> str:\n    \"\"\"快捷函数：获取发行渠道标识。\"\"\"\n    return get_unified_config().get_edition()\n\n\ndef is_trial() -> bool:\n    \"\"\"快捷函数：是否为体验版。\"\"\"\n    return get_unified_config().is_trial()\n","numLines":264,"startLine":1,"totalLines":264}}}
{"parentUuid":"1f97b537-4574-4395-be11-aaf1438b4f86","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BVMNE8xXyB6Duv34n1xhRW","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/config_api_example.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_2026q1_config_api/config_api_production.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_2026q1_config_api/config_api_trial.py\n/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_体验版/_internal/config_api_trial.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/config/config_manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_2026q1_config_api/config_api.py"}]},"uuid":"b02affe0-5cc5-430d-8626-f5a0a17025d2","timestamp":"2026-01-05T11:53:49.406Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/config_api_example.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_2026q1_config_api/config_api_production.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_2026q1_config_api/config_api_trial.py","/Users/yunchang/Documents/GitHub/gemeng2/dist/鸽梦Godream_体验版/_internal/config_api_trial.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/config/config_manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/retired_2026q1_config_api/config_api.py"],"durationMs":31,"numFiles":7,"truncated":false}}
{"parentUuid":"b02affe0-5cc5-430d-8626-f5a0a17025d2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DE7qk7NyZDUvMFJuUJ97Ef","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→仓库管理器 - 统一管理所有内容仓库功能\n     5→\n     6→主要功能：\n     7→- 协调各个子模块的工作\n     8→- 提供统一的API接口\n     9→- 管理仓库配置和状态\n    10→- 处理跨模块的数据交互\n    11→\"\"\"\n    12→\n    13→import os\n    14→import json\n    15→from pathlib import Path\n    16→from typing import Dict, List, Optional, Any\n    17→from datetime import datetime\n    18→from typing import Tuple\n    19→\n    20→from .sqlite_handler import SQLiteHandler\n    21→from loguru import logger\n    22→try:\n    23→    from utils.error_handler import global_error_handler as _global_error_handler\n    24→except Exception:\n    25→    _global_error_handler = None\n    26→\n    27→\n    28→class _RepoErrorHandler:\n    29→    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    30→    def log_error(self, message: str):\n    31→        try:\n    32→            if _global_error_handler:\n    33→                logger.error(message)\n    34→            else:\n    35→                print(f\"[RepositoryManager][ERROR] {message}\")\n    36→        except Exception:\n    37→            print(f\"[RepositoryManager][ERROR] {message}\")\n    38→\n    39→\n    40→class _NullTagManager:\n    41→    def get_content_tags(self, content_id: str):\n    42→        return []\n    43→    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n    44→        return False\n    45→    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n    46→        return False\n    47→    def get_all_tags(self, category: str = None):\n    48→        return []\n    49→    def get_statistics(self):\n    50→        return {}\n    51→    def export_data(self):\n    52→        return {}\n    53→\n    54→\n    55→class _NullSearchEngine:\n    56→    def get_total_count(self) -> int:\n    57→        return 0\n    58→    def export_data(self):\n    59→        return {}\n    60→\n    61→\n    62→class RepositoryManager:\n    63→    \"\"\"\n    64→    仓库管理器 - 内容仓库的核心控制器\n    65→    \n    66→    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    67→    为上层应用提供统一的仓库管理接口。\n    68→    \"\"\"\n    69→    \n    70→    def __init__(self, storage_root: str):\n    71→        \"\"\"\n    72→        初始化仓库管理器\n    73→        \n    74→        Args:\n    75→            storage_root: 用户指定的存储根目录\n    76→        \"\"\"\n    77→        self.storage_root = Path(storage_root)\n    78→        self.repository_root = self.storage_root / \"repository\"\n    79→        self.config_file = self.repository_root / \"config.json\"\n    80→        \n    81→        # 确保仓库目录存在\n    82→        self.repository_root.mkdir(parents=True, exist_ok=True)\n    83→        \n    84→        # 初始化子模块\n    85→        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n    86→        # 提供占位依赖，避免未实现接口导致崩溃\n    87→        self.error_handler = _RepoErrorHandler()\n    88→        self.tag_manager = _NullTagManager()\n    89→        self.search_engine = _NullSearchEngine()\n    90→        \n    91→        # 加载配置\n    92→        self.config = self._load_config()\n    93→        \n    94→        # 初始化仓库\n    95→        self._initialize_repository()\n    96→    \n    97→    def _load_config(self) -> Dict[str, Any]:\n    98→        \"\"\"\n    99→        加载仓库配置\n   100→        \n   101→        Returns:\n   102→            配置字典\n   103→        \"\"\"\n   104→        default_config = {\n   105→            \"version\": \"0.1.5\",\n   106→            \"created_at\": datetime.now().isoformat(),\n   107→            \"last_updated\": datetime.now().isoformat(),\n   108→            \"auto_tag_enabled\": True,\n   109→            \"search_index_enabled\": True,\n   110→            \"tag_categories\": [\n   111→                \"内容类型\",\n   112→                \"创建时间\", \n   113→                \"质量评级\",\n   114→                \"使用场景\",\n   115→                \"风格特征\",\n   116→                \"自定义标签\"\n   117→            ],\n   118→            \"supported_file_types\": [\"image\", \"video\", \"audio\", \"chat\"],\n   119→            \"max_tags_per_item\": 20,\n   120→            \"search_result_limit\": 100\n   121→        }\n   122→        \n   123→        if self.config_file.exists():\n   124→            try:\n   125→                with open(self.config_file, 'r', encoding='utf-8') as f:\n   126→                    config = json.load(f)\n   127→                # 合并默认配置，确保新字段存在\n   128→                for key, value in default_config.items():\n   129→                    if key not in config:\n   130→                        config[key] = value\n   131→                return config\n   132→            except Exception as e:\n   133→                self.error_handler.log_error(f\"加载仓库配置失败: {e}\")\n   134→                return default_config\n   135→        else:\n   136→            # 创建默认配置文件\n   137→            self._save_config(default_config)\n   138→            return default_config\n   139→    \n   140→    def _save_config(self, config: Dict[str, Any]) -> None:\n   141→        \"\"\"\n   142→        保存仓库配置\n   143→        \n   144→        Args:\n   145→            config: 配置字典\n   146→        \"\"\"\n   147→        try:\n   148→            config[\"last_updated\"] = datetime.now().isoformat()\n   149→            with open(self.config_file, 'w', encoding='utf-8') as f:\n   150→                json.dump(config, f, ensure_ascii=False, indent=2)\n   151→        except Exception as e:\n   152→            self.error_handler.log_error(f\"保存仓库配置失败: {e}\")\n   153→    \n   154→    def _initialize_repository(self) -> None:\n   155→        \"\"\"\n   156→        初始化仓库结构\n   157→        \"\"\"\n   158→        try:\n   159→            # 创建必要的子目录\n   160→            subdirs = [\"tags\", \"index\", \"cache\", \"exports\"]\n   161→            for subdir in subdirs:\n   162→                (self.repository_root / subdir).mkdir(exist_ok=True)\n   163→            \n   164→            print(f\"仓库初始化完成: {self.repository_root}\")\n   165→            \n   166→        except Exception as e:\n   167→            self.error_handler.log_error(f\"仓库初始化失败: {e}\")\n   168→            raise\n   169→\n   170→    def _ensure_dict(self, value: Any) -> Dict[str, Any]:\n   171→        if isinstance(value, dict):\n   172→            return value\n   173→        if isinstance(value, str) and value:\n   174→            try:\n   175→                loaded = json.loads(value)\n   176→                return loaded if isinstance(loaded, dict) else {}\n   177→            except Exception:\n   178→                return {}\n   179→        return {}\n   180→\n   181→    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n   182→        normalized: List[Dict[str, Any]] = []\n   183→        if not records:\n   184→            return normalized\n   185→        seen_keys: set[str] = set()\n   186→        for record in records:\n   187→            normalized_record = self._normalize_record(record, content_type)\n   188→            if not normalized_record:\n   189→                continue\n   190→            gen_key = normalized_record.get('generation_id') or normalized_record.get('task_id') or normalized_record.get('file_id')\n   191→            key = str(gen_key) if gen_key else None\n   192→            if key and key in seen_keys:\n   193→                continue\n   194→            if key:\n   195→                seen_keys.add(key)\n   196→            normalized.append(normalized_record)\n   197→        return normalized\n   198→\n   199→    \n   200→    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n   201→        if not isinstance(record, dict):\n   202→            return {}\n   203→\n   204→        item = dict(record)\n   205→        metadata_raw = item.get('metadata') or {}\n   206→        if isinstance(metadata_raw, str):\n   207→            try:\n   208→                metadata_raw = json.loads(metadata_raw) or {}\n   209→            except Exception:\n   210→                metadata_raw = {}\n   211→        item['metadata'] = metadata_raw\n   212→\n   213→        # 统一内容类型\n   214→        ctype = item.get('content_type') or content_type or ''\n   215→        if ctype == 'image':\n   216→            ctype = 'images'\n   217→        elif ctype == 'video':\n   218→            ctype = 'videos'\n   219→        item['content_type'] = ctype\n   220→\n   221→        # 解析JSON字段\n   222→        item['parameters'] = self._ensure_dict(item.get('parameters'))\n   223→        item['metadata'] = self._ensure_dict(item.get('metadata'))\n   224→        item['batch_info'] = self._ensure_dict(item.get('batch_info'))\n   225→\n   226→        metadata = item['metadata']\n   227→\n   228→        # 同步核心字段\n   229→        created_at = item.get('created_at')\n   230→        if not created_at:\n   231→            created_at = metadata.get('created_at') or metadata.get('completed_at')\n   232→        if not created_at:\n   233→            created_at = datetime.now().isoformat()\n   234→        if isinstance(created_at, datetime):\n   235→            item['created_at'] = created_at.isoformat()\n   236→        else:\n   237→            item['created_at'] = created_at\n   238→\n   239→        file_id = item.get('file_id') or item.get('generation_id') or metadata.get('task_id')\n   240→        if file_id:\n   241→            item['file_id'] = str(file_id)\n   242→\n   243→        generation_id = item.get('generation_id') or metadata.get('generation_id') or metadata.get('task_id')\n   244→        if generation_id:\n   245→            item['generation_id'] = str(generation_id)\n   246→\n   247→        resolved_path = item.get('resolved_path')\n   248→        candidate_paths = [\n   249→            resolved_path,\n   250→            item.get('absolute_path'),\n   251→            metadata.get('local_path'),\n   252→            item.get('file_path'),\n   253→        ]\n   254→        abs_path = next((p for p in candidate_paths if p), None)\n   255→        \n   256→        # 验证绝对路径是否真实存在（修复旧记录路径失效问题）\n   257→        if abs_path and not Path(abs_path).exists():\n   258→            logger.warning(f\"绝对路径无效，将尝试从relative_path重新构造: {abs_path}\")\n   259→            abs_path = None  # 重置，触发下面的重新构造逻辑\n   260→        \n   261→        if not abs_path and (item.get('relative_path') or metadata.get('relative_path')):\n   262→            rel = item.get('relative_path') or metadata.get('relative_path')\n   263→            try:\n   264→                root = self.storage_root\n   265→                original_path = Path(root) / rel\n   266→                if original_path.exists():\n   267→                    abs_path = str(original_path)\n   268→                    logger.debug(f\"使用路径: {abs_path}\")\n   269→                else:\n   270→                    abs_path = str(original_path)\n   271→                    logger.warning(f\"文件不存在: {original_path}\")\n   272→            except Exception as e:\n   273→                logger.error(f\"路径解析失败: {rel}, 错误: {e}\")\n   274→                abs_path = None\n   275→\n   276→        if abs_path:\n   277→            abs_path = str(abs_path)\n   278→            item['absolute_path'] = abs_path\n   279→            item['local_path'] = abs_path\n   280→            item['file_path'] = abs_path\n   281→            \n   282→            # 自动补充文件大小\n   283→            if not item.get('file_size'):\n   284→                try:\n   285→                    size = os.path.getsize(abs_path)\n   286→                    item['file_size'] = size\n   287→                    # 同时回写到 metadata 以备后用\n   288→                    item['metadata']['file_size'] = size\n   289→                except Exception:\n   290→                    pass\n   291→\n   292→        # 记录相对路径\n   293→        rel_value = item.get('relative_path') or metadata.get('relative_path')\n   294→        if rel_value:\n   295→            item['relative_path'] = str(rel_value)\n   296→\n   297→        # 若缺少真实路径且状态已完成，则忽略该记录\n   298→        if not (item.get('file_path') or item.get('absolute_path') or item.get('relative_path')):\n   299→            status = str(item.get('status') or '').lower()\n   300→            # pending 状态的记录应该保留（即使缺路径，用于占位卡片显示）\n   301→            if status == 'pending':\n   302→                pass  # 不过滤，继续处理\n   303→            elif not status or status in {'completed', 'success'}:\n   304→                return {}\n   305→\n   306→       # 缩略图字段\n   307→        thumb_local = item.get('thumbnail_local_path') or metadata.get('thumbnail_local_path') or metadata.get('api_thumbnail_local_path')\n   308→        if thumb_local:\n   309→            item['thumbnail_local_path'] = str(thumb_local)\n   310→\n   311→        thumb_rel = item.get('thumbnail_path') or metadata.get('thumbnail_path') or item.get('thumbnail_local_path')\n   312→        if thumb_rel:\n   313→            item['thumbnail_path'] = str(thumb_rel)\n   314→            # 如果没有 thumbnail_local_path，则从相对路径生成绝对路径\n   315→            if not thumb_local:\n   316→                try:\n   317→                    thumb_abs = Path(self.storage_root) / thumb_rel\n   318→                    if thumb_abs.exists():\n   319→                        item['thumbnail_local_path'] = str(thumb_abs)\n   320→                        # logger.debug(f\"生成缩略图绝对路径: {thumb_abs}\")\n   321→                    else:\n   322→                        # logger.debug(f\"缩略图文件不存在: {thumb_abs}\")\n   323→                        pass\n   324→                except Exception as e:\n   325→                    logger.debug(f\"缩略图路径解析失败: {thumb_rel}, 错误: {e}\")\n   326→\n   327→        # 补充尺寸信息，便于前端按比例渲染\n   328→        width = item.get('width') or metadata.get('width')\n   329→        height = item.get('height') or metadata.get('height')\n   330→        if width:\n   331→            try:\n   332→                item['width'] = int(float(width))\n   333→            except Exception:\n   334→                pass\n   335→        if height:\n   336→            try:\n   337→                item['height'] = int(float(height))\n   338→            except Exception:\n   339→                pass\n   340→        # 尝试从参数 size 提取比例（如果未提供 width/height）\n   341→        if (not item.get('width') or not item.get('height')):\n   342→            size_txt = item['parameters'].get('size') if isinstance(item['parameters'], dict) else None\n   343→            if isinstance(size_txt, str) and 'x' in size_txt:\n   344→                try:\n   345→                    sw, sh = size_txt.split('x')\n   346→                    item['width'] = item.get('width') or int(float(sw))\n   347→                    item['height'] = item.get('height') or int(float(sh))\n   348→                except Exception:\n   349→                    pass\n   350→        # 兜底：若本地文件存在且仍缺尺寸，尝试读取一次\n   351→        if (not item.get('width') or not item.get('height')):\n   352→            try:\n   353→                abs_path_probe = item.get('absolute_path') or item.get('file_path')\n   354→                if abs_path_probe and Path(abs_path_probe).exists():\n   355→                    from PIL import Image\n   356→                    with Image.open(abs_path_probe) as img:\n   357→                        item['width'] = item.get('width') or int(img.width)\n   358→                        item['height'] = item.get('height') or int(img.height)\n   359→            except Exception as exc:\n   360→                logger.debug(f\"尺寸读取失败: {exc}\")\n   361→\n   362→        # 提升 prompt 等常用字段\n   363→        if not item.get('prompt') and item['parameters'].get('prompt'):\n   364→            item['prompt'] = item['parameters']['prompt']\n   365→\n   366→        return item\n   367→\n   368→    def _parse_created_at(self, value: Any) -> datetime:\n   369→        if isinstance(value, datetime):\n   370→            return value\n   371→        if not value:\n   372→            return datetime.min\n   373→        text = str(value)\n   374→        try:\n   375→            if text.endswith('Z'):\n   376→                text = text[:-1] + '+00:00'\n   377→            return datetime.fromisoformat(text)\n   378→        except Exception:\n   379→            try:\n   380→                return datetime.strptime(text, '%Y-%m-%d %H:%M:%S')\n   381→            except Exception:\n   382→                return datetime.min\n   383→\n   384→    def _record_sort_key(self, record: Dict[str, Any]) -> Tuple[datetime, str]:\n   385→        created_dt = self._parse_created_at(record.get('created_at'))\n   386→        # fallback: 如果 created_at 无效，尝试使用 updated_at\n   387→        if created_dt == datetime.min:\n   388→            created_dt = self._parse_created_at(record.get('updated_at'))\n   389→        file_id = str(record.get('file_id', ''))\n   390→        return (created_dt, file_id)\n   391→\n   392→    def add_content(self, content_id: str, content_type: str, \n   393→                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n   394→        \"\"\"\n   395→        添加内容到仓库\n   396→        \n   397→        Args:\n   398→            content_id: 内容唯一标识\n   399→            content_type: 内容类型 (image/video/audio/chat)\n   400→            metadata: 内容元数据\n   401→            auto_tag: 是否自动生成标签\n   402→        \n   403→        Returns:\n   404→            是否添加成功\n   405→        \"\"\"\n   406→        try:\n   407→            normalized_type = (content_type or '').lower()\n   408→            if normalized_type in {'image', 'images'}:\n   409→                storage_type = 'images'\n   410→            elif normalized_type in {'video', 'videos'}:\n   411→                storage_type = 'videos'\n   412→            else:\n   413→                storage_type = normalized_type or 'unknown'\n   414→            status = metadata.get('status', 'unknown')\n   415→            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n   416→            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n   417→            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n   418→            return result\n   419→        except Exception as e:\n   420→            logger.error(f\"添加内容失败: {e}\")\n   421→            return False\n   422→    \n   423→    def update_record(self, record_id: str, data: Dict[str, Any]) -> bool:\n   424→        \"\"\"更新记录\"\"\"\n   425→        try:\n   426→            return self.sqlite_handler.update_record(record_id, data)\n   427→        except Exception as e:\n   428→            logger.error(f\"更新记录失败: {e}\")\n   429→            return False\n   430→\n   431→    def delete_record(self, record_id: str) -> bool:\n   432→        \"\"\"删除记录\"\"\"\n   433→        try:\n   434→            return self.sqlite_handler.delete_record(record_id)\n   435→        except Exception as e:\n   436→            logger.error(f\"删除记录失败: {e}\")\n   437→            return False\n   438→\n   439→    def delete_record_with_files(self, record_id: str) -> bool:\n   440→        \"\"\"删除记录及其所有关联文件\n   441→        \n   442→        Args:\n   443→            record_id: 记录ID\n   444→            \n   445→        Returns:\n   446→            bool: 是否删除成功\n   447→        \"\"\"\n   448→        if not record_id:\n   449→            return False\n   450→            \n   451→        try:\n   452→            # 1. 获取记录详情\n   453→            record = self.get_record_by_id(record_id)\n   454→            if not record:\n   455→                logger.warning(f\"删除记录: 未找到记录 {record_id}\")\n   456→                return False\n   457→            \n   458→            # 2. 收集需要删除的文件路径\n   459→            files_to_delete = []\n   460→            \n   461→            # 主文件（图片/视频）\n   462→            file_path = record.get('absolute_path') or record.get('file_path')\n   463→            if file_path:\n   464→                files_to_delete.append(file_path)\n   465→            \n   466→            # 缩略图\n   467→            thumb_path = record.get('thumbnail_local_path')\n   468→            if thumb_path:\n   469→                files_to_delete.append(thumb_path)\n   470→            \n   471→            # 参考图资产 - 跳过删除\n   472→            # 原因：同一参考图可能被多条记录引用（已验证），删除会影响其他记录\n   473→            \n   474→            # 3. 删除数据库记录\n   475→            if not self.delete_record(record_id):\n   476→                logger.error(f\"删除记录失败: 数据库删除失败 {record_id}\")\n   477→                return False\n   478→            \n   479→            # 4. 删除文件（忽略不存在的文件）\n   480→            deleted_files = []\n   481→            for path in files_to_delete:\n   482→                try:\n   483→                    if path and Path(path).exists():\n   484→                        Path(path).unlink()\n   485→                        deleted_files.append(path)\n   486→                        logger.debug(f\"已删除文件: {path}\")\n   487→                except Exception as e:\n   488→                    logger.warning(f\"删除文件失败: {path}, {e}\")\n   489→            \n   490→            logger.info(f\"删除记录完成: {record_id}, 删除了 {len(deleted_files)} 个文件\")\n   491→            return True\n   492→            \n   493→        except Exception as e:\n   494→            logger.error(f\"删除记录及文件失败: {record_id}, {e}\")\n   495→            return False\n   496→\n   497→    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n   498→        \"\"\"清理超时的 pending 记录\n   499→\n   500→        Args:\n   501→            timeout_hours: 超时时间（小时），默认 1 小时\n   502→\n   503→        Returns:\n   504→            清理的记录数量\n   505→        \"\"\"\n   506→        try:\n   507→            return self.sqlite_handler.cleanup_stale_pending_records(timeout_hours)\n   508→        except Exception as e:\n   509→            logger.error(f\"清理过期 pending 记录失败: {e}\")\n   510→            return 0\n   511→\n   512→    def get_record_by_id(self, record_id: str) -> Optional[Dict[str, Any]]:\n   513→        \"\"\"根据 ID 获取单条记录。\"\"\"\n   514→        if not record_id:\n   515→            return None\n   516→        try:\n   517→            raw = self.sqlite_handler.get_record_by_id(record_id)\n   518→            if not raw:\n   519→                return None\n   520→            content_type = raw.get('content_type') or 'image'\n   521→            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n   522→            normalized = self._normalize_record(raw, normalized_type)\n   523→            if not normalized:\n   524→                return None\n   525→            self._attach_reference_assets([normalized], absolute=True)\n   526→            return normalized\n   527→        except Exception as e:\n   528→            logger.error(f\"获取记录失败: {e}\")\n   529→            return None\n   530→\n   531→    def get_records_by_status(\n   532→        self,\n   533→        record_type: str,\n   534→        statuses: List[str],\n   535→        *,\n   536→        limit: int = 50,\n   537→    ) -> List[Dict[str, Any]]:\n   538→        \"\"\"按状态获取记录（用于 pending 恢复等场景）.\"\"\"\n   539→\n   540→        normalized_type = (record_type or '').lower()\n   541→        if normalized_type in {'images', 'image'}:\n   542→            normalized_type = 'image'\n   543→        elif normalized_type in {'videos', 'video'}:\n   544→            normalized_type = 'video'\n   545→\n   546→        content_type = 'videos' if normalized_type == 'video' else 'images'\n   547→        try:\n   548→            raw = self.sqlite_handler.get_records_by_status(content_type, statuses, limit=limit) or []\n   549→            normalized = self._normalize_records(raw, normalized_type)\n   550→            self._attach_reference_assets(normalized, absolute=True)\n   551→            return normalized\n   552→        except Exception as e:\n   553→            self.error_handler.log_error(f\"按状态获取记录失败: {e}\")\n   554→            return []\n   555→    \n   556→    def get_records_batch(self, start_index=0, batch_size=40, record_type='all'):\n   557→        \"\"\"\n   558→        批量获取记录，支持分页查询\n   559→        \n   560→        Args:\n   561→            start_index: 起始索引\n   562→            batch_size: 批量大小\n   563→            record_type: 记录类型 ('image', 'video', 'all')\n   564→        \n   565→        Returns:\n   566→            List[Dict]: 记录列表\n   567→        \"\"\"\n   568→        try:\n   569→            normalized_type = (record_type or 'all').lower()\n   570→            if normalized_type == 'images':\n   571→                normalized_type = 'image'\n   572→            elif normalized_type == 'videos':\n   573→                normalized_type = 'video'\n   574→\n   575→            if normalized_type == 'all':\n   576→                fetch_limit = max(batch_size, start_index + batch_size)\n   577→                images = self.sqlite_handler.get_records('images', fetch_limit, 0) or []\n   578→                videos = self.sqlite_handler.get_records('videos', fetch_limit, 0) or []\n   579→                combined = images + videos\n   580→                combined.sort(key=self._record_sort_key, reverse=True)\n   581→                end_index = start_index + batch_size\n   582→                result = combined[start_index:end_index]\n   583→            else:\n   584→                content_type = 'images' if normalized_type == 'image' else 'videos'\n   585→                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n   586→                result.sort(key=self._record_sort_key, reverse=True)\n   587→\n   588→            normalized = self._normalize_records(result, normalized_type)\n   589→            self._attach_reference_assets(normalized, absolute=True)\n   590→            return normalized\n   591→        except Exception as e:\n   592→            self.error_handler.log_error(f\"批量获取记录失败: {e}\")\n   593→            return []\n   594→\n   595→    def get_records_batch_reverse(self, limit=80, offset=0, record_type='all'):\n   596→        \"\"\"\n   597→        倒序分页查询记录 - 瀑布流1000条方案专用\n   598→        \n   599→        优化特性：\n   600→        - 从最新记录开始的高效倒序查询\n   601→        - 支持80+30增量加载模式\n   602→        - 针对1000条数据优化的性能\n   603→        - 减少内存占用和查询时间\n   604→        \n   605→        Args:\n   606→            limit: 查询数量限制 (默认80，增量30)\n   607→            offset: 偏移量 (从最新记录开始计算)\n   608→            record_type: 记录类型 ('image', 'video', 'all')\n   609→        \n   610→        Returns:\n   611→            List[Dict]: 按时间倒序排列的记录列表\n   612→        \"\"\"\n   613→        try:\n   614→            normalized_type = (record_type or 'all').lower()\n   615→            if normalized_type == 'images':\n   616→                normalized_type = 'image'\n   617→            elif normalized_type == 'videos':\n   618→                normalized_type = 'video'\n   619→\n   620→            max_single_query = min(limit + 50, 200)\n   621→\n   622→            if normalized_type == 'all':\n   623→                images = self.sqlite_handler.get_records('images', max_single_query, 0) or []\n   624→                videos = self.sqlite_handler.get_records('videos', max_single_query, 0) or []\n   625→                combined = images + videos\n   626→                combined.sort(key=self._record_sort_key, reverse=True)\n   627→                start_idx = offset\n   628→                end_idx = offset + limit\n   629→                result = combined[start_idx:end_idx]\n   630→            else:\n   631→                content_type = 'images' if normalized_type == 'image' else 'videos'\n   632→                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n   633→                result.sort(key=self._record_sort_key, reverse=True)\n   634→\n   635→            normalized = self._normalize_records(result, normalized_type)\n   636→            self._attach_reference_assets(normalized, absolute=True)\n   637→\n   638→            return normalized\n   639→\n   640→        except Exception as e:\n   641→            self.error_handler.log_error(f\"倒序分页查询失败: {e}\")\n   642→            return []\n   643→\n   644→    def get_records_count_optimized(self, record_type='all'):\n   645→        \"\"\"\n   646→        优化的记录计数方法 - 瀑布流1000条方案专用\n   647→        \n   648→        提供快速的记录计数，支持1000条限制逻辑\n   649→        \n   650→        Args:\n   651→            record_type: 记录类型 ('image', 'video', 'all')\n   652→        \n   653→        Returns:\n   654→            Dict: {'total': int, 'capped_at_1000': bool}\n   655→        \"\"\"\n   656→        try:\n   657→            normalized_type = (record_type or 'all').lower()\n   658→            if normalized_type == 'image':\n   659→                total = self.sqlite_handler.get_total_count('images')\n   660→            elif normalized_type == 'video':\n   661→                total = self.sqlite_handler.get_total_count('videos')\n   662→            else:\n   663→                total = (\n   664→                    self.sqlite_handler.get_total_count('images') +\n   665→                    self.sqlite_handler.get_total_count('videos')\n   666→                )\n   667→\n   668→            # 1000条限制逻辑\n   669→            capped_at_1000 = total > 1000\n   670→            effective_total = min(total, 1000)\n   671→            \n   672→            return {\n   673→                'total': effective_total,\n   674→                'actual_total': total,\n   675→                'capped_at_1000': capped_at_1000\n   676→            }\n   677→            \n   678→        except Exception as e:\n   679→            self.error_handler.log_error(f\"优化记录计数失败: {e}\")\n   680→            return {'total': 0, 'actual_total': 0, 'capped_at_1000': False}\n   681→\n   682→    # =========================\n   683→    # 游标分页协议（初版实现）\n   684→    # 接口：get_records(page_size, cursor, record_type) -> { items, next_cursor }\n   685→    # 说明：当前实现基于现有CSV读取能力合并排序后切片，后续可在存储层优化为限窗/游标扫描。\n   686→    # =========================\n   687→    def get_records(self, page_size: int = 40, cursor: Optional[str] = None, record_type: str = 'all') -> Dict[str, Any]:\n   688→        \"\"\"\n   689→        游标分页获取记录\n   690→\n   691→        Args:\n   692→            page_size: 每页大小\n   693→            cursor: 上一页游标（格式：\"<created_at>|<file_id>|<type>\"），None表示第一页\n   694→            record_type: 'image' | 'video' | 'all'\n   695→\n   696→        Returns:\n   697→            dict: { items: List[Dict], next_cursor: Optional[str] }\n   698→        \"\"\"\n   699→        try:\n   700→            # 解析游标\n   701→            cursor_tuple: Optional[Tuple[str, str, str]] = None\n   702→            if cursor:\n   703→                try:\n   704→                    parts = cursor.split('|')\n   705→                    if len(parts) >= 3:\n   706→                        cursor_tuple = (parts[0], parts[1], parts[2])  # created_at, file_id, type\n   707→                except Exception:\n   708→                    cursor_tuple = None\n   709→\n   710→            # 拉取候选数据（按需窗口，尽量少取）\n   711→            fetch_limit = max(page_size * 3, 60)\n   712→\n   713→            def _load(ct: str) -> List[Dict[str, Any]]:\n   714→                return self._normalize_records(\n   715→                    self.sqlite_handler.get_records(ct, fetch_limit, 0) or [],\n   716→                    ct\n   717→                )\n   718→\n   719→            if record_type == 'image':\n   720→                records = _load('images')\n   721→            elif record_type == 'video':\n   722→                records = _load('videos')\n   723→            else:\n   724→                records = _load('images') + _load('videos')\n   725→\n   726→            # 排序：created_at DESC, file_id DESC\n   727→            records.sort(key=self._record_sort_key, reverse=True)\n   728→\n   729→            # 光标过滤：跳过光标及其之前的元素（保持稳定倒序）\n   730→            filtered: List[Dict[str, Any]] = []\n   731→            if cursor_tuple:\n   732→                cur_created, cur_id, cur_type = cursor_tuple\n   733→                passed = False\n   734→                for rec in records:\n   735→                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n   736→                    rec_key = (rec.get('created_at', '1970-01-01T00:00:00'), rec.get('file_id', ''), rec_type)\n   737→                    # 记录严格小于游标（因为倒序），才加入\n   738→                    if passed:\n   739→                        filtered.append(rec)\n   740→                    else:\n   741→                        if (rec_key[0] < cur_created) or (rec_key[0] == cur_created and rec_key[1] < cur_id) or (rec_key[0] == cur_created and rec_key[1] == cur_id and rec_key[2] < cur_type):\n   742→                            passed = True\n   743→                            filtered.append(rec)\n   744→                candidates = filtered\n   745→            else:\n   746→                candidates = records\n   747→\n   748→            # 取一页\n   749→            page_items = candidates[:page_size]\n   750→            self._attach_reference_assets(page_items, absolute=True)\n   751→\n   752→            # 生成 next_cursor\n   753→            if page_items:\n   754→                last = page_items[-1]\n   755→                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n   756→                next_cursor = f\"{last.get('created_at','')}|{last.get('file_id','')}|{last_type}\"\n   757→            else:\n   758→                next_cursor = None\n   759→\n   760→            return {\n   761→                'items': page_items,\n   762→                'next_cursor': next_cursor\n   763→            }\n   764→\n   765→        except Exception as e:\n   766→            self.error_handler.log_error(f\"游标分页获取记录失败: {e}\")\n   767→            return {\n   768→                'items': [],\n   769→                'next_cursor': None\n   770→            }\n   771→\n   772→    def get_total_count(self, record_type='all'):\n   773→        \"\"\"\n   774→        获取总记录数\n   775→        \n   776→        Args:\n   777→            record_type: 记录类型 ('image', 'video', 'all')\n   778→            \n   779→        Returns:\n   780→            int: 总记录数\n   781→        \"\"\"\n   782→        try:\n   783→            normalized_type = (record_type or 'all').lower()\n   784→            if normalized_type == 'image':\n   785→                return self.sqlite_handler.get_total_count('images')\n   786→            if normalized_type == 'video':\n   787→                return self.sqlite_handler.get_total_count('videos')\n   788→\n   789→            return (\n   790→                self.sqlite_handler.get_total_count('images') +\n   791→                self.sqlite_handler.get_total_count('videos')\n   792→            )\n   793→        except Exception as e:\n   794→            self.error_handler.log_error(f\"获取记录总数失败: {e}\")\n   795→            return 0\n   796→\n   797→    def _resolve_reference_assets(self, record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n   798→        if not isinstance(record, dict):\n   799→            return []\n   800→\n   801→        params_raw = record.get('parameters')\n   802→        params_dict: Dict[str, Any] = {}\n   803→        if isinstance(params_raw, dict):\n   804→            params_dict = params_raw\n   805→        elif isinstance(params_raw, str):\n   806→            try:\n   807→                params_dict = json.loads(params_raw) or {}\n   808→            except Exception:\n   809→                params_dict = {}\n   810→\n   811→        assets = []\n   812→        if isinstance(params_dict, dict):\n   813→            assets = params_dict.get('reference_assets') or []\n   814→        if not assets:\n   815→            fallback = record.get('reference_assets')\n   816→            assets = fallback if isinstance(fallback, list) else []\n   817→        if not assets:\n   818→            return []\n   819→\n   820→        resolved: List[Dict[str, Any]] = []\n   821→        for item in assets:\n   822→            if not isinstance(item, dict):\n   823→                continue\n   824→            rec = dict(item)\n   825→            rel_path = rec.get('relative_path') or rec.get('asset_path')\n   826→            if rel_path and absolute:\n   827→                abs_path = Path(self.storage_root) / rel_path\n   828→                rec['absolute_path'] = str(abs_path)\n   829→                rec['asset_path'] = str(abs_path)\n   830→            resolved.append(rec)\n   831→        return resolved\n   832→\n   833→    \n   834→    def _resolve_video_reference_assets(self, record: Dict[str, Any]) -> List[Dict[str, Any]]:\n   835→        \"\"\"\n   836→        解析视频记录中的参考图资产\n   837→        \n   838→        从parameters.first_frame和image_path提取参考图信息\n   839→        \"\"\"\n   840→        if not isinstance(record, dict):\n   841→            return []\n   842→            \n   843→        params = record.get('parameters', {})\n   844→        if isinstance(params, str):\n   845→            try:\n   846→                params = json.loads(params)\n   847→            except:\n   848→                params = {}\n   849→\n   850→        # 收集参考图路径\n   851→        ref_paths = []\n   852→\n   853→        storage_root = self.storage_root\n   854→\n   855→        def _resolve_path(path_str: Optional[str]) -> Optional[Path]:\n   856→            if not path_str:\n   857→                return None\n   858→            candidate = Path(path_str).expanduser()\n   859→            if candidate.is_absolute():\n   860→                return candidate if candidate.exists() else None\n   861→            combined = storage_root / path_str.lstrip('/\\\\')\n   862→            return combined if combined.exists() else None\n   863→\n   864→        # 从first_frame提取\n   865→        first_frame = params.get('first_frame')\n   866→        resolved_first = _resolve_path(first_frame) if isinstance(first_frame, str) else None\n   867→        if resolved_first:\n   868→            ref_paths.append(('first_frame', str(resolved_first)))\n   869→\n   870→        # 从last_frame提取（首尾帧模式）\n   871→        last_frame = params.get('last_frame')\n   872→        resolved_last = _resolve_path(last_frame) if isinstance(last_frame, str) else None\n   873→        if resolved_last:\n   874→            ref_paths.append(('last_frame', str(resolved_last)))\n   875→\n   876→        # 从image_path提取\n   877→        image_path = params.get('image_path')\n   878→        resolved_image = _resolve_path(image_path) if isinstance(image_path, str) else None\n   879→        if resolved_image and all(str(resolved_image) != existing_path for _, existing_path in ref_paths):\n   880→            ref_paths.append(('image', str(resolved_image)))\n   881→\n   882→        # 构建参考图资产信息\n   883→        resolved_assets = []\n   884→        for i, (kind, path) in enumerate(ref_paths):\n   885→            try:\n   886→                file_path = Path(path)\n   887→                if file_path.exists():\n   888→                    stat = file_path.stat()\n   889→                    try:\n   890→                        rel = file_path.resolve().relative_to(storage_root)\n   891→                        rel_str = str(rel).replace('\\\\', '/')\n   892→                    except ValueError:\n   893→                        rel_str = str(file_path)\n   894→                    asset = {\n   895→                        'id': f'ref_video_{record.get(\"generation_id\", \"unknown\")}_{i}',\n   896→                        'path': rel_str,\n   897→                        'relative_path': rel_str,\n   898→                        'absolute_path': str(file_path.resolve()),\n   899→                        'type': 'image',\n   900→                        'kind': kind or 'image',\n   901→                        'source': file_path.name,\n   902→                        'order': i,\n   903→                        'size': stat.st_size,\n   904→                        'exists': True,\n   905→                        'created_at': record.get('created_at', datetime.now().isoformat())\n   906→                    }\n   907→\n   908→                    # 尝试获取图片尺寸\n   909→                    try:\n   910→                        from PIL import Image\n   911→                        with Image.open(path) as img:\n   912→                            asset['width'] = img.width\n   913→                            asset['height'] = img.height\n   914→                    except:\n   915→                        asset['width'] = None\n   916→                        asset['height'] = None\n   917→                        \n   918→                    resolved_assets.append(asset)\n   919→            except Exception as e:\n   920→                print(f\"  ⚠️ 解析参考图失败: {path} - {e}\")\n   921→                \n   922→        return resolved_assets\n   923→\n   924→    def _attach_reference_assets(self, records: List[Dict[str, Any]], *, absolute: bool = False) -> None:\n   925→        if not records:\n   926→            return\n   927→        for record in records:\n   928→            try:\n   929→                # 先尝试原有的解析逻辑\n   930→                resolved = self._resolve_reference_assets(record, absolute=absolute)\n   931→                \n   932→                # 如果原有逻辑没有找到参考图，尝试视频参考图解析\n   933→                if not resolved and record.get('content_type') == 'videos':\n   934→                    video_refs = self._resolve_video_reference_assets(record)\n   935→                    if video_refs:\n   936→                        resolved = video_refs\n   937→                        # 更新_reference_info\n   938→                        record['_reference_info'] = {\n   939→                            'count': len(video_refs),\n   940→                            'summary': f'{len(video_refs)}个参考图',\n   941→                            'labels': ['参考图'],\n   942→                            'assets': video_refs\n   943→                        }\n   944→                \n   945→                if absolute:\n   946→                    record['_resolved_reference_assets_abs'] = resolved\n   947→                record['_resolved_reference_assets'] = resolved\n   948→                \n   949→                # 确保_reference_info存在\n   950→                if '_reference_info' not in record:\n   951→                    record['_reference_info'] = {\n   952→                        'count': len(resolved),\n   953→                        'summary': f'{len(resolved)}个参考图' if resolved else '',\n   954→                        'labels': ['参考图'] if resolved else [],\n   955→                        'assets': resolved\n   956→                    }\n   957→                    \n   958→            except Exception as exc:\n   959→                logger.debug(f\"attach_reference_assets failed: {exc}\")\n   960→\n   961→    def search_content(self, query: str, content_type: Optional[str] = None,\n   962→                      tags: Optional[List[str]] = None, \n   963→                      limit: int = None) -> List[Dict[str, Any]]:\n   964→        \"\"\"\n   965→        搜索仓库内容\n   966→        \n   967→        Args:\n   968→            query: 搜索关键词\n   969→            content_type: 内容类型过滤\n   970→            tags: 标签过滤\n   971→            limit: 结果数量限制\n   972→        \n   973→        Returns:\n   974→            搜索结果列表\n   975→        \"\"\"\n   976→        try:\n   977→            if limit is None or limit <= 0:\n   978→                limit = self.config.get(\"search_result_limit\", 100)\n   979→\n   980→            keyword = (query or \"\").strip()\n   981→            if not keyword:\n   982→                return []\n   983→\n   984→            normalized_type = 'all'\n   985→            sqlite_type: Optional[str] = None\n   986→            if content_type:\n   987→                ct = content_type.lower()\n   988→                if ct in {'image', 'images'}:\n   989→                    sqlite_type = 'images'\n   990→                    normalized_type = 'image'\n   991→                elif ct in {'video', 'videos'}:\n   992→                    sqlite_type = 'videos'\n   993→                    normalized_type = 'video'\n   994→\n   995→            results = self.sqlite_handler.search_records(keyword, sqlite_type, limit) or []\n   996→            normalized = self._normalize_records(results, normalized_type)\n   997→            self._attach_reference_assets(normalized, absolute=True)\n   998→            return normalized\n   999→        except Exception as e:\n  1000→            logger.error(f\"搜索内容失败: {e}\")\n  1001→            return []\n  1002→    \n  1003→    def get_content_tags(self, content_id: str) -> List[str]:\n  1004→        \"\"\"\n  1005→        获取内容的所有标签\n  1006→        \n  1007→        Args:\n  1008→            content_id: 内容ID\n  1009→        \n  1010→        Returns:\n  1011→            标签列表\n  1012→        \"\"\"\n  1013→        return self.tag_manager.get_content_tags(content_id)\n  1014→    \n  1015→    def add_tag_to_content(self, content_id: str, tag: str, \n  1016→                          category: str = \"自定义标签\") -> bool:\n  1017→        \"\"\"\n  1018→        为内容添加标签\n  1019→        \n  1020→        Args:\n  1021→            content_id: 内容ID\n  1022→            tag: 标签名称\n  1023→            category: 标签分类\n  1024→        \n  1025→        Returns:\n  1026→            是否添加成功\n  1027→        \"\"\"\n  1028→        return self.tag_manager.add_tag_to_content(content_id, tag, category)\n  1029→    \n  1030→    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n  1031→        \"\"\"\n  1032→        从内容中移除标签\n  1033→        \n  1034→        Args:\n  1035→            content_id: 内容ID\n  1036→            tag: 标签名称\n  1037→        \n  1038→        Returns:\n  1039→            是否移除成功\n  1040→        \"\"\"\n  1041→        return self.tag_manager.remove_tag_from_content(content_id, tag)\n  1042→    \n  1043→    def get_all_tags(self, category: Optional[str] = None) -> List[str]:\n  1044→        \"\"\"\n  1045→        获取所有标签\n  1046→        \n  1047→        Args:\n  1048→            category: 标签分类过滤\n  1049→        \n  1050→        Returns:\n  1051→            标签列表\n  1052→        \"\"\"\n  1053→        return self.tag_manager.get_all_tags(category)\n  1054→    \n  1055→    def get_tag_statistics(self) -> Dict[str, Any]:\n  1056→        \"\"\"\n  1057→        获取标签统计信息\n  1058→        \n  1059→        Returns:\n  1060→            统计信息字典\n  1061→        \"\"\"\n  1062→        return self.tag_manager.get_statistics()\n  1063→    \n  1064→    def export_repository_data(self, export_format: str = \"json\") -> str:\n  1065→        \"\"\"\n  1066→        导出仓库数据\n  1067→\n  1068→        Args:\n  1069→            export_format: 导出格式 (json/csv/xlsx)\n  1070→\n  1071→        Returns:\n  1072→            导出文件路径\n  1073→        \"\"\"\n  1074→        try:\n  1075→            export_dir = self.repository_root / \"exports\"\n  1076→            export_dir.mkdir(exist_ok=True)\n  1077→            \n  1078→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n  1079→            filename = f\"repository_export_{timestamp}.{export_format}\"\n  1080→            export_path = export_dir / filename\n  1081→            \n  1082→            # 收集所有数据\n  1083→            storage_stats = {\n  1084→                \"images\": self.sqlite_handler.get_total_count('images'),\n  1085→                \"videos\": self.sqlite_handler.get_total_count('videos')\n  1086→            }\n  1087→            data = {\n  1088→                \"config\": self.config,\n  1089→                \"tags\": self.tag_manager.export_data(),\n  1090→                \"search_index\": self.search_engine.export_data(),\n  1091→                \"storage_stats\": storage_stats,\n  1092→                \"export_time\": datetime.now().isoformat()\n  1093→            }\n  1094→            \n  1095→            if export_format == \"json\":\n  1096→                with open(export_path, 'w', encoding='utf-8') as f:\n  1097→                    json.dump(data, f, ensure_ascii=False, indent=2)\n  1098→            \n  1099→            return str(export_path)\n  1100→            \n  1101→        except Exception as e:\n  1102→            self.error_handler.log_error(f\"导出仓库数据失败: {e}\")\n  1103→            return \"\"\n  1104→\n  1105→    def get_repository_status(self) -> Dict[str, Any]:\n  1106→        \"\"\"\n  1107→        获取仓库状态信息\n  1108→        \n  1109→        Returns:\n  1110→            状态信息字典\n  1111→        \"\"\"\n  1112→        try:\n  1113→            return {\n  1114→                \"version\": self.config.get(\"version\", \"0.1.5\"),\n  1115→                \"storage_root\": str(self.storage_root),\n  1116→                \"repository_root\": str(self.repository_root),\n  1117→                \"total_content_count\": self.get_total_count('all'),\n  1118→                \"total_tags_count\": len(self.tag_manager.get_all_tags()),\n  1119→                \"tag_categories\": self.config.get(\"tag_categories\", []),\n  1120→                \"last_updated\": self.config.get(\"last_updated\"),\n  1121→                \"auto_tag_enabled\": self.config.get(\"auto_tag_enabled\", True),\n  1122→                \"search_index_enabled\": self.config.get(\"search_index_enabled\", True)\n  1123→            }\n  1124→        except Exception as e:\n  1125→            self.error_handler.log_error(f\"获取仓库状态失败: {e}\")\n  1126→            return {}\n  1127→    \n  1128→    def update_config(self, new_config: Dict[str, Any]) -> bool:\n  1129→        \"\"\"\n  1130→        更新仓库配置\n  1131→        \n  1132→        Args:\n  1133→            new_config: 新配置字典\n  1134→        \n  1135→        Returns:\n  1136→            是否更新成功\n  1137→        \"\"\"\n  1138→        try:\n  1139→            self.config.update(new_config)\n  1140→            self._save_config(self.config)\n  1141→            return True\n  1142→        except Exception as e:\n  1143→            self.error_handler.log_error(f\"更新仓库配置失败: {e}\")\n  1144→            return False\n  1145→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d6844bdf-c698-40cd-a4f7-4e357b397698","timestamp":"2026-01-05T11:53:50.496Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n仓库管理器 - 统一管理所有内容仓库功能\n\n主要功能：\n- 协调各个子模块的工作\n- 提供统一的API接口\n- 管理仓库配置和状态\n- 处理跨模块的数据交互\n\"\"\"\n\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nfrom typing import Tuple\n\nfrom .sqlite_handler import SQLiteHandler\nfrom loguru import logger\ntry:\n    from utils.error_handler import global_error_handler as _global_error_handler\nexcept Exception:\n    _global_error_handler = None\n\n\nclass _RepoErrorHandler:\n    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    def log_error(self, message: str):\n        try:\n            if _global_error_handler:\n                logger.error(message)\n            else:\n                print(f\"[RepositoryManager][ERROR] {message}\")\n        except Exception:\n            print(f\"[RepositoryManager][ERROR] {message}\")\n\n\nclass _NullTagManager:\n    def get_content_tags(self, content_id: str):\n        return []\n    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n        return False\n    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n        return False\n    def get_all_tags(self, category: str = None):\n        return []\n    def get_statistics(self):\n        return {}\n    def export_data(self):\n        return {}\n\n\nclass _NullSearchEngine:\n    def get_total_count(self) -> int:\n        return 0\n    def export_data(self):\n        return {}\n\n\nclass RepositoryManager:\n    \"\"\"\n    仓库管理器 - 内容仓库的核心控制器\n    \n    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    为上层应用提供统一的仓库管理接口。\n    \"\"\"\n    \n    def __init__(self, storage_root: str):\n        \"\"\"\n        初始化仓库管理器\n        \n        Args:\n            storage_root: 用户指定的存储根目录\n        \"\"\"\n        self.storage_root = Path(storage_root)\n        self.repository_root = self.storage_root / \"repository\"\n        self.config_file = self.repository_root / \"config.json\"\n        \n        # 确保仓库目录存在\n        self.repository_root.mkdir(parents=True, exist_ok=True)\n        \n        # 初始化子模块\n        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n        # 提供占位依赖，避免未实现接口导致崩溃\n        self.error_handler = _RepoErrorHandler()\n        self.tag_manager = _NullTagManager()\n        self.search_engine = _NullSearchEngine()\n        \n        # 加载配置\n        self.config = self._load_config()\n        \n        # 初始化仓库\n        self._initialize_repository()\n    \n    def _load_config(self) -> Dict[str, Any]:\n        \"\"\"\n        加载仓库配置\n        \n        Returns:\n            配置字典\n        \"\"\"\n        default_config = {\n            \"version\": \"0.1.5\",\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"auto_tag_enabled\": True,\n            \"search_index_enabled\": True,\n            \"tag_categories\": [\n                \"内容类型\",\n                \"创建时间\", \n                \"质量评级\",\n                \"使用场景\",\n                \"风格特征\",\n                \"自定义标签\"\n            ],\n            \"supported_file_types\": [\"image\", \"video\", \"audio\", \"chat\"],\n            \"max_tags_per_item\": 20,\n            \"search_result_limit\": 100\n        }\n        \n        if self.config_file.exists():\n            try:\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    config = json.load(f)\n                # 合并默认配置，确保新字段存在\n                for key, value in default_config.items():\n                    if key not in config:\n                        config[key] = value\n                return config\n            except Exception as e:\n                self.error_handler.log_error(f\"加载仓库配置失败: {e}\")\n                return default_config\n        else:\n            # 创建默认配置文件\n            self._save_config(default_config)\n            return default_config\n    \n    def _save_config(self, config: Dict[str, Any]) -> None:\n        \"\"\"\n        保存仓库配置\n        \n        Args:\n            config: 配置字典\n        \"\"\"\n        try:\n            config[\"last_updated\"] = datetime.now().isoformat()\n            with open(self.config_file, 'w', encoding='utf-8') as f:\n                json.dump(config, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            self.error_handler.log_error(f\"保存仓库配置失败: {e}\")\n    \n    def _initialize_repository(self) -> None:\n        \"\"\"\n        初始化仓库结构\n        \"\"\"\n        try:\n            # 创建必要的子目录\n            subdirs = [\"tags\", \"index\", \"cache\", \"exports\"]\n            for subdir in subdirs:\n                (self.repository_root / subdir).mkdir(exist_ok=True)\n            \n            print(f\"仓库初始化完成: {self.repository_root}\")\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"仓库初始化失败: {e}\")\n            raise\n\n    def _ensure_dict(self, value: Any) -> Dict[str, Any]:\n        if isinstance(value, dict):\n            return value\n        if isinstance(value, str) and value:\n            try:\n                loaded = json.loads(value)\n                return loaded if isinstance(loaded, dict) else {}\n            except Exception:\n                return {}\n        return {}\n\n    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n        normalized: List[Dict[str, Any]] = []\n        if not records:\n            return normalized\n        seen_keys: set[str] = set()\n        for record in records:\n            normalized_record = self._normalize_record(record, content_type)\n            if not normalized_record:\n                continue\n            gen_key = normalized_record.get('generation_id') or normalized_record.get('task_id') or normalized_record.get('file_id')\n            key = str(gen_key) if gen_key else None\n            if key and key in seen_keys:\n                continue\n            if key:\n                seen_keys.add(key)\n            normalized.append(normalized_record)\n        return normalized\n\n    \n    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n        if not isinstance(record, dict):\n            return {}\n\n        item = dict(record)\n        metadata_raw = item.get('metadata') or {}\n        if isinstance(metadata_raw, str):\n            try:\n                metadata_raw = json.loads(metadata_raw) or {}\n            except Exception:\n                metadata_raw = {}\n        item['metadata'] = metadata_raw\n\n        # 统一内容类型\n        ctype = item.get('content_type') or content_type or ''\n        if ctype == 'image':\n            ctype = 'images'\n        elif ctype == 'video':\n            ctype = 'videos'\n        item['content_type'] = ctype\n\n        # 解析JSON字段\n        item['parameters'] = self._ensure_dict(item.get('parameters'))\n        item['metadata'] = self._ensure_dict(item.get('metadata'))\n        item['batch_info'] = self._ensure_dict(item.get('batch_info'))\n\n        metadata = item['metadata']\n\n        # 同步核心字段\n        created_at = item.get('created_at')\n        if not created_at:\n            created_at = metadata.get('created_at') or metadata.get('completed_at')\n        if not created_at:\n            created_at = datetime.now().isoformat()\n        if isinstance(created_at, datetime):\n            item['created_at'] = created_at.isoformat()\n        else:\n            item['created_at'] = created_at\n\n        file_id = item.get('file_id') or item.get('generation_id') or metadata.get('task_id')\n        if file_id:\n            item['file_id'] = str(file_id)\n\n        generation_id = item.get('generation_id') or metadata.get('generation_id') or metadata.get('task_id')\n        if generation_id:\n            item['generation_id'] = str(generation_id)\n\n        resolved_path = item.get('resolved_path')\n        candidate_paths = [\n            resolved_path,\n            item.get('absolute_path'),\n            metadata.get('local_path'),\n            item.get('file_path'),\n        ]\n        abs_path = next((p for p in candidate_paths if p), None)\n        \n        # 验证绝对路径是否真实存在（修复旧记录路径失效问题）\n        if abs_path and not Path(abs_path).exists():\n            logger.warning(f\"绝对路径无效，将尝试从relative_path重新构造: {abs_path}\")\n            abs_path = None  # 重置，触发下面的重新构造逻辑\n        \n        if not abs_path and (item.get('relative_path') or metadata.get('relative_path')):\n            rel = item.get('relative_path') or metadata.get('relative_path')\n            try:\n                root = self.storage_root\n                original_path = Path(root) / rel\n                if original_path.exists():\n                    abs_path = str(original_path)\n                    logger.debug(f\"使用路径: {abs_path}\")\n                else:\n                    abs_path = str(original_path)\n                    logger.warning(f\"文件不存在: {original_path}\")\n            except Exception as e:\n                logger.error(f\"路径解析失败: {rel}, 错误: {e}\")\n                abs_path = None\n\n        if abs_path:\n            abs_path = str(abs_path)\n            item['absolute_path'] = abs_path\n            item['local_path'] = abs_path\n            item['file_path'] = abs_path\n            \n            # 自动补充文件大小\n            if not item.get('file_size'):\n                try:\n                    size = os.path.getsize(abs_path)\n                    item['file_size'] = size\n                    # 同时回写到 metadata 以备后用\n                    item['metadata']['file_size'] = size\n                except Exception:\n                    pass\n\n        # 记录相对路径\n        rel_value = item.get('relative_path') or metadata.get('relative_path')\n        if rel_value:\n            item['relative_path'] = str(rel_value)\n\n        # 若缺少真实路径且状态已完成，则忽略该记录\n        if not (item.get('file_path') or item.get('absolute_path') or item.get('relative_path')):\n            status = str(item.get('status') or '').lower()\n            # pending 状态的记录应该保留（即使缺路径，用于占位卡片显示）\n            if status == 'pending':\n                pass  # 不过滤，继续处理\n            elif not status or status in {'completed', 'success'}:\n                return {}\n\n       # 缩略图字段\n        thumb_local = item.get('thumbnail_local_path') or metadata.get('thumbnail_local_path') or metadata.get('api_thumbnail_local_path')\n        if thumb_local:\n            item['thumbnail_local_path'] = str(thumb_local)\n\n        thumb_rel = item.get('thumbnail_path') or metadata.get('thumbnail_path') or item.get('thumbnail_local_path')\n        if thumb_rel:\n            item['thumbnail_path'] = str(thumb_rel)\n            # 如果没有 thumbnail_local_path，则从相对路径生成绝对路径\n            if not thumb_local:\n                try:\n                    thumb_abs = Path(self.storage_root) / thumb_rel\n                    if thumb_abs.exists():\n                        item['thumbnail_local_path'] = str(thumb_abs)\n                        # logger.debug(f\"生成缩略图绝对路径: {thumb_abs}\")\n                    else:\n                        # logger.debug(f\"缩略图文件不存在: {thumb_abs}\")\n                        pass\n                except Exception as e:\n                    logger.debug(f\"缩略图路径解析失败: {thumb_rel}, 错误: {e}\")\n\n        # 补充尺寸信息，便于前端按比例渲染\n        width = item.get('width') or metadata.get('width')\n        height = item.get('height') or metadata.get('height')\n        if width:\n            try:\n                item['width'] = int(float(width))\n            except Exception:\n                pass\n        if height:\n            try:\n                item['height'] = int(float(height))\n            except Exception:\n                pass\n        # 尝试从参数 size 提取比例（如果未提供 width/height）\n        if (not item.get('width') or not item.get('height')):\n            size_txt = item['parameters'].get('size') if isinstance(item['parameters'], dict) else None\n            if isinstance(size_txt, str) and 'x' in size_txt:\n                try:\n                    sw, sh = size_txt.split('x')\n                    item['width'] = item.get('width') or int(float(sw))\n                    item['height'] = item.get('height') or int(float(sh))\n                except Exception:\n                    pass\n        # 兜底：若本地文件存在且仍缺尺寸，尝试读取一次\n        if (not item.get('width') or not item.get('height')):\n            try:\n                abs_path_probe = item.get('absolute_path') or item.get('file_path')\n                if abs_path_probe and Path(abs_path_probe).exists():\n                    from PIL import Image\n                    with Image.open(abs_path_probe) as img:\n                        item['width'] = item.get('width') or int(img.width)\n                        item['height'] = item.get('height') or int(img.height)\n            except Exception as exc:\n                logger.debug(f\"尺寸读取失败: {exc}\")\n\n        # 提升 prompt 等常用字段\n        if not item.get('prompt') and item['parameters'].get('prompt'):\n            item['prompt'] = item['parameters']['prompt']\n\n        return item\n\n    def _parse_created_at(self, value: Any) -> datetime:\n        if isinstance(value, datetime):\n            return value\n        if not value:\n            return datetime.min\n        text = str(value)\n        try:\n            if text.endswith('Z'):\n                text = text[:-1] + '+00:00'\n            return datetime.fromisoformat(text)\n        except Exception:\n            try:\n                return datetime.strptime(text, '%Y-%m-%d %H:%M:%S')\n            except Exception:\n                return datetime.min\n\n    def _record_sort_key(self, record: Dict[str, Any]) -> Tuple[datetime, str]:\n        created_dt = self._parse_created_at(record.get('created_at'))\n        # fallback: 如果 created_at 无效，尝试使用 updated_at\n        if created_dt == datetime.min:\n            created_dt = self._parse_created_at(record.get('updated_at'))\n        file_id = str(record.get('file_id', ''))\n        return (created_dt, file_id)\n\n    def add_content(self, content_id: str, content_type: str, \n                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n        \"\"\"\n        添加内容到仓库\n        \n        Args:\n            content_id: 内容唯一标识\n            content_type: 内容类型 (image/video/audio/chat)\n            metadata: 内容元数据\n            auto_tag: 是否自动生成标签\n        \n        Returns:\n            是否添加成功\n        \"\"\"\n        try:\n            normalized_type = (content_type or '').lower()\n            if normalized_type in {'image', 'images'}:\n                storage_type = 'images'\n            elif normalized_type in {'video', 'videos'}:\n                storage_type = 'videos'\n            else:\n                storage_type = normalized_type or 'unknown'\n            status = metadata.get('status', 'unknown')\n            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n            return result\n        except Exception as e:\n            logger.error(f\"添加内容失败: {e}\")\n            return False\n    \n    def update_record(self, record_id: str, data: Dict[str, Any]) -> bool:\n        \"\"\"更新记录\"\"\"\n        try:\n            return self.sqlite_handler.update_record(record_id, data)\n        except Exception as e:\n            logger.error(f\"更新记录失败: {e}\")\n            return False\n\n    def delete_record(self, record_id: str) -> bool:\n        \"\"\"删除记录\"\"\"\n        try:\n            return self.sqlite_handler.delete_record(record_id)\n        except Exception as e:\n            logger.error(f\"删除记录失败: {e}\")\n            return False\n\n    def delete_record_with_files(self, record_id: str) -> bool:\n        \"\"\"删除记录及其所有关联文件\n        \n        Args:\n            record_id: 记录ID\n            \n        Returns:\n            bool: 是否删除成功\n        \"\"\"\n        if not record_id:\n            return False\n            \n        try:\n            # 1. 获取记录详情\n            record = self.get_record_by_id(record_id)\n            if not record:\n                logger.warning(f\"删除记录: 未找到记录 {record_id}\")\n                return False\n            \n            # 2. 收集需要删除的文件路径\n            files_to_delete = []\n            \n            # 主文件（图片/视频）\n            file_path = record.get('absolute_path') or record.get('file_path')\n            if file_path:\n                files_to_delete.append(file_path)\n            \n            # 缩略图\n            thumb_path = record.get('thumbnail_local_path')\n            if thumb_path:\n                files_to_delete.append(thumb_path)\n            \n            # 参考图资产 - 跳过删除\n            # 原因：同一参考图可能被多条记录引用（已验证），删除会影响其他记录\n            \n            # 3. 删除数据库记录\n            if not self.delete_record(record_id):\n                logger.error(f\"删除记录失败: 数据库删除失败 {record_id}\")\n                return False\n            \n            # 4. 删除文件（忽略不存在的文件）\n            deleted_files = []\n            for path in files_to_delete:\n                try:\n                    if path and Path(path).exists():\n                        Path(path).unlink()\n                        deleted_files.append(path)\n                        logger.debug(f\"已删除文件: {path}\")\n                except Exception as e:\n                    logger.warning(f\"删除文件失败: {path}, {e}\")\n            \n            logger.info(f\"删除记录完成: {record_id}, 删除了 {len(deleted_files)} 个文件\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"删除记录及文件失败: {record_id}, {e}\")\n            return False\n\n    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n        \"\"\"清理超时的 pending 记录\n\n        Args:\n            timeout_hours: 超时时间（小时），默认 1 小时\n\n        Returns:\n            清理的记录数量\n        \"\"\"\n        try:\n            return self.sqlite_handler.cleanup_stale_pending_records(timeout_hours)\n        except Exception as e:\n            logger.error(f\"清理过期 pending 记录失败: {e}\")\n            return 0\n\n    def get_record_by_id(self, record_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"根据 ID 获取单条记录。\"\"\"\n        if not record_id:\n            return None\n        try:\n            raw = self.sqlite_handler.get_record_by_id(record_id)\n            if not raw:\n                return None\n            content_type = raw.get('content_type') or 'image'\n            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n            normalized = self._normalize_record(raw, normalized_type)\n            if not normalized:\n                return None\n            self._attach_reference_assets([normalized], absolute=True)\n            return normalized\n        except Exception as e:\n            logger.error(f\"获取记录失败: {e}\")\n            return None\n\n    def get_records_by_status(\n        self,\n        record_type: str,\n        statuses: List[str],\n        *,\n        limit: int = 50,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"按状态获取记录（用于 pending 恢复等场景）.\"\"\"\n\n        normalized_type = (record_type or '').lower()\n        if normalized_type in {'images', 'image'}:\n            normalized_type = 'image'\n        elif normalized_type in {'videos', 'video'}:\n            normalized_type = 'video'\n\n        content_type = 'videos' if normalized_type == 'video' else 'images'\n        try:\n            raw = self.sqlite_handler.get_records_by_status(content_type, statuses, limit=limit) or []\n            normalized = self._normalize_records(raw, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n            return normalized\n        except Exception as e:\n            self.error_handler.log_error(f\"按状态获取记录失败: {e}\")\n            return []\n    \n    def get_records_batch(self, start_index=0, batch_size=40, record_type='all'):\n        \"\"\"\n        批量获取记录，支持分页查询\n        \n        Args:\n            start_index: 起始索引\n            batch_size: 批量大小\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            List[Dict]: 记录列表\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'images':\n                normalized_type = 'image'\n            elif normalized_type == 'videos':\n                normalized_type = 'video'\n\n            if normalized_type == 'all':\n                fetch_limit = max(batch_size, start_index + batch_size)\n                images = self.sqlite_handler.get_records('images', fetch_limit, 0) or []\n                videos = self.sqlite_handler.get_records('videos', fetch_limit, 0) or []\n                combined = images + videos\n                combined.sort(key=self._record_sort_key, reverse=True)\n                end_index = start_index + batch_size\n                result = combined[start_index:end_index]\n            else:\n                content_type = 'images' if normalized_type == 'image' else 'videos'\n                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n                result.sort(key=self._record_sort_key, reverse=True)\n\n            normalized = self._normalize_records(result, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n            return normalized\n        except Exception as e:\n            self.error_handler.log_error(f\"批量获取记录失败: {e}\")\n            return []\n\n    def get_records_batch_reverse(self, limit=80, offset=0, record_type='all'):\n        \"\"\"\n        倒序分页查询记录 - 瀑布流1000条方案专用\n        \n        优化特性：\n        - 从最新记录开始的高效倒序查询\n        - 支持80+30增量加载模式\n        - 针对1000条数据优化的性能\n        - 减少内存占用和查询时间\n        \n        Args:\n            limit: 查询数量限制 (默认80，增量30)\n            offset: 偏移量 (从最新记录开始计算)\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            List[Dict]: 按时间倒序排列的记录列表\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'images':\n                normalized_type = 'image'\n            elif normalized_type == 'videos':\n                normalized_type = 'video'\n\n            max_single_query = min(limit + 50, 200)\n\n            if normalized_type == 'all':\n                images = self.sqlite_handler.get_records('images', max_single_query, 0) or []\n                videos = self.sqlite_handler.get_records('videos', max_single_query, 0) or []\n                combined = images + videos\n                combined.sort(key=self._record_sort_key, reverse=True)\n                start_idx = offset\n                end_idx = offset + limit\n                result = combined[start_idx:end_idx]\n            else:\n                content_type = 'images' if normalized_type == 'image' else 'videos'\n                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n                result.sort(key=self._record_sort_key, reverse=True)\n\n            normalized = self._normalize_records(result, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n\n            return normalized\n\n        except Exception as e:\n            self.error_handler.log_error(f\"倒序分页查询失败: {e}\")\n            return []\n\n    def get_records_count_optimized(self, record_type='all'):\n        \"\"\"\n        优化的记录计数方法 - 瀑布流1000条方案专用\n        \n        提供快速的记录计数，支持1000条限制逻辑\n        \n        Args:\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            Dict: {'total': int, 'capped_at_1000': bool}\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'image':\n                total = self.sqlite_handler.get_total_count('images')\n            elif normalized_type == 'video':\n                total = self.sqlite_handler.get_total_count('videos')\n            else:\n                total = (\n                    self.sqlite_handler.get_total_count('images') +\n                    self.sqlite_handler.get_total_count('videos')\n                )\n\n            # 1000条限制逻辑\n            capped_at_1000 = total > 1000\n            effective_total = min(total, 1000)\n            \n            return {\n                'total': effective_total,\n                'actual_total': total,\n                'capped_at_1000': capped_at_1000\n            }\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"优化记录计数失败: {e}\")\n            return {'total': 0, 'actual_total': 0, 'capped_at_1000': False}\n\n    # =========================\n    # 游标分页协议（初版实现）\n    # 接口：get_records(page_size, cursor, record_type) -> { items, next_cursor }\n    # 说明：当前实现基于现有CSV读取能力合并排序后切片，后续可在存储层优化为限窗/游标扫描。\n    # =========================\n    def get_records(self, page_size: int = 40, cursor: Optional[str] = None, record_type: str = 'all') -> Dict[str, Any]:\n        \"\"\"\n        游标分页获取记录\n\n        Args:\n            page_size: 每页大小\n            cursor: 上一页游标（格式：\"<created_at>|<file_id>|<type>\"），None表示第一页\n            record_type: 'image' | 'video' | 'all'\n\n        Returns:\n            dict: { items: List[Dict], next_cursor: Optional[str] }\n        \"\"\"\n        try:\n            # 解析游标\n            cursor_tuple: Optional[Tuple[str, str, str]] = None\n            if cursor:\n                try:\n                    parts = cursor.split('|')\n                    if len(parts) >= 3:\n                        cursor_tuple = (parts[0], parts[1], parts[2])  # created_at, file_id, type\n                except Exception:\n                    cursor_tuple = None\n\n            # 拉取候选数据（按需窗口，尽量少取）\n            fetch_limit = max(page_size * 3, 60)\n\n            def _load(ct: str) -> List[Dict[str, Any]]:\n                return self._normalize_records(\n                    self.sqlite_handler.get_records(ct, fetch_limit, 0) or [],\n                    ct\n                )\n\n            if record_type == 'image':\n                records = _load('images')\n            elif record_type == 'video':\n                records = _load('videos')\n            else:\n                records = _load('images') + _load('videos')\n\n            # 排序：created_at DESC, file_id DESC\n            records.sort(key=self._record_sort_key, reverse=True)\n\n            # 光标过滤：跳过光标及其之前的元素（保持稳定倒序）\n            filtered: List[Dict[str, Any]] = []\n            if cursor_tuple:\n                cur_created, cur_id, cur_type = cursor_tuple\n                passed = False\n                for rec in records:\n                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n                    rec_key = (rec.get('created_at', '1970-01-01T00:00:00'), rec.get('file_id', ''), rec_type)\n                    # 记录严格小于游标（因为倒序），才加入\n                    if passed:\n                        filtered.append(rec)\n                    else:\n                        if (rec_key[0] < cur_created) or (rec_key[0] == cur_created and rec_key[1] < cur_id) or (rec_key[0] == cur_created and rec_key[1] == cur_id and rec_key[2] < cur_type):\n                            passed = True\n                            filtered.append(rec)\n                candidates = filtered\n            else:\n                candidates = records\n\n            # 取一页\n            page_items = candidates[:page_size]\n            self._attach_reference_assets(page_items, absolute=True)\n\n            # 生成 next_cursor\n            if page_items:\n                last = page_items[-1]\n                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n                next_cursor = f\"{last.get('created_at','')}|{last.get('file_id','')}|{last_type}\"\n            else:\n                next_cursor = None\n\n            return {\n                'items': page_items,\n                'next_cursor': next_cursor\n            }\n\n        except Exception as e:\n            self.error_handler.log_error(f\"游标分页获取记录失败: {e}\")\n            return {\n                'items': [],\n                'next_cursor': None\n            }\n\n    def get_total_count(self, record_type='all'):\n        \"\"\"\n        获取总记录数\n        \n        Args:\n            record_type: 记录类型 ('image', 'video', 'all')\n            \n        Returns:\n            int: 总记录数\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'image':\n                return self.sqlite_handler.get_total_count('images')\n            if normalized_type == 'video':\n                return self.sqlite_handler.get_total_count('videos')\n\n            return (\n                self.sqlite_handler.get_total_count('images') +\n                self.sqlite_handler.get_total_count('videos')\n            )\n        except Exception as e:\n            self.error_handler.log_error(f\"获取记录总数失败: {e}\")\n            return 0\n\n    def _resolve_reference_assets(self, record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n        if not isinstance(record, dict):\n            return []\n\n        params_raw = record.get('parameters')\n        params_dict: Dict[str, Any] = {}\n        if isinstance(params_raw, dict):\n            params_dict = params_raw\n        elif isinstance(params_raw, str):\n            try:\n                params_dict = json.loads(params_raw) or {}\n            except Exception:\n                params_dict = {}\n\n        assets = []\n        if isinstance(params_dict, dict):\n            assets = params_dict.get('reference_assets') or []\n        if not assets:\n            fallback = record.get('reference_assets')\n            assets = fallback if isinstance(fallback, list) else []\n        if not assets:\n            return []\n\n        resolved: List[Dict[str, Any]] = []\n        for item in assets:\n            if not isinstance(item, dict):\n                continue\n            rec = dict(item)\n            rel_path = rec.get('relative_path') or rec.get('asset_path')\n            if rel_path and absolute:\n                abs_path = Path(self.storage_root) / rel_path\n                rec['absolute_path'] = str(abs_path)\n                rec['asset_path'] = str(abs_path)\n            resolved.append(rec)\n        return resolved\n\n    \n    def _resolve_video_reference_assets(self, record: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"\n        解析视频记录中的参考图资产\n        \n        从parameters.first_frame和image_path提取参考图信息\n        \"\"\"\n        if not isinstance(record, dict):\n            return []\n            \n        params = record.get('parameters', {})\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n\n        # 收集参考图路径\n        ref_paths = []\n\n        storage_root = self.storage_root\n\n        def _resolve_path(path_str: Optional[str]) -> Optional[Path]:\n            if not path_str:\n                return None\n            candidate = Path(path_str).expanduser()\n            if candidate.is_absolute():\n                return candidate if candidate.exists() else None\n            combined = storage_root / path_str.lstrip('/\\\\')\n            return combined if combined.exists() else None\n\n        # 从first_frame提取\n        first_frame = params.get('first_frame')\n        resolved_first = _resolve_path(first_frame) if isinstance(first_frame, str) else None\n        if resolved_first:\n            ref_paths.append(('first_frame', str(resolved_first)))\n\n        # 从last_frame提取（首尾帧模式）\n        last_frame = params.get('last_frame')\n        resolved_last = _resolve_path(last_frame) if isinstance(last_frame, str) else None\n        if resolved_last:\n            ref_paths.append(('last_frame', str(resolved_last)))\n\n        # 从image_path提取\n        image_path = params.get('image_path')\n        resolved_image = _resolve_path(image_path) if isinstance(image_path, str) else None\n        if resolved_image and all(str(resolved_image) != existing_path for _, existing_path in ref_paths):\n            ref_paths.append(('image', str(resolved_image)))\n\n        # 构建参考图资产信息\n        resolved_assets = []\n        for i, (kind, path) in enumerate(ref_paths):\n            try:\n                file_path = Path(path)\n                if file_path.exists():\n                    stat = file_path.stat()\n                    try:\n                        rel = file_path.resolve().relative_to(storage_root)\n                        rel_str = str(rel).replace('\\\\', '/')\n                    except ValueError:\n                        rel_str = str(file_path)\n                    asset = {\n                        'id': f'ref_video_{record.get(\"generation_id\", \"unknown\")}_{i}',\n                        'path': rel_str,\n                        'relative_path': rel_str,\n                        'absolute_path': str(file_path.resolve()),\n                        'type': 'image',\n                        'kind': kind or 'image',\n                        'source': file_path.name,\n                        'order': i,\n                        'size': stat.st_size,\n                        'exists': True,\n                        'created_at': record.get('created_at', datetime.now().isoformat())\n                    }\n\n                    # 尝试获取图片尺寸\n                    try:\n                        from PIL import Image\n                        with Image.open(path) as img:\n                            asset['width'] = img.width\n                            asset['height'] = img.height\n                    except:\n                        asset['width'] = None\n                        asset['height'] = None\n                        \n                    resolved_assets.append(asset)\n            except Exception as e:\n                print(f\"  ⚠️ 解析参考图失败: {path} - {e}\")\n                \n        return resolved_assets\n\n    def _attach_reference_assets(self, records: List[Dict[str, Any]], *, absolute: bool = False) -> None:\n        if not records:\n            return\n        for record in records:\n            try:\n                # 先尝试原有的解析逻辑\n                resolved = self._resolve_reference_assets(record, absolute=absolute)\n                \n                # 如果原有逻辑没有找到参考图，尝试视频参考图解析\n                if not resolved and record.get('content_type') == 'videos':\n                    video_refs = self._resolve_video_reference_assets(record)\n                    if video_refs:\n                        resolved = video_refs\n                        # 更新_reference_info\n                        record['_reference_info'] = {\n                            'count': len(video_refs),\n                            'summary': f'{len(video_refs)}个参考图',\n                            'labels': ['参考图'],\n                            'assets': video_refs\n                        }\n                \n                if absolute:\n                    record['_resolved_reference_assets_abs'] = resolved\n                record['_resolved_reference_assets'] = resolved\n                \n                # 确保_reference_info存在\n                if '_reference_info' not in record:\n                    record['_reference_info'] = {\n                        'count': len(resolved),\n                        'summary': f'{len(resolved)}个参考图' if resolved else '',\n                        'labels': ['参考图'] if resolved else [],\n                        'assets': resolved\n                    }\n                    \n            except Exception as exc:\n                logger.debug(f\"attach_reference_assets failed: {exc}\")\n\n    def search_content(self, query: str, content_type: Optional[str] = None,\n                      tags: Optional[List[str]] = None, \n                      limit: int = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        搜索仓库内容\n        \n        Args:\n            query: 搜索关键词\n            content_type: 内容类型过滤\n            tags: 标签过滤\n            limit: 结果数量限制\n        \n        Returns:\n            搜索结果列表\n        \"\"\"\n        try:\n            if limit is None or limit <= 0:\n                limit = self.config.get(\"search_result_limit\", 100)\n\n            keyword = (query or \"\").strip()\n            if not keyword:\n                return []\n\n            normalized_type = 'all'\n            sqlite_type: Optional[str] = None\n            if content_type:\n                ct = content_type.lower()\n                if ct in {'image', 'images'}:\n                    sqlite_type = 'images'\n                    normalized_type = 'image'\n                elif ct in {'video', 'videos'}:\n                    sqlite_type = 'videos'\n                    normalized_type = 'video'\n\n            results = self.sqlite_handler.search_records(keyword, sqlite_type, limit) or []\n            normalized = self._normalize_records(results, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n            return normalized\n        except Exception as e:\n            logger.error(f\"搜索内容失败: {e}\")\n            return []\n    \n    def get_content_tags(self, content_id: str) -> List[str]:\n        \"\"\"\n        获取内容的所有标签\n        \n        Args:\n            content_id: 内容ID\n        \n        Returns:\n            标签列表\n        \"\"\"\n        return self.tag_manager.get_content_tags(content_id)\n    \n    def add_tag_to_content(self, content_id: str, tag: str, \n                          category: str = \"自定义标签\") -> bool:\n        \"\"\"\n        为内容添加标签\n        \n        Args:\n            content_id: 内容ID\n            tag: 标签名称\n            category: 标签分类\n        \n        Returns:\n            是否添加成功\n        \"\"\"\n        return self.tag_manager.add_tag_to_content(content_id, tag, category)\n    \n    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n        \"\"\"\n        从内容中移除标签\n        \n        Args:\n            content_id: 内容ID\n            tag: 标签名称\n        \n        Returns:\n            是否移除成功\n        \"\"\"\n        return self.tag_manager.remove_tag_from_content(content_id, tag)\n    \n    def get_all_tags(self, category: Optional[str] = None) -> List[str]:\n        \"\"\"\n        获取所有标签\n        \n        Args:\n            category: 标签分类过滤\n        \n        Returns:\n            标签列表\n        \"\"\"\n        return self.tag_manager.get_all_tags(category)\n    \n    def get_tag_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取标签统计信息\n        \n        Returns:\n            统计信息字典\n        \"\"\"\n        return self.tag_manager.get_statistics()\n    \n    def export_repository_data(self, export_format: str = \"json\") -> str:\n        \"\"\"\n        导出仓库数据\n\n        Args:\n            export_format: 导出格式 (json/csv/xlsx)\n\n        Returns:\n            导出文件路径\n        \"\"\"\n        try:\n            export_dir = self.repository_root / \"exports\"\n            export_dir.mkdir(exist_ok=True)\n            \n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"repository_export_{timestamp}.{export_format}\"\n            export_path = export_dir / filename\n            \n            # 收集所有数据\n            storage_stats = {\n                \"images\": self.sqlite_handler.get_total_count('images'),\n                \"videos\": self.sqlite_handler.get_total_count('videos')\n            }\n            data = {\n                \"config\": self.config,\n                \"tags\": self.tag_manager.export_data(),\n                \"search_index\": self.search_engine.export_data(),\n                \"storage_stats\": storage_stats,\n                \"export_time\": datetime.now().isoformat()\n            }\n            \n            if export_format == \"json\":\n                with open(export_path, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, ensure_ascii=False, indent=2)\n            \n            return str(export_path)\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"导出仓库数据失败: {e}\")\n            return \"\"\n\n    def get_repository_status(self) -> Dict[str, Any]:\n        \"\"\"\n        获取仓库状态信息\n        \n        Returns:\n            状态信息字典\n        \"\"\"\n        try:\n            return {\n                \"version\": self.config.get(\"version\", \"0.1.5\"),\n                \"storage_root\": str(self.storage_root),\n                \"repository_root\": str(self.repository_root),\n                \"total_content_count\": self.get_total_count('all'),\n                \"total_tags_count\": len(self.tag_manager.get_all_tags()),\n                \"tag_categories\": self.config.get(\"tag_categories\", []),\n                \"last_updated\": self.config.get(\"last_updated\"),\n                \"auto_tag_enabled\": self.config.get(\"auto_tag_enabled\", True),\n                \"search_index_enabled\": self.config.get(\"search_index_enabled\", True)\n            }\n        except Exception as e:\n            self.error_handler.log_error(f\"获取仓库状态失败: {e}\")\n            return {}\n    \n    def update_config(self, new_config: Dict[str, Any]) -> bool:\n        \"\"\"\n        更新仓库配置\n        \n        Args:\n            new_config: 新配置字典\n        \n        Returns:\n            是否更新成功\n        \"\"\"\n        try:\n            self.config.update(new_config)\n            self._save_config(self.config)\n            return True\n        except Exception as e:\n            self.error_handler.log_error(f\"更新仓库配置失败: {e}\")\n            return False\n","numLines":1145,"startLine":1,"totalLines":1145}}}
{"parentUuid":"d6844bdf-c698-40cd-a4f7-4e357b397698","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GHpSFaJe7QzwoquTdGCWaN","type":"tool_result","content":"","is_error":false}]},"uuid":"5013df45-2974-4dc2-ad89-bbd4965dc1f0","timestamp":"2026-01-05T11:53:52.294Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"5013df45-2974-4dc2-ad89-bbd4965dc1f0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YDwkyyTwZSU3GEGUeXHaCJ","type":"message","role":"assistant","content":[{"type":"text","text":"让我检查数据库schema和模型枚举定义："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":25515,"cache_read_input_tokens":63703,"cache_creation":{"ephemeral_5m_input_tokens":25515,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a4986c7e-b92a-4633-b72d-d3d3cdcca564","timestamp":"2026-01-05T11:53:57.378Z"}
{"parentUuid":"a4986c7e-b92a-4633-b72d-d3d3cdcca564","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YDwkyyTwZSU3GEGUeXHaCJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DrbYqBmn31z4gEBGFJeraX","name":"Grep","input":{"pattern":"CREATE TABLE.*generations","path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":25515,"cache_read_input_tokens":63703,"cache_creation":{"ephemeral_5m_input_tokens":25515,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"ca53b269-dec7-4b77-a040-9834456a415b","timestamp":"2026-01-05T11:53:58.939Z"}
{"parentUuid":"ca53b269-dec7-4b77-a040-9834456a415b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YDwkyyTwZSU3GEGUeXHaCJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UwLkaryMERDhHDgTnQrkrW","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":25515,"cache_read_input_tokens":63703,"cache_creation":{"ephemeral_5m_input_tokens":25515,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"79a4b33a-9c1a-48cf-9763-064953512dc8","timestamp":"2026-01-05T11:53:59.698Z"}
{"parentUuid":"79a4b33a-9c1a-48cf-9763-064953512dc8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YDwkyyTwZSU3GEGUeXHaCJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U7AsvjxZs9uG38UK5Nqcqh","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":25515,"cache_read_input_tokens":63703,"cache_creation":{"ephemeral_5m_input_tokens":25515,"ephemeral_1h_input_tokens":0},"output_tokens":277,"service_tier":"standard"}},"type":"assistant","uuid":"85584c53-6e64-48d9-a740-305ae37fe8d2","timestamp":"2026-01-05T11:54:00.221Z"}
{"parentUuid":"85584c53-6e64-48d9-a740-305ae37fe8d2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UwLkaryMERDhHDgTnQrkrW","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import json\n     8→import sqlite3\n     9→import threading\n    10→from concurrent.futures import Future, TimeoutError\n    11→from queue import Queue\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Any, Callable, Dict, List, Optional\n    15→\n    16→from loguru import logger\n    17→\n    18→\n    19→class SQLiteHandler:\n    20→    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n    21→\n    22→    _DEFAULT_TIMEOUT_SECONDS = 30.0\n    23→\n    24→    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n    25→        \"\"\"初始化数据库连接并创建所需表结构.\n    26→\n    27→        Args:\n    28→            db_path: 数据库文件路径\n    29→            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n    30→        \"\"\"\n    31→\n    32→        self.db_path = Path(db_path)\n    33→        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n    34→        self.storage_root = storage_root\n    35→\n    36→        # 并发策略（Q002-方案B）：单线程 DB Worker + 队列串行执行\n    37→        self._closed = False\n    38→        self._queue: Queue[Optional[tuple[Future, Callable[[sqlite3.Connection], Any]]]] = Queue()\n    39→        self._init_future: Future[bool] = Future()\n    40→\n    41→        self._worker_thread = threading.Thread(\n    42→            target=self._run_worker,\n    43→            name=f\"SQLiteHandler[{self.db_path.name}]\",\n    44→            daemon=True,\n    45→        )\n    46→        self._worker_thread.start()\n    47→\n    48→        try:\n    49→            self._init_future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n    50→        except Exception as exc:\n    51→            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n    52→            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n    53→\n    54→    def _run_worker(self) -> None:\n    55→        connection: Optional[sqlite3.Connection] = None\n    56→        try:\n    57→            connection = sqlite3.connect(self.db_path)\n    58→            connection.row_factory = sqlite3.Row\n    59→            connection.execute(\"PRAGMA foreign_keys = ON;\")\n    60→            self._create_tables(connection)\n    61→        except Exception as exc:\n    62→            self._init_future.set_exception(exc)\n    63→            if connection:\n    64→                try:\n    65→                    connection.close()\n    66→                except Exception:\n    67→                    pass\n    68→            return\n    69→\n    70→        self._init_future.set_result(True)\n    71→\n    72→        while True:\n    73→            item = self._queue.get()\n    74→            try:\n    75→                if item is None:\n    76→                    break\n    77→                future, fn = item\n    78→                if not future.set_running_or_notify_cancel():\n    79→                    continue\n    80→                try:\n    81→                    future.set_result(fn(connection))\n    82→                except Exception as exc:\n    83→                    future.set_exception(exc)\n    84→            finally:\n    85→                self._queue.task_done()\n    86→\n    87→        if connection:\n    88→            try:\n    89→                connection.close()\n    90→            except sqlite3.Error as exc:\n    91→                logger.error(\"Failed to close SQLite connection: {}\", exc)\n    92→\n    93→    def _call(self, operation: str, fn: Callable[[sqlite3.Connection], Any], default: Any):\n    94→        if self._closed:\n    95→            return default\n    96→        future: Future = Future()\n    97→        self._queue.put((future, fn))\n    98→        try:\n    99→            return future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n   100→        except TimeoutError:\n   101→            logger.error(\"SQLite operation timed out: {}\", operation)\n   102→            return default\n   103→        except Exception as exc:\n   104→            logger.error(\"SQLite operation failed {}: {}\", operation, exc)\n   105→            return default\n   106→\n   107→    def _create_tables(self, connection: sqlite3.Connection) -> None:\n   108→        \"\"\"初始化数据库表结构.\"\"\"\n   109→\n   110→        schema = \"\"\"\n   111→        CREATE TABLE IF NOT EXISTS generations (\n   112→            id TEXT PRIMARY KEY,\n   113→            content_type TEXT NOT NULL,\n   114→            prompt TEXT,\n   115→            model TEXT,\n   116→            status TEXT DEFAULT 'completed',\n   117→            file_path TEXT,\n   118→            relative_path TEXT,\n   119→            thumbnail_path TEXT,\n   120→            parameters TEXT,\n   121→            metadata TEXT,\n   122→            created_at TEXT,\n   123→            updated_at TEXT\n   124→        );\n   125→\n   126→        CREATE TABLE IF NOT EXISTS reference_assets (\n   127→            id TEXT PRIMARY KEY,\n   128→            generation_id TEXT NOT NULL,\n   129→            asset_path TEXT,\n   130→            relative_path TEXT,\n   131→            asset_type TEXT,\n   132→            order_index INTEGER DEFAULT 0,\n   133→            metadata TEXT,\n   134→            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n   135→        );\n   136→\n   137→        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n   138→        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n   139→        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n   140→        \"\"\"\n   141→\n   142→        try:\n   143→            with connection:\n   144→                connection.executescript(schema)\n   145→        except sqlite3.Error as exc:\n   146→            logger.error(\"Failed to create initial tables: {}\", exc)\n   147→            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n   148→\n   149→    @staticmethod\n   150→    def _now() -> str:\n   151→        return datetime.utcnow().isoformat()\n   152→\n   153→    @staticmethod\n   154→    def _dump_json(data: Any) -> Optional[str]:\n   155→        if data is None:\n   156→            return None\n   157→\n   158→        try:\n   159→            return json.dumps(data)\n   160→        except (TypeError, ValueError) as exc:\n   161→            logger.error(\"Failed to serialize JSON field: {}\", exc)\n   162→            return None\n   163→\n   164→    @staticmethod\n   165→    def _load_json(payload: Optional[str]) -> Optional[Any]:\n   166→        if not payload:\n   167→            return None\n   168→\n   169→        try:\n   170→            return json.loads(payload)\n   171→        except json.JSONDecodeError as exc:\n   172→            logger.error(\"Failed to decode JSON payload: {}\", exc)\n   173→            return None\n   174→\n   175→    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n   176→        result = dict(row)\n   177→        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n   178→        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n   179→\n   180→        # 将相对路径转换为绝对路径\n   181→        if self.storage_root:\n   182→            import os\n   183→            # file_path / relative_path -> absolute_path\n   184→            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n   185→            if rel_path:\n   186→                # 统一路径分隔符\n   187→                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n   188→                abs_path = self.storage_root / rel_path\n   189→                result[\"absolute_path\"] = str(abs_path)\n   190→\n   191→            # thumbnail_path -> absolute thumbnail path\n   192→            thumb_path = result.get(\"thumbnail_path\")\n   193→            if thumb_path:\n   194→                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n   195→                abs_thumb = self.storage_root / thumb_path\n   196→                result[\"thumbnail_path\"] = str(abs_thumb)\n   197→\n   198→        return result\n   199→\n   200→    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"24bd97f8-cfad-45e5-8c21-cf2219a3b72d","timestamp":"2026-01-05T11:54:00.264Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"SQLite 存储层，负责管理图像/视频生成记录.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sqlite3\nimport threading\nfrom concurrent.futures import Future, TimeoutError\nfrom queue import Queue\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, List, Optional\n\nfrom loguru import logger\n\n\nclass SQLiteHandler:\n    \"\"\"封装 SQLite 持久化逻辑.\"\"\"\n\n    _DEFAULT_TIMEOUT_SECONDS = 30.0\n\n    def __init__(self, db_path: Path, storage_root: Optional[Path] = None):\n        \"\"\"初始化数据库连接并创建所需表结构.\n\n        Args:\n            db_path: 数据库文件路径\n            storage_root: 存储根目录，用于将相对路径转换为绝对路径\n        \"\"\"\n\n        self.db_path = Path(db_path)\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n        self.storage_root = storage_root\n\n        # 并发策略（Q002-方案B）：单线程 DB Worker + 队列串行执行\n        self._closed = False\n        self._queue: Queue[Optional[tuple[Future, Callable[[sqlite3.Connection], Any]]]] = Queue()\n        self._init_future: Future[bool] = Future()\n\n        self._worker_thread = threading.Thread(\n            target=self._run_worker,\n            name=f\"SQLiteHandler[{self.db_path.name}]\",\n            daemon=True,\n        )\n        self._worker_thread.start()\n\n        try:\n            self._init_future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except Exception as exc:\n            logger.error(\"Failed to initialize SQLite database {}: {}\", self.db_path, exc)\n            raise RuntimeError(\"Unable to initialize SQLite database\") from exc\n\n    def _run_worker(self) -> None:\n        connection: Optional[sqlite3.Connection] = None\n        try:\n            connection = sqlite3.connect(self.db_path)\n            connection.row_factory = sqlite3.Row\n            connection.execute(\"PRAGMA foreign_keys = ON;\")\n            self._create_tables(connection)\n        except Exception as exc:\n            self._init_future.set_exception(exc)\n            if connection:\n                try:\n                    connection.close()\n                except Exception:\n                    pass\n            return\n\n        self._init_future.set_result(True)\n\n        while True:\n            item = self._queue.get()\n            try:\n                if item is None:\n                    break\n                future, fn = item\n                if not future.set_running_or_notify_cancel():\n                    continue\n                try:\n                    future.set_result(fn(connection))\n                except Exception as exc:\n                    future.set_exception(exc)\n            finally:\n                self._queue.task_done()\n\n        if connection:\n            try:\n                connection.close()\n            except sqlite3.Error as exc:\n                logger.error(\"Failed to close SQLite connection: {}\", exc)\n\n    def _call(self, operation: str, fn: Callable[[sqlite3.Connection], Any], default: Any):\n        if self._closed:\n            return default\n        future: Future = Future()\n        self._queue.put((future, fn))\n        try:\n            return future.result(timeout=self._DEFAULT_TIMEOUT_SECONDS)\n        except TimeoutError:\n            logger.error(\"SQLite operation timed out: {}\", operation)\n            return default\n        except Exception as exc:\n            logger.error(\"SQLite operation failed {}: {}\", operation, exc)\n            return default\n\n    def _create_tables(self, connection: sqlite3.Connection) -> None:\n        \"\"\"初始化数据库表结构.\"\"\"\n\n        schema = \"\"\"\n        CREATE TABLE IF NOT EXISTS generations (\n            id TEXT PRIMARY KEY,\n            content_type TEXT NOT NULL,\n            prompt TEXT,\n            model TEXT,\n            status TEXT DEFAULT 'completed',\n            file_path TEXT,\n            relative_path TEXT,\n            thumbnail_path TEXT,\n            parameters TEXT,\n            metadata TEXT,\n            created_at TEXT,\n            updated_at TEXT\n        );\n\n        CREATE TABLE IF NOT EXISTS reference_assets (\n            id TEXT PRIMARY KEY,\n            generation_id TEXT NOT NULL,\n            asset_path TEXT,\n            relative_path TEXT,\n            asset_type TEXT,\n            order_index INTEGER DEFAULT 0,\n            metadata TEXT,\n            FOREIGN KEY (generation_id) REFERENCES generations(id) ON DELETE CASCADE\n        );\n\n        CREATE INDEX IF NOT EXISTS idx_generations_type ON generations(content_type);\n        CREATE INDEX IF NOT EXISTS idx_generations_created ON generations(created_at DESC);\n        CREATE INDEX IF NOT EXISTS idx_refs_generation ON reference_assets(generation_id);\n        \"\"\"\n\n        try:\n            with connection:\n                connection.executescript(schema)\n        except sqlite3.Error as exc:\n            logger.error(\"Failed to create initial tables: {}\", exc)\n            raise RuntimeError(\"Unable to create SQLite tables\") from exc\n\n    @staticmethod\n    def _now() -> str:\n        return datetime.utcnow().isoformat()\n\n    @staticmethod\n    def _dump_json(data: Any) -> Optional[str]:\n        if data is None:\n            return None\n\n        try:\n            return json.dumps(data)\n        except (TypeError, ValueError) as exc:\n            logger.error(\"Failed to serialize JSON field: {}\", exc)\n            return None\n\n    @staticmethod\n    def _load_json(payload: Optional[str]) -> Optional[Any]:\n        if not payload:\n            return None\n\n        try:\n            return json.loads(payload)\n        except json.JSONDecodeError as exc:\n            logger.error(\"Failed to decode JSON payload: {}\", exc)\n            return None\n\n    def _row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:\n        result = dict(row)\n        result[\"parameters\"] = self._load_json(result.get(\"parameters\"))\n        result[\"metadata\"] = self._load_json(result.get(\"metadata\"))\n\n        # 将相对路径转换为绝对路径\n        if self.storage_root:\n            import os\n            # file_path / relative_path -> absolute_path\n            rel_path = result.get(\"file_path\") or result.get(\"relative_path\")\n            if rel_path:\n                # 统一路径分隔符\n                rel_path = rel_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_path = self.storage_root / rel_path\n                result[\"absolute_path\"] = str(abs_path)\n\n            # thumbnail_path -> absolute thumbnail path\n            thumb_path = result.get(\"thumbnail_path\")\n            if thumb_path:\n                thumb_path = thumb_path.replace('\\\\', '/').replace('/', os.sep)\n                abs_thumb = self.storage_root / thumb_path\n                result[\"thumbnail_path\"] = str(abs_thumb)\n\n        return result\n\n    def _reference_row_to_dict(self, row: sqlite3.Row) -> Dict[str, Any]:","numLines":200,"startLine":1,"totalLines":588}}}
{"parentUuid":"24bd97f8-cfad-45e5-8c21-cf2219a3b72d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DrbYqBmn31z4gEBGFJeraX","type":"tool_result","content":"modules/repository/sqlite_handler.py:111:        CREATE TABLE IF NOT EXISTS generations ("}]},"uuid":"23ef84c0-1dfc-4563-84c8-5cce0c956adf","timestamp":"2026-01-05T11:54:00.278Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"modules/repository/sqlite_handler.py:111:        CREATE TABLE IF NOT EXISTS generations (","numLines":1}}
{"parentUuid":"23ef84c0-1dfc-4563-84c8-5cce0c956adf","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U7AsvjxZs9uG38UK5Nqcqh","type":"tool_result","content":"     1→﻿#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 参数 Schema 与校验（最小落地）\n     5→\n     6→目标：\n     7→- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n     8→- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n     9→- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n    10→\"\"\"\n    11→\n    12→import copy\n    13→from dataclasses import dataclass, field\n    14→from typing import Any, Optional, Tuple, List, Dict\n    15→\n    16→# 参考图限制（见官方文档 lines 203-204）\n    17→MAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\n    18→MAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n    19→\n    20→\n    21→# 白名单与范围\n    22→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    23→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n    24→\n    25→\n    26→@dataclass\n    27→class TextToImageParams:\n    28→    prompt: str\n    29→    size: str = \"1024x1024\"\n    30→    guidance_scale: float = 2.5\n    31→    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    32→    reference_images: List[str] = field(default_factory=list)\n    33→    sequential_mode: bool = False\n    34→    count: int = 1\n    35→\n    36→\n    37→@dataclass\n    38→class ImageToImageParams:\n    39→    prompt: str\n    40→    image: str  # URL 或 data URL\n    41→    guidance_scale: float = 5.5\n    42→    seed: Optional[int] = None\n    43→    reference_images: List[str] = field(default_factory=list)\n    44→    sequential_mode: bool = False\n    45→    count: int = 1\n    46→\n    47→\n    48→@dataclass\n    49→class VideoParams:\n    50→    prompt: str\n    51→    image_path: Optional[str] = None\n    52→    first_frame_path: Optional[str] = None\n    53→    last_frame_path: Optional[str] = None\n    54→    duration: int = 8\n    55→    fps: int = 24\n    56→    seed: Optional[int] = None\n    57→    camera_fixed: bool = True\n    58→    watermark: bool = False\n    59→    resolution_grade: Optional[str] = None\n    60→    ratio: Optional[str] = None\n    61→    use_pro_model: bool = True\n    62→    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    63→    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    64→    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    65→    reference_images: List[str] = field(default_factory=list)\n    66→\n    67→\n    68→@dataclass(frozen=True)\n    69→class UIOption:\n    70→    value: Any\n    71→    label: str\n    72→    description: Optional[str] = None\n    73→    meta: Dict[str, Any] = field(default_factory=dict)\n    74→\n    75→\n    76→@dataclass(frozen=True)\n    77→class UIDependency:\n    78→    field: str\n    79→    equals: Any = None\n    80→    not_equals: Any = None\n    81→    exists: bool = False\n    82→\n    83→\n    84→@dataclass\n    85→class UISchemaField:\n    86→    name: str\n    87→    field_type: str\n    88→    label: str\n    89→    default: Any = None\n    90→    required: bool = False\n    91→    help_text: Optional[str] = None\n    92→    placeholder: Optional[str] = None\n    93→    options: List[UIOption] = field(default_factory=list)\n    94→    min_value: Optional[float] = None\n    95→    max_value: Optional[float] = None\n    96→    step: Optional[float] = None\n    97→    visible_if: List[UIDependency] = field(default_factory=list)\n    98→    enabled_if: List[UIDependency] = field(default_factory=list)\n    99→    extra: Dict[str, Any] = field(default_factory=dict)\n   100→\n   101→    def to_dict(self) -> Dict[str, Any]:\n   102→        return {\n   103→            \"name\": self.name,\n   104→            \"type\": self.field_type,\n   105→            \"label\": self.label,\n   106→            \"default\": self.default,\n   107→            \"required\": self.required,\n   108→            \"help_text\": self.help_text,\n   109→            \"placeholder\": self.placeholder,\n   110→            \"options\": [\n   111→                {\n   112→                    \"value\": opt.value,\n   113→                    \"label\": opt.label,\n   114→                    \"description\": opt.description,\n   115→                    \"meta\": opt.meta,\n   116→                }\n   117→                for opt in self.options\n   118→            ],\n   119→            \"min\": self.min_value,\n   120→            \"max\": self.max_value,\n   121→            \"step\": self.step,\n   122→            \"visible_if\": [\n   123→                {\n   124→                    \"field\": dep.field,\n   125→                    \"equals\": dep.equals,\n   126→                    \"not_equals\": dep.not_equals,\n   127→                    \"exists\": dep.exists,\n   128→                }\n   129→                for dep in self.visible_if\n   130→            ],\n   131→            \"enabled_if\": [\n   132→                {\n   133→                    \"field\": dep.field,\n   134→                    \"equals\": dep.equals,\n   135→                    \"not_equals\": dep.not_equals,\n   136→                    \"exists\": dep.exists,\n   137→                }\n   138→                for dep in self.enabled_if\n   139→            ],\n   140→            \"extra\": self.extra,\n   141→        }\n   142→\n   143→\n   144→@dataclass\n   145→class UISchema:\n   146→    provider: str\n   147→    mode: str\n   148→    variant: str\n   149→    fields: List[UISchemaField] = field(default_factory=list)\n   150→    primary_image: Dict[str, Any] = field(default_factory=dict)\n   151→    reference_assets: Dict[str, Any] = field(default_factory=dict)\n   152→    extra: Dict[str, Any] = field(default_factory=dict)\n   153→\n   154→    def to_dict(self) -> Dict[str, Any]:\n   155→        return {\n   156→            \"provider\": self.provider,\n   157→            \"mode\": self.mode,\n   158→            \"variant\": self.variant,\n   159→            \"fields\": [field.to_dict() for field in self.fields],\n   160→            \"primary_image\": self.primary_image,\n   161→            \"reference_assets\": self.reference_assets,\n   162→            \"extra\": self.extra,\n   163→        }\n   164→\n   165→\n   166→def _clip_seed(seed: Optional[int]) -> Optional[int]:\n   167→    if seed is None:\n   168→        return None\n   169→    try:\n   170→        iv = int(seed)\n   171→    except Exception:\n   172→        return None\n   173→    if iv < 0:\n   174→        return None\n   175→    if iv > 2147483647:\n   176→        iv = 2147483647\n   177→    return iv\n   178→\n   179→\n   180→def validate_and_normalize_t2i(p: TextToImageParams) -> Tuple[TextToImageParams, bool, str]:\n   181→    fb = False\n   182→    reasons: List[str] = []\n   183→    # size: 期望形如 WxH，范围 512..4096（兼容 Seedream 4.0 高分辨率）\n   184→    def _valid_size(s: str) -> bool:\n   185→        try:\n   186→            if 'x' not in s:\n   187→                return False\n   188→            w, h = s.split('x', 1)\n   189→            w, h = int(w), int(h)\n   190→            return 512 <= w <= 4096 and 512 <= h <= 4096\n   191→        except Exception:\n   192→            return False\n   193→\n   194→    size = p.size or \"1024x1024\"\n   195→    if not _valid_size(size):\n   196→        fb = True\n   197→        reasons.append(f\"无效尺寸: {p.size or '缺失'}\")\n   198→        size = \"1024x1024\"\n   199→\n   200→    gs = p.guidance_scale\n   201→    if not (1.0 <= gs <= 10.0):\n   202→        fb = True\n   203→        reasons.append(f\"guidance_scale越界: {gs}\")\n   204→        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 2.5\n   205→\n   206→    seed = _clip_seed(p.seed)\n   207→\n   208→    raw_refs: List[str] = []\n   209→    try:\n   210→        for item in p.reference_images or []:\n   211→            if isinstance(item, str) and item:\n   212→                raw_refs.append(item)\n   213→    except Exception:\n   214→        raw_refs = []\n   215→\n   216→    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n   217→    if ref_fb:\n   218→        fb = True\n   219→        reasons.append(ref_reason)\n   220→\n   221→    norm = TextToImageParams(\n   222→        prompt=p.prompt,\n   223→        size=size,\n   224→        guidance_scale=gs,\n   225→        seed=seed,\n   226→        reference_images=refs,\n   227→        sequential_mode=p.sequential_mode,\n   228→        count=p.count,\n   229→    )\n   230→    return norm, fb, \", \".join(reasons) if fb else \"\"\n   231→\n   232→\n   233→def _normalize_reference_images(refs: List[str], expected_outputs: int = 1) -> Tuple[List[str], bool, str]:\n   234→    \"\"\"裁剪/校验参考图数量，返回 (normalized_refs, fallback, reason)。\n   235→\n   236→    约束源于官方文档《doubao-seedream-4.0 教程》（行 203-204）：\n   237→    - Seedream 4.0 最多 10 张参考图；\n   238→    - （组图扩展）参考图数量 + 生成图数量 ≤ 15。\n   239→    \"\"\"\n   240→    fb = False\n   241→    reasons: List[str] = []\n   242→    refs = [r for r in refs if isinstance(r, str) and r]\n   243→    # 限制：≤10 张\n   244→    if len(refs) > MAX_REFERENCE_IMAGES:\n   245→        fb = True\n   246→        reasons.append(\n   247→            f\"参考图数量超过 {MAX_REFERENCE_IMAGES}，已自动截取前 {MAX_REFERENCE_IMAGES} 张\"\n   248→        )\n   249→        refs = refs[:MAX_REFERENCE_IMAGES]\n   250→    # 组图扩展：参考图 + 生成图 ≤ 15（当前生成图默认为 expected_outputs）\n   251→    if expected_outputs >= 0 and len(refs) + expected_outputs > MAX_REFERENCE_BUNDLE:\n   252→        allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n   253→        if len(refs) > allowed:\n   254→            fb = True\n   255→            reasons.append(\n   256→                f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}，已截取前 {allowed} 张\"\n   257→            )\n   258→            refs = refs[:allowed]\n   259→    return refs, fb, \", \".join(reasons) if fb else \"\"\n   260→\n   261→\n   262→def validate_and_normalize_i2i(p: ImageToImageParams) -> Tuple[ImageToImageParams, bool, str]:\n   263→    fb = False\n   264→    reasons: List[str] = []\n   265→    gs = p.guidance_scale\n   266→    if not (1.0 <= gs <= 10.0):\n   267→        fb = True\n   268→        reasons.append(f\"guidance_scale越界: {gs}\")\n   269→        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 5.5\n   270→    seed = _clip_seed(p.seed)\n   271→    raw_refs: List[str] = []\n   272→    try:\n   273→        for item in p.reference_images or []:\n   274→            if isinstance(item, str) and item:\n   275→                raw_refs.append(item)\n   276→    except Exception:\n   277→        raw_refs = []\n   278→\n   279→    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n   280→    if ref_fb:\n   281→        fb = True\n   282→        reasons.append(ref_reason)\n   283→\n   284→    norm = ImageToImageParams(\n   285→        prompt=p.prompt,\n   286→        image=p.image,\n   287→        guidance_scale=gs,\n   288→        seed=seed,\n   289→        reference_images=refs,\n   290→    )\n   291→    return norm, fb, \", \".join(reasons) if fb else \"\"\n   292→\n   293→\n   294→def validate_and_normalize_video(p: VideoParams) -> Tuple[VideoParams, bool, str, str, str]:\n   295→    \"\"\"返回 (normalized, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n   296→    fb = False\n   297→    reasons: List[str] = []\n   298→\n   299→    variant = (p.model_variant or \"\").strip().lower()\n   300→    is_seedance_1_5 = variant == \"seedance_1_5_pro\"\n   301→\n   302→    rs_default = \"720p\" if is_seedance_1_5 else \"1080p\"\n   303→    rt_default = \"adaptive\" if is_seedance_1_5 else \"16:9\"\n   304→\n   305→    rs = p.resolution_grade or rs_default\n   306→    rt = p.ratio or rt_default\n   307→    if rs not in RES_GRADES:\n   308→        fb = True\n   309→        reasons.append(f\"无效分辨率: {rs}\")\n   310→        rs = rs_default\n   311→    if rt not in RATIOS:\n   312→        fb = True\n   313→        reasons.append(f\"无效比例: {rt}\")\n   314→        rt = rt_default\n   315→\n   316→    # Seedance 1.5 Pro 暂不支持 1080p\n   317→    if is_seedance_1_5 and rs == \"1080p\":\n   318→        fb = True\n   319→        reasons.append(\"1.5 Pro 不支持1080p，已降级到720p\")\n   320→        rs = \"720p\"\n   321→\n   322→    fps = int(p.fps or 24)\n   323→    if fps <= 0:\n   324→        fps = 24\n   325→\n   326→    # duration: 1.5 Pro 支持 -1（自适应），否则要求 4-12；其他模型沿用 3-12\n   327→    raw_duration = p.duration\n   328→    if is_seedance_1_5 and raw_duration == -1:\n   329→        dur = -1\n   330→    else:\n   331→        try:\n   332→            dur = int(raw_duration if raw_duration is not None else (5 if is_seedance_1_5 else 8))\n   333→        except Exception:\n   334→            dur = 5 if is_seedance_1_5 else 8\n   335→\n   336→        dur_min = 4 if is_seedance_1_5 else 3\n   337→        dur_max = 12\n   338→        if dur < dur_min:\n   339→            fb = True\n   340→            reasons.append(f\"时长过短(<{dur_min}s)\")\n   341→            dur = dur_min\n   342→        if dur > dur_max:\n   343→            fb = True\n   344→            reasons.append(f\"时长过长(>{dur_max}s)\")\n   345→            dur = dur_max\n   346→\n   347→    seed = _clip_seed(p.seed)\n   348→    raw_refs: List[str] = []\n   349→    try:\n   350→        for item in p.reference_images or []:\n   351→            if isinstance(item, str) and item:\n   352→                raw_refs.append(item)\n   353→    except Exception:\n   354→        raw_refs = []\n   355→\n   356→    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n   357→    if ref_fb:\n   358→        fb = True\n   359→        reasons.append(ref_reason)\n   360→\n   361→    norm = VideoParams(\n   362→        prompt=p.prompt,\n   363→        image_path=p.image_path,\n   364→        first_frame_path=p.first_frame_path,\n   365→        last_frame_path=p.last_frame_path,\n   366→        duration=dur,\n   367→        fps=fps,\n   368→        seed=seed,\n   369→        camera_fixed=bool(p.camera_fixed),\n   370→        watermark=bool(p.watermark),\n   371→        resolution_grade=rs,\n   372→        ratio=rt,\n   373→        use_pro_model=bool(p.use_pro_model),\n   374→        model_variant=p.model_variant,\n   375→        generate_audio=p.generate_audio,\n   376→        reference_images=refs,\n   377→    )\n   378→    return norm, fb, \", \".join(reasons) if fb else \"\", rs, rt\n   379→\n   380→\n   381→# ------------------------------\n   382→# UI Schema 定义（供前端驱动参数面板）\n   383→# ------------------------------\n   384→\n   385→\n   386→def _schema_key(provider: str, mode: str, variant: str) -> str:\n   387→    return f\"{provider}:{mode}:{variant}\"\n   388→\n   389→\n   390→def _option(value: Any, label: str, *, description: Optional[str] = None, meta: Optional[Dict[str, Any]] = None) -> UIOption:\n   391→    return UIOption(value=value, label=label, description=description, meta=meta or {})\n   392→\n   393→\n   394→def _dependency(field: str, *, equals: Any = None, not_equals: Any = None, exists: bool = False) -> UIDependency:\n   395→    return UIDependency(field=field, equals=equals, not_equals=not_equals, exists=exists)\n   396→\n   397→\n   398→def _build_seedream_schema(variant: str) -> UISchema:\n   399→    variant = variant or \"seedream_v4\"\n   400→    fields: List[UISchemaField] = []\n   401→\n   402→    model_options = [\n   403→        _option(\n   404→            \"seedream_v3\",\n   405→            \"Seedream 3.x\",\n   406→            description=\"稳定版本，支持单图/文生图\",\n   407→            meta={\n   408→                \"t2i_model\": \"doubao-seedream-3-0-t2i-250415\",\n   409→                \"i2i_model\": \"doubao-seededit-3-0-i2i-250628\",\n   410→                \"ui_variant\": \"seedream_v3\",\n   411→            },\n   412→        ),\n   413→        _option(\n   414→            \"seedream_v4\",\n   415→            \"Seedream 4.0\",\n   416→            description=\"多参考图融合，最大10张参考图\",\n   417→            meta={\n   418→                \"t2i_model\": \"doubao-seedream-4-0-250828\",\n   419→                \"i2i_model\": \"doubao-seedream-4-0-250828\",\n   420→                \"ui_variant\": \"seedream_v4\",\n   421→            },\n   422→        ),\n   423→        _option(\n   424→            \"seedream_v4_5\",\n   425→            \"Seedream 4.5\",\n   426→            description=\"最新版本，支持组图生成，最大10张参考图\",\n   427→            meta={\n   428→                \"t2i_model\": \"doubao-seedream-4-5-251128\",\n   429→                \"i2i_model\": \"doubao-seedream-4-5-251128\",\n   430→                \"ui_variant\": \"seedream_v4_5\",\n   431→            },\n   432→        ),\n   433→    ]\n   434→    fields.append(\n   435→        UISchemaField(\n   436→            name=\"model_variant\",\n   437→            field_type=\"select\",\n   438→            label=\"模型\",\n   439→            default=variant,\n   440→            help_text=\"切换模型将刷新可选参数与上传限制\",\n   441→            options=model_options,\n   442→            extra={\"reload_on_change\": True, \"schema_family\": \"seedream\"},\n   443→        )\n   444→    )\n   445→\n   446→    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n   447→        # Seedream 4.x 尺寸限制（官方文档）：\n   448→        # 总像素范围：[3,686,400 ~ 16,777,216]\n   449→        # 宽高比范围：[1/16, 16]\n   450→        # 以下尺寸均为各比例的顶格尺寸\n   451→        size_options = [\n   452→            # 1:1\n   453→            _option(\"4096x4096\", \"4096×4096 (1:1)\"),\n   454→            # 16:9 / 9:16\n   455→            _option(\"4096x2304\", \"4096×2304 (16:9)\"),\n   456→            _option(\"2304x4096\", \"2304×4096 (9:16)\"),\n   457→            # 4:3 / 3:4\n   458→            _option(\"4096x3072\", \"4096×3072 (4:3)\"),\n   459→            _option(\"3072x4096\", \"3072×4096 (3:4)\"),\n   460→            # 3:2 / 2:3\n   461→            _option(\"4096x2731\", \"4096×2731 (3:2)\"),\n   462→            _option(\"2731x4096\", \"2731×4096 (2:3)\"),\n   463→            # 21:9 / 9:21\n   464→            _option(\"4096x1755\", \"4096×1755 (21:9)\"),\n   465→            _option(\"1755x4096\", \"1755×4096 (9:21)\"),\n   466→        ]\n   467→        default_size = \"4096x4096\"\n   468→    else:\n   469→        # Seedream 3.x：按常见比例提供范围内的最大像素组合（宽高在 512–2048）\n   470→        size_options = [\n   471→            _option(\"2048x2048\", \"2048×2048 (1:1)\"),\n   472→            _option(\"2048x1536\", \"2048×1536 (4:3)\"),\n   473→            _option(\"1536x2048\", \"1536×2048 (3:4)\"),\n   474→            _option(\"2048x1152\", \"2048×1152 (16:9)\"),\n   475→            _option(\"1152x2048\", \"1152×2048 (9:16)\"),\n   476→            _option(\"1920x1280\", \"1920×1280 (3:2)\"),\n   477→            _option(\"1280x1920\", \"1280×1920 (2:3)\"),\n   478→            _option(\"1792x768\",  \"1792×768 (21:9)\"),\n   479→        ]\n   480→        default_size = \"2048x2048\"\n   481→\n   482→    fields.append(\n   483→        UISchemaField(\n   484→            name=\"size\",\n   485→            field_type=\"select\",\n   486→            label=\"分辨率\",\n   487→            default=default_size,\n   488→            options=size_options,\n   489→            help_text=\"仅提供官方支持的常用分辨率\",\n   490→        )\n   491→    )\n   492→\n   493→    fields.append(\n   494→        UISchemaField(\n   495→            name=\"seed\",\n   496→            field_type=\"text\",  # 使用 QLineEdit 替代 QSpinBox，去掉上下按钮\n   497→            label=\"Seed\",\n   498→            default=\"-1\",\n   499→            help_text=\"-1 表示随机；指定整数可复现结果\",\n   500→            extra={\"is_integer\": True, \"min_value\": -1, \"max_value\": 4294967295},  # 2^32-1\n   501→        )\n   502→    )\n   503→\n   504→    # 新增：组图模式开关（Seedream 4.0 和 4.5 都支持）\n   505→    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n   506→        fields.append(\n   507→            UISchemaField(\n   508→                name=\"sequential_mode\",\n   509→                field_type=\"toggle\",\n   510→                label=\"组图\",\n   511→                default=False,\n   512→                help_text=\"开启后单次请求返回多张风格一致的图；关闭时逐张调用\",\n   513→            )\n   514→        )\n   515→\n   516→    # 修改：count 控件的帮助文本\n   517→    count_help = \"一次最多生成 10 张\"\n   518→    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n   519→        count_help = \"普通模式最多 10 张；组图模式最多 15 张（参考图 + 输出 ≤ 15）\"\n   520→\n   521→    fields.append(\n   522→        UISchemaField(\n   523→            name=\"count\",\n   524→            field_type=\"text\",  # 使用 QLineEdit 替代 QSpinBox，去掉上下按钮\n   525→            label=\"生成数量\",\n   526→            default=\"4\",  # 默认4张\n   527→            help_text=count_help,\n   528→            extra={\"is_integer\": True, \"min_value\": 1, \"max_value\": 15},  # 组图最大15，普通模式由动态逻辑限制为10\n   529→        )\n   530→    )\n   531→\n   532→    # 隐藏\"自动压缩参考图\"参数，后端自动启用\n   533→    # fields.append(\n   534→    #     UISchemaField(\n   535→    #         name=\"auto_compress_references\",\n   536→    #         field_type=\"toggle\",\n   537→    #         label=\"自动压缩参考图\",\n   538→    #         default=True,\n   539→    #         help_text=\"上传时自动压缩到 2K 内，避免超出 API 限制\",\n   540→    #     )\n   541→    # )\n   542→\n   543→    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n   544→        reference_enabled = True\n   545→        ref_max_count = MAX_REFERENCE_IMAGES\n   546→        ref_bundle_limit = MAX_REFERENCE_BUNDLE\n   547→        ref_help = \"最多 14 张参考图，参考图 + 输出数量 ≤ 15\"\n   548→        if variant == \"seedream_v4_5\":\n   549→            ref_help = \"默认最多 14 张参考图；组图模式下参考图 + 输出数量 ≤ 15\"\n   550→        multi_reference = True\n   551→    else:\n   552→        # seedream_v3: 保留旧体验（单张参考图，面板隐藏）\n   553→        reference_enabled = False\n   554→        ref_max_count = 1\n   555→        ref_bundle_limit = 1\n   556→        ref_help = \"最多 1 张参考图\"\n   557→        multi_reference = False\n   558→\n   559→    reference_assets = {\n   560→        \"enabled\": reference_enabled,\n   561→        \"max_count\": ref_max_count,\n   562→        \"bundle_limit\": ref_bundle_limit,\n   563→        \"accept\": [\"image/png\", \"image/jpeg\"],\n   564→        \"auto_compress_field\": \"auto_compress_references\",\n   565→        \"help_text\": ref_help,\n   566→        \"orderable\": True,\n   567→    }\n   568→\n   569→    primary_image = {\n   570→        \"enabled\": True,\n   571→        \"label\": \"基础图 (可选)\",\n   572→        \"placeholder\": \"拖拽或点击上传一张基础图，留空则进行文生图\",\n   573→        \"accept\": [\"image/png\", \"image/jpeg\"],\n   574→        \"max_size_mb\": 10,\n   575→    }\n   576→\n   577→    capabilities = {\n   578→        \"multi_reference\": multi_reference,\n   579→        \"supports_reference\": True,\n   580→        \"single_reference\": not multi_reference,\n   581→    }\n   582→\n   583→    # 构建第一行布局 - 自适应设计，AdjustToContents + stretch 分配\n   584→    first_row = [\n   585→        # 模型名较长，Expanding + AdjustToContents\n   586→        {\"name\": \"model_variant\", \"stretch\": 3, \"label_width\": 35, \"min_width\": 100,\n   587→         \"size_policy\": \"expanding\", \"adjust_to_contents\": True},\n   588→        # 尺寸选项较长(1024x1024)，也使用 Expanding\n   589→        {\"name\": \"size\", \"stretch\": 3, \"label_width\": 50, \"min_width\": 100,\n   590→         \"size_policy\": \"expanding\", \"adjust_to_contents\": True},\n   591→        # Seed 和数量：Preferred + AdjustToContents\n   592→        {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 35, \"min_width\": 60,\n   593→         \"size_policy\": \"preferred\"},\n   594→        {\"name\": \"count\", \"stretch\": 1, \"label_width\": 55, \"min_width\": 50,\n   595→         \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n   596→        {\n   597→            \"name\": \"auto_compress_references\",\n   598→            \"stretch\": 0,\n   599→            \"label_width\": 0,\n   600→        },\n   601→    ]\n   602→\n   603→    # 如果是 Seedream 4.0/4.5，在 seed 和 count 之间插入 sequential_mode\n   604→    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n   605→        first_row.insert(\n   606→            3,  # 在 seed 后、count 前插入\n   607→            {\"name\": \"sequential_mode\", \"stretch\": 0, \"label_width\": 45, \"min_width\": 45,\n   608→             \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n   609→        )\n   610→\n   611→    extra = {\n   612→        \"supports_reference\": True,  # 3.x模式也支持参考图显示，只是UI面板隐藏\n   613→        \"layout\": {\n   614→            \"type\": \"rows\",\n   615→            \"row_spacing\": 6,\n   616→            \"column_spacing\": 8,  # 与视频模式一致\n   617→            \"rows\": [first_row],\n   618→        },\n   619→        \"capabilities\": capabilities,\n   620→    }\n   621→\n   622→    return UISchema(\n   623→        provider=\"seedream\",\n   624→        mode=\"image\",\n   625→        variant=variant,\n   626→        fields=fields,\n   627→        primary_image=primary_image,\n   628→        reference_assets=reference_assets,\n   629→        extra=extra,\n   630→    )\n   631→\n   632→\n   633→def _build_seedance_schema(variant: str) -> UISchema:\n   634→    variant = variant or \"seedance_pro\"\n   635→    model_options = [\n   636→        _option(\n   637→            \"seedance_1_5_pro\",\n   638→            \"Seedance 1.5 Pro (有声)\",\n   639→            description=\"最新版本，可生成音画同步音频（默认开启）\",\n   640→            meta={\"use_pro_model\": True, \"model_type\": \"pro\", \"ui_variant\": \"seedance_1_5_pro\"},\n   641→        ),\n   642→        _option(\n   643→            \"seedance_pro\",\n   644→            \"Seedance Pro\",\n   645→            description=\"高质量输出，适合正式素材\",\n   646→            meta={\"use_pro_model\": True, \"model_type\": \"pro\", \"ui_variant\": \"seedance_pro\"},\n   647→        ),\n   648→        _option(\n   649→            \"seedance_pro_fast\",\n   650→            \"Seedance Pro-fast\",\n   651→            description=\"Pro级质量+更快速度（不支持首尾帧）\",\n   652→            meta={\"use_pro_model\": True, \"model_type\": \"pro_fast\", \"ui_variant\": \"seedance_pro_fast\"},\n   653→        ),\n   654→        _option(\n   655→            \"seedance_lite\",\n   656→            \"Seedance Lite\",\n   657→            description=\"快速输出，适合草稿\",\n   658→            meta={\"use_pro_model\": False, \"model_type\": \"lite\", \"ui_variant\": \"seedance_lite\"},\n   659→        ),\n   660→    ]\n   661→\n   662→    is_seedance_1_5 = variant == \"seedance_1_5_pro\"\n   663→    is_seedance_lite = variant == \"seedance_lite\"\n   664→\n   665→    resolution_default = \"720p\" if (is_seedance_1_5 or is_seedance_lite) else \"1080p\"\n   666→    resolution_options = [\n   667→        _option(\"480p\", \"480p\"),\n   668→        _option(\"720p\", \"720p\"),\n   669→    ]\n   670→    # 1.5 Pro 暂不支持 1080p（官方文档）\n   671→    if not is_seedance_1_5:\n   672→        resolution_options.append(_option(\"1080p\", \"1080p\"))\n   673→\n   674→    ratio_options = [\n   675→        _option(\"16:9\", \"16:9\"),\n   676→        _option(\"9:16\", \"9:16\"),\n   677→        _option(\"4:3\", \"4:3\"),\n   678→        _option(\"1:1\", \"1:1\"),\n   679→        _option(\"3:4\", \"3:4\"),\n   680→        _option(\"21:9\", \"21:9\"),\n   681→    ]\n   682→    ratio_default = \"16:9\"\n   683→    if is_seedance_1_5:\n   684→        ratio_options = [_option(\"adaptive\", \"自适应\")] + ratio_options\n   685→        ratio_default = \"adaptive\"\n   686→\n   687→    duration_default: int = 5\n   688→    duration_options: List[UIOption] = []\n   689→    duration_help = \"范围 3-12 秒，超过范围将自动回退\"\n   690→    if is_seedance_1_5:\n   691→        duration_help = \"Seedance 1.5 Pro：支持 4-12 秒整数，或自适应（-1）\"\n   692→        duration_options = [_option(-1, \"自适应\")] + [_option(sec, f\"{sec} 秒\") for sec in range(4, 13)]\n   693→    else:\n   694→        duration_options = [_option(sec, f\"{sec} 秒\") for sec in range(3, 13)]\n   695→\n   696→    fields: List[UISchemaField] = [\n   697→        UISchemaField(\n   698→            name=\"model_variant\",\n   699→            field_type=\"select\",\n   700→            label=\"模型\",\n   701→            default=variant,\n   702→            help_text=\"Pro 输出质量更高，Lite 更快速\",\n   703→            options=model_options,\n   704→            extra={\"reload_on_change\": True, \"schema_family\": \"seedance\"},\n   705→        ),\n   706→        UISchemaField(\n   707→            name=\"resolution_grade\",\n   708→            field_type=\"select\",\n   709→            label=\"分辨率\",\n   710→            default=resolution_default,\n   711→            options=resolution_options,\n   712→            help_text=\"官方推荐 480p/720p/1080p 三档（1.5 Pro 暂不支持 1080p）\",\n   713→        ),\n   714→        UISchemaField(\n   715→            name=\"ratio\",\n   716→            field_type=\"select\",\n   717→            label=\"比例\",\n   718→            default=ratio_default,\n   719→            options=ratio_options,\n   720→            help_text=\"生成时自动拼接 --rs/--rt 参数（1.5 Pro 支持自适应）\",\n   721→        ),\n   722→        UISchemaField(\n   723→            name=\"duration\",\n   724→            field_type=\"select\",\n   725→            label=\"时长 (秒)\",\n   726→            default=duration_default,\n   727→            options=duration_options,\n   728→            help_text=duration_help,\n   729→        ),\n   730→        UISchemaField(\n   731→            name=\"seed\",\n   732→            field_type=\"text\",  # 使用 QLineEdit 替代 QSpinBox，去掉上下按钮\n   733→            label=\"Seed\",\n   734→            default=\"-1\",\n   735→            help_text=\"-1 表示随机；指定整数可复现\",\n   736→            extra={\"is_integer\": True, \"min_value\": -1, \"max_value\": 4294967295},  # 2^32-1\n   737→        ),\n   738→        UISchemaField(\n   739→            name=\"camera_fixed\",\n   740→            field_type=\"toggle\",\n   741→            label=\"固定镜头\",\n   742→            default=True,\n   743→            help_text=\"开启后相机保持固定，适合稳态镜头\",\n   744→        ),\n   745→    ]\n   746→\n   747→    reference_assets = {\n   748→        \"enabled\": False,\n   749→        \"max_count\": 0,\n   750→        \"bundle_limit\": 0,\n   751→        \"accept\": [],\n   752→        \"auto_compress_field\": None,\n   753→        \"help_text\": \"\",\n   754→        \"orderable\": False,\n   755→    }\n   756→\n   757→    primary_frames = {\n   758→        \"enabled\": True,\n   759→        \"slots\": [\n   760→            {\n   761→                \"name\": \"first_frame\",\n   762→                \"label\": \"首帧 (可选)\",\n   763→                \"help_text\": \"提供首帧可提升人物一致性\",\n   764→                \"accept\": [\"image/png\", \"image/jpeg\"],\n   765→            },\n   766→            {\n   767→                \"name\": \"last_frame\",\n   768→                \"label\": \"尾帧 (可选)\",\n   769→                \"help_text\": \"提供尾帧可控制结尾画面\",\n   770→                \"accept\": [\"image/png\", \"image/jpeg\"],\n   771→            },\n   772→        ],\n   773→        \"max_size_mb\": 10,\n   774→    }\n   775→\n   776→    capabilities = {\n   777→        \"multi_reference\": False,\n   778→        \"supports_reference\": False,\n   779→    }\n   780→\n   781→    # Pro-fast 也属于 Pro 系列，但不支持首尾帧\n   782→    is_pro_series = variant in (\"seedance_1_5_pro\", \"seedance_pro\", \"seedance_pro_fast\")\n   783→    extra = {\n   784→        \"use_pro_model\": is_pro_series,\n   785→        \"model_type\": \"pro_fast\"\n   786→        if variant == \"seedance_pro_fast\"\n   787→        else (\"lite\" if variant == \"seedance_lite\" else \"pro\"),\n   788→        \"supports_first_last_frame\": variant != \"seedance_pro_fast\",  # Pro-fast 不支持首尾帧\n   789→        # 交互语义：首尾帧开关仅在 Lite 下用于切换“首尾帧 vs 参考图”\n   790→        \"show_first_last_toggle\": bool(is_seedance_lite),\n   791→        # 交互语义：生成音频开关仅 1.5 Pro 显示\n   792→        \"show_generate_audio_toggle\": bool(is_seedance_1_5),\n   793→        \"layout\": {\n   794→            \"type\": \"rows\",\n   795→            \"row_spacing\": 6,\n   796→            \"column_spacing\": 8,\n   797→            \"rows\": [\n   798→                [\n   799→                    # 模型名较长，Expanding + AdjustToContents，吃掉剩余空间\n   800→                    {\"name\": \"model_variant\", \"stretch\": 5, \"label_width\": 35, \"min_width\": 120,\n   801→                     \"size_policy\": \"expanding\", \"adjust_to_contents\": True},\n   802→                    # 短文本字段：Preferred + AdjustToContents，刚好包裹内容\n   803→                    {\"name\": \"resolution_grade\", \"stretch\": 1, \"label_width\": 45, \"min_width\": 55,\n   804→                     \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n   805→                    {\"name\": \"ratio\", \"stretch\": 1, \"label_width\": 35, \"min_width\": 45,\n   806→                     \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n   807→                    {\"name\": \"duration\", \"stretch\": 1, \"label_width\": 55, \"min_width\": 50,\n   808→                     \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n   809→                    {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 35, \"min_width\": 60,\n   810→                     \"size_policy\": \"preferred\"},\n   811→                    {\"name\": \"camera_fixed\", \"stretch\": 0, \"label_width\": 55, \"min_width\": 25},\n   812→                ],\n   813→            ],\n   814→        },\n   815→        \"capabilities\": capabilities,\n   816→    }\n   817→\n   818→    return UISchema(\n   819→        provider=\"seedance\",\n   820→        mode=\"video\",\n   821→        variant=variant,\n   822→        fields=fields,\n   823→        primary_image=primary_frames,\n   824→        reference_assets=reference_assets,\n   825→        extra=extra,\n   826→    )\n   827→\n   828→\n   829→_UI_SCHEMAS: Dict[str, UISchema] = {\n   830→    _schema_key(\"seedream\", \"image\", \"seedream_v3\"): _build_seedream_schema(\"seedream_v3\"),\n   831→    _schema_key(\"seedream\", \"image\", \"seedream_v4\"): _build_seedream_schema(\"seedream_v4\"),\n   832→    _schema_key(\"seedream\", \"image\", \"seedream_v4_5\"): _build_seedream_schema(\"seedream_v4_5\"),\n   833→    _schema_key(\"seedance\", \"video\", \"seedance_1_5_pro\"): _build_seedance_schema(\"seedance_1_5_pro\"),\n   834→    _schema_key(\"seedance\", \"video\", \"seedance_pro\"): _build_seedance_schema(\"seedance_pro\"),\n   835→    _schema_key(\"seedance\", \"video\", \"seedance_pro_fast\"): _build_seedance_schema(\"seedance_pro_fast\"),\n   836→    _schema_key(\"seedance\", \"video\", \"seedance_lite\"): _build_seedance_schema(\"seedance_lite\"),\n   837→}\n   838→\n   839→\n   840→_DEFAULT_VARIANTS: Dict[Tuple[str, str], str] = {\n   841→    (\"seedream\", \"image\"): \"seedream_v4\",\n   842→    (\"seedance\", \"video\"): \"seedance_pro\",\n   843→}\n   844→\n   845→\n   846→def get_ui_schema(provider: str, mode: str, variant: Optional[str] = None, *, as_dict: bool = False) -> UISchema:\n   847→    \"\"\"返回 UI Schema（深拷贝，避免调用侧修改真源）。\"\"\"\n   848→\n   849→    key_variant = variant or _DEFAULT_VARIANTS.get((provider, mode))\n   850→    if not key_variant:\n   851→        raise ValueError(f\"未定义默认 UI Schema: provider={provider} mode={mode}\")\n   852→\n   853→    key = _schema_key(provider, mode, key_variant)\n   854→    if key not in _UI_SCHEMAS:\n   855→        raise ValueError(f\"未找到 UI Schema: provider={provider} mode={mode} variant={key_variant}\")\n   856→\n   857→    schema = copy.deepcopy(_UI_SCHEMAS[key])\n   858→    if as_dict:\n   859→        return schema.to_dict()  # type: ignore[return-value]\n   860→    return schema\n   861→\n   862→\n   863→def list_ui_schema_variants(provider: str, mode: str) -> List[str]:\n   864→    prefix = f\"{provider}:{mode}:\"\n   865→    return [key.split(\":\", 2)[-1] for key in _UI_SCHEMAS.keys() if key.startswith(prefix)]\n   866→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e2698e5b-5d2d-4571-888c-b5d058b05122","timestamp":"2026-01-05T11:54:01.650Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/schema.py","content":"﻿#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 参数 Schema 与校验（最小落地）\n\n目标：\n- 为图片/视频生成提供统一的参数模型与校验/归一化逻辑；\n- 返回 (normalized, fallback_applied, fallback_reason) 三元组；\n- 本阶段仅覆盖 Seedream 3.0/3.1 与 Seedance pro/lite 所需字段；UI 暂不改动。\n\"\"\"\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Any, Optional, Tuple, List, Dict\n\n# 参考图限制（见官方文档 lines 203-204）\nMAX_REFERENCE_IMAGES = 14  # Seedream 4.5 默认支持 14 张参考图（组图模式下按 15-N 动态裁剪）\nMAX_REFERENCE_BUNDLE = 15  # 参考图数量 + 生成图数量 ≤ 15（组图扩展）\n\n\n# 白名单与范围\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n\n\n@dataclass\nclass TextToImageParams:\n    prompt: str\n    size: str = \"1024x1024\"\n    guidance_scale: float = 2.5\n    seed: Optional[int] = None  # -1 表示随机 → 归一化为 None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass ImageToImageParams:\n    prompt: str\n    image: str  # URL 或 data URL\n    guidance_scale: float = 5.5\n    seed: Optional[int] = None\n    reference_images: List[str] = field(default_factory=list)\n    sequential_mode: bool = False\n    count: int = 1\n\n\n@dataclass\nclass VideoParams:\n    prompt: str\n    image_path: Optional[str] = None\n    first_frame_path: Optional[str] = None\n    last_frame_path: Optional[str] = None\n    duration: int = 8\n    fps: int = 24\n    seed: Optional[int] = None\n    camera_fixed: bool = True\n    watermark: bool = False\n    resolution_grade: Optional[str] = None\n    ratio: Optional[str] = None\n    use_pro_model: bool = True\n    model_type: Optional[str] = None  # \"pro\"/\"pro_fast\"/\"lite\"，优先级高于 use_pro_model\n    model_variant: Optional[str] = None  # UI schema variant（如 seedance_1_5_pro）\n    generate_audio: Optional[bool] = None  # 仅 Seedance 1.5 Pro 生效\n    reference_images: List[str] = field(default_factory=list)\n\n\n@dataclass(frozen=True)\nclass UIOption:\n    value: Any\n    label: str\n    description: Optional[str] = None\n    meta: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass(frozen=True)\nclass UIDependency:\n    field: str\n    equals: Any = None\n    not_equals: Any = None\n    exists: bool = False\n\n\n@dataclass\nclass UISchemaField:\n    name: str\n    field_type: str\n    label: str\n    default: Any = None\n    required: bool = False\n    help_text: Optional[str] = None\n    placeholder: Optional[str] = None\n    options: List[UIOption] = field(default_factory=list)\n    min_value: Optional[float] = None\n    max_value: Optional[float] = None\n    step: Optional[float] = None\n    visible_if: List[UIDependency] = field(default_factory=list)\n    enabled_if: List[UIDependency] = field(default_factory=list)\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"type\": self.field_type,\n            \"label\": self.label,\n            \"default\": self.default,\n            \"required\": self.required,\n            \"help_text\": self.help_text,\n            \"placeholder\": self.placeholder,\n            \"options\": [\n                {\n                    \"value\": opt.value,\n                    \"label\": opt.label,\n                    \"description\": opt.description,\n                    \"meta\": opt.meta,\n                }\n                for opt in self.options\n            ],\n            \"min\": self.min_value,\n            \"max\": self.max_value,\n            \"step\": self.step,\n            \"visible_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.visible_if\n            ],\n            \"enabled_if\": [\n                {\n                    \"field\": dep.field,\n                    \"equals\": dep.equals,\n                    \"not_equals\": dep.not_equals,\n                    \"exists\": dep.exists,\n                }\n                for dep in self.enabled_if\n            ],\n            \"extra\": self.extra,\n        }\n\n\n@dataclass\nclass UISchema:\n    provider: str\n    mode: str\n    variant: str\n    fields: List[UISchemaField] = field(default_factory=list)\n    primary_image: Dict[str, Any] = field(default_factory=dict)\n    reference_assets: Dict[str, Any] = field(default_factory=dict)\n    extra: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"provider\": self.provider,\n            \"mode\": self.mode,\n            \"variant\": self.variant,\n            \"fields\": [field.to_dict() for field in self.fields],\n            \"primary_image\": self.primary_image,\n            \"reference_assets\": self.reference_assets,\n            \"extra\": self.extra,\n        }\n\n\ndef _clip_seed(seed: Optional[int]) -> Optional[int]:\n    if seed is None:\n        return None\n    try:\n        iv = int(seed)\n    except Exception:\n        return None\n    if iv < 0:\n        return None\n    if iv > 2147483647:\n        iv = 2147483647\n    return iv\n\n\ndef validate_and_normalize_t2i(p: TextToImageParams) -> Tuple[TextToImageParams, bool, str]:\n    fb = False\n    reasons: List[str] = []\n    # size: 期望形如 WxH，范围 512..4096（兼容 Seedream 4.0 高分辨率）\n    def _valid_size(s: str) -> bool:\n        try:\n            if 'x' not in s:\n                return False\n            w, h = s.split('x', 1)\n            w, h = int(w), int(h)\n            return 512 <= w <= 4096 and 512 <= h <= 4096\n        except Exception:\n            return False\n\n    size = p.size or \"1024x1024\"\n    if not _valid_size(size):\n        fb = True\n        reasons.append(f\"无效尺寸: {p.size or '缺失'}\")\n        size = \"1024x1024\"\n\n    gs = p.guidance_scale\n    if not (1.0 <= gs <= 10.0):\n        fb = True\n        reasons.append(f\"guidance_scale越界: {gs}\")\n        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 2.5\n\n    seed = _clip_seed(p.seed)\n\n    raw_refs: List[str] = []\n    try:\n        for item in p.reference_images or []:\n            if isinstance(item, str) and item:\n                raw_refs.append(item)\n    except Exception:\n        raw_refs = []\n\n    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n    if ref_fb:\n        fb = True\n        reasons.append(ref_reason)\n\n    norm = TextToImageParams(\n        prompt=p.prompt,\n        size=size,\n        guidance_scale=gs,\n        seed=seed,\n        reference_images=refs,\n        sequential_mode=p.sequential_mode,\n        count=p.count,\n    )\n    return norm, fb, \", \".join(reasons) if fb else \"\"\n\n\ndef _normalize_reference_images(refs: List[str], expected_outputs: int = 1) -> Tuple[List[str], bool, str]:\n    \"\"\"裁剪/校验参考图数量，返回 (normalized_refs, fallback, reason)。\n\n    约束源于官方文档《doubao-seedream-4.0 教程》（行 203-204）：\n    - Seedream 4.0 最多 10 张参考图；\n    - （组图扩展）参考图数量 + 生成图数量 ≤ 15。\n    \"\"\"\n    fb = False\n    reasons: List[str] = []\n    refs = [r for r in refs if isinstance(r, str) and r]\n    # 限制：≤10 张\n    if len(refs) > MAX_REFERENCE_IMAGES:\n        fb = True\n        reasons.append(\n            f\"参考图数量超过 {MAX_REFERENCE_IMAGES}，已自动截取前 {MAX_REFERENCE_IMAGES} 张\"\n        )\n        refs = refs[:MAX_REFERENCE_IMAGES]\n    # 组图扩展：参考图 + 生成图 ≤ 15（当前生成图默认为 expected_outputs）\n    if expected_outputs >= 0 and len(refs) + expected_outputs > MAX_REFERENCE_BUNDLE:\n        allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n        if len(refs) > allowed:\n            fb = True\n            reasons.append(\n                f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}，已截取前 {allowed} 张\"\n            )\n            refs = refs[:allowed]\n    return refs, fb, \", \".join(reasons) if fb else \"\"\n\n\ndef validate_and_normalize_i2i(p: ImageToImageParams) -> Tuple[ImageToImageParams, bool, str]:\n    fb = False\n    reasons: List[str] = []\n    gs = p.guidance_scale\n    if not (1.0 <= gs <= 10.0):\n        fb = True\n        reasons.append(f\"guidance_scale越界: {gs}\")\n        gs = min(10.0, max(1.0, gs)) if isinstance(gs, (int, float)) else 5.5\n    seed = _clip_seed(p.seed)\n    raw_refs: List[str] = []\n    try:\n        for item in p.reference_images or []:\n            if isinstance(item, str) and item:\n                raw_refs.append(item)\n    except Exception:\n        raw_refs = []\n\n    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n    if ref_fb:\n        fb = True\n        reasons.append(ref_reason)\n\n    norm = ImageToImageParams(\n        prompt=p.prompt,\n        image=p.image,\n        guidance_scale=gs,\n        seed=seed,\n        reference_images=refs,\n    )\n    return norm, fb, \", \".join(reasons) if fb else \"\"\n\n\ndef validate_and_normalize_video(p: VideoParams) -> Tuple[VideoParams, bool, str, str, str]:\n    \"\"\"返回 (normalized, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n    fb = False\n    reasons: List[str] = []\n\n    variant = (p.model_variant or \"\").strip().lower()\n    is_seedance_1_5 = variant == \"seedance_1_5_pro\"\n\n    rs_default = \"720p\" if is_seedance_1_5 else \"1080p\"\n    rt_default = \"adaptive\" if is_seedance_1_5 else \"16:9\"\n\n    rs = p.resolution_grade or rs_default\n    rt = p.ratio or rt_default\n    if rs not in RES_GRADES:\n        fb = True\n        reasons.append(f\"无效分辨率: {rs}\")\n        rs = rs_default\n    if rt not in RATIOS:\n        fb = True\n        reasons.append(f\"无效比例: {rt}\")\n        rt = rt_default\n\n    # Seedance 1.5 Pro 暂不支持 1080p\n    if is_seedance_1_5 and rs == \"1080p\":\n        fb = True\n        reasons.append(\"1.5 Pro 不支持1080p，已降级到720p\")\n        rs = \"720p\"\n\n    fps = int(p.fps or 24)\n    if fps <= 0:\n        fps = 24\n\n    # duration: 1.5 Pro 支持 -1（自适应），否则要求 4-12；其他模型沿用 3-12\n    raw_duration = p.duration\n    if is_seedance_1_5 and raw_duration == -1:\n        dur = -1\n    else:\n        try:\n            dur = int(raw_duration if raw_duration is not None else (5 if is_seedance_1_5 else 8))\n        except Exception:\n            dur = 5 if is_seedance_1_5 else 8\n\n        dur_min = 4 if is_seedance_1_5 else 3\n        dur_max = 12\n        if dur < dur_min:\n            fb = True\n            reasons.append(f\"时长过短(<{dur_min}s)\")\n            dur = dur_min\n        if dur > dur_max:\n            fb = True\n            reasons.append(f\"时长过长(>{dur_max}s)\")\n            dur = dur_max\n\n    seed = _clip_seed(p.seed)\n    raw_refs: List[str] = []\n    try:\n        for item in p.reference_images or []:\n            if isinstance(item, str) and item:\n                raw_refs.append(item)\n    except Exception:\n        raw_refs = []\n\n    refs, ref_fb, ref_reason = _normalize_reference_images(raw_refs, expected_outputs=1)\n    if ref_fb:\n        fb = True\n        reasons.append(ref_reason)\n\n    norm = VideoParams(\n        prompt=p.prompt,\n        image_path=p.image_path,\n        first_frame_path=p.first_frame_path,\n        last_frame_path=p.last_frame_path,\n        duration=dur,\n        fps=fps,\n        seed=seed,\n        camera_fixed=bool(p.camera_fixed),\n        watermark=bool(p.watermark),\n        resolution_grade=rs,\n        ratio=rt,\n        use_pro_model=bool(p.use_pro_model),\n        model_variant=p.model_variant,\n        generate_audio=p.generate_audio,\n        reference_images=refs,\n    )\n    return norm, fb, \", \".join(reasons) if fb else \"\", rs, rt\n\n\n# ------------------------------\n# UI Schema 定义（供前端驱动参数面板）\n# ------------------------------\n\n\ndef _schema_key(provider: str, mode: str, variant: str) -> str:\n    return f\"{provider}:{mode}:{variant}\"\n\n\ndef _option(value: Any, label: str, *, description: Optional[str] = None, meta: Optional[Dict[str, Any]] = None) -> UIOption:\n    return UIOption(value=value, label=label, description=description, meta=meta or {})\n\n\ndef _dependency(field: str, *, equals: Any = None, not_equals: Any = None, exists: bool = False) -> UIDependency:\n    return UIDependency(field=field, equals=equals, not_equals=not_equals, exists=exists)\n\n\ndef _build_seedream_schema(variant: str) -> UISchema:\n    variant = variant or \"seedream_v4\"\n    fields: List[UISchemaField] = []\n\n    model_options = [\n        _option(\n            \"seedream_v3\",\n            \"Seedream 3.x\",\n            description=\"稳定版本，支持单图/文生图\",\n            meta={\n                \"t2i_model\": \"doubao-seedream-3-0-t2i-250415\",\n                \"i2i_model\": \"doubao-seededit-3-0-i2i-250628\",\n                \"ui_variant\": \"seedream_v3\",\n            },\n        ),\n        _option(\n            \"seedream_v4\",\n            \"Seedream 4.0\",\n            description=\"多参考图融合，最大10张参考图\",\n            meta={\n                \"t2i_model\": \"doubao-seedream-4-0-250828\",\n                \"i2i_model\": \"doubao-seedream-4-0-250828\",\n                \"ui_variant\": \"seedream_v4\",\n            },\n        ),\n        _option(\n            \"seedream_v4_5\",\n            \"Seedream 4.5\",\n            description=\"最新版本，支持组图生成，最大10张参考图\",\n            meta={\n                \"t2i_model\": \"doubao-seedream-4-5-251128\",\n                \"i2i_model\": \"doubao-seedream-4-5-251128\",\n                \"ui_variant\": \"seedream_v4_5\",\n            },\n        ),\n    ]\n    fields.append(\n        UISchemaField(\n            name=\"model_variant\",\n            field_type=\"select\",\n            label=\"模型\",\n            default=variant,\n            help_text=\"切换模型将刷新可选参数与上传限制\",\n            options=model_options,\n            extra={\"reload_on_change\": True, \"schema_family\": \"seedream\"},\n        )\n    )\n\n    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n        # Seedream 4.x 尺寸限制（官方文档）：\n        # 总像素范围：[3,686,400 ~ 16,777,216]\n        # 宽高比范围：[1/16, 16]\n        # 以下尺寸均为各比例的顶格尺寸\n        size_options = [\n            # 1:1\n            _option(\"4096x4096\", \"4096×4096 (1:1)\"),\n            # 16:9 / 9:16\n            _option(\"4096x2304\", \"4096×2304 (16:9)\"),\n            _option(\"2304x4096\", \"2304×4096 (9:16)\"),\n            # 4:3 / 3:4\n            _option(\"4096x3072\", \"4096×3072 (4:3)\"),\n            _option(\"3072x4096\", \"3072×4096 (3:4)\"),\n            # 3:2 / 2:3\n            _option(\"4096x2731\", \"4096×2731 (3:2)\"),\n            _option(\"2731x4096\", \"2731×4096 (2:3)\"),\n            # 21:9 / 9:21\n            _option(\"4096x1755\", \"4096×1755 (21:9)\"),\n            _option(\"1755x4096\", \"1755×4096 (9:21)\"),\n        ]\n        default_size = \"4096x4096\"\n    else:\n        # Seedream 3.x：按常见比例提供范围内的最大像素组合（宽高在 512–2048）\n        size_options = [\n            _option(\"2048x2048\", \"2048×2048 (1:1)\"),\n            _option(\"2048x1536\", \"2048×1536 (4:3)\"),\n            _option(\"1536x2048\", \"1536×2048 (3:4)\"),\n            _option(\"2048x1152\", \"2048×1152 (16:9)\"),\n            _option(\"1152x2048\", \"1152×2048 (9:16)\"),\n            _option(\"1920x1280\", \"1920×1280 (3:2)\"),\n            _option(\"1280x1920\", \"1280×1920 (2:3)\"),\n            _option(\"1792x768\",  \"1792×768 (21:9)\"),\n        ]\n        default_size = \"2048x2048\"\n\n    fields.append(\n        UISchemaField(\n            name=\"size\",\n            field_type=\"select\",\n            label=\"分辨率\",\n            default=default_size,\n            options=size_options,\n            help_text=\"仅提供官方支持的常用分辨率\",\n        )\n    )\n\n    fields.append(\n        UISchemaField(\n            name=\"seed\",\n            field_type=\"text\",  # 使用 QLineEdit 替代 QSpinBox，去掉上下按钮\n            label=\"Seed\",\n            default=\"-1\",\n            help_text=\"-1 表示随机；指定整数可复现结果\",\n            extra={\"is_integer\": True, \"min_value\": -1, \"max_value\": 4294967295},  # 2^32-1\n        )\n    )\n\n    # 新增：组图模式开关（Seedream 4.0 和 4.5 都支持）\n    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n        fields.append(\n            UISchemaField(\n                name=\"sequential_mode\",\n                field_type=\"toggle\",\n                label=\"组图\",\n                default=False,\n                help_text=\"开启后单次请求返回多张风格一致的图；关闭时逐张调用\",\n            )\n        )\n\n    # 修改：count 控件的帮助文本\n    count_help = \"一次最多生成 10 张\"\n    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n        count_help = \"普通模式最多 10 张；组图模式最多 15 张（参考图 + 输出 ≤ 15）\"\n\n    fields.append(\n        UISchemaField(\n            name=\"count\",\n            field_type=\"text\",  # 使用 QLineEdit 替代 QSpinBox，去掉上下按钮\n            label=\"生成数量\",\n            default=\"4\",  # 默认4张\n            help_text=count_help,\n            extra={\"is_integer\": True, \"min_value\": 1, \"max_value\": 15},  # 组图最大15，普通模式由动态逻辑限制为10\n        )\n    )\n\n    # 隐藏\"自动压缩参考图\"参数，后端自动启用\n    # fields.append(\n    #     UISchemaField(\n    #         name=\"auto_compress_references\",\n    #         field_type=\"toggle\",\n    #         label=\"自动压缩参考图\",\n    #         default=True,\n    #         help_text=\"上传时自动压缩到 2K 内，避免超出 API 限制\",\n    #     )\n    # )\n\n    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n        reference_enabled = True\n        ref_max_count = MAX_REFERENCE_IMAGES\n        ref_bundle_limit = MAX_REFERENCE_BUNDLE\n        ref_help = \"最多 14 张参考图，参考图 + 输出数量 ≤ 15\"\n        if variant == \"seedream_v4_5\":\n            ref_help = \"默认最多 14 张参考图；组图模式下参考图 + 输出数量 ≤ 15\"\n        multi_reference = True\n    else:\n        # seedream_v3: 保留旧体验（单张参考图，面板隐藏）\n        reference_enabled = False\n        ref_max_count = 1\n        ref_bundle_limit = 1\n        ref_help = \"最多 1 张参考图\"\n        multi_reference = False\n\n    reference_assets = {\n        \"enabled\": reference_enabled,\n        \"max_count\": ref_max_count,\n        \"bundle_limit\": ref_bundle_limit,\n        \"accept\": [\"image/png\", \"image/jpeg\"],\n        \"auto_compress_field\": \"auto_compress_references\",\n        \"help_text\": ref_help,\n        \"orderable\": True,\n    }\n\n    primary_image = {\n        \"enabled\": True,\n        \"label\": \"基础图 (可选)\",\n        \"placeholder\": \"拖拽或点击上传一张基础图，留空则进行文生图\",\n        \"accept\": [\"image/png\", \"image/jpeg\"],\n        \"max_size_mb\": 10,\n    }\n\n    capabilities = {\n        \"multi_reference\": multi_reference,\n        \"supports_reference\": True,\n        \"single_reference\": not multi_reference,\n    }\n\n    # 构建第一行布局 - 自适应设计，AdjustToContents + stretch 分配\n    first_row = [\n        # 模型名较长，Expanding + AdjustToContents\n        {\"name\": \"model_variant\", \"stretch\": 3, \"label_width\": 35, \"min_width\": 100,\n         \"size_policy\": \"expanding\", \"adjust_to_contents\": True},\n        # 尺寸选项较长(1024x1024)，也使用 Expanding\n        {\"name\": \"size\", \"stretch\": 3, \"label_width\": 50, \"min_width\": 100,\n         \"size_policy\": \"expanding\", \"adjust_to_contents\": True},\n        # Seed 和数量：Preferred + AdjustToContents\n        {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 35, \"min_width\": 60,\n         \"size_policy\": \"preferred\"},\n        {\"name\": \"count\", \"stretch\": 1, \"label_width\": 55, \"min_width\": 50,\n         \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n        {\n            \"name\": \"auto_compress_references\",\n            \"stretch\": 0,\n            \"label_width\": 0,\n        },\n    ]\n\n    # 如果是 Seedream 4.0/4.5，在 seed 和 count 之间插入 sequential_mode\n    if variant in [\"seedream_v4\", \"seedream_v4_5\"]:\n        first_row.insert(\n            3,  # 在 seed 后、count 前插入\n            {\"name\": \"sequential_mode\", \"stretch\": 0, \"label_width\": 45, \"min_width\": 45,\n             \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n        )\n\n    extra = {\n        \"supports_reference\": True,  # 3.x模式也支持参考图显示，只是UI面板隐藏\n        \"layout\": {\n            \"type\": \"rows\",\n            \"row_spacing\": 6,\n            \"column_spacing\": 8,  # 与视频模式一致\n            \"rows\": [first_row],\n        },\n        \"capabilities\": capabilities,\n    }\n\n    return UISchema(\n        provider=\"seedream\",\n        mode=\"image\",\n        variant=variant,\n        fields=fields,\n        primary_image=primary_image,\n        reference_assets=reference_assets,\n        extra=extra,\n    )\n\n\ndef _build_seedance_schema(variant: str) -> UISchema:\n    variant = variant or \"seedance_pro\"\n    model_options = [\n        _option(\n            \"seedance_1_5_pro\",\n            \"Seedance 1.5 Pro (有声)\",\n            description=\"最新版本，可生成音画同步音频（默认开启）\",\n            meta={\"use_pro_model\": True, \"model_type\": \"pro\", \"ui_variant\": \"seedance_1_5_pro\"},\n        ),\n        _option(\n            \"seedance_pro\",\n            \"Seedance Pro\",\n            description=\"高质量输出，适合正式素材\",\n            meta={\"use_pro_model\": True, \"model_type\": \"pro\", \"ui_variant\": \"seedance_pro\"},\n        ),\n        _option(\n            \"seedance_pro_fast\",\n            \"Seedance Pro-fast\",\n            description=\"Pro级质量+更快速度（不支持首尾帧）\",\n            meta={\"use_pro_model\": True, \"model_type\": \"pro_fast\", \"ui_variant\": \"seedance_pro_fast\"},\n        ),\n        _option(\n            \"seedance_lite\",\n            \"Seedance Lite\",\n            description=\"快速输出，适合草稿\",\n            meta={\"use_pro_model\": False, \"model_type\": \"lite\", \"ui_variant\": \"seedance_lite\"},\n        ),\n    ]\n\n    is_seedance_1_5 = variant == \"seedance_1_5_pro\"\n    is_seedance_lite = variant == \"seedance_lite\"\n\n    resolution_default = \"720p\" if (is_seedance_1_5 or is_seedance_lite) else \"1080p\"\n    resolution_options = [\n        _option(\"480p\", \"480p\"),\n        _option(\"720p\", \"720p\"),\n    ]\n    # 1.5 Pro 暂不支持 1080p（官方文档）\n    if not is_seedance_1_5:\n        resolution_options.append(_option(\"1080p\", \"1080p\"))\n\n    ratio_options = [\n        _option(\"16:9\", \"16:9\"),\n        _option(\"9:16\", \"9:16\"),\n        _option(\"4:3\", \"4:3\"),\n        _option(\"1:1\", \"1:1\"),\n        _option(\"3:4\", \"3:4\"),\n        _option(\"21:9\", \"21:9\"),\n    ]\n    ratio_default = \"16:9\"\n    if is_seedance_1_5:\n        ratio_options = [_option(\"adaptive\", \"自适应\")] + ratio_options\n        ratio_default = \"adaptive\"\n\n    duration_default: int = 5\n    duration_options: List[UIOption] = []\n    duration_help = \"范围 3-12 秒，超过范围将自动回退\"\n    if is_seedance_1_5:\n        duration_help = \"Seedance 1.5 Pro：支持 4-12 秒整数，或自适应（-1）\"\n        duration_options = [_option(-1, \"自适应\")] + [_option(sec, f\"{sec} 秒\") for sec in range(4, 13)]\n    else:\n        duration_options = [_option(sec, f\"{sec} 秒\") for sec in range(3, 13)]\n\n    fields: List[UISchemaField] = [\n        UISchemaField(\n            name=\"model_variant\",\n            field_type=\"select\",\n            label=\"模型\",\n            default=variant,\n            help_text=\"Pro 输出质量更高，Lite 更快速\",\n            options=model_options,\n            extra={\"reload_on_change\": True, \"schema_family\": \"seedance\"},\n        ),\n        UISchemaField(\n            name=\"resolution_grade\",\n            field_type=\"select\",\n            label=\"分辨率\",\n            default=resolution_default,\n            options=resolution_options,\n            help_text=\"官方推荐 480p/720p/1080p 三档（1.5 Pro 暂不支持 1080p）\",\n        ),\n        UISchemaField(\n            name=\"ratio\",\n            field_type=\"select\",\n            label=\"比例\",\n            default=ratio_default,\n            options=ratio_options,\n            help_text=\"生成时自动拼接 --rs/--rt 参数（1.5 Pro 支持自适应）\",\n        ),\n        UISchemaField(\n            name=\"duration\",\n            field_type=\"select\",\n            label=\"时长 (秒)\",\n            default=duration_default,\n            options=duration_options,\n            help_text=duration_help,\n        ),\n        UISchemaField(\n            name=\"seed\",\n            field_type=\"text\",  # 使用 QLineEdit 替代 QSpinBox，去掉上下按钮\n            label=\"Seed\",\n            default=\"-1\",\n            help_text=\"-1 表示随机；指定整数可复现\",\n            extra={\"is_integer\": True, \"min_value\": -1, \"max_value\": 4294967295},  # 2^32-1\n        ),\n        UISchemaField(\n            name=\"camera_fixed\",\n            field_type=\"toggle\",\n            label=\"固定镜头\",\n            default=True,\n            help_text=\"开启后相机保持固定，适合稳态镜头\",\n        ),\n    ]\n\n    reference_assets = {\n        \"enabled\": False,\n        \"max_count\": 0,\n        \"bundle_limit\": 0,\n        \"accept\": [],\n        \"auto_compress_field\": None,\n        \"help_text\": \"\",\n        \"orderable\": False,\n    }\n\n    primary_frames = {\n        \"enabled\": True,\n        \"slots\": [\n            {\n                \"name\": \"first_frame\",\n                \"label\": \"首帧 (可选)\",\n                \"help_text\": \"提供首帧可提升人物一致性\",\n                \"accept\": [\"image/png\", \"image/jpeg\"],\n            },\n            {\n                \"name\": \"last_frame\",\n                \"label\": \"尾帧 (可选)\",\n                \"help_text\": \"提供尾帧可控制结尾画面\",\n                \"accept\": [\"image/png\", \"image/jpeg\"],\n            },\n        ],\n        \"max_size_mb\": 10,\n    }\n\n    capabilities = {\n        \"multi_reference\": False,\n        \"supports_reference\": False,\n    }\n\n    # Pro-fast 也属于 Pro 系列，但不支持首尾帧\n    is_pro_series = variant in (\"seedance_1_5_pro\", \"seedance_pro\", \"seedance_pro_fast\")\n    extra = {\n        \"use_pro_model\": is_pro_series,\n        \"model_type\": \"pro_fast\"\n        if variant == \"seedance_pro_fast\"\n        else (\"lite\" if variant == \"seedance_lite\" else \"pro\"),\n        \"supports_first_last_frame\": variant != \"seedance_pro_fast\",  # Pro-fast 不支持首尾帧\n        # 交互语义：首尾帧开关仅在 Lite 下用于切换“首尾帧 vs 参考图”\n        \"show_first_last_toggle\": bool(is_seedance_lite),\n        # 交互语义：生成音频开关仅 1.5 Pro 显示\n        \"show_generate_audio_toggle\": bool(is_seedance_1_5),\n        \"layout\": {\n            \"type\": \"rows\",\n            \"row_spacing\": 6,\n            \"column_spacing\": 8,\n            \"rows\": [\n                [\n                    # 模型名较长，Expanding + AdjustToContents，吃掉剩余空间\n                    {\"name\": \"model_variant\", \"stretch\": 5, \"label_width\": 35, \"min_width\": 120,\n                     \"size_policy\": \"expanding\", \"adjust_to_contents\": True},\n                    # 短文本字段：Preferred + AdjustToContents，刚好包裹内容\n                    {\"name\": \"resolution_grade\", \"stretch\": 1, \"label_width\": 45, \"min_width\": 55,\n                     \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n                    {\"name\": \"ratio\", \"stretch\": 1, \"label_width\": 35, \"min_width\": 45,\n                     \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n                    {\"name\": \"duration\", \"stretch\": 1, \"label_width\": 55, \"min_width\": 50,\n                     \"size_policy\": \"preferred\", \"adjust_to_contents\": True},\n                    {\"name\": \"seed\", \"stretch\": 1, \"label_width\": 35, \"min_width\": 60,\n                     \"size_policy\": \"preferred\"},\n                    {\"name\": \"camera_fixed\", \"stretch\": 0, \"label_width\": 55, \"min_width\": 25},\n                ],\n            ],\n        },\n        \"capabilities\": capabilities,\n    }\n\n    return UISchema(\n        provider=\"seedance\",\n        mode=\"video\",\n        variant=variant,\n        fields=fields,\n        primary_image=primary_frames,\n        reference_assets=reference_assets,\n        extra=extra,\n    )\n\n\n_UI_SCHEMAS: Dict[str, UISchema] = {\n    _schema_key(\"seedream\", \"image\", \"seedream_v3\"): _build_seedream_schema(\"seedream_v3\"),\n    _schema_key(\"seedream\", \"image\", \"seedream_v4\"): _build_seedream_schema(\"seedream_v4\"),\n    _schema_key(\"seedream\", \"image\", \"seedream_v4_5\"): _build_seedream_schema(\"seedream_v4_5\"),\n    _schema_key(\"seedance\", \"video\", \"seedance_1_5_pro\"): _build_seedance_schema(\"seedance_1_5_pro\"),\n    _schema_key(\"seedance\", \"video\", \"seedance_pro\"): _build_seedance_schema(\"seedance_pro\"),\n    _schema_key(\"seedance\", \"video\", \"seedance_pro_fast\"): _build_seedance_schema(\"seedance_pro_fast\"),\n    _schema_key(\"seedance\", \"video\", \"seedance_lite\"): _build_seedance_schema(\"seedance_lite\"),\n}\n\n\n_DEFAULT_VARIANTS: Dict[Tuple[str, str], str] = {\n    (\"seedream\", \"image\"): \"seedream_v4\",\n    (\"seedance\", \"video\"): \"seedance_pro\",\n}\n\n\ndef get_ui_schema(provider: str, mode: str, variant: Optional[str] = None, *, as_dict: bool = False) -> UISchema:\n    \"\"\"返回 UI Schema（深拷贝，避免调用侧修改真源）。\"\"\"\n\n    key_variant = variant or _DEFAULT_VARIANTS.get((provider, mode))\n    if not key_variant:\n        raise ValueError(f\"未定义默认 UI Schema: provider={provider} mode={mode}\")\n\n    key = _schema_key(provider, mode, key_variant)\n    if key not in _UI_SCHEMAS:\n        raise ValueError(f\"未找到 UI Schema: provider={provider} mode={mode} variant={key_variant}\")\n\n    schema = copy.deepcopy(_UI_SCHEMAS[key])\n    if as_dict:\n        return schema.to_dict()  # type: ignore[return-value]\n    return schema\n\n\ndef list_ui_schema_variants(provider: str, mode: str) -> List[str]:\n    prefix = f\"{provider}:{mode}:\"\n    return [key.split(\":\", 2)[-1] for key in _UI_SCHEMAS.keys() if key.startswith(prefix)]\n","numLines":866,"startLine":1,"totalLines":866}}}
{"parentUuid":"e2698e5b-5d2d-4571-888c-b5d058b05122","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XyzVgN7NEGSctCVEo2wNXw","type":"message","role":"assistant","content":[{"type":"text","text":"现在我已经全面理解了当前架构。让我查看一下现有的模型配置来完善理解："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15981,"cache_read_input_tokens":89218,"cache_creation":{"ephemeral_5m_input_tokens":15981,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c651f381-7f38-4658-abe9-fcdb7a876f33","timestamp":"2026-01-05T11:54:08.311Z"}
{"parentUuid":"c651f381-7f38-4658-abe9-fcdb7a876f33","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XyzVgN7NEGSctCVEo2wNXw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EvD7nwrcsD43NWdJKTkku8","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15981,"cache_read_input_tokens":89218,"cache_creation":{"ephemeral_5m_input_tokens":15981,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"a40a45b9-1ef2-4ce9-9b4c-8963309d5179","timestamp":"2026-01-05T11:54:09.732Z"}
{"parentUuid":"a40a45b9-1ef2-4ce9-9b4c-8963309d5179","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XyzVgN7NEGSctCVEo2wNXw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TwwJYCbgjxgS2UBwkwaxVx","name":"Grep","input":{"pattern":"class.*Provider","path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15981,"cache_read_input_tokens":89218,"cache_creation":{"ephemeral_5m_input_tokens":15981,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"159d97e7-b11c-4409-a125-7741ef5301bf","timestamp":"2026-01-05T11:54:10.953Z"}
{"parentUuid":"159d97e7-b11c-4409-a125-7741ef5301bf","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01XyzVgN7NEGSctCVEo2wNXw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018gwWzcuuCz7MZTs71zTwGN","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15981,"cache_read_input_tokens":89218,"cache_creation":{"ephemeral_5m_input_tokens":15981,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"7228619c-1ef5-445a-9316-9a8e36c92b19","timestamp":"2026-01-05T11:54:11.441Z"}
{"parentUuid":"7228619c-1ef5-445a-9316-9a8e36c92b19","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EvD7nwrcsD43NWdJKTkku8","type":"tool_result","content":"     1→# Seedance配置管理\n     2→# 定义模型、状态和配置常量\n     3→\n     4→from enum import Enum\n     5→from typing import Dict, List\n     6→\n     7→\n     8→class SeedanceModels(Enum):\n     9→    \"\"\"Seedance模型枚举\"\"\"\n    10→    PRO_1_5 = \"doubao-seedance-1-5-pro-251215\"\n    11→    PRO = \"doubao-seedance-1-0-pro-250528\"\n    12→    PRO_FAST = \"doubao-seedance-1-0-pro-fast-251015\"\n    13→    LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    14→    LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n    15→\n    16→\n    17→class TaskStatus(Enum):\n    18→    \"\"\"任务状态枚举\"\"\"\n    19→    PENDING = \"pending\"\n    20→    QUEUED = \"queued\"\n    21→    PROCESSING = \"processing\"\n    22→    RUNNING = \"running\"\n    23→    SUCCEEDED = \"succeeded\"\n    24→    FAILED = \"failed\"\n    25→    CANCELLED = \"cancelled\"\n    26→    EXPIRED = \"expired\"\n    27→    \n    28→    @classmethod\n    29→    def is_terminal(cls, status: str) -> bool:\n    30→        \"\"\"判断是否为终态\"\"\"\n    31→        return status in [\n    32→            cls.SUCCEEDED.value,\n    33→            cls.FAILED.value,\n    34→            cls.CANCELLED.value,\n    35→            cls.EXPIRED.value,\n    36→        ]\n    37→    \n    38→    @classmethod\n    39→    def is_active(cls, status: str) -> bool:\n    40→        \"\"\"判断是否为活跃状态\"\"\"\n    41→        return status in [\n    42→            cls.PENDING.value,\n    43→            cls.QUEUED.value,\n    44→            cls.PROCESSING.value,\n    45→            cls.RUNNING.value,\n    46→        ]\n    47→\n    48→\n    49→class SeedanceConfig:\n    50→    \"\"\"Seedance配置管理\"\"\"\n    51→    \n    52→    # API端点\n    53→    ENDPOINTS = {\n    54→        \"create_task\": \"/contents/generations/tasks\",\n    55→        \"query_task\": \"/contents/generations/tasks/{task_id}\",\n    56→        # 根据实测，取消为对任务资源本身执行DELETE，而非 /cancel 动作\n    57→        \"cancel_task\": \"/contents/generations/tasks/{task_id}\",\n    58→        \"list_tasks\": \"/contents/generations/tasks\"\n    59→    }\n    60→    \n    61→    # 轮询配置\n    62→    POLLING = {\n    63→        \"max_wait_time\": 600,  # 10分钟\n    64→        \"intervals\": [2, 3, 5, 8, 10],  # 递增间隔\n    65→        \"max_retries\": 3\n    66→    }\n    67→    \n    68→    # 模型价格（元/百万token）\n    69→    MODEL_PRICING = {\n    70→        SeedanceModels.PRO.value: 15,\n    71→        SeedanceModels.LITE_T2V.value: 10,\n    72→        SeedanceModels.LITE_I2V.value: 10\n    73→    }\n    74→    \n    75→    # 默认参数\n    76→    DEFAULTS = {\n    77→        \"duration\": 8,\n    78→        \"fps\": 24,\n    79→        \"width\": 1920,\n    80→        \"height\": 1080,\n    81→        \"model_type\": \"pro\"\n    82→    }\n    83→    \n    84→    # 支持的分辨率\n    85→    RESOLUTIONS = {\n    86→        \"480p\": {\"width\": 854, \"height\": 480},\n    87→        \"720p\": {\"width\": 1280, \"height\": 720},\n    88→        \"1080p\": {\"width\": 1920, \"height\": 1080}\n    89→    }\n    90→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"755ed932-56ba-4821-9128-4df900b0ee2b","timestamp":"2026-01-05T11:54:11.490Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py","content":"# Seedance配置管理\n# 定义模型、状态和配置常量\n\nfrom enum import Enum\nfrom typing import Dict, List\n\n\nclass SeedanceModels(Enum):\n    \"\"\"Seedance模型枚举\"\"\"\n    PRO_1_5 = \"doubao-seedance-1-5-pro-251215\"\n    PRO = \"doubao-seedance-1-0-pro-250528\"\n    PRO_FAST = \"doubao-seedance-1-0-pro-fast-251015\"\n    LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n\n\nclass TaskStatus(Enum):\n    \"\"\"任务状态枚举\"\"\"\n    PENDING = \"pending\"\n    QUEUED = \"queued\"\n    PROCESSING = \"processing\"\n    RUNNING = \"running\"\n    SUCCEEDED = \"succeeded\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    EXPIRED = \"expired\"\n    \n    @classmethod\n    def is_terminal(cls, status: str) -> bool:\n        \"\"\"判断是否为终态\"\"\"\n        return status in [\n            cls.SUCCEEDED.value,\n            cls.FAILED.value,\n            cls.CANCELLED.value,\n            cls.EXPIRED.value,\n        ]\n    \n    @classmethod\n    def is_active(cls, status: str) -> bool:\n        \"\"\"判断是否为活跃状态\"\"\"\n        return status in [\n            cls.PENDING.value,\n            cls.QUEUED.value,\n            cls.PROCESSING.value,\n            cls.RUNNING.value,\n        ]\n\n\nclass SeedanceConfig:\n    \"\"\"Seedance配置管理\"\"\"\n    \n    # API端点\n    ENDPOINTS = {\n        \"create_task\": \"/contents/generations/tasks\",\n        \"query_task\": \"/contents/generations/tasks/{task_id}\",\n        # 根据实测，取消为对任务资源本身执行DELETE，而非 /cancel 动作\n        \"cancel_task\": \"/contents/generations/tasks/{task_id}\",\n        \"list_tasks\": \"/contents/generations/tasks\"\n    }\n    \n    # 轮询配置\n    POLLING = {\n        \"max_wait_time\": 600,  # 10分钟\n        \"intervals\": [2, 3, 5, 8, 10],  # 递增间隔\n        \"max_retries\": 3\n    }\n    \n    # 模型价格（元/百万token）\n    MODEL_PRICING = {\n        SeedanceModels.PRO.value: 15,\n        SeedanceModels.LITE_T2V.value: 10,\n        SeedanceModels.LITE_I2V.value: 10\n    }\n    \n    # 默认参数\n    DEFAULTS = {\n        \"duration\": 8,\n        \"fps\": 24,\n        \"width\": 1920,\n        \"height\": 1080,\n        \"model_type\": \"pro\"\n    }\n    \n    # 支持的分辨率\n    RESOLUTIONS = {\n        \"480p\": {\"width\": 854, \"height\": 480},\n        \"720p\": {\"width\": 1280, \"height\": 720},\n        \"1080p\": {\"width\": 1920, \"height\": 1080}\n    }\n","numLines":90,"startLine":1,"totalLines":90}}}
{"parentUuid":"755ed932-56ba-4821-9128-4df900b0ee2b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TwwJYCbgjxgS2UBwkwaxVx","type":"tool_result","content":"Found 4 files\nmodules/provider/volc.py\nmodules/provider/volc_v4_5.py\nmodules/provider/volc_v4.py\nmodules/provider/base.py"}]},"uuid":"032518aa-2fdf-43e3-ae83-74fbde188e39","timestamp":"2026-01-05T11:54:11.507Z","toolUseResult":{"mode":"files_with_matches","filenames":["modules/provider/volc.py","modules/provider/volc_v4_5.py","modules/provider/volc_v4.py","modules/provider/base.py"],"numFiles":4}}
{"parentUuid":"032518aa-2fdf-43e3-ae83-74fbde188e39","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018gwWzcuuCz7MZTs71zTwGN","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→Provider 工厂（最小实现）\n     5→\"\"\"\n     6→import os\n     7→from typing import Optional\n     8→from .base import BaseProvider\n     9→from .volc import VolcProvider\n    10→from .volc_v4 import VolcV4Provider\n    11→from .volc_v4_5 import VolcV4_5Provider\n    12→\n    13→\n    14→def get_default_provider(provider_name: Optional[str] = None) -> BaseProvider:\n    15→    raw_name = provider_name or os.environ.get(\"GEMENG_PROVIDER\", \"volc_v3\")\n    16→    try:\n    17→        name = str(raw_name).strip().lower()\n    18→    except Exception:\n    19→        name = \"volc_v3\"\n    20→\n    21→    if name in {\"volc_v4\", \"volcengine_v4\", \"seedream_v4\", \"seedream4\", \"volc4\"}:\n    22→        return VolcV4Provider()\n    23→    elif name in {\"volc_v4_5\", \"volcengine_v4_5\", \"seedream_v4_5\", \"seedream4_5\", \"volc4_5\"}:\n    24→        return VolcV4_5Provider()\n    25→    # 默认与历史兼容，返回 v3 实现\n    26→    return VolcProvider()\n    27→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c4fe19b6-a76a-4cbd-a718-5af7d38ba062","timestamp":"2026-01-05T11:54:11.490Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/factory.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nProvider 工厂（最小实现）\n\"\"\"\nimport os\nfrom typing import Optional\nfrom .base import BaseProvider\nfrom .volc import VolcProvider\nfrom .volc_v4 import VolcV4Provider\nfrom .volc_v4_5 import VolcV4_5Provider\n\n\ndef get_default_provider(provider_name: Optional[str] = None) -> BaseProvider:\n    raw_name = provider_name or os.environ.get(\"GEMENG_PROVIDER\", \"volc_v3\")\n    try:\n        name = str(raw_name).strip().lower()\n    except Exception:\n        name = \"volc_v3\"\n\n    if name in {\"volc_v4\", \"volcengine_v4\", \"seedream_v4\", \"seedream4\", \"volc4\"}:\n        return VolcV4Provider()\n    elif name in {\"volc_v4_5\", \"volcengine_v4_5\", \"seedream_v4_5\", \"seedream4_5\", \"volc4_5\"}:\n        return VolcV4_5Provider()\n    # 默认与历史兼容，返回 v3 实现\n    return VolcProvider()\n","numLines":27,"startLine":1,"totalLines":27}}}
{"parentUuid":"c4fe19b6-a76a-4cbd-a718-5af7d38ba062","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GjV4MsbJJSGdZSeAaAatAW","type":"message","role":"assistant","content":[{"type":"text","text":"完美！现在我已经全面理解了项目的架构。让我创建一个完整的多模型提供商架构设计方案。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2490,"cache_read_input_tokens":105199,"cache_creation":{"ephemeral_5m_input_tokens":2490,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"85f0c0ec-9109-4328-ab6a-e4b050aa0fe0","timestamp":"2026-01-05T11:54:18.186Z"}
{"parentUuid":"85f0c0ec-9109-4328-ab6a-e4b050aa0fe0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GjV4MsbJJSGdZSeAaAatAW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PrhLdHRBs1wcL2Ep12H1Z5","name":"Write","input":{"file_path":"/Users/yunchang/.claude/plans/inherited-napping-neumann-agent-a8dfeb5.md","content":"# 多模型提供商架构设计方案\n\n## 执行摘要\n\n基于对现有代码库的深入分析，本方案提供一个**分阶段、向后兼容、低侵入性**的多模型提供商接入架构。核心目标：\n\n1. **降低接入难度**：新提供商接入从当前 500+ 行代码降至 ~100 行\n2. **统一抽象层**：Provider 负责完整的 HTTP 调用，不只是参数映射\n3. **灵活配置**：支持多厂商 API Key、模型列表、别名映射\n4. **数据库改进**：添加 vendor 字段，标准化模型标识体系\n5. **保持兼容**：现有功能零破坏，分阶段迁移\n\n---\n\n## 1. 当前架构分析\n\n### 1.1 现状诊断\n\n**优势**：\n- ✅ **服务层分离良好**：`ImageService`/`VideoService` 不依赖具体实现\n- ✅ **Provider 基础已建立**：`BaseProvider` + `VolcProvider/V4/V4_5` 三版本\n- ✅ **工厂模式注入**：`get_default_provider()` 支持环境变量切换\n- ✅ **数据库灵活**：`parameters` 字段为 JSON，可存储任意厂商参数\n\n**问题**：\n- ❌ **Provider 职责不完整**：只做参数映射，HTTP 调用仍在 `Client` 内\n- ❌ **强耦合点**：\n  - 模型 ID 硬编码（`doubao-*` 前缀）\n  - API 端点路径绑定火山引擎\n  - Client 内大量 if/else 分支处理不同 Provider\n- ❌ **缺少 vendor 字段**：数据库无法区分模型来源\n- ❌ **配置分散**：API Key 在 `config/sources/api_config.py`，模型枚举在各模块\n\n### 1.2 关键文件清单\n\n| 文件 | 当前职责 | 改造优先级 |\n|------|---------|-----------|\n| `modules/provider/base.py` | Provider 接口定义 | 🔴 高 |\n| `modules/provider/factory.py` | Provider 工厂 | 🔴 高 |\n| `modules/seedream/client.py` | 火山引擎图像 API | 🟡 中 |\n| `modules/seedream/manager.py` | 图像生成业务逻辑 | 🟡 中 |\n| `services/image_service.py` | 服务层封装 | 🟢 低 |\n| `modules/repository/sqlite_handler.py` | 数据库 Schema | 🔴 高 |\n| `config/sources/api_config.py` | API 密钥管理 | 🟡 中 |\n\n---\n\n## 2. 目标架构设计\n\n### 2.1 目录结构重构\n\n```\nmodules/\n├── providers/                    # 统一改名（复数形式）\n│   ├── __init__.py\n│   ├── base.py                  # 基础抽象类（改进）\n│   ├── registry.py              # 提供商注册表（新增）\n│   ├── factory.py               # 工厂模式\n│   ├── schema.py                # 参数 Schema（保持）\n│   │\n│   ├── volcengine/              # 火山引擎提供商（独立模块）\n│   │   ├── __init__.py\n│   │   ├── provider.py          # 继承 BaseProvider\n│   │   ├── models.py            # 模型枚举\n│   │   └── config.py            # 端点/默认值\n│   │\n│   ├── openai/                  # OpenAI 提供商（示例）\n│   │   ├── __init__.py\n│   │   ├── provider.py\n│   │   ├── models.py\n│   │   └── config.py\n│   │\n│   ├── stability/               # Stability AI 提供商（示例）\n│   │   ├── __init__.py\n│   │   ├── provider.py\n│   │   ├── models.py\n│   │   └── config.py\n│   │\n│   └── midjourney/              # Midjourney 提供商（示例）\n│       ├── __init__.py\n│       ├── provider.py\n│       └── models.py\n│\nconfig/\n└── sources/\n    ├── api_config.py            # 多厂商 API Key 管理（增强）\n    └── models_config.py         # 模型列表与别名映射（新增）\n```\n\n### 2.2 改进的 Provider 抽象\n\n**核心改变**：Provider 负责完整 HTTP 调用，不再只是参数映射。\n\n```python\n# modules/providers/base.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom dataclasses import dataclass\n\n@dataclass\nclass ProviderConfig:\n    \"\"\"提供商配置\"\"\"\n    name: str                    # 提供商名称（如 \"volcengine\"）\n    api_key: str                 # API 密钥\n    base_url: str               # API 基础 URL\n    timeout: int = 60           # 请求超时\n    max_retries: int = 3        # 最大重试次数\n    extra: Dict[str, Any] = None  # 扩展配置\n\n@dataclass\nclass GenerationResult:\n    \"\"\"统一的生成结果格式\"\"\"\n    success: bool\n    images: List[Dict[str, Any]] = None  # 图像 URL 列表\n    videos: List[Dict[str, Any]] = None  # 视频 URL 列表\n    task_id: Optional[str] = None\n    model: Optional[str] = None\n    vendor: Optional[str] = None\n    parameters: Dict[str, Any] = None    # 实际使用的参数\n    metadata: Dict[str, Any] = None      # 厂商特定元数据\n    error: Optional[str] = None\n\nclass BaseProvider(ABC):\n    \"\"\"提供商基类 - 完整的 HTTP 调用封装\"\"\"\n    \n    def __init__(self, config: ProviderConfig):\n        self.config = config\n        self.name = config.name\n    \n    # ========== 图像生成接口 ==========\n    @abstractmethod\n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n        model: Optional[str] = None,\n        **kwargs\n    ) -> GenerationResult:\n        \"\"\"文生图（完整 HTTP 调用）\"\"\"\n        pass\n    \n    @abstractmethod\n    def image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: Optional[int] = None,\n        model: Optional[str] = None,\n        **kwargs\n    ) -> GenerationResult:\n        \"\"\"图生图（完整 HTTP 调用）\"\"\"\n        pass\n    \n    # ========== 视频生成接口 ==========\n    @abstractmethod\n    def text_to_video(\n        self,\n        prompt: str,\n        duration: int = 5,\n        fps: int = 24,\n        resolution: str = \"720p\",\n        ratio: str = \"16:9\",\n        model: Optional[str] = None,\n        **kwargs\n    ) -> GenerationResult:\n        \"\"\"文生视频（完整 HTTP 调用）\"\"\"\n        pass\n    \n    @abstractmethod\n    def image_to_video(\n        self,\n        prompt: str,\n        image_path: str,\n        duration: int = 5,\n        model: Optional[str] = None,\n        **kwargs\n    ) -> GenerationResult:\n        \"\"\"图生视频（完整 HTTP 调用）\"\"\"\n        pass\n    \n    # ========== 能力查询接口 ==========\n    @abstractmethod\n    def get_supported_models(self) -> List[str]:\n        \"\"\"返回支持的模型 ID 列表\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_model_capabilities(self, model: str) -> Dict[str, Any]:\n        \"\"\"返回模型能力描述\"\"\"\n        pass\n    \n    @abstractmethod\n    def validate_parameters(\n        self,\n        operation: str,  # \"t2i\", \"i2i\", \"t2v\", \"i2v\"\n        params: Dict[str, Any]\n    ) -> Tuple[bool, Optional[str]]:\n        \"\"\"参数校验，返回 (is_valid, error_message)\"\"\"\n        pass\n```\n\n### 2.3 提供商注册表\n\n```python\n# modules/providers/registry.py\nfrom typing import Dict, Type, Optional\nfrom .base import BaseProvider, ProviderConfig\n\nclass ProviderRegistry:\n    \"\"\"提供商注册表（单例模式）\"\"\"\n    \n    _instance = None\n    _providers: Dict[str, Type[BaseProvider]] = {}\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def register(self, name: str, provider_class: Type[BaseProvider]):\n        \"\"\"注册提供商\"\"\"\n        self._providers[name] = provider_class\n    \n    def get(self, name: str, config: ProviderConfig) -> BaseProvider:\n        \"\"\"获取提供商实例\"\"\"\n        if name not in self._providers:\n            raise ValueError(f\"Unknown provider: {name}\")\n        return self._providers[name](config)\n    \n    def list_providers(self) -> List[str]:\n        \"\"\"列出所有已注册的提供商\"\"\"\n        return list(self._providers.keys())\n\n# 全局注册表实例\nregistry = ProviderRegistry()\n\n# 自动注册装饰器\ndef register_provider(name: str):\n    def decorator(cls):\n        registry.register(name, cls)\n        return cls\n    return decorator\n```\n\n### 2.4 火山引擎提供商实现示例\n\n```python\n# modules/providers/volcengine/provider.py\nfrom ..base import BaseProvider, GenerationResult, ProviderConfig\nfrom ..registry import register_provider\nfrom .models import VolcengineModels\nfrom .config import ENDPOINTS\nimport requests\n\n@register_provider(\"volcengine\")\nclass VolcengineProvider(BaseProvider):\n    \"\"\"火山引擎提供商\"\"\"\n    \n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n        model: Optional[str] = None,\n        **kwargs\n    ) -> GenerationResult:\n        \"\"\"文生图实现\"\"\"\n        # 1. 模型选择\n        model_id = model or VolcengineModels.SEEDREAM_4_5_T2I\n        \n        # 2. 构建请求载荷\n        payload = {\n            \"model\": model_id,\n            \"prompt\": prompt,\n            \"size\": size,\n            \"guidance_scale\": guidance_scale,\n            \"watermark\": False,\n            \"response_format\": \"url\"\n        }\n        if seed is not None:\n            payload[\"seed\"] = seed\n        if reference_images:\n            payload[\"image\"] = reference_images\n        \n        # 3. 发起 HTTP 请求\n        try:\n            response = requests.post(\n                f\"{self.config.base_url}{ENDPOINTS['images/generations']}\",\n                headers={\n                    \"Authorization\": f\"Bearer {self.config.api_key}\",\n                    \"Content-Type\": \"application/json\"\n                },\n                json=payload,\n                timeout=self.config.timeout\n            )\n            response.raise_for_status()\n            data = response.json()\n            \n            # 4. 转换为统一格式\n            return GenerationResult(\n                success=True,\n                images=data.get(\"data\", []),\n                task_id=None,\n                model=model_id,\n                vendor=\"volcengine\",\n                parameters=payload,\n                metadata={\"usage\": data.get(\"usage\", {})}\n            )\n        except Exception as e:\n            return GenerationResult(\n                success=False,\n                error=str(e),\n                vendor=\"volcengine\"\n            )\n    \n    def get_supported_models(self) -> List[str]:\n        \"\"\"返回支持的模型\"\"\"\n        return [m.value for m in VolcengineModels]\n    \n    def get_model_capabilities(self, model: str) -> Dict[str, Any]:\n        \"\"\"返回模型能力\"\"\"\n        if model == VolcengineModels.SEEDREAM_4_5_T2I:\n            return {\n                \"max_size\": \"4096x4096\",\n                \"supports_reference\": True,\n                \"max_reference_images\": 14,\n                \"sequential_mode\": True\n            }\n        # ... 其他模型\n        return {}\n```\n\n```python\n# modules/providers/volcengine/models.py\nfrom enum import Enum\n\nclass VolcengineModels(Enum):\n    \"\"\"火山引擎模型枚举\"\"\"\n    # Seedream 图像模型\n    SEEDREAM_3_0_T2I = \"doubao-seedream-3-0-t2i-250415\"\n    SEEDREAM_4_0 = \"doubao-seedream-4-0-250828\"\n    SEEDREAM_4_5_T2I = \"doubao-seedream-4-5-251128\"\n    SEEDEDIT_3_0_I2I = \"doubao-seededit-3-0-i2i-250628\"\n    \n    # Seedance 视频模型\n    SEEDANCE_1_0_PRO = \"doubao-seedance-1-0-pro-250528\"\n    SEEDANCE_1_0_PRO_FAST = \"doubao-seedance-1-0-pro-fast-251015\"\n    SEEDANCE_1_5_PRO = \"doubao-seedance-1-5-pro-251215\"\n    SEEDANCE_1_0_LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n    SEEDANCE_1_0_LITE_I2V = \"doubao-seedance-1-0-lite-i2v-250428\"\n```\n\n```python\n# modules/providers/volcengine/config.py\nENDPOINTS = {\n    \"images/generations\": \"/images/generations\",\n    \"videos/tasks\": \"/contents/generations/tasks\",\n    \"videos/query\": \"/contents/generations/tasks/{task_id}\"\n}\n\nDEFAULTS = {\n    \"base_url\": \"https://ark.cn-beijing.volces.com/api/v3\",\n    \"timeout\": 60,\n    \"max_retries\": 3\n}\n```\n\n---\n\n## 3. 数据库改进方案\n\n### 3.1 Schema 变更\n\n```sql\n-- 在 generations 表添加 vendor 字段\nALTER TABLE generations ADD COLUMN vendor TEXT;\nCREATE INDEX IF NOT EXISTS idx_generations_vendor ON generations(vendor);\n\n-- 迁移脚本：为现有记录填充 vendor\nUPDATE generations \nSET vendor = 'volcengine' \nWHERE model LIKE 'doubao-%' AND vendor IS NULL;\n```\n\n### 3.2 模型标识体系\n\n**统一格式**：`{vendor}:{model_family}:{version}`\n\n| Vendor | 原模型 ID | 新标识符 | 别名 |\n|--------|---------|---------|------|\n| volcengine | doubao-seedream-4-5-251128 | volcengine:seedream:4.5 | seedream-4.5, v4.5 |\n| volcengine | doubao-seedance-1-5-pro-251215 | volcengine:seedance:1.5-pro | seedance-pro-1.5 |\n| openai | dall-e-3 | openai:dalle:3 | dalle3, dall-e-3 |\n| stability | stable-diffusion-xl-1024-v1-0 | stability:sdxl:1.0 | sdxl, sdxl-1.0 |\n\n**向后兼容**：\n- 数据库 `model` 字段仍存储原厂商 ID（`doubao-seedream-4-5-251128`）\n- `vendor` 字段存储提供商名称（`volcengine`）\n- 别名映射在 `config/sources/models_config.py` 中维护\n\n### 3.3 数据库记录示例\n\n```json\n{\n  \"id\": \"gen_abc123\",\n  \"content_type\": \"images\",\n  \"vendor\": \"volcengine\",\n  \"model\": \"doubao-seedream-4-5-251128\",\n  \"prompt\": \"a beautiful sunset\",\n  \"parameters\": {\n    \"size\": \"4096x4096\",\n    \"guidance_scale\": 2.5,\n    \"seed\": 42,\n    \"provider_params\": {\n      \"watermark\": false,\n      \"response_format\": \"url\"\n    }\n  },\n  \"metadata\": {\n    \"usage\": {\"tokens\": 100},\n    \"model_alias\": \"seedream-4.5\",\n    \"provider_version\": \"v4.5\"\n  }\n}\n```\n\n---\n\n## 4. 配置管理改进\n\n### 4.1 多厂商 API Key 管理\n\n```python\n# config/sources/api_config.py（增强）\nimport os\nfrom typing import Dict, Optional\n\n_API_KEYS: Dict[str, str] = {}\n\n# 支持的提供商列表\nSUPPORTED_PROVIDERS = [\n    \"volcengine\",\n    \"openai\",\n    \"stability\",\n    \"midjourney\"\n]\n\ndef get_api_key(provider: str) -> str:\n    \"\"\"获取指定提供商的 API 密钥\"\"\"\n    if provider not in SUPPORTED_PROVIDERS:\n        raise ValueError(f\"Unknown provider: {provider}\")\n    \n    # 1. 优先从内存缓存读取\n    if provider in _API_KEYS:\n        return _API_KEYS[provider]\n    \n    # 2. 从环境变量读取\n    env_key = f\"{provider.upper()}_API_KEY\"\n    api_key = os.environ.get(env_key)\n    if api_key:\n        _API_KEYS[provider] = api_key\n        return api_key\n    \n    # 3. 从配置文件读取（JSON）\n    config_path = Path.home() / \".gemeng\" / \"api_keys.json\"\n    if config_path.exists():\n        try:\n            with open(config_path) as f:\n                keys = json.load(f)\n                if provider in keys:\n                    _API_KEYS[provider] = keys[provider]\n                    return keys[provider]\n        except Exception as e:\n            logger.warning(f\"Failed to load API keys: {e}\")\n    \n    raise ValueError(f\"API key not found for provider: {provider}\")\n\ndef update_api_key(provider: str, api_key: str) -> None:\n    \"\"\"更新 API 密钥（持久化到配置文件）\"\"\"\n    _API_KEYS[provider] = api_key\n    \n    config_path = Path.home() / \".gemeng\" / \"api_keys.json\"\n    config_path.parent.mkdir(parents=True, exist_ok=True)\n    \n    # 读取现有配置\n    keys = {}\n    if config_path.exists():\n        try:\n            with open(config_path) as f:\n                keys = json.load(f)\n        except Exception:\n            pass\n    \n    # 更新并保存\n    keys[provider] = api_key\n    with open(config_path, 'w') as f:\n        json.dump(keys, f, indent=2)\n```\n\n### 4.2 模型列表与别名映射\n\n```python\n# config/sources/models_config.py（新增）\nfrom typing import Dict, List, Optional\n\n# 模型别名映射表\nMODEL_ALIASES: Dict[str, str] = {\n    # Volcengine\n    \"seedream-3\": \"doubao-seedream-3-0-t2i-250415\",\n    \"seedream-4\": \"doubao-seedream-4-0-250828\",\n    \"seedream-4.5\": \"doubao-seedream-4-5-251128\",\n    \"v3\": \"doubao-seedream-3-0-t2i-250415\",\n    \"v4\": \"doubao-seedream-4-0-250828\",\n    \"v4.5\": \"doubao-seedream-4-5-251128\",\n    \n    # OpenAI\n    \"dalle3\": \"dall-e-3\",\n    \"dall-e-3\": \"dall-e-3\",\n    \n    # Stability AI\n    \"sdxl\": \"stable-diffusion-xl-1024-v1-0\",\n    \"sdxl-1.0\": \"stable-diffusion-xl-1024-v1-0\",\n}\n\n# 反向映射：模型 ID -> 提供商\nMODEL_TO_PROVIDER: Dict[str, str] = {\n    # Volcengine\n    \"doubao-seedream-3-0-t2i-250415\": \"volcengine\",\n    \"doubao-seedream-4-0-250828\": \"volcengine\",\n    \"doubao-seedream-4-5-251128\": \"volcengine\",\n    \"doubao-seedance-1-5-pro-251215\": \"volcengine\",\n    \n    # OpenAI\n    \"dall-e-3\": \"openai\",\n    \"dall-e-2\": \"openai\",\n    \n    # Stability AI\n    \"stable-diffusion-xl-1024-v1-0\": \"stability\",\n}\n\ndef resolve_model(model_alias: str) -> str:\n    \"\"\"解析模型别名为完整模型 ID\"\"\"\n    return MODEL_ALIASES.get(model_alias, model_alias)\n\ndef get_provider_for_model(model: str) -> Optional[str]:\n    \"\"\"根据模型 ID 推断提供商\"\"\"\n    return MODEL_TO_PROVIDER.get(model)\n\ndef list_models_by_provider(provider: str) -> List[str]:\n    \"\"\"列出指定提供商的所有模型\"\"\"\n    return [\n        model for model, prov in MODEL_TO_PROVIDER.items()\n        if prov == provider\n    ]\n```\n\n---\n\n## 5. 实施路径（分 4 个阶段）\n\n### 阶段 1：数据库与配置基础（1-2 天）\n\n**目标**：添加 vendor 字段，增强 API 配置\n\n**改动文件**：\n- `modules/repository/sqlite_handler.py`\n- `config/sources/api_config.py`\n- `config/sources/models_config.py`（新增）\n\n**任务清单**：\n1. ✅ 在 SQLite schema 中添加 vendor 字段\n2. ✅ 编写迁移脚本，为现有记录填充 vendor\n3. ✅ 增强 `api_config.py` 支持多厂商密钥\n4. ✅ 创建 `models_config.py` 定义模型别名\n\n**向后兼容**：\n- ✅ 旧记录自动填充 `vendor='volcengine'`\n- ✅ API 接口保持不变\n\n---\n\n### 阶段 2：Provider 抽象层重构（2-3 天）\n\n**目标**：改进 BaseProvider，让其负责完整 HTTP 调用\n\n**改动文件**：\n- `modules/providers/base.py`\n- `modules/providers/registry.py`（新增）\n- `modules/providers/factory.py`\n\n**任务清单**：\n1. ✅ 定义新的 `BaseProvider` 接口（包含 HTTP 调用）\n2. ✅ 创建 `ProviderRegistry` 注册表\n3. ✅ 更新 `factory.py` 使用注册表\n\n**向后兼容**：\n- ✅ 保留旧的 `VolcProvider` 暂不删除\n- ✅ Factory 支持双模式（新旧 Provider 并存）\n\n---\n\n### 阶段 3：火山引擎提供商迁移（2-3 天）\n\n**目标**：将火山引擎实现迁移到新架构\n\n**改动文件**：\n- `modules/providers/volcengine/`（新增目录）\n  - `provider.py`\n  - `models.py`\n  - `config.py`\n- `modules/seedream/client.py`（逐步废弃）\n- `modules/seedream/manager.py`（适配新 Provider）\n\n**任务清单**：\n1. ✅ 创建 `VolcengineProvider` 实现\n2. ✅ 迁移 Seedream 图像生成逻辑\n3. ✅ 迁移 Seedance 视频生成逻辑\n4. ✅ 更新 `SeedreamManager` 调用新 Provider\n5. ✅ 编写单元测试\n\n**向后兼容**：\n- ✅ 保留旧 Client 代码（标记为 deprecated）\n- ✅ Manager 层使用 Provider 接口\n\n---\n\n### 阶段 4：示例提供商接入（1-2 天）\n\n**目标**：验证新架构可用性，接入 OpenAI DALL-E\n\n**改动文件**：\n- `modules/providers/openai/`（新增目录）\n  - `provider.py`\n  - `models.py`\n  - `config.py`\n\n**任务清单**：\n1. ✅ 实现 `OpenAIProvider`\n2. ✅ 支持 DALL-E 3 文生图\n3. ✅ 编写接入文档\n4. ✅ 性能测试\n\n**成功标准**：\n- ✅ 新提供商接入代码量 < 150 行\n- ✅ 无需修改 Service 层\n- ✅ 数据库正确记录 vendor\n\n---\n\n## 6. 新模型接入流程（目标代码量）\n\n### 6.1 接入步骤\n\n**步骤 1：创建提供商目录**\n```bash\nmkdir -p modules/providers/{provider_name}\ntouch modules/providers/{provider_name}/__init__.py\ntouch modules/providers/{provider_name}/provider.py\ntouch modules/providers/{provider_name}/models.py\ntouch modules/providers/{provider_name}/config.py\n```\n\n**步骤 2：定义模型枚举** (~20 行)\n```python\n# modules/providers/{provider_name}/models.py\nfrom enum import Enum\n\nclass {ProviderName}Models(Enum):\n    MODEL_1 = \"model-id-1\"\n    MODEL_2 = \"model-id-2\"\n```\n\n**步骤 3：配置端点** (~10 行)\n```python\n# modules/providers/{provider_name}/config.py\nENDPOINTS = {\n    \"text_to_image\": \"/v1/images/generations\",\n    \"image_to_image\": \"/v1/images/edits\"\n}\n\nDEFAULTS = {\n    \"base_url\": \"https://api.example.com\",\n    \"timeout\": 60\n}\n```\n\n**步骤 4：实现 Provider** (~80 行)\n```python\n# modules/providers/{provider_name}/provider.py\nfrom ..base import BaseProvider, GenerationResult, ProviderConfig\nfrom ..registry import register_provider\n\n@register_provider(\"{provider_name}\")\nclass {ProviderName}Provider(BaseProvider):\n    def text_to_image(self, prompt: str, **kwargs) -> GenerationResult:\n        # 1. 构建请求载荷（10-15 行）\n        # 2. 发起 HTTP 请求（5-10 行）\n        # 3. 转换为统一格式（5-10 行）\n        pass\n    \n    def get_supported_models(self) -> List[str]:\n        return [m.value for m in {ProviderName}Models]\n```\n\n**步骤 5：注册 API 密钥** (UI 操作或配置文件)\n```json\n// ~/.gemeng/api_keys.json\n{\n  \"{provider_name}\": \"your-api-key-here\"\n}\n```\n\n**步骤 6：更新模型别名映射** (~5 行)\n```python\n# config/sources/models_config.py\nMODEL_ALIASES.update({\n    \"alias1\": \"{provider_name}:model-1\",\n    \"alias2\": \"{provider_name}:model-2\"\n})\n\nMODEL_TO_PROVIDER.update({\n    \"{provider_name}:model-1\": \"{provider_name}\",\n    \"{provider_name}:model-2\": \"{provider_name}\"\n})\n```\n\n### 6.2 代码量统计\n\n| 文件 | 预期行数 | 说明 |\n|------|---------|------|\n| `models.py` | ~20 | 模型枚举 |\n| `config.py` | ~10 | 端点配置 |\n| `provider.py` | ~80 | 核心实现 |\n| `models_config.py` | ~5 | 别名映射 |\n| **总计** | **~115 行** | **比当前 500+ 行减少 77%** |\n\n---\n\n## 7. 关键设计决策\n\n### 7.1 为什么 Provider 应该负责完整 HTTP 调用？\n\n**理由**：\n1. **职责清晰**：Provider = \"如何调用这个厂商的 API\"\n2. **降低耦合**：Client 不需要知道不同 Provider 的差异\n3. **易于测试**：Mock Provider 即可测试整个流程\n4. **扩展性强**：新 Provider 无需修改 Client 代码\n\n**反例（当前架构）**：\n```python\n# seedream/client.py 中的反模式\nif provider_name == \"volc_v4\":\n    endpoint = \"/images/generations\"\nelif provider_name == \"volc_v4_5\":\n    endpoint = \"/images/v2/generations\"\nelse:\n    endpoint = \"/images/generations\"\n```\n\n**改进后**：\n```python\n# 服务层调用\nresult = provider.text_to_image(prompt=\"...\", size=\"1024x1024\")\n# Provider 内部决定如何调用 API\n```\n\n### 7.2 为什么需要 vendor 字段？\n\n**理由**：\n1. **数据溯源**：明确每条记录来自哪个提供商\n2. **费用统计**：按提供商统计调用次数和成本\n3. **故障排查**：快速定位某个提供商的问题\n4. **模型迁移**：未来切换提供商时保留历史数据\n\n**示例查询**：\n```sql\n-- 统计各提供商的调用量\nSELECT vendor, COUNT(*) as count \nFROM generations \nWHERE created_at > '2026-01-01' \nGROUP BY vendor;\n\n-- 查找火山引擎的失败记录\nSELECT * FROM generations \nWHERE vendor = 'volcengine' AND status = 'failed';\n```\n\n### 7.3 为什么使用注册表模式？\n\n**理由**：\n1. **解耦注册与使用**：Provider 实现无需硬编码在 factory 中\n2. **支持插件化**：未来可从外部加载 Provider\n3. **自动发现**：装饰器自动注册，减少样板代码\n\n**示例**：\n```python\n# 定义即注册\n@register_provider(\"stability\")\nclass StabilityProvider(BaseProvider):\n    ...\n\n# 使用时按名称获取\nprovider = registry.get(\"stability\", config)\n```\n\n---\n\n## 8. 风险评估与缓解\n\n### 8.1 风险矩阵\n\n| 风险 | 严重程度 | 发生概率 | 缓解措施 |\n|------|---------|---------|---------|\n| 数据库迁移失败 | 高 | 低 | 备份 + 事务回滚 |\n| 旧功能破坏 | 高 | 中 | 保留旧代码 + 分阶段切换 |\n| 新 Provider 接口不适配 | 中 | 中 | 先验证火山引擎迁移 |\n| 性能下降 | 低 | 低 | Provider 接口设计避免额外开销 |\n\n### 8.2 缓解措施详情\n\n**数据库迁移**：\n```python\n# 迁移脚本示例（带回滚）\ndef migrate_add_vendor_field(db_path):\n    conn = sqlite3.connect(db_path)\n    try:\n        conn.execute(\"BEGIN TRANSACTION\")\n        conn.execute(\"ALTER TABLE generations ADD COLUMN vendor TEXT\")\n        conn.execute(\"\"\"\n            UPDATE generations \n            SET vendor = 'volcengine' \n            WHERE model LIKE 'doubao-%'\n        \"\"\")\n        conn.execute(\"COMMIT\")\n    except Exception as e:\n        conn.execute(\"ROLLBACK\")\n        raise e\n    finally:\n        conn.close()\n```\n\n**向后兼容**：\n- 保留 `modules/seedream/client.py` 至少 2 个版本\n- Factory 同时支持新旧 Provider\n- 添加弃用警告（deprecation warnings）\n\n---\n\n## 9. 成功指标\n\n### 9.1 技术指标\n\n- ✅ 新提供商接入代码量 < 150 行（目标 ~115 行）\n- ✅ 单元测试覆盖率 > 80%\n- ✅ API 调用性能无下降（<5% 开销）\n- ✅ 数据库查询性能无下降\n\n### 9.2 业务指标\n\n- ✅ 支持 3+ 个提供商（volcengine, openai, stability）\n- ✅ 现有功能零破坏\n- ✅ 接入新提供商时间 < 1 天\n\n### 9.3 文档指标\n\n- ✅ 接入文档完整（步骤 + 示例代码）\n- ✅ API 参考文档（Provider 接口说明）\n- ✅ 故障排查指南\n\n---\n\n## 10. 附录：关键文件改动清单\n\n### 10.1 数据库层\n\n| 文件 | 改动类型 | 优先级 |\n|------|---------|-------|\n| `modules/repository/sqlite_handler.py` | 修改 Schema | P0 |\n| `modules/repository/manager.py` | 支持 vendor 查询 | P1 |\n\n### 10.2 Provider 层\n\n| 文件 | 改动类型 | 优先级 |\n|------|---------|-------|\n| `modules/providers/base.py` | 重构接口 | P0 |\n| `modules/providers/registry.py` | 新增注册表 | P0 |\n| `modules/providers/factory.py` | 适配注册表 | P0 |\n| `modules/providers/volcengine/` | 新增模块 | P0 |\n\n### 10.3 配置层\n\n| 文件 | 改动类型 | 优先级 |\n|------|---------|-------|\n| `config/sources/api_config.py` | 多厂商支持 | P0 |\n| `config/sources/models_config.py` | 新增别名映射 | P0 |\n\n### 10.4 业务层\n\n| 文件 | 改动类型 | 优先级 |\n|------|---------|-------|\n| `modules/seedream/manager.py` | 适配新 Provider | P1 |\n| `services/image_service.py` | 最小改动 | P2 |\n\n---\n\n## 总结\n\n本方案提供了一个**渐进式、低风险、高扩展性**的多模型提供商架构：\n\n1. **核心改进**：Provider 负责完整 HTTP 调用，而非只做参数映射\n2. **数据库增强**：添加 vendor 字段，支持模型溯源\n3. **配置统一**：多厂商 API Key + 模型别名映射\n4. **分阶段实施**：4 个阶段，每个阶段都保持向后兼容\n5. **接入简化**：新提供商接入从 500+ 行降至 ~115 行\n\n**下一步行动**：\n1. 审查本方案，确认架构方向\n2. 开始阶段 1（数据库与配置基础）\n3. 编写单元测试框架\n4. 迁移火山引擎提供商（验证新架构）\n\n---\n\n**方案版本**: v1.0  \n**创建日期**: 2026-01-05  \n**维护者**: Claude Code Planning Agent\n"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2490,"cache_read_input_tokens":105199,"cache_creation":{"ephemeral_5m_input_tokens":2490,"ephemeral_1h_input_tokens":0},"output_tokens":10167,"service_tier":"standard"},"context_management":{"applied_edits":[]}},"type":"assistant","uuid":"878cf434-4a1d-4d25-9b6d-b80e33123cf7","timestamp":"2026-01-05T11:56:38.306Z"}
{"parentUuid":"878cf434-4a1d-4d25-9b6d-b80e33123cf7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Error: No such tool available: Write</tool_use_error>","is_error":true,"tool_use_id":"toolu_01PrhLdHRBs1wcL2Ep12H1Z5"}]},"uuid":"db5cb420-9acc-4e1e-a2c8-e2834bfb94f7","timestamp":"2026-01-05T11:56:38.320Z","toolUseResult":"Error: No such tool available: Write"}
{"parentUuid":"db5cb420-9acc-4e1e-a2c8-e2834bfb94f7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"da242acd-a1a1-4b1f-9601-6b35ad04425d","version":"2.0.76","gitBranch":"refactor/governed-phases-2026q1","agentId":"a8dfeb5","slug":"inherited-napping-neumann","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LoZqoCdcmcf8gd4VXJZjxw","type":"message","role":"assistant","content":[{"type":"text","text":"我理解了，这是只读模式。让我直接向您呈现完整的设计方案：\n\n---\n\n# 多模型提供商架构设计方案\n\n## 执行摘要\n\n基于对代码库的深入分析，我设计了一个**分阶段、向后兼容、低侵入性**的多模型提供商接入架构：\n\n### 核心改进\n1. **接入难度**：从 500+ 行降至 ~115 行（减少 77%）\n2. **Provider 职责**：从\"参数映射\"升级为\"完整 HTTP 调用\"\n3. **数据库增强**：添加 `vendor` 字段，支持模型溯源\n4. **配置统一**：多厂商 API Key + 模型别名映射\n\n---\n\n## 1. 当前架构诊断\n\n### 优势 ✅\n- 服务层（`ImageService`/`VideoService`）与实现解耦良好\n- 已有 Provider 基础（`BaseProvider` + 3 个版本）\n- 工厂模式注入，支持环境变量切换\n- SQLite `parameters` 字段为 JSON，可存储任意厂商参数\n\n### 问题 ❌\n- **Provider 职责不完整**：只做参数映射，HTTP 调用仍在 `Client` 内\n- **强耦合**：\n  - 模型 ID 硬编码（`doubao-*` 前缀）\n  - 端点路径绑定火山引擎\n  - Client 内充斥 if/else 分支（如 `_call_seedream_provider` 227-341 行）\n- **缺少 vendor 字段**：无法区分模型来源\n- **配置分散**：API Key、模型枚举、端点定义散落各处\n\n### 接入难度评估\n- **当前架构**：需修改 500+ 行，涉及 8+ 文件\n- **目标架构**：~115 行，3 个文件\n\n---\n\n## 2. 目标架构设计\n\n### 2.1 目录结构\n\n```\nmodules/\n├── providers/                    # 统一改名（复数）\n│   ├── __init__.py\n│   ├── base.py                  # 基础抽象类（改进）\n│   ├── registry.py              # 提供商注册表（新增）\n│   ├── factory.py               # 工厂模式\n│   ├── schema.py                # 参数 Schema（保持）\n│   │\n│   ├── volcengine/              # 火山引擎（独立模块）\n│   │   ├── __init__.py\n│   │   ├── provider.py          # 继承 BaseProvider\n│   │   ├── models.py            # 模型枚举\n│   │   └── config.py            # 端点/默认值\n│   │\n│   ├── openai/                  # OpenAI（示例）\n│   │   ├── __init__.py\n│   │   ├── provider.py\n│   │   ├── models.py\n│   │   └── config.py\n│   │\n│   ├── stability/               # Stability AI（示例）\n│   │   └── ...\n│   │\n│   └── midjourney/              # Midjourney（示例）\n│       └── ...\n│\nconfig/sources/\n├── api_config.py                # 多厂商 API Key（增强）\n└── models_config.py             # 模型别名映射（新增）\n```\n\n### 2.2 改进的 Provider 抽象\n\n**核心改变**：Provider 负责完整 HTTP 调用，不再只是参数映射。\n\n```python\n# modules/providers/base.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass\n\n@dataclass\nclass ProviderConfig:\n    \"\"\"提供商配置\"\"\"\n    name: str                    # \"volcengine\", \"openai\"\n    api_key: str                 # API 密钥\n    base_url: str               # API 基础 URL\n    timeout: int = 60\n    max_retries: int = 3\n    extra: Dict[str, Any] = None\n\n@dataclass\nclass GenerationResult:\n    \"\"\"统一的生成结果\"\"\"\n    success: bool\n    images: List[Dict[str, Any]] = None\n    videos: List[Dict[str, Any]] = None\n    task_id: Optional[str] = None\n    model: Optional[str] = None\n    vendor: Optional[str] = None      # 关键：标记来源\n    parameters: Dict[str, Any] = None  # 实际使用的参数\n    metadata: Dict[str, Any] = None\n    error: Optional[str] = None\n\nclass BaseProvider(ABC):\n    \"\"\"提供商基类 - 完整的 HTTP 调用封装\"\"\"\n    \n    def __init__(self, config: ProviderConfig):\n        self.config = config\n        self.name = config.name\n    \n    @abstractmethod\n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n        model: Optional[str] = None,\n        **kwargs\n    ) -> GenerationResult:\n        \"\"\"文生图（完整 HTTP 调用，不只是参数映射）\"\"\"\n        pass\n    \n    @abstractmethod\n    def image_to_image(...) -> GenerationResult:\n        pass\n    \n    @abstractmethod\n    def text_to_video(...) -> GenerationResult:\n        pass\n    \n    @abstractmethod\n    def image_to_video(...) -> GenerationResult:\n        pass\n    \n    @abstractmethod\n    def get_supported_models(self) -> List[str]:\n        \"\"\"返回支持的模型列表\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_model_capabilities(self, model: str) -> Dict[str, Any]:\n        \"\"\"返回模型能力描述\"\"\"\n        pass\n```\n\n### 2.3 提供商注册表\n\n```python\n# modules/providers/registry.py\nfrom typing import Dict, Type\nfrom .base import BaseProvider, ProviderConfig\n\nclass ProviderRegistry:\n    \"\"\"提供商注册表（单例）\"\"\"\n    _instance = None\n    _providers: Dict[str, Type[BaseProvider]] = {}\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def register(self, name: str, provider_class: Type[BaseProvider]):\n        self._providers[name] = provider_class\n    \n    def get(self, name: str, config: ProviderConfig) -> BaseProvider:\n        if name not in self._providers:\n            raise ValueError(f\"Unknown provider: {name}\")\n        return self._providers[name](config)\n    \n    def list_providers(self) -> List[str]:\n        return list(self._providers.keys())\n\nregistry = ProviderRegistry()\n\ndef register_provider(name: str):\n    \"\"\"装饰器：自动注册提供商\"\"\"\n    def decorator(cls):\n        registry.register(name, cls)\n        return cls\n    return decorator\n```\n\n### 2.4 火山引擎提供商实现示例\n\n```python\n# modules/providers/volcengine/provider.py\nfrom ..base import BaseProvider, GenerationResult, ProviderConfig\nfrom ..registry import register_provider\nfrom .models import VolcengineModels\nfrom .config import ENDPOINTS\nimport requests\n\n@register_provider(\"volcengine\")\nclass VolcengineProvider(BaseProvider):\n    \n    def text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: Optional[int] = None,\n        reference_images: Optional[List[str]] = None,\n        model: Optional[str] = None,\n        **kwargs\n    ) -> GenerationResult:\n        # 1. 选择模型\n        model_id = model or VolcengineModels.SEEDREAM_4_5_T2I.value\n        \n        # 2. 构建载荷\n        payload = {\n            \"model\": model_id,\n            \"prompt\": prompt,\n            \"size\": size,\n            \"guidance_scale\": guidance_scale,\n            \"watermark\": False,\n            \"response_format\": \"url\"\n        }\n        if seed is not None:\n            payload[\"seed\"] = seed\n        if reference_images:\n            payload[\"image\"] = reference_images\n        \n        # 3. HTTP 请求\n        try:\n            response = requests.post(\n                f\"{self.config.base_url}{ENDPOINTS['images']}\",\n                headers={\n                    \"Authorization\": f\"Bearer {self.config.api_key}\",\n                    \"Content-Type\": \"application/json\"\n                },\n                json=payload,\n                timeout=self.config.timeout\n            )\n            response.raise_for_status()\n            data = response.json()\n            \n            # 4. 转换为统一格式\n            return GenerationResult(\n                success=True,\n                images=data.get(\"data\", []),\n                model=model_id,\n                vendor=\"volcengine\",  # 关键标记\n                parameters=payload,\n                metadata={\"usage\": data.get(\"usage\", {})}\n            )\n        except Exception as e:\n            return GenerationResult(\n                success=False,\n                error=str(e),\n                vendor=\"volcengine\"\n            )\n    \n    def get_supported_models(self) -> List[str]:\n        return [m.value for m in VolcengineModels]\n    \n    def get_model_capabilities(self, model: str) -> Dict[str, Any]:\n        if model == VolcengineModels.SEEDREAM_4_5_T2I.value:\n            return {\n                \"max_size\": \"4096x4096\",\n                \"supports_reference\": True,\n                \"max_reference_images\": 14,\n                \"sequential_mode\": True\n            }\n        return {}\n```\n\n```python\n# modules/providers/volcengine/models.py\nfrom enum import Enum\n\nclass VolcengineModels(Enum):\n    # Seedream\n    SEEDREAM_3_0_T2I = \"doubao-seedream-3-0-t2i-250415\"\n    SEEDREAM_4_0 = \"doubao-seedream-4-0-250828\"\n    SEEDREAM_4_5_T2I = \"doubao-seedream-4-5-251128\"\n    SEEDEDIT_3_0_I2I = \"doubao-seededit-3-0-i2i-250628\"\n    \n    # Seedance\n    SEEDANCE_1_0_PRO = \"doubao-seedance-1-0-pro-250528\"\n    SEEDANCE_1_5_PRO = \"doubao-seedance-1-5-pro-251215\"\n    SEEDANCE_1_0_LITE_T2V = \"doubao-seedance-1-0-lite-t2v-250428\"\n```\n\n```python\n# modules/providers/volcengine/config.py\nENDPOINTS = {\n    \"images\": \"/images/generations\",\n    \"videos_create\": \"/contents/generations/tasks\",\n    \"videos_query\": \"/contents/generations/tasks/{task_id}\"\n}\n\nDEFAULTS = {\n    \"base_url\": \"https://ark.cn-beijing.volces.com/api/v3\",\n    \"timeout\": 60,\n    \"max_retries\": 3\n}\n```\n\n---\n\n## 3. 数据库改进方案\n\n### 3.1 Schema 变更\n\n```sql\n-- 添加 vendor 字段\nALTER TABLE generations ADD COLUMN vendor TEXT;\nCREATE INDEX IF NOT EXISTS idx_generations_vendor ON generations(vendor);\n\n-- 迁移现有记录\nUPDATE generations \nSET vendor = 'volcengine' \nWHERE model LIKE 'doubao-%' AND vendor IS NULL;\n```\n\n### 3.2 模型标识体系\n\n**统一格式**：`{vendor}:{model_family}:{version}`\n\n| Vendor | 原模型 ID | 新标识符 | 别名 |\n|--------|---------|---------|------|\n| volcengine | doubao-seedream-4-5-251128 | volcengine:seedream:4.5 | seedream-4.5, v4.5 |\n| volcengine | doubao-seedance-1-5-pro-251215 | volcengine:seedance:1.5-pro | seedance-1.5-pro |\n| openai | dall-e-3 | openai:dalle:3 | dalle3 |\n| stability | stable-diffusion-xl-1024-v1-0 | stability:sdxl:1.0 | sdxl |\n\n**向后兼容**：\n- `model` 字段仍存储原厂商 ID（如 `doubao-seedream-4-5-251128`）\n- `vendor` 字段存储提供商名称（如 `volcengine`）\n- 别名映射在 `models_config.py` 维护\n\n### 3.3 记录示例\n\n```json\n{\n  \"id\": \"gen_abc123\",\n  \"content_type\": \"images\",\n  \"vendor\": \"volcengine\",\n  \"model\": \"doubao-seedream-4-5-251128\",\n  \"prompt\": \"a beautiful sunset\",\n  \"parameters\": {\n    \"size\": \"4096x4096\",\n    \"guidance_scale\": 2.5,\n    \"seed\": 42\n  },\n  \"metadata\": {\n    \"usage\": {\"tokens\": 100},\n    \"model_alias\": \"seedream-4.5\"\n  }\n}\n```\n\n---\n\n## 4. 配置管理\n\n### 4.1 多厂商 API Key\n\n```python\n# config/sources/api_config.py（增强）\nSUPPORTED_PROVIDERS = [\"volcengine\", \"openai\", \"stability\", \"midjourney\"]\n\ndef get_api_key(provider: str) -> str:\n    \"\"\"获取 API 密钥（优先级：缓存 > 环境变量 > 配置文件）\"\"\"\n    # 1. 内存缓存\n    if provider in _API_KEYS:\n        return _API_KEYS[provider]\n    \n    # 2. 环境变量\n    env_key = f\"{provider.upper()}_API_KEY\"\n    api_key = os.environ.get(env_key)\n    if api_key:\n        return api_key\n    \n    # 3. 配置文件 ~/.gemeng/api_keys.json\n    config_path = Path.home() / \".gemeng\" / \"api_keys.json\"\n    if config_path.exists():\n        with open(config_path) as f:\n            keys = json.load(f)\n            if provider in keys:\n                return keys[provider]\n    \n    raise ValueError(f\"API key not found: {provider}\")\n```\n\n### 4.2 模型别名映射\n\n```python\n# config/sources/models_config.py（新增）\nMODEL_ALIASES = {\n    # Volcengine\n    \"seedream-4.5\": \"doubao-seedream-4-5-251128\",\n    \"v4.5\": \"doubao-seedream-4-5-251128\",\n    \n    # OpenAI\n    \"dalle3\": \"dall-e-3\",\n    \n    # Stability\n    \"sdxl\": \"stable-diffusion-xl-1024-v1-0\"\n}\n\nMODEL_TO_PROVIDER = {\n    \"doubao-seedream-4-5-251128\": \"volcengine\",\n    \"dall-e-3\": \"openai\",\n    \"stable-diffusion-xl-1024-v1-0\": \"stability\"\n}\n\ndef resolve_model(alias: str) -> str:\n    \"\"\"解析别名为完整模型 ID\"\"\"\n    return MODEL_ALIASES.get(alias, alias)\n\ndef get_provider_for_model(model: str) -> Optional[str]:\n    \"\"\"根据模型推断提供商\"\"\"\n    return MODEL_TO_PROVIDER.get(model)\n```\n\n---\n\n## 5. 实施路径（4 阶段）\n\n### 阶段 1：数据库与配置基础（1-2 天）\n\n**目标**：添加 vendor 字段，增强 API 配置\n\n**改动文件**：\n- `modules/repository/sqlite_handler.py`（Schema 变更）\n- `config/sources/api_config.py`（多厂商支持）\n- `config/sources/models_config.py`（新增别名映射）\n\n**任务清单**：\n1. 在 SQLite schema 添加 `vendor` 字段\n2. 编写迁移脚本（带回滚）\n3. 增强 `api_config.py` 支持多厂商\n4. 创建 `models_config.py`\n\n**向后兼容**：\n- 旧记录自动填充 `vendor='volcengine'`\n- API 接口保持不变\n\n---\n\n### 阶段 2：Provider 抽象层重构（2-3 天）\n\n**目标**：改进 BaseProvider，让其负责完整 HTTP 调用\n\n**改动文件**：\n- `modules/providers/base.py`（重构接口）\n- `modules/providers/registry.py`（新增注册表）\n- `modules/providers/factory.py`（适配注册表）\n\n**任务清单**：\n1. 定义新的 `BaseProvider` 接口\n2. 创建 `ProviderRegistry`\n3. 更新 `factory.py`\n\n**向后兼容**：\n- 保留旧 `VolcProvider` 暂不删除\n- Factory 支持双模式\n\n---\n\n### 阶段 3：火山引擎提供商迁移（2-3 天）\n\n**目标**：验证新架构可行性\n\n**改动文件**：\n- `modules/providers/volcengine/`（新增目录）\n- `modules/seedream/manager.py`（适配新 Provider）\n\n**任务清单**：\n1. 创建 `VolcengineProvider` 实现\n2. 迁移 Seedream 图像逻辑\n3. 迁移 Seedance 视频逻辑\n4. 更新 `SeedreamManager`\n5. 编写单元测试\n\n**向后兼容**：\n- 保留旧 Client（标记 deprecated）\n\n---\n\n### 阶段 4：示例提供商接入（1-2 天）\n\n**目标**：验证新架构易用性\n\n**改动文件**：\n- `modules/providers/openai/`（新增）\n\n**成功标准**：\n- 代码量 < 150 行\n- 无需修改 Service 层\n- 数据库正确记录 vendor\n\n---\n\n## 6. 新模型接入流程\n\n### 步骤 1：创建目录\n```bash\nmkdir -p modules/providers/{provider_name}\ntouch modules/providers/{provider_name}/{__init__,provider,models,config}.py\n```\n\n### 步骤 2：定义模型 (~20 行)\n```python\n# models.py\nfrom enum import Enum\n\nclass {Provider}Models(Enum):\n    MODEL_1 = \"model-id-1\"\n    MODEL_2 = \"model-id-2\"\n```\n\n### 步骤 3：配置端点 (~10 行)\n```python\n# config.py\nENDPOINTS = {\n    \"text_to_image\": \"/v1/images/generations\"\n}\n\nDEFAULTS = {\n    \"base_url\": \"https://api.example.com\",\n    \"timeout\": 60\n}\n```\n\n### 步骤 4：实现 Provider (~80 行)\n```python\n# provider.py\nfrom ..base import BaseProvider, GenerationResult\nfrom ..registry import register_provider\n\n@register_provider(\"{provider_name}\")\nclass {Provider}Provider(BaseProvider):\n    def text_to_image(self, prompt: str, **kwargs) -> GenerationResult:\n        # 1. 构建载荷（10-15 行）\n        # 2. HTTP 请求（5-10 行）\n        # 3. 转换格式（5-10 行）\n        pass\n```\n\n### 步骤 5：注册 API Key\n```json\n// ~/.gemeng/api_keys.json\n{\n  \"{provider_name}\": \"your-api-key\"\n}\n```\n\n### 步骤 6：更新别名 (~5 行)\n```python\n# models_config.py\nMODEL_ALIASES.update({\n    \"alias\": \"{provider}:model-1\"\n})\n```\n\n### 代码量统计\n\n| 文件 | 行数 |\n|------|-----|\n| `models.py` | ~20 |\n| `config.py` | ~10 |\n| `provider.py` | ~80 |\n| `models_config.py` | ~5 |\n| **总计** | **~115 行** |\n\n**对比**：当前架构需 500+ 行，减少 77%\n\n---\n\n## 7. 关键设计决策\n\n### 7.1 为什么 Provider 应该负责完整 HTTP 调用？\n\n**理由**：\n1. **职责清晰**：Provider = \"如何调用这个厂商的 API\"\n2. **降低耦合**：Client 不需要知道不同 Provider 的差异\n3. **易于测试**：Mock Provider 即可\n4. **扩展性强**：新 Provider 无需修改 Client\n\n**当前反模式**：\n```python\n# client.py 中的问题（227-341 行）\nif provider_name == \"volc_v4\":\n    endpoint = \"/images/generations\"\nelif provider_name == \"volc_v4_5\":\n    endpoint = \"/images/v2/generations\"\n# ... 大量 if/else\n```\n\n**改进后**：\n```python\n# 服务层直接调用\nresult = provider.text_to_image(prompt=\"...\", size=\"1024x1024\")\n```\n\n### 7.2 为什么需要 vendor 字段？\n\n**理由**：\n1. **数据溯源**：明确每条记录来源\n2. **费用统计**：按提供商统计调用成本\n3. **故障排查**：快速定位问题\n4. **模型迁移**：切换提供商时保留历史\n\n**示例查询**：\n```sql\n-- 统计各提供商调用量\nSELECT vendor, COUNT(*) FROM generations \nWHERE created_at > '2026-01-01' GROUP BY vendor;\n```\n\n### 7.3 为什么使用注册表模式？\n\n**理由**：\n1. **解耦注册与使用**：Provider 无需硬编码在 factory 中\n2. **支持插件化**：未来可从外部加载\n3. **自动发现**：装饰器自动注册\n\n**示例**：\n```python\n@register_provider(\"stability\")\nclass StabilityProvider(BaseProvider):\n    ...\n\n# 使用时按名称获取\nprovider = registry.get(\"stability\", config)\n```\n\n---\n\n## 8. 风险评估\n\n| 风险 | 严重程度 | 概率 | 缓解措施 |\n|------|---------|-----|---------|\n| 数据库迁移失败 | 高 | 低 | 备份 + 事务回滚 |\n| 旧功能破坏 | 高 | 中 | 保留旧代码 + 分阶段切换 |\n| 新 Provider 不适配 | 中 | 中 | 先验证火山引擎迁移 |\n| 性能下降 | 低 | 低 | Provider 设计避免额外开销 |\n\n---\n\n## 9. 成功指标\n\n### 技术指标\n- ✅ 新提供商接入 < 150 行（目标 ~115 行）\n- ✅ 单元测试覆盖率 > 80%\n- ✅ API 性能无下降（<5% 开销）\n\n### 业务指标\n- ✅ 支持 3+ 提供商\n- ✅ 现有功能零破坏\n- ✅ 接入时间 < 1 天\n\n---\n\n### 关键文件（实施时优先）\n\n以下 5 个文件是实施本方案的核心：\n\n1. **`/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/sqlite_handler.py`**  \n   理由：数据库 Schema 变更，添加 vendor 字段（阶段 1）\n\n2. **`/Users/yunchang/Documents/GitHub/gemeng2/modules/provider/base.py`**  \n   理由：重构 Provider 接口，从\"参数映射\"升级为\"完整 HTTP 调用\"（阶段 2）\n\n3. **`/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/client.py`**  \n   理由：当前 HTTP 调用逻辑的参考实现，迁移到新 Provider 时需复用其逻辑（阶段 3）\n\n4. **`/Users/yunchang/Documents/GitHub/gemeng2/config/sources/api_config.py`**  \n   理由：增强多厂商 API Key 管理（阶段 1）\n\n5. **`/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py`**  \n   理由：业务逻辑层需要适配新 Provider 接口（阶段 3）\n\n---\n\n这个方案平衡了**可行性、扩展性、兼容性**，通过 4 个阶段渐进实施，确保每一步都可验证、可回滚。下一步建议从阶段 1（数据库与配置基础）开始，验证设计可行性后再推进后续阶段。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":10243,"cache_read_input_tokens":107689,"cache_creation":{"ephemeral_5m_input_tokens":10243,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"74876c55-879c-4514-b4e6-78964ac9ba19","timestamp":"2026-01-05T11:58:26.876Z"}
