{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":"用户选择了 Pro-fast 模型生成视频，生成成功，但保存的参数详情页显示的是 \"seedance pro\" 而不是 \"seedance_pro_fast\"。\n\n请探索以下内容：\n1. 视频生成结果保存到数据库的流程\n2. 在 video_service.py、manager.py 中，model_type 和 model_variant 是如何被保存的\n3. 详情页是从哪里读取模型信息的\n4. 找出 model 或 model_variant 在保存时可能被覆盖或丢失的位置\n\n重点搜索：\n- video_service.py 中的 _build_complete_result 和 _save_result 方法\n- manager.py 中保存参数的逻辑\n- 任何 model_variant 被硬编码或覆盖的地方\n\n请详细列出文件路径和行号。"},"uuid":"b20673c9-bf03-44a0-85bb-143400bf3553","timestamp":"2025-12-11T08:09:18.649Z"}
{"parentUuid":"b20673c9-bf03-44a0-85bb-143400bf3553","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M2erDzLEPuozpjAJpCyQCJ","type":"message","role":"assistant","content":[{"type":"text","text":"我来帮你探索这个问题。让我系统地搜索相关的代码文件和逻辑。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":19422,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":19422,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"6aa039fe-ecf6-4052-85d0-bbbb0348c9b8","timestamp":"2025-12-11T08:09:22.133Z"}
{"parentUuid":"6aa039fe-ecf6-4052-85d0-bbbb0348c9b8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M2erDzLEPuozpjAJpCyQCJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019TAnHJ1qUHxYgcw9vwaKkF","name":"Glob","input":{"pattern":"**/{video_service,manager}.py","path":"/Users/yunchang/Documents/GitHub/gemeng2"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":19422,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":19422,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"4753a1c0-b957-4426-9283-2e3f1d346c17","timestamp":"2025-12-11T08:09:22.731Z"}
{"parentUuid":"4753a1c0-b957-4426-9283-2e3f1d346c17","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M2erDzLEPuozpjAJpCyQCJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DTuxrY3bDRWWDTyohii7uA","name":"Grep","input":{"pattern":"_build_complete_result|_save_result","path":"/Users/yunchang/Documents/GitHub/gemeng2","type":"py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":19422,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":19422,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"2aa95038-53a7-4c4a-a858-ceb264c93cee","timestamp":"2025-12-11T08:09:23.078Z"}
{"parentUuid":"2aa95038-53a7-4c4a-a858-ceb264c93cee","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M2erDzLEPuozpjAJpCyQCJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C1kAEZeT5VAkv1FXvHNshG","name":"Grep","input":{"pattern":"model_variant","path":"/Users/yunchang/Documents/GitHub/gemeng2","type":"py","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":19422,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":19422,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"c90fe204-fcfb-43fd-9f87-1adec718b390","timestamp":"2025-12-11T08:09:23.560Z"}
{"parentUuid":"c90fe204-fcfb-43fd-9f87-1adec718b390","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DTuxrY3bDRWWDTyohii7uA","type":"tool_result","content":"Found 2 files\nservices/video_service.py\ntools/performance_benchmark.py"}]},"uuid":"d4a13ca5-d8a4-42ac-b1e8-f20a6bfcb9c3","timestamp":"2025-12-11T08:09:23.672Z","toolUseResult":{"mode":"files_with_matches","filenames":["services/video_service.py","tools/performance_benchmark.py"],"numFiles":2}}
{"parentUuid":"d4a13ca5-d8a4-42ac-b1e8-f20a6bfcb9c3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C1kAEZeT5VAkv1FXvHNshG","type":"tool_result","content":"Found 14 files\nmodules/seedance/manager.py\nservices/video_service.py\ncomponents/modes/video_mode_widget.py\nmodules/provider/schema.py\nmodules/seedream/manager.py\ncomponents/modes/image_mode_widget.py\nservices/image_service.py\ntools/diagnose_visibility_rules.py\ncomponents/generation_image_mode_widget_backup.py\narchive/refactoring_20250924/qt_app_modified.py\narchive/refactoring_20250924/image_mode_widget.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py\n.style_backup/qt_app.py\n.style_backup/components/generation/image_mode_widget.py"}]},"uuid":"2fc96796-2378-47d2-bbd1-861154645469","timestamp":"2025-12-11T08:09:23.674Z","toolUseResult":{"mode":"files_with_matches","filenames":["modules/seedance/manager.py","services/video_service.py","components/modes/video_mode_widget.py","modules/provider/schema.py","modules/seedream/manager.py","components/modes/image_mode_widget.py","services/image_service.py","tools/diagnose_visibility_rules.py","components/generation_image_mode_widget_backup.py","archive/refactoring_20250924/qt_app_modified.py","archive/refactoring_20250924/image_mode_widget.py",".style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py",".style_backup/qt_app.py",".style_backup/components/generation/image_mode_widget.py"],"numFiles":14}}
{"parentUuid":"2fc96796-2378-47d2-bbd1-861154645469","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019TAnHJ1qUHxYgcw9vwaKkF","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/glm/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedance/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/glm/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedance/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py\n/Users/yunchang/Documents/GitHub/gemeng2/services/video_service.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}]},"uuid":"94b94f6b-4783-40d5-b829-15eca49610d0","timestamp":"2025-12-11T08:09:23.745Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/glm/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/repository/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedance/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/gemeng2-0.7.0/modules/seedream/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/glm/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/repository/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedance/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/archive/imported_sources/modules/seedream/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","/Users/yunchang/Documents/GitHub/gemeng2/services/video_service.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"],"durationMs":108,"numFiles":12,"truncated":false}}
{"parentUuid":"94b94f6b-4783-40d5-b829-15eca49610d0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KLY9sToDQensDkAcZgFj3t","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我详细读取主要的文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":267,"cache_creation_input_tokens":1008,"cache_read_input_tokens":19422,"cache_creation":{"ephemeral_5m_input_tokens":1008,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c4207ebf-a8dd-4066-96aa-b912f69df81f","timestamp":"2025-12-11T08:09:25.834Z"}
{"parentUuid":"c4207ebf-a8dd-4066-96aa-b912f69df81f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KLY9sToDQensDkAcZgFj3t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KNk9wr8NdqigZkJuPfT5am","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/services/video_service.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":267,"cache_creation_input_tokens":1008,"cache_read_input_tokens":19422,"cache_creation":{"ephemeral_5m_input_tokens":1008,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2885390b-7ce6-43ee-8cd5-60ce034daea7","timestamp":"2025-12-11T08:09:26.074Z"}
{"parentUuid":"2885390b-7ce6-43ee-8cd5-60ce034daea7","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KLY9sToDQensDkAcZgFj3t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DQFY3jiHsspS4QpFKcAAnF","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":267,"cache_creation_input_tokens":1008,"cache_read_input_tokens":19422,"cache_creation":{"ephemeral_5m_input_tokens":1008,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"c043908e-c58d-4b59-b7f7-b60d08271dc6","timestamp":"2025-12-11T08:09:26.878Z"}
{"parentUuid":"c043908e-c58d-4b59-b7f7-b60d08271dc6","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KLY9sToDQensDkAcZgFj3t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016A3WwNppi64os5QE8fo384","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":267,"cache_creation_input_tokens":1008,"cache_read_input_tokens":19422,"cache_creation":{"ephemeral_5m_input_tokens":1008,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"b43158d0-e13a-4222-b9dd-73ab987f5865","timestamp":"2025-12-11T08:09:26.929Z"}
{"parentUuid":"b43158d0-e13a-4222-b9dd-73ab987f5865","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KLY9sToDQensDkAcZgFj3t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012qh2rxTPGPawwktNCp4z21","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":267,"cache_creation_input_tokens":1008,"cache_read_input_tokens":19422,"cache_creation":{"ephemeral_5m_input_tokens":1008,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9a54da7b-2761-4d80-8d5a-cbd8d7b59382","timestamp":"2025-12-11T08:09:27.024Z"}
{"parentUuid":"9a54da7b-2761-4d80-8d5a-cbd8d7b59382","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KNk9wr8NdqigZkJuPfT5am","type":"tool_result","content":"     1→\"\"\"Seedance 视频生成服务层，实现与 UI 解耦并统一水印逻辑。\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import time\n     6→from datetime import datetime\n     7→from typing import Any, Callable, Dict, Optional\n     8→\n     9→from config.unified_config import get_unified_config\n    10→from modules.repository.manager import RepositoryManager\n    11→from modules.seedance.manager import SeedanceManager\n    12→from utils.logger import logger\n    13→\n    14→ProgressCallback = Optional[Callable[[Optional[float], str], None]]\n    15→CancelCallback = Optional[Callable[[], bool]]\n    16→\n    17→\n    18→class VideoService:\n    19→    \"\"\"封装 Seedance 视频生成的业务逻辑与水印处理。\"\"\"\n    20→\n    21→    def __init__(\n    22→        self,\n    23→        repository_manager: Optional[RepositoryManager] = None,\n    24→        seedance_manager_factory: Optional[Callable[[Optional[str]], SeedanceManager]] = None,\n    25→    ) -> None:\n    26→        \"\"\"\n    27→        初始化服务层并注入依赖。\n    28→\n    29→        Args:\n    30→            repository_manager: 历史记录仓库管理器。\n    31→            seedance_manager_factory: SeedanceManager 工厂，便于测试替身。\n    32→        \"\"\"\n    33→        # 使用统一配置\n    34→        self.unified_config = get_unified_config()\n    35→\n    36→        self.repository_manager = repository_manager\n    37→        self._seedance_manager_factory = seedance_manager_factory or (lambda api_key=None: SeedanceManager(api_key))\n    38→\n    39→    # ------------------------------------------------------------------\n    40→    # 公共接口\n    41→    # ------------------------------------------------------------------\n    42→    def generate_video(\n    43→        self,\n    44→        params: Dict[str, Any],\n    45→        progress_callback: ProgressCallback = None,\n    46→        should_cancel: CancelCallback = None,\n    47→    ) -> Dict[str, Any]:\n    48→        \"\"\"\n    49→        统一的视频生成入口。\n    50→\n    51→        Args:\n    52→            params: 视频生成参数，兼容 VideoModeWidget 的字段集合。\n    53→            progress_callback: 进度回调函数，形如 callback(percentage, message)。\n    54→\n    55→        Returns:\n    56→            生成结果字典，包含 success / error / local_path 等信息。\n    57→        \"\"\"\n    58→        task_id: Optional[str] = params.get(\"generation_id\")\n    59→        api_task_id: Optional[str] = None\n    60→\n    61→        prompt = (params.get(\"prompt\") or \"\").strip()\n    62→        if not prompt:\n    63→            return self._failure(\"提示词不能为空\")\n    64→\n    65→        if self._is_cancelled(should_cancel):\n    66→            logger.info(\"用户取消了视频生成: 初始化前\")\n    67→            return self._cancelled()\n    68→\n    69→        self._emit_progress(progress_callback, \"正在初始化视频生成...\")\n    70→\n    71→        try:\n    72→            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n    73→            if not is_valid:\n    74→                missing = f\"缺失: {', '.join(missing_keys)}\" if missing_keys else \"\"\n    75→                detail = message or \"API密钥未配置\"\n    76→                return self._failure(detail if not missing else f\"{detail}（{missing}）\")\n    77→        except Exception as cfg_err:\n    78→            return self._failure(f\"配置检查失败: {cfg_err}\")\n    79→\n    80→        if self._is_cancelled(should_cancel):\n    81→            logger.info(\"用户取消了视频生成: 配置检查后\")\n    82→            return self._cancelled()\n    83→\n    84→        watermark_settings = self._apply_watermark_config(params)\n    85→        watermark_enabled = watermark_settings[\"watermark_enabled\"]\n    86→\n    87→        try:\n    88→            api_key = self.unified_config.get_api_key(\"volcengine\")\n    89→            manager = self._seedance_manager_factory(api_key)\n    90→            self._emit_progress(progress_callback, \"Seedance 管理器初始化成功\", percentage=5.0)\n    91→        except Exception as init_err:\n    92→            logger.error(f\"Seedance 管理器初始化失败: {init_err}\")\n    93→            return self._failure(f\"Seedance管理器初始化失败: {init_err}\")\n    94→\n    95→        if self._is_cancelled(should_cancel):\n    96→            logger.info(\"用户取消了视频生成: 管理器初始化后\")\n    97→            return self._cancelled()\n    98→\n    99→        duration = self._safe_int(params.get(\"duration\", 5), default=5, minimum=1)\n   100→        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n   101→        fps = self._safe_int(params.get(\"fps\", 24), default=24, minimum=1)\n   102→        ratio = params.get(\"ratio\", \"16:9\")\n   103→        resolution_grade = params.get(\"resolution_grade\", \"1080p\")\n   104→        camera_fixed = bool(params.get(\"camera_fixed\", True))\n   105→        model_type = params.get(\"model_type\", \"pro\")\n   106→        model_variant = params.get(\"model_variant\") or \"seedance_pro\"\n   107→\n   108→        first_frame = params.get(\"first_frame\")\n   109→        last_frame = params.get(\"last_frame\")\n   110→        input_image = params.get(\"image_path\") or params.get(\"input_image\")\n   111→        reference_images = params.get(\"reference_images\") or params.get(\"reference_assets\") or []\n   112→        schema_values = params.get(\"schema_values\") or {}\n   113→\n   114→        self._emit_progress(progress_callback, \"正在创建视频生成任务...\", percentage=10.0)\n   115→        try:\n   116→            create_result = manager.generate_video(\n   117→                prompt=prompt,\n   118→                first_frame_path=first_frame if first_frame and last_frame else None,\n   119→                last_frame_path=last_frame if first_frame and last_frame else None,\n   120→                image_path=None if (first_frame and last_frame) else (first_frame or input_image),\n   121→                duration=duration,\n   122→                seed=seed if seed >= 0 else -1,\n   123→                resolution_grade=resolution_grade,\n   124→                ratio=ratio,\n   125→                fps=fps,\n   126→                watermark=watermark_enabled,\n   127→                camera_fixed=camera_fixed,\n   128→                use_pro_model=(model_type in (\"pro\", \"pro_fast\")),\n   129→                model_type=model_type,\n   130→                save_local=False,\n   131→                wait_for_completion=False,\n   132→                reference_images=reference_images,\n   133→                generation_id=task_id,\n   134→            )\n   135→        except Exception as api_err:\n   136→            logger.error(f\"调用 Seedance API 创建任务失败: {api_err}\")\n   137→            return self._failure(f\"创建任务失败: {api_err}\")\n   138→\n   139→        api_task_id = create_result.get(\"api_task_id\") or create_result.get(\"task_id\") or api_task_id\n   140→        task_id = task_id or create_result.get(\"task_id\")\n   141→\n   142→        if self._is_cancelled(should_cancel):\n   143→            self._request_remote_cancel(manager, api_task_id)\n   144→            logger.info(\"用户取消了视频生成: 任务创建后\")\n   145→            return self._cancelled()\n   146→\n   147→        if not create_result.get(\"success\"):\n   148→            return self._failure(create_result.get(\"error\", \"创建任务失败\"))\n   149→\n   150→        if not api_task_id:\n   151→            return self._failure(\"未获取到服务端任务ID\")\n   152→\n   153→        if not task_id:\n   154→            return self._failure(\"未获取到任务ID\")\n   155→\n   156→        if create_result.get(\"fallback_applied\"):\n   157→            logger.warning(f\"视频生成参数已自动回退: {create_result.get('fallback_reason', '')}\")\n   158→\n   159→        status_result = self._poll_task(manager, api_task_id, progress_callback, should_cancel)\n   160→        if not status_result.get(\"success\"):\n   161→            return status_result\n   162→\n   163→        if task_id:\n   164→            status_result[\"task_id\"] = task_id\n   165→        if api_task_id:\n   166→            status_result[\"api_task_id\"] = api_task_id\n   167→\n   168→        complete_result = self._build_complete_result(\n   169→            create_result=create_result,\n   170→            status_result=status_result,\n   171→            params=params,\n   172→            watermark_settings=watermark_settings,\n   173→            schema_values=schema_values,\n   174→            reference_images=reference_images,\n   175→            model_variant=model_variant,\n   176→            model_type=model_type,\n   177→            duration=duration,\n   178→            fps=fps,\n   179→            seed=seed,\n   180→        )\n   181→\n   182→        if self._is_cancelled(should_cancel):\n   183→            logger.info(\"用户取消了视频生成: 保存结果前\")\n   184→            return self._cancelled()\n   185→\n   186→        return self._save_result(manager, complete_result)\n   187→\n   188→    # ------------------------------------------------------------------\n   189→    # 内部工具方法\n   190→    # ------------------------------------------------------------------\n   191→    def _poll_task(\n   192→        self,\n   193→        manager: SeedanceManager,\n   194→        task_id: str,\n   195→        progress_callback: ProgressCallback,\n   196→        should_cancel: CancelCallback,\n   197→        max_wait_seconds: int = 600,\n   198→    ) -> Dict[str, Any]:\n   199→        start_time = time.time()\n   200→        intervals = [2, 3, 5, 8, 10]\n   201→        attempt = 0\n   202→\n   203→        while time.time() - start_time < max_wait_seconds:\n   204→            if self._is_cancelled(should_cancel):\n   205→                self._request_remote_cancel(manager, task_id)\n   206→                logger.info(\"用户取消了视频生成任务\")\n   207→                return self._cancelled()\n   208→\n   209→            status_result = manager.client.query_video_task(task_id)\n   210→\n   211→            if not status_result.get(\"success\"):\n   212→                return self._failure(f\"查询任务状态失败: {status_result.get('error', '未知错误')}\")\n   213→\n   214→            status = status_result.get(\"status\")\n   215→            elapsed = time.time() - start_time\n   216→            progress = min(int((elapsed / max_wait_seconds) * 100), 95)\n   217→            self._emit_progress(progress_callback, f\"任务状态: {status}\", percentage=progress)\n   218→\n   219→            if status == \"succeeded\":\n   220→                self._emit_progress(progress_callback, \"视频生成完成\", percentage=100.0)\n   221→                status_result[\"success\"] = True\n   222→                status_result[\"task_id\"] = status_result.get(\"task_id\") or task_id\n   223→                return status_result\n   224→            if status == \"failed\":\n   225→                return self._failure(\"视频生成失败\")\n   226→            if status == \"cancelled\":\n   227→                return self._failure(\"任务被取消\")\n   228→\n   229→            interval = intervals[min(attempt, len(intervals) - 1)]\n   230→            time.sleep(interval)\n   231→            attempt += 1\n   232→\n   233→        return self._failure(\"视频生成超时\")\n   234→\n   235→    def _build_complete_result(\n   236→        self,\n   237→        create_result: Dict[str, Any],\n   238→        status_result: Dict[str, Any],\n   239→        params: Dict[str, Any],\n   240→        watermark_settings: Dict[str, Any],\n   241→        schema_values: Dict[str, Any],\n   242→        reference_images: Any,\n   243→        model_variant: str,\n   244→        model_type: str,\n   245→        duration: int,\n   246→        fps: int,\n   247→        seed: int,\n   248→    ) -> Dict[str, Any]:\n   249→        task_id = status_result.get(\"task_id\") or create_result.get(\"task_id\")\n   250→        video_url = status_result.get(\"video_url\")\n   251→        thumbnail_url = status_result.get(\"thumbnail_url\", \"\")\n   252→        preview_url = status_result.get(\"preview_url\", \"\")\n   253→        ref_assets = (\n   254→            status_result.get(\"reference_assets\")\n   255→            or create_result.get(\"reference_assets\")\n   256→            or status_result.get(\"parameters\", {}).get(\"reference_assets\")\n   257→            or reference_images\n   258→            or []\n   259→        )\n   260→\n   261→        now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n   262→\n   263→        parameters = {\n   264→            \"prompt\": params.get(\"prompt\", \"\"),\n   265→            \"resolution_grade\": params.get(\"resolution_grade\", \"1080p\"),\n   266→            \"ratio\": params.get(\"ratio\", \"16:9\"),\n   267→            \"duration\": duration,\n   268→            \"fps\": fps,\n   269→            \"watermark\": watermark_settings.get(\"watermark_enabled\", False),\n   270→            \"watermark_text\": watermark_settings.get(\"watermark_text\", \"\"),\n   271→            \"watermark_opacity\": watermark_settings.get(\"watermark_opacity\", 0.0),\n   272→            \"watermark_position\": watermark_settings.get(\"watermark_position\", \"bottom_right\"),\n   273→            \"watermark_font_size\": watermark_settings.get(\"watermark_font_size\", 0),\n   274→            \"camera_fixed\": bool(params.get(\"camera_fixed\", True)),\n   275→            \"seed\": None if seed < 0 else seed,\n   276→            \"model_type\": model_type,\n   277→            \"model_variant\": model_variant,\n   278→            \"first_frame\": params.get(\"first_frame\"),\n   279→            \"last_frame\": params.get(\"last_frame\"),\n   280→            \"image_path\": params.get(\"image_path\") or params.get(\"input_image\"),\n   281→            \"reference_assets\": ref_assets,\n   282→        }\n   283→        if schema_values:\n   284→            parameters[\"schema_values\"] = dict(schema_values)\n   285→\n   286→        parameters.update(status_result.get(\"parameters\", {}))\n   287→\n   288→        complete_result: Dict[str, Any] = {\n   289→            \"success\": True,\n   290→            \"task_id\": task_id,\n   291→            \"api_task_id\": status_result.get(\"api_task_id\") or create_result.get(\"api_task_id\"),\n   292→            \"video_url\": video_url,\n   293→            \"thumbnail_url\": thumbnail_url,\n   294→            \"preview_url\": preview_url,\n   295→            \"status\": status_result.get(\"status\", \"success\"),\n   296→            \"type\": \"video\",\n   297→            \"input_image\": params.get(\"first_frame\", \"\") or params.get(\"image_path\") or \"\",\n   298→            \"parameters\": parameters,\n   299→            \"created_at\": now,\n   300→            \"completed_at\": now,\n   301→        }\n   302→\n   303→        complete_result[\"reference_assets\"] = ref_assets\n   304→\n   305→        if create_result.get(\"fallback_applied\"):\n   306→            complete_result[\"fallback_applied\"] = True\n   307→            complete_result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n   308→\n   309→        return complete_result\n   310→\n   311→    def _save_result(self, manager: SeedanceManager, complete_result: Dict[str, Any]) -> Dict[str, Any]:\n   312→        try:\n   313→            local_result = manager._save_video_locally(complete_result)\n   314→        except Exception as save_err:  # pylint: disable=broad-except\n   315→            logger.error(f\"保存视频失败: {save_err}\")\n   316→            return self._failure(f\"保存视频失败: {save_err}\")\n   317→\n   318→        if not isinstance(local_result, dict):\n   319→            return self._failure(\"视频保存返回无效结果\")\n   320→\n   321→        if local_result.get(\"local_save_error\"):\n   322→            return self._failure(f\"视频保存失败: {local_result['local_save_error']}\")\n   323→\n   324→        merged = {**complete_result, **local_result}\n   325→        merged[\"success\"] = True\n   326→        return merged\n   327→\n   328→    def _apply_watermark_config(self, params: Dict[str, Any]) -> Dict[str, Any]:\n   329→        \"\"\"\n   330→        统一应用水印配置，优先使用传入配置，其次使用 config_api.LOCAL_WATERMARK_CONFIG。\n   331→        \"\"\"\n   332→        watermark_config = params.get(\"watermark_config\", self.unified_config.get_watermark_config())\n   333→        normalized = {\n   334→            \"watermark_enabled\": watermark_config.get(\"enabled\", False),\n   335→            \"watermark_text\": watermark_config.get(\"text\", \"\"),\n   336→            \"watermark_opacity\": watermark_config.get(\"opacity\", 0.0),\n   337→            \"watermark_position\": watermark_config.get(\"position\", \"bottom_right\"),\n   338→            \"watermark_font_size\": watermark_config.get(\"font_size\", 0),\n   339→        }\n   340→        logger.info(\n   341→            \"视频水印配置应用: enabled=%s text=%s opacity=%s position=%s font_size=%s\",\n   342→            normalized[\"watermark_enabled\"],\n   343→            normalized[\"watermark_text\"],\n   344→            normalized[\"watermark_opacity\"],\n   345→            normalized[\"watermark_position\"],\n   346→            normalized[\"watermark_font_size\"],\n   347→        )\n   348→        return normalized\n   349→\n   350→    @staticmethod\n   351→    def _emit_progress(callback: ProgressCallback, message: str, percentage: Optional[float] = None) -> None:\n   352→        if callback:\n   353→            try:\n   354→                callback(percentage, message)\n   355→            except Exception:\n   356→                logger.debug(\"进度回调执行失败，已忽略。\")\n   357→\n   358→    @staticmethod\n   359→    def _failure(message: str) -> Dict[str, Any]:\n   360→        return {\"success\": False, \"error\": message}\n   361→\n   362→    @staticmethod\n   363→    def _is_cancelled(should_cancel: CancelCallback) -> bool:\n   364→        return bool(should_cancel and callable(should_cancel) and should_cancel())\n   365→\n   366→    @staticmethod\n   367→    def _cancelled() -> Dict[str, Any]:\n   368→        return {\"success\": False, \"error\": \"用户已取消操作\"}\n   369→\n   370→    def _request_remote_cancel(self, manager: Optional[SeedanceManager], task_id: Optional[str]) -> None:\n   371→        \"\"\"尝试向服务端发送取消任务请求，失败时仅记录日志。\"\"\"\n   372→        if not manager or not task_id:\n   373→            return\n   374→\n   375→        try:\n   376→            cancel_result = manager.client.cancel_task(task_id)\n   377→            if cancel_result.get(\"success\"):\n   378→                logger.info(f\"已向服务端成功发送取消请求: {task_id}\")\n   379→            else:\n   380→                logger.warning(\n   381→                    f\"服务端取消请求失败（任务可能已在running状态）: {cancel_result.get('error', '未知错误')}\"\n   382→                )\n   383→        except Exception as exc:  # pylint: disable=broad-except\n   384→            logger.warning(f\"服务端取消请求异常: {exc}\")\n   385→\n   386→    @staticmethod\n   387→    def _safe_int(value: Any, default: int = 0, minimum: Optional[int] = None) -> int:\n   388→        try:\n   389→            parsed = int(value)\n   390→            if minimum is not None:\n   391→                parsed = max(parsed, minimum)\n   392→            return parsed\n   393→        except Exception:\n   394→            return default\n   395→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"424a2a55-1eb7-41cc-b358-7cddab15af3b","timestamp":"2025-12-11T08:09:27.073Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/services/video_service.py","content":"\"\"\"Seedance 视频生成服务层，实现与 UI 解耦并统一水印逻辑。\"\"\"\n\nfrom __future__ import annotations\n\nimport time\nfrom datetime import datetime\nfrom typing import Any, Callable, Dict, Optional\n\nfrom config.unified_config import get_unified_config\nfrom modules.repository.manager import RepositoryManager\nfrom modules.seedance.manager import SeedanceManager\nfrom utils.logger import logger\n\nProgressCallback = Optional[Callable[[Optional[float], str], None]]\nCancelCallback = Optional[Callable[[], bool]]\n\n\nclass VideoService:\n    \"\"\"封装 Seedance 视频生成的业务逻辑与水印处理。\"\"\"\n\n    def __init__(\n        self,\n        repository_manager: Optional[RepositoryManager] = None,\n        seedance_manager_factory: Optional[Callable[[Optional[str]], SeedanceManager]] = None,\n    ) -> None:\n        \"\"\"\n        初始化服务层并注入依赖。\n\n        Args:\n            repository_manager: 历史记录仓库管理器。\n            seedance_manager_factory: SeedanceManager 工厂，便于测试替身。\n        \"\"\"\n        # 使用统一配置\n        self.unified_config = get_unified_config()\n\n        self.repository_manager = repository_manager\n        self._seedance_manager_factory = seedance_manager_factory or (lambda api_key=None: SeedanceManager(api_key))\n\n    # ------------------------------------------------------------------\n    # 公共接口\n    # ------------------------------------------------------------------\n    def generate_video(\n        self,\n        params: Dict[str, Any],\n        progress_callback: ProgressCallback = None,\n        should_cancel: CancelCallback = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        统一的视频生成入口。\n\n        Args:\n            params: 视频生成参数，兼容 VideoModeWidget 的字段集合。\n            progress_callback: 进度回调函数，形如 callback(percentage, message)。\n\n        Returns:\n            生成结果字典，包含 success / error / local_path 等信息。\n        \"\"\"\n        task_id: Optional[str] = params.get(\"generation_id\")\n        api_task_id: Optional[str] = None\n\n        prompt = (params.get(\"prompt\") or \"\").strip()\n        if not prompt:\n            return self._failure(\"提示词不能为空\")\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 初始化前\")\n            return self._cancelled()\n\n        self._emit_progress(progress_callback, \"正在初始化视频生成...\")\n\n        try:\n            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n            if not is_valid:\n                missing = f\"缺失: {', '.join(missing_keys)}\" if missing_keys else \"\"\n                detail = message or \"API密钥未配置\"\n                return self._failure(detail if not missing else f\"{detail}（{missing}）\")\n        except Exception as cfg_err:\n            return self._failure(f\"配置检查失败: {cfg_err}\")\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 配置检查后\")\n            return self._cancelled()\n\n        watermark_settings = self._apply_watermark_config(params)\n        watermark_enabled = watermark_settings[\"watermark_enabled\"]\n\n        try:\n            api_key = self.unified_config.get_api_key(\"volcengine\")\n            manager = self._seedance_manager_factory(api_key)\n            self._emit_progress(progress_callback, \"Seedance 管理器初始化成功\", percentage=5.0)\n        except Exception as init_err:\n            logger.error(f\"Seedance 管理器初始化失败: {init_err}\")\n            return self._failure(f\"Seedance管理器初始化失败: {init_err}\")\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 管理器初始化后\")\n            return self._cancelled()\n\n        duration = self._safe_int(params.get(\"duration\", 5), default=5, minimum=1)\n        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n        fps = self._safe_int(params.get(\"fps\", 24), default=24, minimum=1)\n        ratio = params.get(\"ratio\", \"16:9\")\n        resolution_grade = params.get(\"resolution_grade\", \"1080p\")\n        camera_fixed = bool(params.get(\"camera_fixed\", True))\n        model_type = params.get(\"model_type\", \"pro\")\n        model_variant = params.get(\"model_variant\") or \"seedance_pro\"\n\n        first_frame = params.get(\"first_frame\")\n        last_frame = params.get(\"last_frame\")\n        input_image = params.get(\"image_path\") or params.get(\"input_image\")\n        reference_images = params.get(\"reference_images\") or params.get(\"reference_assets\") or []\n        schema_values = params.get(\"schema_values\") or {}\n\n        self._emit_progress(progress_callback, \"正在创建视频生成任务...\", percentage=10.0)\n        try:\n            create_result = manager.generate_video(\n                prompt=prompt,\n                first_frame_path=first_frame if first_frame and last_frame else None,\n                last_frame_path=last_frame if first_frame and last_frame else None,\n                image_path=None if (first_frame and last_frame) else (first_frame or input_image),\n                duration=duration,\n                seed=seed if seed >= 0 else -1,\n                resolution_grade=resolution_grade,\n                ratio=ratio,\n                fps=fps,\n                watermark=watermark_enabled,\n                camera_fixed=camera_fixed,\n                use_pro_model=(model_type in (\"pro\", \"pro_fast\")),\n                model_type=model_type,\n                save_local=False,\n                wait_for_completion=False,\n                reference_images=reference_images,\n                generation_id=task_id,\n            )\n        except Exception as api_err:\n            logger.error(f\"调用 Seedance API 创建任务失败: {api_err}\")\n            return self._failure(f\"创建任务失败: {api_err}\")\n\n        api_task_id = create_result.get(\"api_task_id\") or create_result.get(\"task_id\") or api_task_id\n        task_id = task_id or create_result.get(\"task_id\")\n\n        if self._is_cancelled(should_cancel):\n            self._request_remote_cancel(manager, api_task_id)\n            logger.info(\"用户取消了视频生成: 任务创建后\")\n            return self._cancelled()\n\n        if not create_result.get(\"success\"):\n            return self._failure(create_result.get(\"error\", \"创建任务失败\"))\n\n        if not api_task_id:\n            return self._failure(\"未获取到服务端任务ID\")\n\n        if not task_id:\n            return self._failure(\"未获取到任务ID\")\n\n        if create_result.get(\"fallback_applied\"):\n            logger.warning(f\"视频生成参数已自动回退: {create_result.get('fallback_reason', '')}\")\n\n        status_result = self._poll_task(manager, api_task_id, progress_callback, should_cancel)\n        if not status_result.get(\"success\"):\n            return status_result\n\n        if task_id:\n            status_result[\"task_id\"] = task_id\n        if api_task_id:\n            status_result[\"api_task_id\"] = api_task_id\n\n        complete_result = self._build_complete_result(\n            create_result=create_result,\n            status_result=status_result,\n            params=params,\n            watermark_settings=watermark_settings,\n            schema_values=schema_values,\n            reference_images=reference_images,\n            model_variant=model_variant,\n            model_type=model_type,\n            duration=duration,\n            fps=fps,\n            seed=seed,\n        )\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 保存结果前\")\n            return self._cancelled()\n\n        return self._save_result(manager, complete_result)\n\n    # ------------------------------------------------------------------\n    # 内部工具方法\n    # ------------------------------------------------------------------\n    def _poll_task(\n        self,\n        manager: SeedanceManager,\n        task_id: str,\n        progress_callback: ProgressCallback,\n        should_cancel: CancelCallback,\n        max_wait_seconds: int = 600,\n    ) -> Dict[str, Any]:\n        start_time = time.time()\n        intervals = [2, 3, 5, 8, 10]\n        attempt = 0\n\n        while time.time() - start_time < max_wait_seconds:\n            if self._is_cancelled(should_cancel):\n                self._request_remote_cancel(manager, task_id)\n                logger.info(\"用户取消了视频生成任务\")\n                return self._cancelled()\n\n            status_result = manager.client.query_video_task(task_id)\n\n            if not status_result.get(\"success\"):\n                return self._failure(f\"查询任务状态失败: {status_result.get('error', '未知错误')}\")\n\n            status = status_result.get(\"status\")\n            elapsed = time.time() - start_time\n            progress = min(int((elapsed / max_wait_seconds) * 100), 95)\n            self._emit_progress(progress_callback, f\"任务状态: {status}\", percentage=progress)\n\n            if status == \"succeeded\":\n                self._emit_progress(progress_callback, \"视频生成完成\", percentage=100.0)\n                status_result[\"success\"] = True\n                status_result[\"task_id\"] = status_result.get(\"task_id\") or task_id\n                return status_result\n            if status == \"failed\":\n                return self._failure(\"视频生成失败\")\n            if status == \"cancelled\":\n                return self._failure(\"任务被取消\")\n\n            interval = intervals[min(attempt, len(intervals) - 1)]\n            time.sleep(interval)\n            attempt += 1\n\n        return self._failure(\"视频生成超时\")\n\n    def _build_complete_result(\n        self,\n        create_result: Dict[str, Any],\n        status_result: Dict[str, Any],\n        params: Dict[str, Any],\n        watermark_settings: Dict[str, Any],\n        schema_values: Dict[str, Any],\n        reference_images: Any,\n        model_variant: str,\n        model_type: str,\n        duration: int,\n        fps: int,\n        seed: int,\n    ) -> Dict[str, Any]:\n        task_id = status_result.get(\"task_id\") or create_result.get(\"task_id\")\n        video_url = status_result.get(\"video_url\")\n        thumbnail_url = status_result.get(\"thumbnail_url\", \"\")\n        preview_url = status_result.get(\"preview_url\", \"\")\n        ref_assets = (\n            status_result.get(\"reference_assets\")\n            or create_result.get(\"reference_assets\")\n            or status_result.get(\"parameters\", {}).get(\"reference_assets\")\n            or reference_images\n            or []\n        )\n\n        now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        parameters = {\n            \"prompt\": params.get(\"prompt\", \"\"),\n            \"resolution_grade\": params.get(\"resolution_grade\", \"1080p\"),\n            \"ratio\": params.get(\"ratio\", \"16:9\"),\n            \"duration\": duration,\n            \"fps\": fps,\n            \"watermark\": watermark_settings.get(\"watermark_enabled\", False),\n            \"watermark_text\": watermark_settings.get(\"watermark_text\", \"\"),\n            \"watermark_opacity\": watermark_settings.get(\"watermark_opacity\", 0.0),\n            \"watermark_position\": watermark_settings.get(\"watermark_position\", \"bottom_right\"),\n            \"watermark_font_size\": watermark_settings.get(\"watermark_font_size\", 0),\n            \"camera_fixed\": bool(params.get(\"camera_fixed\", True)),\n            \"seed\": None if seed < 0 else seed,\n            \"model_type\": model_type,\n            \"model_variant\": model_variant,\n            \"first_frame\": params.get(\"first_frame\"),\n            \"last_frame\": params.get(\"last_frame\"),\n            \"image_path\": params.get(\"image_path\") or params.get(\"input_image\"),\n            \"reference_assets\": ref_assets,\n        }\n        if schema_values:\n            parameters[\"schema_values\"] = dict(schema_values)\n\n        parameters.update(status_result.get(\"parameters\", {}))\n\n        complete_result: Dict[str, Any] = {\n            \"success\": True,\n            \"task_id\": task_id,\n            \"api_task_id\": status_result.get(\"api_task_id\") or create_result.get(\"api_task_id\"),\n            \"video_url\": video_url,\n            \"thumbnail_url\": thumbnail_url,\n            \"preview_url\": preview_url,\n            \"status\": status_result.get(\"status\", \"success\"),\n            \"type\": \"video\",\n            \"input_image\": params.get(\"first_frame\", \"\") or params.get(\"image_path\") or \"\",\n            \"parameters\": parameters,\n            \"created_at\": now,\n            \"completed_at\": now,\n        }\n\n        complete_result[\"reference_assets\"] = ref_assets\n\n        if create_result.get(\"fallback_applied\"):\n            complete_result[\"fallback_applied\"] = True\n            complete_result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n\n        return complete_result\n\n    def _save_result(self, manager: SeedanceManager, complete_result: Dict[str, Any]) -> Dict[str, Any]:\n        try:\n            local_result = manager._save_video_locally(complete_result)\n        except Exception as save_err:  # pylint: disable=broad-except\n            logger.error(f\"保存视频失败: {save_err}\")\n            return self._failure(f\"保存视频失败: {save_err}\")\n\n        if not isinstance(local_result, dict):\n            return self._failure(\"视频保存返回无效结果\")\n\n        if local_result.get(\"local_save_error\"):\n            return self._failure(f\"视频保存失败: {local_result['local_save_error']}\")\n\n        merged = {**complete_result, **local_result}\n        merged[\"success\"] = True\n        return merged\n\n    def _apply_watermark_config(self, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        统一应用水印配置，优先使用传入配置，其次使用 config_api.LOCAL_WATERMARK_CONFIG。\n        \"\"\"\n        watermark_config = params.get(\"watermark_config\", self.unified_config.get_watermark_config())\n        normalized = {\n            \"watermark_enabled\": watermark_config.get(\"enabled\", False),\n            \"watermark_text\": watermark_config.get(\"text\", \"\"),\n            \"watermark_opacity\": watermark_config.get(\"opacity\", 0.0),\n            \"watermark_position\": watermark_config.get(\"position\", \"bottom_right\"),\n            \"watermark_font_size\": watermark_config.get(\"font_size\", 0),\n        }\n        logger.info(\n            \"视频水印配置应用: enabled=%s text=%s opacity=%s position=%s font_size=%s\",\n            normalized[\"watermark_enabled\"],\n            normalized[\"watermark_text\"],\n            normalized[\"watermark_opacity\"],\n            normalized[\"watermark_position\"],\n            normalized[\"watermark_font_size\"],\n        )\n        return normalized\n\n    @staticmethod\n    def _emit_progress(callback: ProgressCallback, message: str, percentage: Optional[float] = None) -> None:\n        if callback:\n            try:\n                callback(percentage, message)\n            except Exception:\n                logger.debug(\"进度回调执行失败，已忽略。\")\n\n    @staticmethod\n    def _failure(message: str) -> Dict[str, Any]:\n        return {\"success\": False, \"error\": message}\n\n    @staticmethod\n    def _is_cancelled(should_cancel: CancelCallback) -> bool:\n        return bool(should_cancel and callable(should_cancel) and should_cancel())\n\n    @staticmethod\n    def _cancelled() -> Dict[str, Any]:\n        return {\"success\": False, \"error\": \"用户已取消操作\"}\n\n    def _request_remote_cancel(self, manager: Optional[SeedanceManager], task_id: Optional[str]) -> None:\n        \"\"\"尝试向服务端发送取消任务请求，失败时仅记录日志。\"\"\"\n        if not manager or not task_id:\n            return\n\n        try:\n            cancel_result = manager.client.cancel_task(task_id)\n            if cancel_result.get(\"success\"):\n                logger.info(f\"已向服务端成功发送取消请求: {task_id}\")\n            else:\n                logger.warning(\n                    f\"服务端取消请求失败（任务可能已在running状态）: {cancel_result.get('error', '未知错误')}\"\n                )\n        except Exception as exc:  # pylint: disable=broad-except\n            logger.warning(f\"服务端取消请求异常: {exc}\")\n\n    @staticmethod\n    def _safe_int(value: Any, default: int = 0, minimum: Optional[int] = None) -> int:\n        try:\n            parsed = int(value)\n            if minimum is not None:\n                parsed = max(parsed, minimum)\n            return parsed\n        except Exception:\n            return default\n","numLines":395,"startLine":1,"totalLines":395}}}
{"parentUuid":"424a2a55-1eb7-41cc-b358-7cddab15af3b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DQFY3jiHsspS4QpFKcAAnF","type":"tool_result","content":"     1→# Seedance视频生成管理器\n     2→# 负责视频生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→import base64\n    13→import pandas as pd\n    14→from datetime import datetime\n    15→from pathlib import Path\n    16→from typing import Dict, Any, List, Optional, Tuple\n    17→from urllib.parse import urlparse\n    18→from loguru import logger\n    19→from PIL import Image\n    20→\n    21→from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n    22→\n    23→from .client import SeedanceClient\n    24→from ..storage import get_v2_storage_manager\n    25→from ..provider.schema import (\n    26→    VideoParams,\n    27→    validate_and_normalize_video,\n    28→)\n    29→from config.unified_config import get_unified_config\n    30→from config_api import get_storage_dir\n    31→# 使用统一水印服务（edition/watermark_service.py）\n    32→from edition.watermark_service import (\n    33→    should_add_watermark,\n    34→    get_watermark_text,\n    35→    get_watermark_opacity,\n    36→)\n    37→\n    38→# API水印配置保持不变（用于服务端水印）\n    39→try:  # pragma: no cover\n    40→    from config_api import API_WATERMARK_CONFIG  # type: ignore\n    41→except Exception:  # pragma: no cover\n    42→    API_WATERMARK_CONFIG = {\n    43→        \"image_watermark\": False,\n    44→        \"video_watermark\": False,\n    45→    }\n    46→try:  # pragma: no cover\n    47→    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\n    48→except Exception:  # pragma: no cover\n    49→    LOCAL_WATERMARK_CONFIG = {\n    50→        \"enabled\": False,\n    51→        \"text\": \"\",\n    52→        \"opacity\": 0.0,\n    53→        \"position\": \"bottom_right\",\n    54→        \"font_size\": 0,\n    55→    }\n    56→\n    57→\n    58→class SeedanceManager:\n    59→    \"\"\"Seedance视频生成管理器\"\"\"\n    60→\n    61→    def __init__(self, api_key: str = None):\n    62→        \"\"\"\n    63→        初始化Seedance管理器\n    64→\n    65→        Args:\n    66→            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n    67→        \"\"\"\n    68→        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n    69→        if api_key is None:\n    70→            try:\n    71→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    72→            except Exception as exc:\n    73→                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n    74→        \n    75→        self.client = SeedanceClient(api_key)\n    76→        \n    77→        # 使用V2统一存储管理器（与单一真源对齐）\n    78→        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n    79→        \n    80→        # 保持兼容性别名\n    81→        self.file_manager = self.storage_manager\n    82→        self.metadata_manager = self.storage_manager\n    83→        self.video_storage_manager = self.storage_manager\n    84→        \n    85→        # 保留原有的目录属性以保持兼容性\n    86→        self.data_dir = Path(self.storage_manager.root_path)\n    87→        self.videos_dir = self.data_dir / \"videos\"\n    88→        self.metadata_dir = self.data_dir / \"metadata\"\n    89→\n    90→        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    91→\n    92→    def generate_video(\n    93→        self,\n    94→        prompt: str,\n    95→        image_path: Optional[str] = None,\n    96→        first_frame_path: Optional[str] = None,\n    97→        last_frame_path: Optional[str] = None,\n    98→        duration: float = 4.0,\n    99→        seed: int = -1,\n   100→        watermark: bool = False,\n   101→        save_local: bool = True,\n   102→        wait_for_completion: bool = True,\n   103→        # 新增参数（P0b）\n   104→        resolution_grade: Optional[str] = None,\n   105→        ratio: Optional[str] = None,\n   106→        fps: int = 24,\n   107→        camera_fixed: bool = True,\n   108→        use_pro_model: bool = True,\n   109→        model_type: Optional[str] = None,\n   110→        reference_images: Optional[List[Any]] = None,\n   111→        generation_id: Optional[str] = None,\n   112→    ) -> Dict[str, Any]:\n   113→        \"\"\"\n   114→        生成视频并保存到本地\n   115→\n   116→        Args:\n   117→            image_path: 输入图像路径\n   118→            duration: 视频时长（秒）\n   119→            motion_strength: 运动强度 (0.1-1.0)\n   120→            seed: 随机种子\n   121→            watermark: 保留参数（服务端水印由配置决定）\n   122→            save_local: 是否保存到本地\n   123→            wait_for_completion: 是否等待任务完成\n   124→\n   125→        Returns:\n   126→            Dict: 生成结果\n   127→        \"\"\"\n   128→        logger.info(\"开始视频生成任务(Manager)\")\n   129→\n   130→        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n   131→        task_id = generation_id or str(uuid.uuid4())\n   132→\n   133→        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n   134→        # 构建待处理的图片列表\n   135→        all_input_images = []\n   136→\n   137→        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n   138→        frame_inputs = []\n   139→        if first_frame_path:\n   140→            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n   141→        if last_frame_path:\n   142→            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n   143→        elif image_path and not first_frame_path:\n   144→            frame_inputs.append({'path': image_path, 'type': 'image'})\n   145→\n   146→        all_input_images.extend(frame_inputs)\n   147→\n   148→        # 2. 添加参考图\n   149→        if reference_images:\n   150→            for ref in reference_images:\n   151→                if isinstance(ref, dict):\n   152→                    ref_copy = dict(ref)\n   153→                    ref_copy['type'] = ref_copy.get('type', 'reference')\n   154→                    all_input_images.append(ref_copy)\n   155→                else:\n   156→                    all_input_images.append({'path': ref, 'type': 'reference'})\n   157→\n   158→        # 3. 统一处理（复制到 references 目录）\n   159→        ref_summary = self._process_reference_assets(\n   160→            all_input_images if all_input_images else None,\n   161→            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n   162→            expected_outputs=1,\n   163→        )\n   164→        ref_assets = ref_summary.get('assets', [])\n   165→        ref_paths: List[str] = list(ref_summary.get('paths', []))\n   166→\n   167→        # 4. 分离帧图片和参考图\n   168→        frame_assets = {}\n   169→        pure_ref_assets = []\n   170→        for asset in ref_assets:\n   171→            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n   172→            if asset_type in ('first_frame', 'last_frame', 'image'):\n   173→                frame_assets[asset_type] = asset\n   174→            else:\n   175→                pure_ref_assets.append(asset)\n   176→\n   177→        # 5. 提取帧图片的相对路径（用于存储）\n   178→        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n   179→        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n   180→        stored_image_path = frame_assets.get('image', {}).get('path')\n   181→\n   182→        # 6. 提取参考图的 payload（用于 API 调用）\n   183→        ref_payloads: List[str] = []\n   184→        for asset in pure_ref_assets:\n   185→            payload = asset.get('_payload_b64')\n   186→            if payload:\n   187→                ref_payloads.append(payload)\n   188→\n   189→        if ref_summary.get('errors'):\n   190→            logger.warning(\n   191→                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   192→            )\n   193→        if ref_summary.get('warnings'):\n   194→            for warn in ref_summary['warnings']:\n   195→                logger.warning(f\"图片处理提示: {warn}\")\n   196→\n   197→        watermark_enabled = bool(\n   198→            LOCAL_WATERMARK_CONFIG.get(\"enabled\", API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n   199→        )\n   200→\n   201→        create_kwargs = dict(\n   202→            prompt=prompt,\n   203→            duration=int(duration),\n   204→            seed=None if seed == -1 else seed,\n   205→            fps=fps,\n   206→            resolution_grade=resolution_grade,\n   207→            ratio=ratio,\n   208→            watermark=watermark_enabled,\n   209→            camera_fixed=bool(camera_fixed),\n   210→            use_pro_model=use_pro_model,\n   211→            model_type=model_type,\n   212→        )\n   213→        if ref_payloads:\n   214→            create_kwargs['reference_images'] = ref_payloads\n   215→        if first_frame_path and last_frame_path:\n   216→            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n   217→        elif image_path:\n   218→            create_kwargs.update(dict(image_path=image_path))\n   219→        # 文生视频：不追加图片参数\n   220→\n   221→        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n   222→        precheck_fb = False\n   223→        precheck_reason = \"\"\n   224→        try:\n   225→            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n   226→                VideoParams(\n   227→                    prompt=prompt,\n   228→                    image_path=None,  # 校验不依赖图像数据\n   229→                    first_frame_path=None,\n   230→                    last_frame_path=None,\n   231→                    duration=int(duration),\n   232→                    fps=int(fps),\n   233→                    seed=(None if seed == -1 else seed),\n   234→                    camera_fixed=bool(camera_fixed),\n   235→                    watermark=bool(watermark),\n   236→                    resolution_grade=resolution_grade,\n   237→                    ratio=ratio,\n   238→                    use_pro_model=bool(use_pro_model),\n   239→                )\n   240→            )\n   241→            logger.info(\n   242→                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   243→            )\n   244→            if fb:\n   245→                logger.warning(f\"前置参数回退建议: {reason}\")\n   246→            precheck_fb = fb\n   247→            precheck_reason = reason\n   248→        except Exception as _e:\n   249→            logger.debug(f\"前置参数校验跳过: {_e}\")\n   250→\n   251→        create_result = self.client.create_video_task(**create_kwargs)\n   252→\n   253→        if not create_result[\"success\"]:\n   254→            self._cleanup_reference_paths(ref_paths)\n   255→            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n   256→            return create_result\n   257→\n   258→        api_task_id = create_result[\"task_id\"]\n   259→\n   260→        result = {\n   261→            \"task_id\": task_id,\n   262→            \"api_task_id\": api_task_id,\n   263→            \"success\": True,\n   264→            \"type\": \"image_to_video\",\n   265→            \"input_image\": image_path,\n   266→            \"status\": \"pending\",\n   267→            \"parameters\": {\n   268→                \"prompt\": prompt,\n   269→                \"duration\": duration,\n   270→                \"seed\": (None if seed == -1 else seed),\n   271→                \"watermark\": watermark_enabled,\n   272→                \"resolution_grade\": resolution_grade,\n   273→                \"ratio\": ratio,\n   274→                \"fps\": fps,\n   275→                \"camera_fixed\": bool(camera_fixed),\n   276→                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n   277→                \"first_frame\": stored_first_frame,\n   278→                \"last_frame\": stored_last_frame,\n   279→                \"image_path\": stored_image_path,\n   280→            },\n   281→            \"created_at\": datetime.now().isoformat(),\n   282→        }\n   283→\n   284→        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   285→        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n   286→        result['reference_assets'] = sanitized_refs\n   287→        if ref_summary.get('errors'):\n   288→            result['reference_asset_errors'] = ref_summary['errors']\n   289→        if ref_summary.get('warnings'):\n   290→            result['reference_asset_warnings'] = ref_summary['warnings']\n   291→        if precheck_fb and precheck_reason:\n   292→            result.setdefault('fallback_applied', True)\n   293→            if result.get('fallback_reason'):\n   294→                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n   295→            else:\n   296→                result['fallback_reason'] = precheck_reason\n   297→\n   298→        masked_ids = self._summarize_reference_ids(sanitized_refs)\n   299→        logger.info(\n   300→            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n   301→            len(sanitized_refs),\n   302→            masked_ids or \"-\",\n   303→            self._provider_hint(),\n   304→        )\n   305→\n   306→        # 透传回退信息\n   307→        if create_result.get(\"fallback_applied\"):\n   308→            result[\"fallback_applied\"] = True\n   309→            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n   310→\n   311→        # 如果等待完成，轮询任务状态\n   312→        if wait_for_completion:\n   313→            completion_result = self.client.wait_for_completion(api_task_id)\n   314→\n   315→            if completion_result[\"success\"]:\n   316→                if completion_result[\"status\"] == \"success\":\n   317→                    result[\"status\"] = \"success\"\n   318→                    result[\"video_url\"] = completion_result[\"video_url\"]\n   319→                    result[\"duration\"] = completion_result.get(\"duration\")\n   320→                    result[\"file_size\"] = completion_result.get(\"file_size\")\n   321→                    result[\"completed_at\"] = datetime.now().isoformat()\n   322→\n   323→                    # 保存到本地\n   324→                    if save_local:\n   325→                        local_result = self._save_video_locally(result)\n   326→                        result.update(local_result)\n   327→                        if local_result.get('local_save_error'):\n   328→                            self._cleanup_reference_paths(ref_paths)\n   329→                            result['parameters'][\"reference_assets\"] = []\n   330→                            result['reference_assets'] = []\n   331→                            warnings = result.setdefault('reference_asset_warnings', [])\n   332→                            warnings.append(\"视频保存失败，参考图已回滚\")\n   333→                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   334→\n   335→                    logger.success(f\"视频生成任务完成: {task_id}\")\n   336→                else:\n   337→                    result[\"status\"] = completion_result[\"status\"]\n   338→                    result[\"error\"] = completion_result.get(\"error\")\n   339→                    result[\"error_code\"] = completion_result.get(\"error_code\")\n   340→                    logger.error(f\"视频生成任务失败: {result['error']}\")\n   341→            else:\n   342→                result[\"status\"] = \"failed\"\n   343→                result[\"error\"] = completion_result[\"error\"]\n   344→                result[\"error_code\"] = completion_result[\"error_code\"]\n   345→                logger.error(f\"等待任务完成失败: {result['error']}\")\n   346→\n   347→        # 记录元数据\n   348→        self._save_task_metadata(result)\n   349→\n   350→        return result\n   351→\n   352→    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n   353→        \"\"\"\n   354→        检查任务状态\n   355→\n   356→        Args:\n   357→            task_id: 本地任务ID\n   358→\n   359→        Returns:\n   360→            Dict: 任务状态信息\n   361→        \"\"\"\n   362→        logger.info(f\"检查任务状态: {task_id}\")\n   363→\n   364→        # 从元数据中获取任务信息\n   365→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   366→\n   367→        if not task_record:\n   368→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   369→\n   370→        api_task_id = task_record.get(\"api_task_id\")\n   371→        if not api_task_id:\n   372→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   373→\n   374→        # 查询API任务状态\n   375→        status_result = self.client.get_task_status(api_task_id)\n   376→\n   377→        if status_result[\"success\"]:\n   378→            # 更新本地记录\n   379→            updates = {\n   380→                \"status\": status_result[\"status\"],\n   381→                \"progress\": status_result.get(\"progress\", 0),\n   382→                \"updated_at\": datetime.now().isoformat(),\n   383→            }\n   384→\n   385→            # 如果任务完成，添加结果信息\n   386→            if status_result[\"status\"] == \"success\":\n   387→                updates[\"video_url\"] = status_result[\"video_url\"]\n   388→                updates[\"duration\"] = status_result.get(\"duration\")\n   389→                updates[\"file_size\"] = status_result.get(\"file_size\")\n   390→                updates[\"completed_at\"] = datetime.now().isoformat()\n   391→\n   392→            # 如果任务失败，添加错误信息\n   393→            elif status_result[\"status\"] == \"failed\":\n   394→                updates[\"error\"] = status_result.get(\"error\")\n   395→                updates[\"error_code\"] = status_result.get(\"error_code\")\n   396→\n   397→            # 更新元数据\n   398→            self.metadata_manager.update_record(task_id, updates)\n   399→\n   400→            # 合并任务信息\n   401→            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n   402→\n   403→            return result\n   404→        else:\n   405→            return status_result\n   406→\n   407→    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n   408→        \"\"\"\n   409→        下载已完成的视频\n   410→\n   411→        Args:\n   412→            task_id: 本地任务ID\n   413→\n   414→        Returns:\n   415→            Dict: 下载结果\n   416→        \"\"\"\n   417→        logger.info(f\"下载视频: {task_id}\")\n   418→\n   419→        # 获取任务信息\n   420→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   421→\n   422→        if not task_record:\n   423→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   424→\n   425→        # 检查任务状态\n   426→        if task_record.get(\"status\") != \"success\":\n   427→            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n   428→\n   429→        video_url = task_record.get(\"video_url\")\n   430→        if not video_url:\n   431→            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n   432→\n   433→        # 检查是否已下载\n   434→        local_path = task_record.get(\"local_path\")\n   435→        if local_path and Path(local_path).exists():\n   436→            logger.info(\n   437→                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n   438→            )\n   439→            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n   440→\n   441→        # 下载视频\n   442→        try:\n   443→            response = safe_requests_get(video_url, timeout=300)\n   444→\n   445→            # 生成本地文件名\n   446→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n   447→            task_id_short = task_id[:8]\n   448→            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n   449→\n   450→            # 保存文件\n   451→            local_path = self.file_manager.save_file(filename, response.content)\n   452→\n   453→            # 获取视频信息\n   454→            video_info = self._get_video_info(local_path)\n   455→\n   456→            # 更新元数据\n   457→            updates = {\n   458→                \"filename\": filename,\n   459→                \"local_path\": str(local_path),\n   460→                \"local_file_size\": local_path.stat().st_size,\n   461→                \"downloaded_at\": datetime.now().isoformat(),\n   462→            }\n   463→\n   464→            if video_info:\n   465→                updates.update(video_info)\n   466→\n   467→            self.metadata_manager.update_record(task_id, updates)\n   468→\n   469→            logger.success(f\"视频下载成功: {filename}\")\n   470→\n   471→            summary = {\n   472→                \"success\": True,\n   473→                \"local_path\": str(local_path),\n   474→                \"filename\": filename,\n   475→                \"file_size\": local_path.stat().st_size,\n   476→                \"video_info\": video_info,\n   477→            }\n   478→            try:\n   479→                logger.info(\n   480→                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n   481→                )\n   482→            except Exception:\n   483→                pass\n   484→            return summary\n   485→\n   486→        except Exception as e:\n   487→            logger.error(f\"下载视频失败: {e}\")\n   488→            try:\n   489→                logger.info(\n   490→                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n   491→                )\n   492→            except Exception:\n   493→                pass\n   494→            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n   495→\n   496→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n   497→        \"\"\"\n   498→        取消任务\n   499→\n   500→        Args:\n   501→            task_id: 本地任务ID\n   502→\n   503→        Returns:\n   504→            Dict: 取消结果\n   505→        \"\"\"\n   506→        logger.info(f\"取消任务: {task_id}\")\n   507→\n   508→        # 获取任务信息\n   509→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   510→\n   511→        if not task_record:\n   512→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   513→\n   514→        api_task_id = task_record.get(\"api_task_id\")\n   515→        if not api_task_id:\n   516→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   517→\n   518→        # 调用API取消任务\n   519→        cancel_result = self.client.cancel_task(api_task_id)\n   520→\n   521→        if cancel_result[\"success\"]:\n   522→            # 更新本地记录\n   523→            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n   524→\n   525→            self.metadata_manager.update_record(task_id, updates)\n   526→\n   527→            logger.success(f\"任务取消成功: {task_id}\")\n   528→\n   529→        return cancel_result\n   530→\n   531→    def batch_generate_videos(\n   532→        self,\n   533→        image_paths: List[str],\n   534→        duration: float = 4.0,\n   535→        motion_strength: float = 0.8,\n   536→        watermark: bool = True,\n   537→        save_local: bool = True,\n   538→        wait_for_completion: bool = False,\n   539→    ) -> List[Dict[str, Any]]:\n   540→        \"\"\"\n   541→        批量生成视频\n   542→\n   543→        Args:\n   544→            image_paths: 图像路径列表\n   545→            duration: 视频时长\n   546→            motion_strength: 运动强度\n   547→            watermark: 保留参数（服务端水印由配置决定）\n   548→            save_local: 是否保存到本地\n   549→            wait_for_completion: 是否等待任务完成\n   550→\n   551→        Returns:\n   552→            List[Dict]: 生成结果列表\n   553→        \"\"\"\n   554→        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n   555→\n   556→        results = []\n   557→        for i, image_path in enumerate(image_paths, 1):\n   558→            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n   559→\n   560→            result = self.generate_video(\n   561→                image_path=image_path,\n   562→                duration=duration,\n   563→                motion_strength=motion_strength,\n   564→                watermark=watermark,\n   565→                save_local=save_local,\n   566→                wait_for_completion=wait_for_completion,\n   567→            )\n   568→\n   569→            results.append(result)\n   570→\n   571→        success_count = sum(1 for r in results if r[\"success\"])\n   572→        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n   573→\n   574→        return results\n   575→\n   576→    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   577→        \"\"\"\n   578→        保存视频到本地\n   579→\n   580→        Args:\n   581→            result: API生成结果\n   582→\n   583→        Returns:\n   584→            Dict: 包含本地文件信息的字典\n   585→        \"\"\"\n   586→        try:\n   587→            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n   588→            \n   589→            # Validate inputs\n   590→            task_id = result.get(\"task_id\")\n   591→            video_url = result.get(\"video_url\")\n   592→            if not task_id:\n   593→                raise ValueError(\"Task ID is required\")\n   594→            if not video_url:\n   595→                raise ValueError(\"Video URL is required\")\n   596→            \n   597→            # 下载视频\n   598→            logger.info(f\"Downloading video from {video_url}\")\n   599→            try:\n   600→                response = safe_requests_get(video_url, stream=True, timeout=300)\n   601→                \n   602→                # Check content type\n   603→                content_type = response.headers.get('content-type', '')\n   604→                if 'video' not in content_type:\n   605→                    logger.warning(f\"Unexpected content type: {content_type}\")\n   606→                \n   607→                # Get file size for progress tracking\n   608→                total_size = int(response.headers.get('content-length', 0))\n   609→                video_data = response.content\n   610→                \n   611→                logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n   612→                \n   613→            except requests.exceptions.RequestException as e:\n   614→                logger.error(f\"Network error downloading video: {e}\")\n   615→                raise Exception(f\"Failed to download video: {str(e)}\")\n   616→            \n   617→            # 在保存前获取真实视频信息（写临时文件以便读取）\n   618→            actual_width = None\n   619→            actual_height = None\n   620→            actual_fps = None\n   621→            actual_duration = None\n   622→            try:\n   623→                import tempfile\n   624→                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   625→                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n   626→                    tf.write(video_data)\n   627→                    temp_path = Path(tf.name)\n   628→                # 使用缩略图工具的get_video_info\n   629→                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   630→                gen = VideoThumbnailGenerator(str(thumbs_dir))\n   631→                info = gen.get_video_info(str(temp_path))\n   632→                try:\n   633→                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n   634→                except Exception:\n   635→                    pass\n   636→                if info:\n   637→                    actual_width = info.get('width')\n   638→                    actual_height = info.get('height')\n   639→                    actual_fps = info.get('fps')\n   640→                    actual_duration = info.get('duration')\n   641→            except Exception as e:\n   642→                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n   643→\n   644→            # 准备元数据（适配UnifiedStorageManager的格式）\n   645→            metadata = {\n   646→                'generation_id': task_id,\n   647→                'task_id': task_id,\n   648→                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n   649→                'parameters': {\n   650→                    **result.get('parameters', {}),\n   651→                    # 回填真实视频信息\n   652→                    **({} if actual_width is None else {'width': actual_width}),\n   653→                    **({} if actual_height is None else {'height': actual_height}),\n   654→                    **({} if actual_fps is None else {'fps': actual_fps}),\n   655→                    **({} if actual_duration is None else {'duration': actual_duration}),\n   656→                    # 透传fallback信息\n   657→                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n   658→                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n   659→                },\n   660→                'model': self._get_display_model_name(result),\n   661→                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n   662→                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n   663→                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n   664→                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n   665→                'generation_time': result.get('generation_time', 0),\n   666→                'status': result.get('status', 'completed'),\n   667→                'batch_id': result.get('batch_id', '')\n   668→            }\n   669→            \n   670→            # 使用统一存储管理器保存文件\n   671→            save_result = self.storage_manager.save_content_file(\n   672→                content_type='videos',\n   673→                file_data=video_data,\n   674→                url=video_url,\n   675→                metadata=metadata\n   676→            )\n   677→\n   678→            # 缩略图生成（已由UnifiedStorageManager处理）\n   679→            thumbnail_local_path = save_result.get('thumbnail_path')\n   680→            thumbnail_filename = None\n   681→            if thumbnail_local_path:\n   682→                thumbnail_filename = Path(thumbnail_local_path).name\n   683→                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n   684→            else:\n   685→                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n   686→\n   687→            # 下载并保存API返回的缩略图（如果有）作为备用\n   688→            api_thumbnail_local_path = None\n   689→            api_thumbnail_filename = None\n   690→            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n   691→                try:\n   692→                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n   693→                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n   694→                    \n   695→                    # 使用统一存储管理器保存备用缩略图\n   696→                    backup_metadata = {\n   697→                        'generation_id': task_id,\n   698→                        'prompt': 'API backup thumbnail for video',\n   699→                        'model': 'seedance',\n   700→                        'width': 320,\n   701→                        'height': 180,\n   702→                        'status': 'completed'\n   703→                    }\n   704→                    \n   705→                    backup_result = self.storage_manager.save_content_file(\n   706→                        content_type='images',  # 缩略图保存为图片\n   707→                        file_data=thumbnail_response.content,\n   708→                        url=result[\"thumbnail_url\"],\n   709→                        metadata=backup_metadata\n   710→                    )\n   711→                    \n   712→                    api_thumbnail_local_path = backup_result['local_path']\n   713→                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n   714→                    \n   715→                    # 如果本地缩略图生成失败，使用API缩略图\n   716→                    if not thumbnail_local_path:\n   717→                        thumbnail_local_path = api_thumbnail_local_path\n   718→                        thumbnail_filename = api_thumbnail_filename\n   719→                    \n   720→                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n   721→                        \n   722→                except Exception as e:\n   723→                    logger.warning(f\"下载API缩略图失败: {e}\")\n   724→                    api_thumbnail_local_path = None\n   725→                    api_thumbnail_filename = None\n   726→\n   727→            # 获取视频信息\n   728→            local_path = Path(save_result['local_path'])\n   729→            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n   730→            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n   731→                try:\n   732→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   733→                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   734→                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n   735→                    video_info = gen.get_video_info(str(local_path))\n   736→                except Exception:\n   737→                    video_info = {}\n   738→            else:\n   739→                video_info = {\n   740→                    'width': actual_width,\n   741→                    'height': actual_height,\n   742→                    'fps': actual_fps,\n   743→                    'duration': actual_duration,\n   744→                }\n   745→            file_size = local_path.stat().st_size if local_path.exists() else 0\n   746→            \n   747→            logger.success(f\"视频已保存到本地: {local_path.name}\")\n   748→            \n   749→            # 本地视频水印（使用统一水印服务控制）\n   750→            if should_add_watermark():\n   751→                try:\n   752→                    from edition.watermark_service import WatermarkService\n   753→\n   754→                    watermark_text = get_watermark_text() or \"PIGEON\"\n   755→                    try:\n   756→                        opacity = get_watermark_opacity()\n   757→                    except Exception:\n   758→                        opacity = 0.3\n   759→                    opacity = max(0.0, min(opacity, 1.0))\n   760→\n   761→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n   762→                    watermark_applied = watermark_service.apply_to_video(local_path)\n   763→                    if watermark_applied:\n   764→                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n   765→                    else:\n   766→                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n   767→                except Exception as e:\n   768→                    logger.warning(f\"添加视频水印时出错: {e}\")\n   769→\n   770→            result_obj = {\n   771→                \"local_path\": save_result['local_path'],\n   772→                \"filename\": local_path.name,\n   773→                \"file_path\": save_result['local_path'],  # 保持兼容性\n   774→                \"local_file_size\": file_size,\n   775→                \"video_info\": video_info,\n   776→                # 同步回填至顶层，便于上游使用\n   777→                **({} if not video_info else {\n   778→                    'width': video_info.get('width'),\n   779→                    'height': video_info.get('height'),\n   780→                    'fps': video_info.get('fps'),\n   781→                    'duration': video_info.get('duration'),\n   782→                }),\n   783→                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n   784→                \"thumbnail_filename\": thumbnail_filename,\n   785→                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n   786→                \"api_thumbnail_filename\": api_thumbnail_filename,\n   787→                \"task_id\": task_id,  # 添加task_id以供后续使用\n   788→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n   789→                \"file_id\": save_result.get('file_id'),\n   790→                \"relative_path\": save_result.get('relative_path'),\n   791→            }\n   792→            try:\n   793→                logger.info(\n   794→                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n   795→                )\n   796→            except Exception:\n   797→                pass\n   798→            return result_obj\n   799→\n   800→        except Exception as e:\n   801→            logger.error(f\"保存视频到本地失败: {e}\")\n   802→            logger.exception(\"Full traceback for video save error:\")\n   803→            try:\n   804→                logger.info(\n   805→                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n   806→                )\n   807→            except Exception:\n   808→                pass\n   809→            return {\"local_save_error\": str(e)}\n   810→\n   811→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n   812→        checksum = hashlib.sha1(file_data).hexdigest()\n   813→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n   814→        return f\"ref_{ts}_{checksum[:8]}\"\n   815→\n   816→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n   817→        source_meta: Dict[str, Any] = {}\n   818→        raw = ref\n   819→        if isinstance(ref, dict):\n   820→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n   821→                if ref.get(key) is not None:\n   822→                    source_meta[key] = ref.get(key)\n   823→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n   824→        if raw is None:\n   825→            return None\n   826→\n   827→        extension = source_meta.get('extension')\n   828→        data = None\n   829→        source_repr = source_meta.get('source')\n   830→\n   831→        try:\n   832→            if isinstance(raw, bytes):\n   833→                data = raw\n   834→            elif isinstance(raw, str):\n   835→                stripped = raw.strip()\n   836→                if stripped.startswith('data:') and ';base64,' in stripped:\n   837→                    header, payload = stripped.split(';base64,', 1)\n   838→                    mime_part = header[5:]\n   839→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n   840→                    data = base64.b64decode(payload)\n   841→                    source_repr = source_repr or mime_part\n   842→                    source_meta.setdefault('type', 'image')\n   843→                elif stripped.startswith(('http://', 'https://')):\n   844→                    resp = safe_requests_get(stripped, timeout=15)\n   845→                    data = resp.content\n   846→                    parsed = urlparse(stripped)\n   847→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n   848→                    source_repr = source_repr or stripped\n   849→                    source_meta.setdefault('source_url', stripped)\n   850→                else:\n   851→                    path = Path(stripped)\n   852→                    if not path.exists():\n   853→                        logger.warning(f\"参考图像不存在: {stripped}\")\n   854→                        return None\n   855→                    data = path.read_bytes()\n   856→                    extension = extension or path.suffix or '.png'\n   857→                    source_repr = source_repr or path.name\n   858→                    source_meta.setdefault('source_path', str(path))\n   859→            else:\n   860→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n   861→                return None\n   862→        except Exception as exc:\n   863→            logger.warning(f\"加载参考图失败: {exc}\")\n   864→            return None\n   865→\n   866→        if data is None:\n   867→            return None\n   868→\n   869→        width = source_meta.get('width')\n   870→        height = source_meta.get('height')\n   871→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n   872→            try:\n   873→                from io import BytesIO\n   874→\n   875→                with Image.open(BytesIO(data)) as img:\n   876→                    width = img.width\n   877→                    height = img.height\n   878→            except Exception:\n   879→                pass\n   880→\n   881→        source_meta['width'] = width\n   882→        source_meta['height'] = height\n   883→        source_meta.setdefault('type', 'image')\n   884→        source_meta['source'] = source_repr or source_meta.get('source')\n   885→\n   886→        return data, extension, source_meta\n   887→\n   888→    def _process_reference_assets(\n   889→        self,\n   890→        references: Optional[List[Any]],\n   891→        *,\n   892→        max_refs: int = MAX_REFERENCE_IMAGES,\n   893→        expected_outputs: int = 1,\n   894→    ) -> Dict[str, Any]:\n   895→        stored: List[Dict[str, Any]] = []\n   896→        absolute_paths: List[str] = []\n   897→        errors: List[str] = []\n   898→        warnings: List[str] = []\n   899→\n   900→        if not references:\n   901→            return {\n   902→                'assets': stored,\n   903→                'paths': absolute_paths,\n   904→                'errors': errors,\n   905→                'warnings': warnings,\n   906→            }\n   907→\n   908→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n   909→            warnings.append(\n   910→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n   911→            )\n   912→            references = references[:max_refs]\n   913→\n   914→        for order, item in enumerate(references):\n   915→            load_result = self._load_reference_source(item)\n   916→            if not load_result:\n   917→                errors.append(f\"ref[{order}] 加载失败\")\n   918→                continue\n   919→\n   920→            file_data, extension, meta = load_result\n   921→            meta.setdefault('order', order)\n   922→            meta.setdefault('kind', meta.get('type', 'image'))\n   923→\n   924→            try:\n   925→                asset_id = self._generate_reference_asset_id(file_data)\n   926→                record = self.storage_manager.save_reference_asset(\n   927→                    'images',\n   928→                    file_data,\n   929→                    asset_id=asset_id,\n   930→                    extension=extension,\n   931→                    metadata=meta,\n   932→                )\n   933→                try:\n   934→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n   935→                except Exception:\n   936→                    record['_payload_b64'] = None\n   937→                record['_source_meta'] = meta\n   938→                stored.append(record)\n   939→                if record.get('absolute_path'):\n   940→                    absolute_paths.append(record['absolute_path'])\n   941→            except Exception as exc:\n   942→                logger.warning(f\"保存参考图失败: {exc}\")\n   943→                errors.append(f\"ref[{order}] 保存失败\")\n   944→\n   945→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n   946→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n   947→            if len(stored) > allowed:\n   948→                warnings.append(\n   949→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n   950→                )\n   951→                stored = stored[:allowed]\n   952→                absolute_paths = absolute_paths[:allowed]\n   953→\n   954→        return {\n   955→            'assets': stored,\n   956→            'paths': absolute_paths,\n   957→            'errors': errors,\n   958→            'warnings': warnings,\n   959→        }\n   960→\n   961→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   962→        cleaned: List[Dict[str, Any]] = []\n   963→        for rec in assets or []:\n   964→            rec.pop('_payload_b64', None)\n   965→            rec.pop('_source_meta', None)\n   966→            rec.pop('absolute_path', None)\n   967→            cleaned.append({\n   968→                'id': rec.get('id') or rec.get('reference_id'),\n   969→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n   970→                'type': rec.get('type'),\n   971→                'kind': rec.get('kind'),\n   972→                'source': rec.get('source'),\n   973→                'order': rec.get('order'),\n   974→                'checksum': rec.get('checksum'),\n   975→                'size': rec.get('size'),\n   976→                'width': rec.get('width'),\n   977→                'height': rec.get('height'),\n   978→                'created_at': rec.get('created_at'),\n   979→            })\n   980→        return cleaned\n   981→\n   982→    @staticmethod\n   983→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n   984→        masked: List[str] = []\n   985→        for rec in assets or []:\n   986→            rid = rec.get('id') or ''\n   987→            if not rid:\n   988→                continue\n   989→            masked.append(f\"{rid[:6]}***\")\n   990→        return \",\".join(masked)\n   991→\n   992→    @staticmethod\n   993→    def _provider_hint() -> str:\n   994→        try:\n   995→            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n   996→        except Exception:\n   997→            return \"seedance\"\n   998→\n   999→    @staticmethod\n  1000→    def _cleanup_reference_paths(paths: List[str]):\n  1001→        for path in paths or []:\n  1002→            try:\n  1003→                if path and Path(path).exists():\n  1004→                    Path(path).unlink(missing_ok=True)\n  1005→            except Exception as exc:\n  1006→                logger.debug(f\"参考图清理失败: {exc}\")\n  1007→\n  1008→    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n  1009→        \"\"\"\n  1010→        将绝对路径转换为相对路径（相对于存储根目录）\n  1011→\n  1012→        如果路径已经是相对路径或无法转换，返回原路径。\n  1013→        这确保数据库中存储的是相对路径，支持跨平台迁移。\n  1014→\n  1015→        Args:\n  1016→            abs_path: 绝对路径或相对路径\n  1017→\n  1018→        Returns:\n  1019→            相对路径字符串，如 \"images/xxx.png\"\n  1020→        \"\"\"\n  1021→        if not abs_path:\n  1022→            return None\n  1023→\n  1024→        try:\n  1025→            path = Path(abs_path)\n  1026→\n  1027→            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n  1028→            if not path.is_absolute():\n  1029→                return str(path).replace('\\\\', '/')\n  1030→\n  1031→            # 尝试转换为相对于存储根目录的路径\n  1032→            storage_root = Path(self.storage_manager.root_path)\n  1033→            try:\n  1034→                relative = path.relative_to(storage_root)\n  1035→                return str(relative).replace('\\\\', '/')\n  1036→            except ValueError:\n  1037→                # 路径不在存储根目录下，尝试提取文件名部分\n  1038→                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n  1039→                parts = path.parts\n  1040→                for i, part in enumerate(parts):\n  1041→                    if part in ('images', 'videos', 'thumbnails', 'references'):\n  1042→                        relative = Path(*parts[i:])\n  1043→                        return str(relative).replace('\\\\', '/')\n  1044→\n  1045→                # 无法提取，返回原路径（记录警告）\n  1046→                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n  1047→                return str(path).replace('\\\\', '/')\n  1048→\n  1049→        except Exception as e:\n  1050→            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n  1051→            return abs_path\n  1052→\n  1053→    def _extract_width_from_resolution(self, resolution: str) -> int:\n  1054→        \"\"\"\n  1055→        从分辨率字符串中提取宽度\n  1056→        \n  1057→        Args:\n  1058→            resolution: 分辨率字符串，如 \"1280x720\"\n  1059→            \n  1060→        Returns:\n  1061→            int: 宽度值\n  1062→        \"\"\"\n  1063→        try:\n  1064→            return int(resolution.split('x')[0])\n  1065→        except (ValueError, IndexError):\n  1066→            return 1280  # 默认值\n  1067→    \n  1068→    def _extract_height_from_resolution(self, resolution: str) -> int:\n  1069→        \"\"\"\n  1070→        从分辨率字符串中提取高度\n  1071→        \n  1072→        Args:\n  1073→            resolution: 分辨率字符串，如 \"1280x720\"\n  1074→            \n  1075→        Returns:\n  1076→            int: 高度值\n  1077→        \"\"\"\n  1078→        try:\n  1079→            return int(resolution.split('x')[1])\n  1080→        except (ValueError, IndexError):\n  1081→            return 720  # 默认值\n  1082→\n  1083→    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n  1084→        \"\"\"\n  1085→        获取视频信息\n  1086→\n  1087→        Args:\n  1088→            video_path: 视频文件路径\n  1089→\n  1090→        Returns:\n  1091→            Dict: 视频信息\n  1092→        \"\"\"\n  1093→        try:\n  1094→            # 这里可以使用ffprobe或其他工具获取视频信息\n  1095→            # 暂时返回基本信息\n  1096→            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n  1097→        except Exception as e:\n  1098→            logger.error(f\"获取视频信息失败: {e}\")\n  1099→            return {}\n  1100→\n  1101→    def _save_task_metadata(self, result: Dict[str, Any]):\n  1102→        \"\"\"\n  1103→        保存任务元数据\n  1104→\n  1105→        Args:\n  1106→            result: 任务结果\n  1107→        \"\"\"\n  1108→        try:\n  1109→            # 构建视频元数据\n  1110→            metadata = {\n  1111→                \"generation_id\": result[\"task_id\"],\n  1112→                \"file_id\": result[\"task_id\"],\n  1113→                \"filename\": result.get(\"filename\", \"\"),\n  1114→                \"file_path\": result.get(\"local_path\", \"\"),\n  1115→                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n  1116→                \"parameters\": result.get(\"parameters\", {}),\n  1117→                \"created_at\": result[\"created_at\"],\n  1118→                \"file_size\": result.get(\"local_file_size\", 0),\n  1119→                \"source_url\": result.get(\"video_url\", \"\"),\n  1120→                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n  1121→                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n  1122→            }\n  1123→\n  1124→            # 调用视频元数据保存方法\n  1125→            self.metadata_manager.save_video_metadata(metadata)\n  1126→            \n  1127→            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n  1128→\n  1129→        except Exception as e:\n  1130→            logger.error(f\"保存任务元数据失败: {e}\")\n  1131→\n  1132→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1133→        \"\"\"\n  1134→        获取视频生成历史记录\n  1135→\n  1136→        Args:\n  1137→            limit: 返回记录数量限制\n  1138→\n  1139→        Returns:\n  1140→            List[Dict]: 历史记录列表\n  1141→        \"\"\"\n  1142→        return self.storage_manager.load_history('videos', limit=limit)\n  1143→\n  1144→    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n  1145→        \"\"\"\n  1146→        根据输入图像路径搜索历史记录\n  1147→\n  1148→        Args:\n  1149→            keyword: 搜索关键字\n  1150→\n  1151→        Returns:\n  1152→            List[Dict]: 匹配的记录列表\n  1153→        \"\"\"\n  1154→        return self.metadata_manager.search_records(\"input_image\", keyword)\n  1155→\n  1156→    def get_statistics(self) -> Dict[str, Any]:\n  1157→        \"\"\"\n  1158→        获取生成统计信息\n  1159→\n  1160→        Returns:\n  1161→            Dict: 统计信息\n  1162→        \"\"\"\n  1163→        try:\n  1164→            df = self.metadata_manager.get_dataframe()\n  1165→\n  1166→            if df.empty:\n  1167→                return {\n  1168→                    \"total_videos\": 0,\n  1169→                    \"success_count\": 0,\n  1170→                    \"failed_count\": 0,\n  1171→                    \"pending_count\": 0,\n  1172→                    \"total_file_size\": 0,\n  1173→                    \"average_file_size\": 0,\n  1174→                    \"total_duration\": 0,\n  1175→                    \"average_duration\": 0,\n  1176→                }\n  1177→\n  1178→            stats = {\n  1179→                \"total_videos\": len(df),\n  1180→                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n  1181→                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n  1182→                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n  1183→                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n  1184→                \"total_file_size\": df[\"local_file_size\"].sum(),\n  1185→                \"average_file_size\": df[\"local_file_size\"].mean(),\n  1186→                \"total_duration\": df[\"duration\"].sum(),\n  1187→                \"average_duration\": df[\"duration\"].mean(),\n  1188→                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n  1189→            }\n  1190→\n  1191→            return stats\n  1192→\n  1193→        except Exception as e:\n  1194→            logger.error(f\"获取统计信息失败: {e}\")\n  1195→            return {}\n  1196→\n  1197→    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n  1198→        \"\"\"获取用于显示的模型名称\"\"\"\n  1199→        # 从参数中获取模型变体信息\n  1200→        params = result.get('parameters', {})\n  1201→        model_variant = params.get('model_variant', '')\n  1202→        use_pro_model = params.get('use_pro_model', True)\n  1203→        \n  1204→        # 根据模型变体返回友好的显示名称\n  1205→        if 'seedance_pro' in model_variant or (use_pro_model and not model_variant):\n  1206→            return 'seedance 1.0 pro'\n  1207→        elif 'seedance_lite' in model_variant or (not use_pro_model and not model_variant):\n  1208→            return 'seedance 1.0 lite'\n  1209→        else:\n  1210→            # 回退到原始模型名称或默认值\n  1211→            return result.get('model', 'seedance')\n  1212→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4e34c062-0202-4ac0-90a4-4a5ebef988c4","timestamp":"2025-12-11T08:09:28.222Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"# Seedance视频生成管理器\n# 负责视频生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nimport base64\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom urllib.parse import urlparse\nfrom loguru import logger\nfrom PIL import Image\n\nfrom ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n\nfrom .client import SeedanceClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    VideoParams,\n    validate_and_normalize_video,\n)\nfrom config.unified_config import get_unified_config\nfrom config_api import get_storage_dir\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n# API水印配置保持不变（用于服务端水印）\ntry:  # pragma: no cover\n    from config_api import API_WATERMARK_CONFIG  # type: ignore\nexcept Exception:  # pragma: no cover\n    API_WATERMARK_CONFIG = {\n        \"image_watermark\": False,\n        \"video_watermark\": False,\n    }\ntry:  # pragma: no cover\n    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\nexcept Exception:  # pragma: no cover\n    LOCAL_WATERMARK_CONFIG = {\n        \"enabled\": False,\n        \"text\": \"\",\n        \"opacity\": 0.0,\n        \"position\": \"bottom_right\",\n        \"font_size\": 0,\n    }\n\n\nclass SeedanceManager:\n    \"\"\"Seedance视频生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedance管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n        \"\"\"\n        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n        \n        self.client = SeedanceClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.video_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.videos_dir = self.data_dir / \"videos\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_video(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: float = 4.0,\n        seed: int = -1,\n        watermark: bool = False,\n        save_local: bool = True,\n        wait_for_completion: bool = True,\n        # 新增参数（P0b）\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        fps: int = 24,\n        camera_fixed: bool = True,\n        use_pro_model: bool = True,\n        model_type: Optional[str] = None,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成视频并保存到本地\n\n        Args:\n            image_path: 输入图像路径\n            duration: 视频时长（秒）\n            motion_strength: 运动强度 (0.1-1.0)\n            seed: 随机种子\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            Dict: 生成结果\n        \"\"\"\n        logger.info(\"开始视频生成任务(Manager)\")\n\n        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n        # 构建待处理的图片列表\n        all_input_images = []\n\n        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n        frame_inputs = []\n        if first_frame_path:\n            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n        if last_frame_path:\n            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n        elif image_path and not first_frame_path:\n            frame_inputs.append({'path': image_path, 'type': 'image'})\n\n        all_input_images.extend(frame_inputs)\n\n        # 2. 添加参考图\n        if reference_images:\n            for ref in reference_images:\n                if isinstance(ref, dict):\n                    ref_copy = dict(ref)\n                    ref_copy['type'] = ref_copy.get('type', 'reference')\n                    all_input_images.append(ref_copy)\n                else:\n                    all_input_images.append({'path': ref, 'type': 'reference'})\n\n        # 3. 统一处理（复制到 references 目录）\n        ref_summary = self._process_reference_assets(\n            all_input_images if all_input_images else None,\n            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n            expected_outputs=1,\n        )\n        ref_assets = ref_summary.get('assets', [])\n        ref_paths: List[str] = list(ref_summary.get('paths', []))\n\n        # 4. 分离帧图片和参考图\n        frame_assets = {}\n        pure_ref_assets = []\n        for asset in ref_assets:\n            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n            if asset_type in ('first_frame', 'last_frame', 'image'):\n                frame_assets[asset_type] = asset\n            else:\n                pure_ref_assets.append(asset)\n\n        # 5. 提取帧图片的相对路径（用于存储）\n        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n        stored_image_path = frame_assets.get('image', {}).get('path')\n\n        # 6. 提取参考图的 payload（用于 API 调用）\n        ref_payloads: List[str] = []\n        for asset in pure_ref_assets:\n            payload = asset.get('_payload_b64')\n            if payload:\n                ref_payloads.append(payload)\n\n        if ref_summary.get('errors'):\n            logger.warning(\n                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n            )\n        if ref_summary.get('warnings'):\n            for warn in ref_summary['warnings']:\n                logger.warning(f\"图片处理提示: {warn}\")\n\n        watermark_enabled = bool(\n            LOCAL_WATERMARK_CONFIG.get(\"enabled\", API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n        )\n\n        create_kwargs = dict(\n            prompt=prompt,\n            duration=int(duration),\n            seed=None if seed == -1 else seed,\n            fps=fps,\n            resolution_grade=resolution_grade,\n            ratio=ratio,\n            watermark=watermark_enabled,\n            camera_fixed=bool(camera_fixed),\n            use_pro_model=use_pro_model,\n            model_type=model_type,\n        )\n        if ref_payloads:\n            create_kwargs['reference_images'] = ref_payloads\n        if first_frame_path and last_frame_path:\n            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n        elif image_path:\n            create_kwargs.update(dict(image_path=image_path))\n        # 文生视频：不追加图片参数\n\n        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n        precheck_fb = False\n        precheck_reason = \"\"\n        try:\n            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n                VideoParams(\n                    prompt=prompt,\n                    image_path=None,  # 校验不依赖图像数据\n                    first_frame_path=None,\n                    last_frame_path=None,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if seed == -1 else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=bool(watermark),\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                )\n            )\n            logger.info(\n                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n            )\n            if fb:\n                logger.warning(f\"前置参数回退建议: {reason}\")\n            precheck_fb = fb\n            precheck_reason = reason\n        except Exception as _e:\n            logger.debug(f\"前置参数校验跳过: {_e}\")\n\n        create_result = self.client.create_video_task(**create_kwargs)\n\n        if not create_result[\"success\"]:\n            self._cleanup_reference_paths(ref_paths)\n            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n            return create_result\n\n        api_task_id = create_result[\"task_id\"]\n\n        result = {\n            \"task_id\": task_id,\n            \"api_task_id\": api_task_id,\n            \"success\": True,\n            \"type\": \"image_to_video\",\n            \"input_image\": image_path,\n            \"status\": \"pending\",\n            \"parameters\": {\n                \"prompt\": prompt,\n                \"duration\": duration,\n                \"seed\": (None if seed == -1 else seed),\n                \"watermark\": watermark_enabled,\n                \"resolution_grade\": resolution_grade,\n                \"ratio\": ratio,\n                \"fps\": fps,\n                \"camera_fixed\": bool(camera_fixed),\n                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n                \"first_frame\": stored_first_frame,\n                \"last_frame\": stored_last_frame,\n                \"image_path\": stored_image_path,\n            },\n            \"created_at\": datetime.now().isoformat(),\n        }\n\n        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n        result['reference_assets'] = sanitized_refs\n        if ref_summary.get('errors'):\n            result['reference_asset_errors'] = ref_summary['errors']\n        if ref_summary.get('warnings'):\n            result['reference_asset_warnings'] = ref_summary['warnings']\n        if precheck_fb and precheck_reason:\n            result.setdefault('fallback_applied', True)\n            if result.get('fallback_reason'):\n                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n            else:\n                result['fallback_reason'] = precheck_reason\n\n        masked_ids = self._summarize_reference_ids(sanitized_refs)\n        logger.info(\n            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n            len(sanitized_refs),\n            masked_ids or \"-\",\n            self._provider_hint(),\n        )\n\n        # 透传回退信息\n        if create_result.get(\"fallback_applied\"):\n            result[\"fallback_applied\"] = True\n            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n\n        # 如果等待完成，轮询任务状态\n        if wait_for_completion:\n            completion_result = self.client.wait_for_completion(api_task_id)\n\n            if completion_result[\"success\"]:\n                if completion_result[\"status\"] == \"success\":\n                    result[\"status\"] = \"success\"\n                    result[\"video_url\"] = completion_result[\"video_url\"]\n                    result[\"duration\"] = completion_result.get(\"duration\")\n                    result[\"file_size\"] = completion_result.get(\"file_size\")\n                    result[\"completed_at\"] = datetime.now().isoformat()\n\n                    # 保存到本地\n                    if save_local:\n                        local_result = self._save_video_locally(result)\n                        result.update(local_result)\n                        if local_result.get('local_save_error'):\n                            self._cleanup_reference_paths(ref_paths)\n                            result['parameters'][\"reference_assets\"] = []\n                            result['reference_assets'] = []\n                            warnings = result.setdefault('reference_asset_warnings', [])\n                            warnings.append(\"视频保存失败，参考图已回滚\")\n                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n                    logger.success(f\"视频生成任务完成: {task_id}\")\n                else:\n                    result[\"status\"] = completion_result[\"status\"]\n                    result[\"error\"] = completion_result.get(\"error\")\n                    result[\"error_code\"] = completion_result.get(\"error_code\")\n                    logger.error(f\"视频生成任务失败: {result['error']}\")\n            else:\n                result[\"status\"] = \"failed\"\n                result[\"error\"] = completion_result[\"error\"]\n                result[\"error_code\"] = completion_result[\"error_code\"]\n                logger.error(f\"等待任务完成失败: {result['error']}\")\n\n        # 记录元数据\n        self._save_task_metadata(result)\n\n        return result\n\n    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        检查任务状态\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        logger.info(f\"检查任务状态: {task_id}\")\n\n        # 从元数据中获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 查询API任务状态\n        status_result = self.client.get_task_status(api_task_id)\n\n        if status_result[\"success\"]:\n            # 更新本地记录\n            updates = {\n                \"status\": status_result[\"status\"],\n                \"progress\": status_result.get(\"progress\", 0),\n                \"updated_at\": datetime.now().isoformat(),\n            }\n\n            # 如果任务完成，添加结果信息\n            if status_result[\"status\"] == \"success\":\n                updates[\"video_url\"] = status_result[\"video_url\"]\n                updates[\"duration\"] = status_result.get(\"duration\")\n                updates[\"file_size\"] = status_result.get(\"file_size\")\n                updates[\"completed_at\"] = datetime.now().isoformat()\n\n            # 如果任务失败，添加错误信息\n            elif status_result[\"status\"] == \"failed\":\n                updates[\"error\"] = status_result.get(\"error\")\n                updates[\"error_code\"] = status_result.get(\"error_code\")\n\n            # 更新元数据\n            self.metadata_manager.update_record(task_id, updates)\n\n            # 合并任务信息\n            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n\n            return result\n        else:\n            return status_result\n\n    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        下载已完成的视频\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 下载结果\n        \"\"\"\n        logger.info(f\"下载视频: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        # 检查任务状态\n        if task_record.get(\"status\") != \"success\":\n            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n\n        video_url = task_record.get(\"video_url\")\n        if not video_url:\n            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n\n        # 检查是否已下载\n        local_path = task_record.get(\"local_path\")\n        if local_path and Path(local_path).exists():\n            logger.info(\n                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n            )\n            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n\n        # 下载视频\n        try:\n            response = safe_requests_get(video_url, timeout=300)\n\n            # 生成本地文件名\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            task_id_short = task_id[:8]\n            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n\n            # 保存文件\n            local_path = self.file_manager.save_file(filename, response.content)\n\n            # 获取视频信息\n            video_info = self._get_video_info(local_path)\n\n            # 更新元数据\n            updates = {\n                \"filename\": filename,\n                \"local_path\": str(local_path),\n                \"local_file_size\": local_path.stat().st_size,\n                \"downloaded_at\": datetime.now().isoformat(),\n            }\n\n            if video_info:\n                updates.update(video_info)\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"视频下载成功: {filename}\")\n\n            summary = {\n                \"success\": True,\n                \"local_path\": str(local_path),\n                \"filename\": filename,\n                \"file_size\": local_path.stat().st_size,\n                \"video_info\": video_info,\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n                )\n            except Exception:\n                pass\n            return summary\n\n        except Exception as e:\n            logger.error(f\"下载视频失败: {e}\")\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n                )\n            except Exception:\n                pass\n            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消任务\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 取消结果\n        \"\"\"\n        logger.info(f\"取消任务: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 调用API取消任务\n        cancel_result = self.client.cancel_task(api_task_id)\n\n        if cancel_result[\"success\"]:\n            # 更新本地记录\n            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"任务取消成功: {task_id}\")\n\n        return cancel_result\n\n    def batch_generate_videos(\n        self,\n        image_paths: List[str],\n        duration: float = 4.0,\n        motion_strength: float = 0.8,\n        watermark: bool = True,\n        save_local: bool = True,\n        wait_for_completion: bool = False,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成视频\n\n        Args:\n            image_paths: 图像路径列表\n            duration: 视频时长\n            motion_strength: 运动强度\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n\n        results = []\n        for i, image_path in enumerate(image_paths, 1):\n            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n\n            result = self.generate_video(\n                image_path=image_path,\n                duration=duration,\n                motion_strength=motion_strength,\n                watermark=watermark,\n                save_local=save_local,\n                wait_for_completion=wait_for_completion,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n\n        return results\n\n    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存视频到本地\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n            \n            # Validate inputs\n            task_id = result.get(\"task_id\")\n            video_url = result.get(\"video_url\")\n            if not task_id:\n                raise ValueError(\"Task ID is required\")\n            if not video_url:\n                raise ValueError(\"Video URL is required\")\n            \n            # 下载视频\n            logger.info(f\"Downloading video from {video_url}\")\n            try:\n                response = safe_requests_get(video_url, stream=True, timeout=300)\n                \n                # Check content type\n                content_type = response.headers.get('content-type', '')\n                if 'video' not in content_type:\n                    logger.warning(f\"Unexpected content type: {content_type}\")\n                \n                # Get file size for progress tracking\n                total_size = int(response.headers.get('content-length', 0))\n                video_data = response.content\n                \n                logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n                \n            except requests.exceptions.RequestException as e:\n                logger.error(f\"Network error downloading video: {e}\")\n                raise Exception(f\"Failed to download video: {str(e)}\")\n            \n            # 在保存前获取真实视频信息（写临时文件以便读取）\n            actual_width = None\n            actual_height = None\n            actual_fps = None\n            actual_duration = None\n            try:\n                import tempfile\n                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n                    tf.write(video_data)\n                    temp_path = Path(tf.name)\n                # 使用缩略图工具的get_video_info\n                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                gen = VideoThumbnailGenerator(str(thumbs_dir))\n                info = gen.get_video_info(str(temp_path))\n                try:\n                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n                except Exception:\n                    pass\n                if info:\n                    actual_width = info.get('width')\n                    actual_height = info.get('height')\n                    actual_fps = info.get('fps')\n                    actual_duration = info.get('duration')\n            except Exception as e:\n                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n\n            # 准备元数据（适配UnifiedStorageManager的格式）\n            metadata = {\n                'generation_id': task_id,\n                'task_id': task_id,\n                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n                'parameters': {\n                    **result.get('parameters', {}),\n                    # 回填真实视频信息\n                    **({} if actual_width is None else {'width': actual_width}),\n                    **({} if actual_height is None else {'height': actual_height}),\n                    **({} if actual_fps is None else {'fps': actual_fps}),\n                    **({} if actual_duration is None else {'duration': actual_duration}),\n                    # 透传fallback信息\n                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n                },\n                'model': self._get_display_model_name(result),\n                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n                'generation_time': result.get('generation_time', 0),\n                'status': result.get('status', 'completed'),\n                'batch_id': result.get('batch_id', '')\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='videos',\n                file_data=video_data,\n                url=video_url,\n                metadata=metadata\n            )\n\n            # 缩略图生成（已由UnifiedStorageManager处理）\n            thumbnail_local_path = save_result.get('thumbnail_path')\n            thumbnail_filename = None\n            if thumbnail_local_path:\n                thumbnail_filename = Path(thumbnail_local_path).name\n                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n            else:\n                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n\n            # 下载并保存API返回的缩略图（如果有）作为备用\n            api_thumbnail_local_path = None\n            api_thumbnail_filename = None\n            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n                try:\n                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n                    \n                    # 使用统一存储管理器保存备用缩略图\n                    backup_metadata = {\n                        'generation_id': task_id,\n                        'prompt': 'API backup thumbnail for video',\n                        'model': 'seedance',\n                        'width': 320,\n                        'height': 180,\n                        'status': 'completed'\n                    }\n                    \n                    backup_result = self.storage_manager.save_content_file(\n                        content_type='images',  # 缩略图保存为图片\n                        file_data=thumbnail_response.content,\n                        url=result[\"thumbnail_url\"],\n                        metadata=backup_metadata\n                    )\n                    \n                    api_thumbnail_local_path = backup_result['local_path']\n                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n                    \n                    # 如果本地缩略图生成失败，使用API缩略图\n                    if not thumbnail_local_path:\n                        thumbnail_local_path = api_thumbnail_local_path\n                        thumbnail_filename = api_thumbnail_filename\n                    \n                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n                        \n                except Exception as e:\n                    logger.warning(f\"下载API缩略图失败: {e}\")\n                    api_thumbnail_local_path = None\n                    api_thumbnail_filename = None\n\n            # 获取视频信息\n            local_path = Path(save_result['local_path'])\n            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n                try:\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n                    video_info = gen.get_video_info(str(local_path))\n                except Exception:\n                    video_info = {}\n            else:\n                video_info = {\n                    'width': actual_width,\n                    'height': actual_height,\n                    'fps': actual_fps,\n                    'duration': actual_duration,\n                }\n            file_size = local_path.stat().st_size if local_path.exists() else 0\n            \n            logger.success(f\"视频已保存到本地: {local_path.name}\")\n            \n            # 本地视频水印（使用统一水印服务控制）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_video(local_path)\n                    if watermark_applied:\n                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n                    else:\n                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n                except Exception as e:\n                    logger.warning(f\"添加视频水印时出错: {e}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": local_path.name,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"local_file_size\": file_size,\n                \"video_info\": video_info,\n                # 同步回填至顶层，便于上游使用\n                **({} if not video_info else {\n                    'width': video_info.get('width'),\n                    'height': video_info.get('height'),\n                    'fps': video_info.get('fps'),\n                    'duration': video_info.get('duration'),\n                }),\n                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n                \"thumbnail_filename\": thumbnail_filename,\n                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n                \"api_thumbnail_filename\": api_thumbnail_filename,\n                \"task_id\": task_id,  # 添加task_id以供后续使用\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n                )\n            except Exception:\n                pass\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存视频到本地失败: {e}\")\n            logger.exception(\"Full traceback for video save error:\")\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n                )\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"参考图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('reference_id'),\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum'),\n                'size': rec.get('size'),\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n        except Exception:\n            return \"seedance\"\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n        \"\"\"\n        将绝对路径转换为相对路径（相对于存储根目录）\n\n        如果路径已经是相对路径或无法转换，返回原路径。\n        这确保数据库中存储的是相对路径，支持跨平台迁移。\n\n        Args:\n            abs_path: 绝对路径或相对路径\n\n        Returns:\n            相对路径字符串，如 \"images/xxx.png\"\n        \"\"\"\n        if not abs_path:\n            return None\n\n        try:\n            path = Path(abs_path)\n\n            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n            if not path.is_absolute():\n                return str(path).replace('\\\\', '/')\n\n            # 尝试转换为相对于存储根目录的路径\n            storage_root = Path(self.storage_manager.root_path)\n            try:\n                relative = path.relative_to(storage_root)\n                return str(relative).replace('\\\\', '/')\n            except ValueError:\n                # 路径不在存储根目录下，尝试提取文件名部分\n                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n                parts = path.parts\n                for i, part in enumerate(parts):\n                    if part in ('images', 'videos', 'thumbnails', 'references'):\n                        relative = Path(*parts[i:])\n                        return str(relative).replace('\\\\', '/')\n\n                # 无法提取，返回原路径（记录警告）\n                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n                return str(path).replace('\\\\', '/')\n\n        except Exception as e:\n            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n            return abs_path\n\n    def _extract_width_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取宽度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[0])\n        except (ValueError, IndexError):\n            return 1280  # 默认值\n    \n    def _extract_height_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取高度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[1])\n        except (ValueError, IndexError):\n            return 720  # 默认值\n\n    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取视频信息\n\n        Args:\n            video_path: 视频文件路径\n\n        Returns:\n            Dict: 视频信息\n        \"\"\"\n        try:\n            # 这里可以使用ffprobe或其他工具获取视频信息\n            # 暂时返回基本信息\n            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n        except Exception as e:\n            logger.error(f\"获取视频信息失败: {e}\")\n            return {}\n\n    def _save_task_metadata(self, result: Dict[str, Any]):\n        \"\"\"\n        保存任务元数据\n\n        Args:\n            result: 任务结果\n        \"\"\"\n        try:\n            # 构建视频元数据\n            metadata = {\n                \"generation_id\": result[\"task_id\"],\n                \"file_id\": result[\"task_id\"],\n                \"filename\": result.get(\"filename\", \"\"),\n                \"file_path\": result.get(\"local_path\", \"\"),\n                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n                \"parameters\": result.get(\"parameters\", {}),\n                \"created_at\": result[\"created_at\"],\n                \"file_size\": result.get(\"local_file_size\", 0),\n                \"source_url\": result.get(\"video_url\", \"\"),\n                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n            }\n\n            # 调用视频元数据保存方法\n            self.metadata_manager.save_video_metadata(metadata)\n            \n            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n\n        except Exception as e:\n            logger.error(f\"保存任务元数据失败: {e}\")\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取视频生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('videos', limit=limit)\n\n    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据输入图像路径搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        return self.metadata_manager.search_records(\"input_image\", keyword)\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            df = self.metadata_manager.get_dataframe()\n\n            if df.empty:\n                return {\n                    \"total_videos\": 0,\n                    \"success_count\": 0,\n                    \"failed_count\": 0,\n                    \"pending_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"total_duration\": 0,\n                    \"average_duration\": 0,\n                }\n\n            stats = {\n                \"total_videos\": len(df),\n                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n                \"total_file_size\": df[\"local_file_size\"].sum(),\n                \"average_file_size\": df[\"local_file_size\"].mean(),\n                \"total_duration\": df[\"duration\"].sum(),\n                \"average_duration\": df[\"duration\"].mean(),\n                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n            }\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {}\n\n    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n        \"\"\"获取用于显示的模型名称\"\"\"\n        # 从参数中获取模型变体信息\n        params = result.get('parameters', {})\n        model_variant = params.get('model_variant', '')\n        use_pro_model = params.get('use_pro_model', True)\n        \n        # 根据模型变体返回友好的显示名称\n        if 'seedance_pro' in model_variant or (use_pro_model and not model_variant):\n            return 'seedance 1.0 pro'\n        elif 'seedance_lite' in model_variant or (not use_pro_model and not model_variant):\n            return 'seedance 1.0 lite'\n        else:\n            # 回退到原始模型名称或默认值\n            return result.get('model', 'seedance')\n","numLines":1212,"startLine":1,"totalLines":1212}}}
{"parentUuid":"4e34c062-0202-4ac0-90a4-4a5ebef988c4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012qh2rxTPGPawwktNCp4z21","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→仓库管理器 - 统一管理所有内容仓库功能\n     5→\n     6→主要功能：\n     7→- 协调各个子模块的工作\n     8→- 提供统一的API接口\n     9→- 管理仓库配置和状态\n    10→- 处理跨模块的数据交互\n    11→\"\"\"\n    12→\n    13→import os\n    14→import json\n    15→import shutil\n    16→from pathlib import Path\n    17→from typing import Dict, List, Optional, Any\n    18→from datetime import datetime\n    19→from typing import Tuple\n    20→\n    21→from .sqlite_handler import SQLiteHandler\n    22→from tools import export_records\n    23→from loguru import logger\n    24→try:\n    25→    from utils.error_handler import global_error_handler as _global_error_handler\n    26→except Exception:\n    27→    _global_error_handler = None\n    28→\n    29→\n    30→class _RepoErrorHandler:\n    31→    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    32→    def log_error(self, message: str):\n    33→        try:\n    34→            if _global_error_handler:\n    35→                logger.error(message)\n    36→            else:\n    37→                print(f\"[RepositoryManager][ERROR] {message}\")\n    38→        except Exception:\n    39→            print(f\"[RepositoryManager][ERROR] {message}\")\n    40→\n    41→\n    42→class _NullTagManager:\n    43→    def get_content_tags(self, content_id: str):\n    44→        return []\n    45→    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n    46→        return False\n    47→    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n    48→        return False\n    49→    def get_all_tags(self, category: str = None):\n    50→        return []\n    51→    def get_statistics(self):\n    52→        return {}\n    53→    def export_data(self):\n    54→        return {}\n    55→\n    56→\n    57→class _NullSearchEngine:\n    58→    def get_total_count(self) -> int:\n    59→        return 0\n    60→    def export_data(self):\n    61→        return {}\n    62→\n    63→\n    64→class RepositoryManager:\n    65→    \"\"\"\n    66→    仓库管理器 - 内容仓库的核心控制器\n    67→    \n    68→    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    69→    为上层应用提供统一的仓库管理接口。\n    70→    \"\"\"\n    71→    \n    72→    def __init__(self, storage_root: str):\n    73→        \"\"\"\n    74→        初始化仓库管理器\n    75→        \n    76→        Args:\n    77→            storage_root: 用户指定的存储根目录\n    78→        \"\"\"\n    79→        self.storage_root = Path(storage_root)\n    80→        self.repository_root = self.storage_root / \"repository\"\n    81→        self.config_file = self.repository_root / \"config.json\"\n    82→        \n    83→        # 确保仓库目录存在\n    84→        self.repository_root.mkdir(parents=True, exist_ok=True)\n    85→        \n    86→        # 初始化子模块\n    87→        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n    88→        # 提供占位依赖，避免未实现接口导致崩溃\n    89→        self.error_handler = _RepoErrorHandler()\n    90→        self.tag_manager = _NullTagManager()\n    91→        self.search_engine = _NullSearchEngine()\n    92→        \n    93→        # 加载配置\n    94→        self.config = self._load_config()\n    95→        \n    96→        # 初始化仓库\n    97→        self._initialize_repository()\n    98→    \n    99→    def _load_config(self) -> Dict[str, Any]:\n   100→        \"\"\"\n   101→        加载仓库配置\n   102→        \n   103→        Returns:\n   104→            配置字典\n   105→        \"\"\"\n   106→        default_config = {\n   107→            \"version\": \"0.1.5\",\n   108→            \"created_at\": datetime.now().isoformat(),\n   109→            \"last_updated\": datetime.now().isoformat(),\n   110→            \"auto_tag_enabled\": True,\n   111→            \"search_index_enabled\": True,\n   112→            \"tag_categories\": [\n   113→                \"内容类型\",\n   114→                \"创建时间\", \n   115→                \"质量评级\",\n   116→                \"使用场景\",\n   117→                \"风格特征\",\n   118→                \"自定义标签\"\n   119→            ],\n   120→            \"supported_file_types\": [\"image\", \"video\", \"audio\", \"chat\"],\n   121→            \"max_tags_per_item\": 20,\n   122→            \"search_result_limit\": 100\n   123→        }\n   124→        \n   125→        if self.config_file.exists():\n   126→            try:\n   127→                with open(self.config_file, 'r', encoding='utf-8') as f:\n   128→                    config = json.load(f)\n   129→                # 合并默认配置，确保新字段存在\n   130→                for key, value in default_config.items():\n   131→                    if key not in config:\n   132→                        config[key] = value\n   133→                return config\n   134→            except Exception as e:\n   135→                self.error_handler.log_error(f\"加载仓库配置失败: {e}\")\n   136→                return default_config\n   137→        else:\n   138→            # 创建默认配置文件\n   139→            self._save_config(default_config)\n   140→            return default_config\n   141→    \n   142→    def _save_config(self, config: Dict[str, Any]) -> None:\n   143→        \"\"\"\n   144→        保存仓库配置\n   145→        \n   146→        Args:\n   147→            config: 配置字典\n   148→        \"\"\"\n   149→        try:\n   150→            config[\"last_updated\"] = datetime.now().isoformat()\n   151→            with open(self.config_file, 'w', encoding='utf-8') as f:\n   152→                json.dump(config, f, ensure_ascii=False, indent=2)\n   153→        except Exception as e:\n   154→            self.error_handler.log_error(f\"保存仓库配置失败: {e}\")\n   155→    \n   156→    def _initialize_repository(self) -> None:\n   157→        \"\"\"\n   158→        初始化仓库结构\n   159→        \"\"\"\n   160→        try:\n   161→            # 创建必要的子目录\n   162→            subdirs = [\"tags\", \"index\", \"cache\", \"exports\"]\n   163→            for subdir in subdirs:\n   164→                (self.repository_root / subdir).mkdir(exist_ok=True)\n   165→            \n   166→            print(f\"仓库初始化完成: {self.repository_root}\")\n   167→            \n   168→        except Exception as e:\n   169→            self.error_handler.log_error(f\"仓库初始化失败: {e}\")\n   170→            raise\n   171→\n   172→    def _ensure_dict(self, value: Any) -> Dict[str, Any]:\n   173→        if isinstance(value, dict):\n   174→            return value\n   175→        if isinstance(value, str) and value:\n   176→            try:\n   177→                loaded = json.loads(value)\n   178→                return loaded if isinstance(loaded, dict) else {}\n   179→            except Exception:\n   180→                return {}\n   181→        return {}\n   182→\n   183→    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n   184→        normalized: List[Dict[str, Any]] = []\n   185→        if not records:\n   186→            return normalized\n   187→        seen_keys: set[str] = set()\n   188→        for record in records:\n   189→            normalized_record = self._normalize_record(record, content_type)\n   190→            if not normalized_record:\n   191→                continue\n   192→            gen_key = normalized_record.get('generation_id') or normalized_record.get('task_id') or normalized_record.get('file_id')\n   193→            key = str(gen_key) if gen_key else None\n   194→            if key and key in seen_keys:\n   195→                continue\n   196→            if key:\n   197→                seen_keys.add(key)\n   198→            normalized.append(normalized_record)\n   199→        return normalized\n   200→\n   201→    \n   202→    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n   203→        if not isinstance(record, dict):\n   204→            return {}\n   205→\n   206→        item = dict(record)\n   207→        metadata_raw = item.get('metadata') or {}\n   208→        if isinstance(metadata_raw, str):\n   209→            try:\n   210→                metadata_raw = json.loads(metadata_raw) or {}\n   211→            except Exception:\n   212→                metadata_raw = {}\n   213→        item['metadata'] = metadata_raw\n   214→\n   215→        # 统一内容类型\n   216→        ctype = item.get('content_type') or content_type or ''\n   217→        if ctype == 'image':\n   218→            ctype = 'images'\n   219→        elif ctype == 'video':\n   220→            ctype = 'videos'\n   221→        item['content_type'] = ctype\n   222→\n   223→        # 解析JSON字段\n   224→        item['parameters'] = self._ensure_dict(item.get('parameters'))\n   225→        item['metadata'] = self._ensure_dict(item.get('metadata'))\n   226→        item['batch_info'] = self._ensure_dict(item.get('batch_info'))\n   227→\n   228→        metadata = item['metadata']\n   229→\n   230→        # 同步核心字段\n   231→        created_at = item.get('created_at')\n   232→        if not created_at:\n   233→            created_at = metadata.get('created_at') or metadata.get('completed_at')\n   234→        if not created_at:\n   235→            created_at = datetime.now().isoformat()\n   236→        if isinstance(created_at, datetime):\n   237→            item['created_at'] = created_at.isoformat()\n   238→        else:\n   239→            item['created_at'] = created_at\n   240→\n   241→        file_id = item.get('file_id') or item.get('generation_id') or metadata.get('task_id')\n   242→        if file_id:\n   243→            item['file_id'] = str(file_id)\n   244→\n   245→        generation_id = item.get('generation_id') or metadata.get('generation_id') or metadata.get('task_id')\n   246→        if generation_id:\n   247→            item['generation_id'] = str(generation_id)\n   248→\n   249→        resolved_path = item.get('resolved_path')\n   250→        candidate_paths = [\n   251→            resolved_path,\n   252→            item.get('absolute_path'),\n   253→            metadata.get('local_path'),\n   254→            item.get('file_path'),\n   255→        ]\n   256→        abs_path = next((p for p in candidate_paths if p), None)\n   257→        \n   258→        # 验证绝对路径是否真实存在（修复旧记录路径失效问题）\n   259→        if abs_path and not Path(abs_path).exists():\n   260→            logger.warning(f\"绝对路径无效，将尝试从relative_path重新构造: {abs_path}\")\n   261→            abs_path = None  # 重置，触发下面的重新构造逻辑\n   262→        \n   263→        if not abs_path and (item.get('relative_path') or metadata.get('relative_path')):\n   264→            rel = item.get('relative_path') or metadata.get('relative_path')\n   265→            try:\n   266→                root = self.storage_root\n   267→                original_path = Path(root) / rel\n   268→                if original_path.exists():\n   269→                    abs_path = str(original_path)\n   270→                    logger.debug(f\"使用路径: {abs_path}\")\n   271→                else:\n   272→                    abs_path = str(original_path)\n   273→                    logger.warning(f\"文件不存在: {original_path}\")\n   274→            except Exception as e:\n   275→                logger.error(f\"路径解析失败: {rel}, 错误: {e}\")\n   276→                abs_path = None\n   277→\n   278→        if abs_path:\n   279→            abs_path = str(abs_path)\n   280→            item['absolute_path'] = abs_path\n   281→            item['local_path'] = abs_path\n   282→            item['file_path'] = abs_path\n   283→\n   284→        # 记录相对路径\n   285→        rel_value = item.get('relative_path') or metadata.get('relative_path')\n   286→        if rel_value:\n   287→            item['relative_path'] = str(rel_value)\n   288→\n   289→        # 若缺少真实路径且状态已完成，则忽略该记录\n   290→        if not (item.get('file_path') or item.get('absolute_path') or item.get('relative_path')):\n   291→            status = str(item.get('status') or '').lower()\n   292→            # pending 状态的记录应该保留（即使缺路径，用于占位卡片显示）\n   293→            if status == 'pending':\n   294→                pass  # 不过滤，继续处理\n   295→            elif not status or status in {'completed', 'success'}:\n   296→                return {}\n   297→\n   298→       # 缩略图字段\n   299→        thumb_local = item.get('thumbnail_local_path') or metadata.get('thumbnail_local_path') or metadata.get('api_thumbnail_local_path')\n   300→        if thumb_local:\n   301→            item['thumbnail_local_path'] = str(thumb_local)\n   302→\n   303→        thumb_rel = item.get('thumbnail_path') or metadata.get('thumbnail_path') or item.get('thumbnail_local_path')\n   304→        if thumb_rel:\n   305→            item['thumbnail_path'] = str(thumb_rel)\n   306→            # 如果没有 thumbnail_local_path，则从相对路径生成绝对路径\n   307→            if not thumb_local:\n   308→                try:\n   309→                    thumb_abs = Path(self.storage_root) / thumb_rel\n   310→                    if thumb_abs.exists():\n   311→                        item['thumbnail_local_path'] = str(thumb_abs)\n   312→                        logger.debug(f\"生成缩略图绝对路径: {thumb_abs}\")\n   313→                    else:\n   314→                        logger.debug(f\"缩略图文件不存在: {thumb_abs}\")\n   315→                except Exception as e:\n   316→                    logger.debug(f\"缩略图路径解析失败: {thumb_rel}, 错误: {e}\")\n   317→\n   318→        # 补充尺寸信息，便于前端按比例渲染\n   319→        width = item.get('width') or metadata.get('width')\n   320→        height = item.get('height') or metadata.get('height')\n   321→        if width:\n   322→            try:\n   323→                item['width'] = int(float(width))\n   324→            except Exception:\n   325→                pass\n   326→        if height:\n   327→            try:\n   328→                item['height'] = int(float(height))\n   329→            except Exception:\n   330→                pass\n   331→        # 尝试从参数 size 提取比例（如果未提供 width/height）\n   332→        if (not item.get('width') or not item.get('height')):\n   333→            size_txt = item['parameters'].get('size') if isinstance(item['parameters'], dict) else None\n   334→            if isinstance(size_txt, str) and 'x' in size_txt:\n   335→                try:\n   336→                    sw, sh = size_txt.split('x')\n   337→                    item['width'] = item.get('width') or int(float(sw))\n   338→                    item['height'] = item.get('height') or int(float(sh))\n   339→                except Exception:\n   340→                    pass\n   341→        # 兜底：若本地文件存在且仍缺尺寸，尝试读取一次\n   342→        if (not item.get('width') or not item.get('height')):\n   343→            try:\n   344→                abs_path_probe = item.get('absolute_path') or item.get('file_path')\n   345→                if abs_path_probe and Path(abs_path_probe).exists():\n   346→                    from PIL import Image\n   347→                    with Image.open(abs_path_probe) as img:\n   348→                        item['width'] = item.get('width') or int(img.width)\n   349→                        item['height'] = item.get('height') or int(img.height)\n   350→            except Exception as exc:\n   351→                logger.debug(f\"尺寸读取失败: {exc}\")\n   352→\n   353→        # 提升 prompt 等常用字段\n   354→        if not item.get('prompt') and item['parameters'].get('prompt'):\n   355→            item['prompt'] = item['parameters']['prompt']\n   356→\n   357→        return item\n   358→\n   359→    def _parse_created_at(self, value: Any) -> datetime:\n   360→        if isinstance(value, datetime):\n   361→            return value\n   362→        if not value:\n   363→            return datetime.min\n   364→        text = str(value)\n   365→        try:\n   366→            if text.endswith('Z'):\n   367→                text = text[:-1] + '+00:00'\n   368→            return datetime.fromisoformat(text)\n   369→        except Exception:\n   370→            try:\n   371→                return datetime.strptime(text, '%Y-%m-%d %H:%M:%S')\n   372→            except Exception:\n   373→                return datetime.min\n   374→\n   375→    def _record_sort_key(self, record: Dict[str, Any]) -> Tuple[datetime, str]:\n   376→        created_dt = self._parse_created_at(record.get('created_at'))\n   377→        # fallback: 如果 created_at 无效，尝试使用 updated_at\n   378→        if created_dt == datetime.min:\n   379→            created_dt = self._parse_created_at(record.get('updated_at'))\n   380→        file_id = str(record.get('file_id', ''))\n   381→        return (created_dt, file_id)\n   382→\n   383→    def add_content(self, content_id: str, content_type: str, \n   384→                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n   385→        \"\"\"\n   386→        添加内容到仓库\n   387→        \n   388→        Args:\n   389→            content_id: 内容唯一标识\n   390→            content_type: 内容类型 (image/video/audio/chat)\n   391→            metadata: 内容元数据\n   392→            auto_tag: 是否自动生成标签\n   393→        \n   394→        Returns:\n   395→            是否添加成功\n   396→        \"\"\"\n   397→        try:\n   398→            normalized_type = (content_type or '').lower()\n   399→            if normalized_type in {'image', 'images'}:\n   400→                storage_type = 'images'\n   401→            elif normalized_type in {'video', 'videos'}:\n   402→                storage_type = 'videos'\n   403→            else:\n   404→                storage_type = normalized_type or 'unknown'\n   405→            status = metadata.get('status', 'unknown')\n   406→            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n   407→            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n   408→            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n   409→            return result\n   410→        except Exception as e:\n   411→            logger.error(f\"添加内容失败: {e}\")\n   412→            return False\n   413→    \n   414→    def update_record(self, record_id: str, data: Dict[str, Any]) -> bool:\n   415→        \"\"\"更新记录\"\"\"\n   416→        try:\n   417→            return self.sqlite_handler.update_record(record_id, data)\n   418→        except Exception as e:\n   419→            logger.error(f\"更新记录失败: {e}\")\n   420→            return False\n   421→\n   422→    def delete_record(self, record_id: str) -> bool:\n   423→        \"\"\"删除记录\"\"\"\n   424→        try:\n   425→            return self.sqlite_handler.delete_record(record_id)\n   426→        except Exception as e:\n   427→            logger.error(f\"删除记录失败: {e}\")\n   428→            return False\n   429→\n   430→    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n   431→        \"\"\"清理超时的 pending 记录\n   432→\n   433→        Args:\n   434→            timeout_hours: 超时时间（小时），默认 1 小时\n   435→\n   436→        Returns:\n   437→            清理的记录数量\n   438→        \"\"\"\n   439→        try:\n   440→            return self.sqlite_handler.cleanup_stale_pending_records(timeout_hours)\n   441→        except Exception as e:\n   442→            logger.error(f\"清理过期 pending 记录失败: {e}\")\n   443→            return 0\n   444→\n   445→    def get_record_by_id(self, record_id: str) -> Optional[Dict[str, Any]]:\n   446→        \"\"\"根据 ID 获取单条记录。\"\"\"\n   447→        if not record_id:\n   448→            return None\n   449→        try:\n   450→            raw = self.sqlite_handler.get_record_by_id(record_id)\n   451→            if not raw:\n   452→                return None\n   453→            content_type = raw.get('content_type') or 'image'\n   454→            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n   455→            normalized = self._normalize_record(raw, normalized_type)\n   456→            if not normalized:\n   457→                return None\n   458→            self._attach_reference_assets([normalized], absolute=True)\n   459→            return normalized\n   460→        except Exception as e:\n   461→            logger.error(f\"获取记录失败: {e}\")\n   462→            return None\n   463→    \n   464→    def get_records_batch(self, start_index=0, batch_size=40, record_type='all'):\n   465→        \"\"\"\n   466→        批量获取记录，支持分页查询\n   467→        \n   468→        Args:\n   469→            start_index: 起始索引\n   470→            batch_size: 批量大小\n   471→            record_type: 记录类型 ('image', 'video', 'all')\n   472→        \n   473→        Returns:\n   474→            List[Dict]: 记录列表\n   475→        \"\"\"\n   476→        try:\n   477→            normalized_type = (record_type or 'all').lower()\n   478→            if normalized_type == 'images':\n   479→                normalized_type = 'image'\n   480→            elif normalized_type == 'videos':\n   481→                normalized_type = 'video'\n   482→\n   483→            if normalized_type == 'all':\n   484→                fetch_limit = max(batch_size, start_index + batch_size)\n   485→                images = self.sqlite_handler.get_records('images', fetch_limit, 0) or []\n   486→                videos = self.sqlite_handler.get_records('videos', fetch_limit, 0) or []\n   487→                combined = images + videos\n   488→                combined.sort(key=self._record_sort_key, reverse=True)\n   489→                end_index = start_index + batch_size\n   490→                result = combined[start_index:end_index]\n   491→            else:\n   492→                content_type = 'images' if normalized_type == 'image' else 'videos'\n   493→                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n   494→                result.sort(key=self._record_sort_key, reverse=True)\n   495→\n   496→            normalized = self._normalize_records(result, normalized_type)\n   497→            self._attach_reference_assets(normalized, absolute=True)\n   498→            return normalized\n   499→        except Exception as e:\n   500→            self.error_handler.log_error(f\"批量获取记录失败: {e}\")\n   501→            return []\n   502→\n   503→    def get_records_batch_reverse(self, limit=80, offset=0, record_type='all'):\n   504→        \"\"\"\n   505→        倒序分页查询记录 - 瀑布流1000条方案专用\n   506→        \n   507→        优化特性：\n   508→        - 从最新记录开始的高效倒序查询\n   509→        - 支持80+30增量加载模式\n   510→        - 针对1000条数据优化的性能\n   511→        - 减少内存占用和查询时间\n   512→        \n   513→        Args:\n   514→            limit: 查询数量限制 (默认80，增量30)\n   515→            offset: 偏移量 (从最新记录开始计算)\n   516→            record_type: 记录类型 ('image', 'video', 'all')\n   517→        \n   518→        Returns:\n   519→            List[Dict]: 按时间倒序排列的记录列表\n   520→        \"\"\"\n   521→        try:\n   522→            normalized_type = (record_type or 'all').lower()\n   523→            if normalized_type == 'images':\n   524→                normalized_type = 'image'\n   525→            elif normalized_type == 'videos':\n   526→                normalized_type = 'video'\n   527→\n   528→            max_single_query = min(limit + 50, 200)\n   529→\n   530→            if normalized_type == 'all':\n   531→                images = self.sqlite_handler.get_records('images', max_single_query, 0) or []\n   532→                videos = self.sqlite_handler.get_records('videos', max_single_query, 0) or []\n   533→                combined = images + videos\n   534→                combined.sort(key=self._record_sort_key, reverse=True)\n   535→                start_idx = offset\n   536→                end_idx = offset + limit\n   537→                result = combined[start_idx:end_idx]\n   538→            else:\n   539→                content_type = 'images' if normalized_type == 'image' else 'videos'\n   540→                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n   541→                result.sort(key=self._record_sort_key, reverse=True)\n   542→\n   543→            normalized = self._normalize_records(result, normalized_type)\n   544→            self._attach_reference_assets(normalized, absolute=True)\n   545→\n   546→            return normalized\n   547→\n   548→        except Exception as e:\n   549→            self.error_handler.log_error(f\"倒序分页查询失败: {e}\")\n   550→            return []\n   551→\n   552→    def get_records_count_optimized(self, record_type='all'):\n   553→        \"\"\"\n   554→        优化的记录计数方法 - 瀑布流1000条方案专用\n   555→        \n   556→        提供快速的记录计数，支持1000条限制逻辑\n   557→        \n   558→        Args:\n   559→            record_type: 记录类型 ('image', 'video', 'all')\n   560→        \n   561→        Returns:\n   562→            Dict: {'total': int, 'capped_at_1000': bool}\n   563→        \"\"\"\n   564→        try:\n   565→            normalized_type = (record_type or 'all').lower()\n   566→            if normalized_type == 'image':\n   567→                total = self.sqlite_handler.get_total_count('images')\n   568→            elif normalized_type == 'video':\n   569→                total = self.sqlite_handler.get_total_count('videos')\n   570→            else:\n   571→                total = (\n   572→                    self.sqlite_handler.get_total_count('images') +\n   573→                    self.sqlite_handler.get_total_count('videos')\n   574→                )\n   575→\n   576→            # 1000条限制逻辑\n   577→            capped_at_1000 = total > 1000\n   578→            effective_total = min(total, 1000)\n   579→            \n   580→            return {\n   581→                'total': effective_total,\n   582→                'actual_total': total,\n   583→                'capped_at_1000': capped_at_1000\n   584→            }\n   585→            \n   586→        except Exception as e:\n   587→            self.error_handler.log_error(f\"优化记录计数失败: {e}\")\n   588→            return {'total': 0, 'actual_total': 0, 'capped_at_1000': False}\n   589→\n   590→    # =========================\n   591→    # 游标分页协议（初版实现）\n   592→    # 接口：get_records(page_size, cursor, record_type) -> { items, next_cursor }\n   593→    # 说明：当前实现基于现有CSV读取能力合并排序后切片，后续可在存储层优化为限窗/游标扫描。\n   594→    # =========================\n   595→    def get_records(self, page_size: int = 40, cursor: Optional[str] = None, record_type: str = 'all') -> Dict[str, Any]:\n   596→        \"\"\"\n   597→        游标分页获取记录\n   598→\n   599→        Args:\n   600→            page_size: 每页大小\n   601→            cursor: 上一页游标（格式：\"<created_at>|<file_id>|<type>\"），None表示第一页\n   602→            record_type: 'image' | 'video' | 'all'\n   603→\n   604→        Returns:\n   605→            dict: { items: List[Dict], next_cursor: Optional[str] }\n   606→        \"\"\"\n   607→        try:\n   608→            # 解析游标\n   609→            cursor_tuple: Optional[Tuple[str, str, str]] = None\n   610→            if cursor:\n   611→                try:\n   612→                    parts = cursor.split('|')\n   613→                    if len(parts) >= 3:\n   614→                        cursor_tuple = (parts[0], parts[1], parts[2])  # created_at, file_id, type\n   615→                except Exception:\n   616→                    cursor_tuple = None\n   617→\n   618→            # 拉取候选数据（按需窗口，尽量少取）\n   619→            fetch_limit = max(page_size * 3, 60)\n   620→\n   621→            def _load(ct: str) -> List[Dict[str, Any]]:\n   622→                return self._normalize_records(\n   623→                    self.sqlite_handler.get_records(ct, fetch_limit, 0) or [],\n   624→                    ct\n   625→                )\n   626→\n   627→            if record_type == 'image':\n   628→                records = _load('images')\n   629→            elif record_type == 'video':\n   630→                records = _load('videos')\n   631→            else:\n   632→                records = _load('images') + _load('videos')\n   633→\n   634→            # 排序：created_at DESC, file_id DESC\n   635→            records.sort(key=self._record_sort_key, reverse=True)\n   636→\n   637→            # 光标过滤：跳过光标及其之前的元素（保持稳定倒序）\n   638→            filtered: List[Dict[str, Any]] = []\n   639→            if cursor_tuple:\n   640→                cur_created, cur_id, cur_type = cursor_tuple\n   641→                passed = False\n   642→                for rec in records:\n   643→                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n   644→                    rec_key = (rec.get('created_at', '1970-01-01T00:00:00'), rec.get('file_id', ''), rec_type)\n   645→                    # 记录严格小于游标（因为倒序），才加入\n   646→                    if passed:\n   647→                        filtered.append(rec)\n   648→                    else:\n   649→                        if (rec_key[0] < cur_created) or (rec_key[0] == cur_created and rec_key[1] < cur_id) or (rec_key[0] == cur_created and rec_key[1] == cur_id and rec_key[2] < cur_type):\n   650→                            passed = True\n   651→                            filtered.append(rec)\n   652→                candidates = filtered\n   653→            else:\n   654→                candidates = records\n   655→\n   656→            # 取一页\n   657→            page_items = candidates[:page_size]\n   658→            self._attach_reference_assets(page_items, absolute=True)\n   659→\n   660→            # 生成 next_cursor\n   661→            if page_items:\n   662→                last = page_items[-1]\n   663→                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n   664→                next_cursor = f\"{last.get('created_at','')}|{last.get('file_id','')}|{last_type}\"\n   665→            else:\n   666→                next_cursor = None\n   667→\n   668→            return {\n   669→                'items': page_items,\n   670→                'next_cursor': next_cursor\n   671→            }\n   672→\n   673→        except Exception as e:\n   674→            self.error_handler.log_error(f\"游标分页获取记录失败: {e}\")\n   675→            return {\n   676→                'items': [],\n   677→                'next_cursor': None\n   678→            }\n   679→\n   680→    def get_total_count(self, record_type='all'):\n   681→        \"\"\"\n   682→        获取总记录数\n   683→        \n   684→        Args:\n   685→            record_type: 记录类型 ('image', 'video', 'all')\n   686→            \n   687→        Returns:\n   688→            int: 总记录数\n   689→        \"\"\"\n   690→        try:\n   691→            normalized_type = (record_type or 'all').lower()\n   692→            if normalized_type == 'image':\n   693→                return self.sqlite_handler.get_total_count('images')\n   694→            if normalized_type == 'video':\n   695→                return self.sqlite_handler.get_total_count('videos')\n   696→\n   697→            return (\n   698→                self.sqlite_handler.get_total_count('images') +\n   699→                self.sqlite_handler.get_total_count('videos')\n   700→            )\n   701→        except Exception as e:\n   702→            self.error_handler.log_error(f\"获取记录总数失败: {e}\")\n   703→            return 0\n   704→\n   705→    def _resolve_reference_assets(self, record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n   706→        if not isinstance(record, dict):\n   707→            return []\n   708→\n   709→        params_raw = record.get('parameters')\n   710→        params_dict: Dict[str, Any] = {}\n   711→        if isinstance(params_raw, dict):\n   712→            params_dict = params_raw\n   713→        elif isinstance(params_raw, str):\n   714→            try:\n   715→                params_dict = json.loads(params_raw) or {}\n   716→            except Exception:\n   717→                params_dict = {}\n   718→\n   719→        assets = []\n   720→        if isinstance(params_dict, dict):\n   721→            assets = params_dict.get('reference_assets') or []\n   722→        if not assets:\n   723→            fallback = record.get('reference_assets')\n   724→            assets = fallback if isinstance(fallback, list) else []\n   725→        if not assets:\n   726→            return []\n   727→\n   728→        resolved: List[Dict[str, Any]] = []\n   729→        for item in assets:\n   730→            if not isinstance(item, dict):\n   731→                continue\n   732→            rec = dict(item)\n   733→            rel_path = rec.get('relative_path') or rec.get('asset_path')\n   734→            if rel_path and absolute:\n   735→                abs_path = Path(self.storage_root) / rel_path\n   736→                rec['absolute_path'] = str(abs_path)\n   737→                rec['asset_path'] = str(abs_path)\n   738→            resolved.append(rec)\n   739→        return resolved\n   740→\n   741→    \n   742→    def _resolve_video_reference_assets(self, record: Dict[str, Any]) -> List[Dict[str, Any]]:\n   743→        \"\"\"\n   744→        解析视频记录中的参考图资产\n   745→        \n   746→        从parameters.first_frame和image_path提取参考图信息\n   747→        \"\"\"\n   748→        if not isinstance(record, dict):\n   749→            return []\n   750→            \n   751→        params = record.get('parameters', {})\n   752→        if isinstance(params, str):\n   753→            try:\n   754→                params = json.loads(params)\n   755→            except:\n   756→                params = {}\n   757→\n   758→        # 收集参考图路径\n   759→        ref_paths = []\n   760→\n   761→        storage_root = self.storage_root\n   762→\n   763→        def _resolve_path(path_str: Optional[str]) -> Optional[Path]:\n   764→            if not path_str:\n   765→                return None\n   766→            candidate = Path(path_str).expanduser()\n   767→            if candidate.is_absolute():\n   768→                return candidate if candidate.exists() else None\n   769→            combined = storage_root / path_str.lstrip('/\\\\')\n   770→            return combined if combined.exists() else None\n   771→\n   772→        # 从first_frame提取\n   773→        first_frame = params.get('first_frame')\n   774→        resolved_first = _resolve_path(first_frame) if isinstance(first_frame, str) else None\n   775→        if resolved_first:\n   776→            ref_paths.append(('first_frame', str(resolved_first)))\n   777→\n   778→        # 从last_frame提取（首尾帧模式）\n   779→        last_frame = params.get('last_frame')\n   780→        resolved_last = _resolve_path(last_frame) if isinstance(last_frame, str) else None\n   781→        if resolved_last:\n   782→            ref_paths.append(('last_frame', str(resolved_last)))\n   783→\n   784→        # 从image_path提取\n   785→        image_path = params.get('image_path')\n   786→        resolved_image = _resolve_path(image_path) if isinstance(image_path, str) else None\n   787→        if resolved_image and all(str(resolved_image) != existing_path for _, existing_path in ref_paths):\n   788→            ref_paths.append(('image', str(resolved_image)))\n   789→\n   790→        # 构建参考图资产信息\n   791→        resolved_assets = []\n   792→        for i, (kind, path) in enumerate(ref_paths):\n   793→            try:\n   794→                file_path = Path(path)\n   795→                if file_path.exists():\n   796→                    stat = file_path.stat()\n   797→                    try:\n   798→                        rel = file_path.resolve().relative_to(storage_root)\n   799→                        rel_str = str(rel).replace('\\\\', '/')\n   800→                    except ValueError:\n   801→                        rel_str = str(file_path)\n   802→                    asset = {\n   803→                        'id': f'ref_video_{record.get(\"generation_id\", \"unknown\")}_{i}',\n   804→                        'path': rel_str,\n   805→                        'relative_path': rel_str,\n   806→                        'absolute_path': str(file_path.resolve()),\n   807→                        'type': 'image',\n   808→                        'kind': kind or 'image',\n   809→                        'source': file_path.name,\n   810→                        'order': i,\n   811→                        'size': stat.st_size,\n   812→                        'exists': True,\n   813→                        'created_at': record.get('created_at', datetime.now().isoformat())\n   814→                    }\n   815→\n   816→                    # 尝试获取图片尺寸\n   817→                    try:\n   818→                        from PIL import Image\n   819→                        with Image.open(path) as img:\n   820→                            asset['width'] = img.width\n   821→                            asset['height'] = img.height\n   822→                    except:\n   823→                        asset['width'] = None\n   824→                        asset['height'] = None\n   825→                        \n   826→                    resolved_assets.append(asset)\n   827→            except Exception as e:\n   828→                print(f\"  ⚠️ 解析参考图失败: {path} - {e}\")\n   829→                \n   830→        return resolved_assets\n   831→\n   832→    def _attach_reference_assets(self, records: List[Dict[str, Any]], *, absolute: bool = False) -> None:\n   833→        if not records:\n   834→            return\n   835→        for record in records:\n   836→            try:\n   837→                # 先尝试原有的解析逻辑\n   838→                resolved = self._resolve_reference_assets(record, absolute=absolute)\n   839→                \n   840→                # 如果原有逻辑没有找到参考图，尝试视频参考图解析\n   841→                if not resolved and record.get('content_type') == 'videos':\n   842→                    video_refs = self._resolve_video_reference_assets(record)\n   843→                    if video_refs:\n   844→                        resolved = video_refs\n   845→                        # 更新_reference_info\n   846→                        record['_reference_info'] = {\n   847→                            'count': len(video_refs),\n   848→                            'summary': f'{len(video_refs)}个参考图',\n   849→                            'labels': ['参考图'],\n   850→                            'assets': video_refs\n   851→                        }\n   852→                \n   853→                if absolute:\n   854→                    record['_resolved_reference_assets_abs'] = resolved\n   855→                record['_resolved_reference_assets'] = resolved\n   856→                \n   857→                # 确保_reference_info存在\n   858→                if '_reference_info' not in record:\n   859→                    record['_reference_info'] = {\n   860→                        'count': len(resolved),\n   861→                        'summary': f'{len(resolved)}个参考图' if resolved else '',\n   862→                        'labels': ['参考图'] if resolved else [],\n   863→                        'assets': resolved\n   864→                    }\n   865→                    \n   866→            except Exception as exc:\n   867→                logger.debug(f\"attach_reference_assets failed: {exc}\")\n   868→\n   869→    def search_content(self, query: str, content_type: Optional[str] = None,\n   870→                      tags: Optional[List[str]] = None, \n   871→                      limit: int = None) -> List[Dict[str, Any]]:\n   872→        \"\"\"\n   873→        搜索仓库内容\n   874→        \n   875→        Args:\n   876→            query: 搜索关键词\n   877→            content_type: 内容类型过滤\n   878→            tags: 标签过滤\n   879→            limit: 结果数量限制\n   880→        \n   881→        Returns:\n   882→            搜索结果列表\n   883→        \"\"\"\n   884→        try:\n   885→            if limit is None or limit <= 0:\n   886→                limit = self.config.get(\"search_result_limit\", 100)\n   887→\n   888→            keyword = (query or \"\").strip()\n   889→            if not keyword:\n   890→                return []\n   891→\n   892→            normalized_type = 'all'\n   893→            sqlite_type: Optional[str] = None\n   894→            if content_type:\n   895→                ct = content_type.lower()\n   896→                if ct in {'image', 'images'}:\n   897→                    sqlite_type = 'images'\n   898→                    normalized_type = 'image'\n   899→                elif ct in {'video', 'videos'}:\n   900→                    sqlite_type = 'videos'\n   901→                    normalized_type = 'video'\n   902→\n   903→            results = self.sqlite_handler.search_records(keyword, sqlite_type, limit) or []\n   904→            normalized = self._normalize_records(results, normalized_type)\n   905→            self._attach_reference_assets(normalized, absolute=True)\n   906→            return normalized\n   907→        except Exception as e:\n   908→            logger.error(f\"搜索内容失败: {e}\")\n   909→            return []\n   910→    \n   911→    def get_content_tags(self, content_id: str) -> List[str]:\n   912→        \"\"\"\n   913→        获取内容的所有标签\n   914→        \n   915→        Args:\n   916→            content_id: 内容ID\n   917→        \n   918→        Returns:\n   919→            标签列表\n   920→        \"\"\"\n   921→        return self.tag_manager.get_content_tags(content_id)\n   922→    \n   923→    def add_tag_to_content(self, content_id: str, tag: str, \n   924→                          category: str = \"自定义标签\") -> bool:\n   925→        \"\"\"\n   926→        为内容添加标签\n   927→        \n   928→        Args:\n   929→            content_id: 内容ID\n   930→            tag: 标签名称\n   931→            category: 标签分类\n   932→        \n   933→        Returns:\n   934→            是否添加成功\n   935→        \"\"\"\n   936→        return self.tag_manager.add_tag_to_content(content_id, tag, category)\n   937→    \n   938→    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n   939→        \"\"\"\n   940→        从内容中移除标签\n   941→        \n   942→        Args:\n   943→            content_id: 内容ID\n   944→            tag: 标签名称\n   945→        \n   946→        Returns:\n   947→            是否移除成功\n   948→        \"\"\"\n   949→        return self.tag_manager.remove_tag_from_content(content_id, tag)\n   950→    \n   951→    def get_all_tags(self, category: Optional[str] = None) -> List[str]:\n   952→        \"\"\"\n   953→        获取所有标签\n   954→        \n   955→        Args:\n   956→            category: 标签分类过滤\n   957→        \n   958→        Returns:\n   959→            标签列表\n   960→        \"\"\"\n   961→        return self.tag_manager.get_all_tags(category)\n   962→    \n   963→    def get_tag_statistics(self) -> Dict[str, Any]:\n   964→        \"\"\"\n   965→        获取标签统计信息\n   966→        \n   967→        Returns:\n   968→            统计信息字典\n   969→        \"\"\"\n   970→        return self.tag_manager.get_statistics()\n   971→    \n   972→    def export_repository_data(self, export_format: str = \"json\") -> str:\n   973→        \"\"\"\n   974→        导出仓库数据\n   975→\n   976→        Args:\n   977→            export_format: 导出格式 (json/csv/xlsx)\n   978→\n   979→        Returns:\n   980→            导出文件路径\n   981→        \"\"\"\n   982→        try:\n   983→            export_dir = self.repository_root / \"exports\"\n   984→            export_dir.mkdir(exist_ok=True)\n   985→            \n   986→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n   987→            filename = f\"repository_export_{timestamp}.{export_format}\"\n   988→            export_path = export_dir / filename\n   989→            \n   990→            # 收集所有数据\n   991→            storage_stats = {\n   992→                \"images\": self.sqlite_handler.get_total_count('images'),\n   993→                \"videos\": self.sqlite_handler.get_total_count('videos')\n   994→            }\n   995→            data = {\n   996→                \"config\": self.config,\n   997→                \"tags\": self.tag_manager.export_data(),\n   998→                \"search_index\": self.search_engine.export_data(),\n   999→                \"storage_stats\": storage_stats,\n  1000→                \"export_time\": datetime.now().isoformat()\n  1001→            }\n  1002→            \n  1003→            if export_format == \"json\":\n  1004→                with open(export_path, 'w', encoding='utf-8') as f:\n  1005→                    json.dump(data, f, ensure_ascii=False, indent=2)\n  1006→            \n  1007→            return str(export_path)\n  1008→            \n  1009→        except Exception as e:\n  1010→            self.error_handler.log_error(f\"导出仓库数据失败: {e}\")\n  1011→            return \"\"\n  1012→\n  1013→    def export_generation_bundle(\n  1014→        self,\n  1015→        file_ids: List[str],\n  1016→        record_type: str = \"image\",\n  1017→        *,\n  1018→        destination_dir: Optional[str] = None,\n  1019→    ) -> Dict[str, Any]:\n  1020→        \"\"\"导出指定文件ID的生成记录及参考图。\"\"\"\n  1021→        def _mask(value: Any) -> str:\n  1022→            if value in (None, \"\"):\n  1023→                return \"-\"\n  1024→            text = str(value)\n  1025→            return f\"{text[:6]}***\"\n  1026→\n  1027→        record_type = (record_type or \"\").lower()\n  1028→        if record_type not in {\"image\", \"video\"}:\n  1029→            raise ValueError(f\"不支持的记录类型: {record_type}\")\n  1030→\n  1031→        exports_dir = Path(self.storage_root) / \"exports\"\n  1032→        exports_dir.mkdir(parents=True, exist_ok=True)\n  1033→        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n  1034→        output_base = exports_dir / f\"{record_type}_bundle_{timestamp}\"\n  1035→\n  1036→        normalized_ids = [str(fid) for fid in file_ids if fid]\n  1037→        export_result = export_records(record_type, normalized_ids, output_base)\n  1038→        if not export_result:\n  1039→            masked_ids = \",\".join(_mask(fid) for fid in normalized_ids) or \"-\"\n  1040→            logger.warning(\n  1041→                \"摘要|operation=export_bundle status=failed record_type={rtype} record_ids={ids} reason={reason}\",\n  1042→                rtype=record_type,\n  1043→                ids=masked_ids,\n  1044→                reason=\"no_result\",\n  1045→            )\n  1046→            raise RuntimeError(\"导出参考图失败\")\n  1047→\n  1048→        zip_path = Path(export_result[\"zip_path\"])\n  1049→        manifest_json = Path(export_result[\"manifest_json\"])\n  1050→        manifest_csv = Path(export_result[\"manifest_csv\"])\n  1051→\n  1052→        destination_zip = None\n  1053→        destination_manifest_json = None\n  1054→        destination_manifest_csv = None\n  1055→\n  1056→        if destination_dir:\n  1057→            dest_dir_path = Path(destination_dir).expanduser()\n  1058→            dest_dir_path.mkdir(parents=True, exist_ok=True)\n  1059→            try:\n  1060→                destination_zip = dest_dir_path / zip_path.name\n  1061→                shutil.copy2(zip_path, destination_zip)\n  1062→                destination_manifest_json = dest_dir_path / manifest_json.name\n  1063→                shutil.copy2(manifest_json, destination_manifest_json)\n  1064→                destination_manifest_csv = dest_dir_path / manifest_csv.name\n  1065→                shutil.copy2(manifest_csv, destination_manifest_csv)\n  1066→            except PermissionError as exc:\n  1067→                logger.warning(\n  1068→                    \"摘要|operation=export_bundle status=failed reason=permission_denied record_type={rtype} dest={dest}\",\n  1069→                    rtype=record_type,\n  1070→                    dest=dest_dir_path.name,\n  1071→                )\n  1072→                raise PermissionError(\"导出目录无写入权限\") from exc\n  1073→\n  1074→        reference_ids = export_result.get(\"reference_ids\", [])\n  1075→        masked_refs = \",\".join(_mask(rid) for rid in reference_ids if rid) or \"-\"\n  1076→        status = export_result.get(\"status\", \"success\") or \"success\"\n  1077→        missing_records = export_result.get(\"missing_records\", []) or []\n  1078→        missing_main_files = export_result.get(\"missing_main_files\", []) or []\n  1079→        missing_references = export_result.get(\"missing_references\", []) or []\n  1080→        dest_hint_path = destination_zip.parent if destination_zip else zip_path.parent\n  1081→        try:\n  1082→            dest_hint_text = Path(dest_hint_path).name or Path(dest_hint_path).parent.name\n  1083→        except Exception:\n  1084→            dest_hint_text = \"-\"\n  1085→        logger.info(\n  1086→            \"摘要|operation=export_bundle status={status} record_type={rtype} record_ids={ids} ref_count={ref_count} ref_ids={refs} missing_records={miss_rec} missing_files={miss_files} missing_refs={miss_refs} dest={dest}\",\n  1087→            status=status,\n  1088→            rtype=record_type,\n  1089→            ids=\",\".join(_mask(fid) for fid in normalized_ids) or \"-\",\n  1090→            ref_count=export_result.get(\"reference_count\", 0),\n  1091→            refs=masked_refs,\n  1092→            miss_rec=len(missing_records),\n  1093→            miss_files=len(missing_main_files),\n  1094→            miss_refs=len(missing_references),\n  1095→            dest=dest_hint_text or \"-\",\n  1096→        )\n  1097→\n  1098→        return {\n  1099→            \"zip_path\": str(zip_path),\n  1100→            \"manifest_json\": str(manifest_json),\n  1101→            \"manifest_csv\": str(manifest_csv),\n  1102→            \"destination_zip\": str(destination_zip) if destination_zip else None,\n  1103→            \"destination_manifest_json\": str(destination_manifest_json) if destination_manifest_json else None,\n  1104→            \"destination_manifest_csv\": str(destination_manifest_csv) if destination_manifest_csv else None,\n  1105→            \"status\": status,\n  1106→            \"reference_count\": export_result.get(\"reference_count\", 0),\n  1107→            \"reference_ids\": reference_ids,\n  1108→            \"missing_records\": missing_records,\n  1109→            \"missing_main_files\": missing_main_files,\n  1110→            \"missing_references\": missing_references,\n  1111→            \"records\": export_result.get(\"records\", []),\n  1112→            \"exported_record_ids\": export_result.get(\"exported_record_ids\", normalized_ids),\n  1113→        }\n  1114→    \n  1115→    def get_repository_status(self) -> Dict[str, Any]:\n  1116→        \"\"\"\n  1117→        获取仓库状态信息\n  1118→        \n  1119→        Returns:\n  1120→            状态信息字典\n  1121→        \"\"\"\n  1122→        try:\n  1123→            return {\n  1124→                \"version\": self.config.get(\"version\", \"0.1.5\"),\n  1125→                \"storage_root\": str(self.storage_root),\n  1126→                \"repository_root\": str(self.repository_root),\n  1127→                \"total_content_count\": self.get_total_count('all'),\n  1128→                \"total_tags_count\": len(self.tag_manager.get_all_tags()),\n  1129→                \"tag_categories\": self.config.get(\"tag_categories\", []),\n  1130→                \"last_updated\": self.config.get(\"last_updated\"),\n  1131→                \"auto_tag_enabled\": self.config.get(\"auto_tag_enabled\", True),\n  1132→                \"search_index_enabled\": self.config.get(\"search_index_enabled\", True)\n  1133→            }\n  1134→        except Exception as e:\n  1135→            self.error_handler.log_error(f\"获取仓库状态失败: {e}\")\n  1136→            return {}\n  1137→    \n  1138→    def update_config(self, new_config: Dict[str, Any]) -> bool:\n  1139→        \"\"\"\n  1140→        更新仓库配置\n  1141→        \n  1142→        Args:\n  1143→            new_config: 新配置字典\n  1144→        \n  1145→        Returns:\n  1146→            是否更新成功\n  1147→        \"\"\"\n  1148→        try:\n  1149→            self.config.update(new_config)\n  1150→            self._save_config(self.config)\n  1151→            return True\n  1152→        except Exception as e:\n  1153→            self.error_handler.log_error(f\"更新仓库配置失败: {e}\")\n  1154→            return False\n  1155→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"18bf93cd-a451-4449-ac6e-9e23afda0c7b","timestamp":"2025-12-11T08:09:28.663Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/repository/manager.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n仓库管理器 - 统一管理所有内容仓库功能\n\n主要功能：\n- 协调各个子模块的工作\n- 提供统一的API接口\n- 管理仓库配置和状态\n- 处理跨模块的数据交互\n\"\"\"\n\nimport os\nimport json\nimport shutil\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nfrom typing import Tuple\n\nfrom .sqlite_handler import SQLiteHandler\nfrom tools import export_records\nfrom loguru import logger\ntry:\n    from utils.error_handler import global_error_handler as _global_error_handler\nexcept Exception:\n    _global_error_handler = None\n\n\nclass _RepoErrorHandler:\n    \"\"\"轻量错误处理封装，兼容旧的 log_error 调用\"\"\"\n    def log_error(self, message: str):\n        try:\n            if _global_error_handler:\n                logger.error(message)\n            else:\n                print(f\"[RepositoryManager][ERROR] {message}\")\n        except Exception:\n            print(f\"[RepositoryManager][ERROR] {message}\")\n\n\nclass _NullTagManager:\n    def get_content_tags(self, content_id: str):\n        return []\n    def add_tag_to_content(self, content_id: str, tag: str, category: str = \"自定义标签\") -> bool:\n        return False\n    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n        return False\n    def get_all_tags(self, category: str = None):\n        return []\n    def get_statistics(self):\n        return {}\n    def export_data(self):\n        return {}\n\n\nclass _NullSearchEngine:\n    def get_total_count(self) -> int:\n        return 0\n    def export_data(self):\n        return {}\n\n\nclass RepositoryManager:\n    \"\"\"\n    仓库管理器 - 内容仓库的核心控制器\n    \n    负责协调标签管理、搜索引擎、CSV处理等各个子模块，\n    为上层应用提供统一的仓库管理接口。\n    \"\"\"\n    \n    def __init__(self, storage_root: str):\n        \"\"\"\n        初始化仓库管理器\n        \n        Args:\n            storage_root: 用户指定的存储根目录\n        \"\"\"\n        self.storage_root = Path(storage_root)\n        self.repository_root = self.storage_root / \"repository\"\n        self.config_file = self.repository_root / \"config.json\"\n        \n        # 确保仓库目录存在\n        self.repository_root.mkdir(parents=True, exist_ok=True)\n        \n        # 初始化子模块\n        self.sqlite_handler = SQLiteHandler(self.repository_root / \"gemeng.db\", storage_root=self.storage_root)\n        # 提供占位依赖，避免未实现接口导致崩溃\n        self.error_handler = _RepoErrorHandler()\n        self.tag_manager = _NullTagManager()\n        self.search_engine = _NullSearchEngine()\n        \n        # 加载配置\n        self.config = self._load_config()\n        \n        # 初始化仓库\n        self._initialize_repository()\n    \n    def _load_config(self) -> Dict[str, Any]:\n        \"\"\"\n        加载仓库配置\n        \n        Returns:\n            配置字典\n        \"\"\"\n        default_config = {\n            \"version\": \"0.1.5\",\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"auto_tag_enabled\": True,\n            \"search_index_enabled\": True,\n            \"tag_categories\": [\n                \"内容类型\",\n                \"创建时间\", \n                \"质量评级\",\n                \"使用场景\",\n                \"风格特征\",\n                \"自定义标签\"\n            ],\n            \"supported_file_types\": [\"image\", \"video\", \"audio\", \"chat\"],\n            \"max_tags_per_item\": 20,\n            \"search_result_limit\": 100\n        }\n        \n        if self.config_file.exists():\n            try:\n                with open(self.config_file, 'r', encoding='utf-8') as f:\n                    config = json.load(f)\n                # 合并默认配置，确保新字段存在\n                for key, value in default_config.items():\n                    if key not in config:\n                        config[key] = value\n                return config\n            except Exception as e:\n                self.error_handler.log_error(f\"加载仓库配置失败: {e}\")\n                return default_config\n        else:\n            # 创建默认配置文件\n            self._save_config(default_config)\n            return default_config\n    \n    def _save_config(self, config: Dict[str, Any]) -> None:\n        \"\"\"\n        保存仓库配置\n        \n        Args:\n            config: 配置字典\n        \"\"\"\n        try:\n            config[\"last_updated\"] = datetime.now().isoformat()\n            with open(self.config_file, 'w', encoding='utf-8') as f:\n                json.dump(config, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            self.error_handler.log_error(f\"保存仓库配置失败: {e}\")\n    \n    def _initialize_repository(self) -> None:\n        \"\"\"\n        初始化仓库结构\n        \"\"\"\n        try:\n            # 创建必要的子目录\n            subdirs = [\"tags\", \"index\", \"cache\", \"exports\"]\n            for subdir in subdirs:\n                (self.repository_root / subdir).mkdir(exist_ok=True)\n            \n            print(f\"仓库初始化完成: {self.repository_root}\")\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"仓库初始化失败: {e}\")\n            raise\n\n    def _ensure_dict(self, value: Any) -> Dict[str, Any]:\n        if isinstance(value, dict):\n            return value\n        if isinstance(value, str) and value:\n            try:\n                loaded = json.loads(value)\n                return loaded if isinstance(loaded, dict) else {}\n            except Exception:\n                return {}\n        return {}\n\n    def _normalize_records(self, records: Optional[List[Dict[str, Any]]], content_type: str) -> List[Dict[str, Any]]:\n        normalized: List[Dict[str, Any]] = []\n        if not records:\n            return normalized\n        seen_keys: set[str] = set()\n        for record in records:\n            normalized_record = self._normalize_record(record, content_type)\n            if not normalized_record:\n                continue\n            gen_key = normalized_record.get('generation_id') or normalized_record.get('task_id') or normalized_record.get('file_id')\n            key = str(gen_key) if gen_key else None\n            if key and key in seen_keys:\n                continue\n            if key:\n                seen_keys.add(key)\n            normalized.append(normalized_record)\n        return normalized\n\n    \n    def _normalize_record(self, record: Dict[str, Any], content_type: str) -> Dict[str, Any]:\n        if not isinstance(record, dict):\n            return {}\n\n        item = dict(record)\n        metadata_raw = item.get('metadata') or {}\n        if isinstance(metadata_raw, str):\n            try:\n                metadata_raw = json.loads(metadata_raw) or {}\n            except Exception:\n                metadata_raw = {}\n        item['metadata'] = metadata_raw\n\n        # 统一内容类型\n        ctype = item.get('content_type') or content_type or ''\n        if ctype == 'image':\n            ctype = 'images'\n        elif ctype == 'video':\n            ctype = 'videos'\n        item['content_type'] = ctype\n\n        # 解析JSON字段\n        item['parameters'] = self._ensure_dict(item.get('parameters'))\n        item['metadata'] = self._ensure_dict(item.get('metadata'))\n        item['batch_info'] = self._ensure_dict(item.get('batch_info'))\n\n        metadata = item['metadata']\n\n        # 同步核心字段\n        created_at = item.get('created_at')\n        if not created_at:\n            created_at = metadata.get('created_at') or metadata.get('completed_at')\n        if not created_at:\n            created_at = datetime.now().isoformat()\n        if isinstance(created_at, datetime):\n            item['created_at'] = created_at.isoformat()\n        else:\n            item['created_at'] = created_at\n\n        file_id = item.get('file_id') or item.get('generation_id') or metadata.get('task_id')\n        if file_id:\n            item['file_id'] = str(file_id)\n\n        generation_id = item.get('generation_id') or metadata.get('generation_id') or metadata.get('task_id')\n        if generation_id:\n            item['generation_id'] = str(generation_id)\n\n        resolved_path = item.get('resolved_path')\n        candidate_paths = [\n            resolved_path,\n            item.get('absolute_path'),\n            metadata.get('local_path'),\n            item.get('file_path'),\n        ]\n        abs_path = next((p for p in candidate_paths if p), None)\n        \n        # 验证绝对路径是否真实存在（修复旧记录路径失效问题）\n        if abs_path and not Path(abs_path).exists():\n            logger.warning(f\"绝对路径无效，将尝试从relative_path重新构造: {abs_path}\")\n            abs_path = None  # 重置，触发下面的重新构造逻辑\n        \n        if not abs_path and (item.get('relative_path') or metadata.get('relative_path')):\n            rel = item.get('relative_path') or metadata.get('relative_path')\n            try:\n                root = self.storage_root\n                original_path = Path(root) / rel\n                if original_path.exists():\n                    abs_path = str(original_path)\n                    logger.debug(f\"使用路径: {abs_path}\")\n                else:\n                    abs_path = str(original_path)\n                    logger.warning(f\"文件不存在: {original_path}\")\n            except Exception as e:\n                logger.error(f\"路径解析失败: {rel}, 错误: {e}\")\n                abs_path = None\n\n        if abs_path:\n            abs_path = str(abs_path)\n            item['absolute_path'] = abs_path\n            item['local_path'] = abs_path\n            item['file_path'] = abs_path\n\n        # 记录相对路径\n        rel_value = item.get('relative_path') or metadata.get('relative_path')\n        if rel_value:\n            item['relative_path'] = str(rel_value)\n\n        # 若缺少真实路径且状态已完成，则忽略该记录\n        if not (item.get('file_path') or item.get('absolute_path') or item.get('relative_path')):\n            status = str(item.get('status') or '').lower()\n            # pending 状态的记录应该保留（即使缺路径，用于占位卡片显示）\n            if status == 'pending':\n                pass  # 不过滤，继续处理\n            elif not status or status in {'completed', 'success'}:\n                return {}\n\n       # 缩略图字段\n        thumb_local = item.get('thumbnail_local_path') or metadata.get('thumbnail_local_path') or metadata.get('api_thumbnail_local_path')\n        if thumb_local:\n            item['thumbnail_local_path'] = str(thumb_local)\n\n        thumb_rel = item.get('thumbnail_path') or metadata.get('thumbnail_path') or item.get('thumbnail_local_path')\n        if thumb_rel:\n            item['thumbnail_path'] = str(thumb_rel)\n            # 如果没有 thumbnail_local_path，则从相对路径生成绝对路径\n            if not thumb_local:\n                try:\n                    thumb_abs = Path(self.storage_root) / thumb_rel\n                    if thumb_abs.exists():\n                        item['thumbnail_local_path'] = str(thumb_abs)\n                        logger.debug(f\"生成缩略图绝对路径: {thumb_abs}\")\n                    else:\n                        logger.debug(f\"缩略图文件不存在: {thumb_abs}\")\n                except Exception as e:\n                    logger.debug(f\"缩略图路径解析失败: {thumb_rel}, 错误: {e}\")\n\n        # 补充尺寸信息，便于前端按比例渲染\n        width = item.get('width') or metadata.get('width')\n        height = item.get('height') or metadata.get('height')\n        if width:\n            try:\n                item['width'] = int(float(width))\n            except Exception:\n                pass\n        if height:\n            try:\n                item['height'] = int(float(height))\n            except Exception:\n                pass\n        # 尝试从参数 size 提取比例（如果未提供 width/height）\n        if (not item.get('width') or not item.get('height')):\n            size_txt = item['parameters'].get('size') if isinstance(item['parameters'], dict) else None\n            if isinstance(size_txt, str) and 'x' in size_txt:\n                try:\n                    sw, sh = size_txt.split('x')\n                    item['width'] = item.get('width') or int(float(sw))\n                    item['height'] = item.get('height') or int(float(sh))\n                except Exception:\n                    pass\n        # 兜底：若本地文件存在且仍缺尺寸，尝试读取一次\n        if (not item.get('width') or not item.get('height')):\n            try:\n                abs_path_probe = item.get('absolute_path') or item.get('file_path')\n                if abs_path_probe and Path(abs_path_probe).exists():\n                    from PIL import Image\n                    with Image.open(abs_path_probe) as img:\n                        item['width'] = item.get('width') or int(img.width)\n                        item['height'] = item.get('height') or int(img.height)\n            except Exception as exc:\n                logger.debug(f\"尺寸读取失败: {exc}\")\n\n        # 提升 prompt 等常用字段\n        if not item.get('prompt') and item['parameters'].get('prompt'):\n            item['prompt'] = item['parameters']['prompt']\n\n        return item\n\n    def _parse_created_at(self, value: Any) -> datetime:\n        if isinstance(value, datetime):\n            return value\n        if not value:\n            return datetime.min\n        text = str(value)\n        try:\n            if text.endswith('Z'):\n                text = text[:-1] + '+00:00'\n            return datetime.fromisoformat(text)\n        except Exception:\n            try:\n                return datetime.strptime(text, '%Y-%m-%d %H:%M:%S')\n            except Exception:\n                return datetime.min\n\n    def _record_sort_key(self, record: Dict[str, Any]) -> Tuple[datetime, str]:\n        created_dt = self._parse_created_at(record.get('created_at'))\n        # fallback: 如果 created_at 无效，尝试使用 updated_at\n        if created_dt == datetime.min:\n            created_dt = self._parse_created_at(record.get('updated_at'))\n        file_id = str(record.get('file_id', ''))\n        return (created_dt, file_id)\n\n    def add_content(self, content_id: str, content_type: str, \n                   metadata: Dict[str, Any], auto_tag: bool = True) -> bool:\n        \"\"\"\n        添加内容到仓库\n        \n        Args:\n            content_id: 内容唯一标识\n            content_type: 内容类型 (image/video/audio/chat)\n            metadata: 内容元数据\n            auto_tag: 是否自动生成标签\n        \n        Returns:\n            是否添加成功\n        \"\"\"\n        try:\n            normalized_type = (content_type or '').lower()\n            if normalized_type in {'image', 'images'}:\n                storage_type = 'images'\n            elif normalized_type in {'video', 'videos'}:\n                storage_type = 'videos'\n            else:\n                storage_type = normalized_type or 'unknown'\n            status = metadata.get('status', 'unknown')\n            logger.debug(f\"[Pending追踪] add_content调用: id={content_id}, type={storage_type}, status={status}\")\n            result = self.sqlite_handler.add_record(content_id, storage_type, metadata)\n            logger.debug(f\"[Pending追踪] add_content结果: id={content_id}, success={result}\")\n            return result\n        except Exception as e:\n            logger.error(f\"添加内容失败: {e}\")\n            return False\n    \n    def update_record(self, record_id: str, data: Dict[str, Any]) -> bool:\n        \"\"\"更新记录\"\"\"\n        try:\n            return self.sqlite_handler.update_record(record_id, data)\n        except Exception as e:\n            logger.error(f\"更新记录失败: {e}\")\n            return False\n\n    def delete_record(self, record_id: str) -> bool:\n        \"\"\"删除记录\"\"\"\n        try:\n            return self.sqlite_handler.delete_record(record_id)\n        except Exception as e:\n            logger.error(f\"删除记录失败: {e}\")\n            return False\n\n    def cleanup_stale_pending_records(self, timeout_hours: float = 1.0) -> int:\n        \"\"\"清理超时的 pending 记录\n\n        Args:\n            timeout_hours: 超时时间（小时），默认 1 小时\n\n        Returns:\n            清理的记录数量\n        \"\"\"\n        try:\n            return self.sqlite_handler.cleanup_stale_pending_records(timeout_hours)\n        except Exception as e:\n            logger.error(f\"清理过期 pending 记录失败: {e}\")\n            return 0\n\n    def get_record_by_id(self, record_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"根据 ID 获取单条记录。\"\"\"\n        if not record_id:\n            return None\n        try:\n            raw = self.sqlite_handler.get_record_by_id(record_id)\n            if not raw:\n                return None\n            content_type = raw.get('content_type') or 'image'\n            normalized_type = 'image' if content_type == 'images' else ('video' if content_type == 'videos' else content_type)\n            normalized = self._normalize_record(raw, normalized_type)\n            if not normalized:\n                return None\n            self._attach_reference_assets([normalized], absolute=True)\n            return normalized\n        except Exception as e:\n            logger.error(f\"获取记录失败: {e}\")\n            return None\n    \n    def get_records_batch(self, start_index=0, batch_size=40, record_type='all'):\n        \"\"\"\n        批量获取记录，支持分页查询\n        \n        Args:\n            start_index: 起始索引\n            batch_size: 批量大小\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            List[Dict]: 记录列表\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'images':\n                normalized_type = 'image'\n            elif normalized_type == 'videos':\n                normalized_type = 'video'\n\n            if normalized_type == 'all':\n                fetch_limit = max(batch_size, start_index + batch_size)\n                images = self.sqlite_handler.get_records('images', fetch_limit, 0) or []\n                videos = self.sqlite_handler.get_records('videos', fetch_limit, 0) or []\n                combined = images + videos\n                combined.sort(key=self._record_sort_key, reverse=True)\n                end_index = start_index + batch_size\n                result = combined[start_index:end_index]\n            else:\n                content_type = 'images' if normalized_type == 'image' else 'videos'\n                result = self.sqlite_handler.get_records(content_type, batch_size, start_index) or []\n                result.sort(key=self._record_sort_key, reverse=True)\n\n            normalized = self._normalize_records(result, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n            return normalized\n        except Exception as e:\n            self.error_handler.log_error(f\"批量获取记录失败: {e}\")\n            return []\n\n    def get_records_batch_reverse(self, limit=80, offset=0, record_type='all'):\n        \"\"\"\n        倒序分页查询记录 - 瀑布流1000条方案专用\n        \n        优化特性：\n        - 从最新记录开始的高效倒序查询\n        - 支持80+30增量加载模式\n        - 针对1000条数据优化的性能\n        - 减少内存占用和查询时间\n        \n        Args:\n            limit: 查询数量限制 (默认80，增量30)\n            offset: 偏移量 (从最新记录开始计算)\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            List[Dict]: 按时间倒序排列的记录列表\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'images':\n                normalized_type = 'image'\n            elif normalized_type == 'videos':\n                normalized_type = 'video'\n\n            max_single_query = min(limit + 50, 200)\n\n            if normalized_type == 'all':\n                images = self.sqlite_handler.get_records('images', max_single_query, 0) or []\n                videos = self.sqlite_handler.get_records('videos', max_single_query, 0) or []\n                combined = images + videos\n                combined.sort(key=self._record_sort_key, reverse=True)\n                start_idx = offset\n                end_idx = offset + limit\n                result = combined[start_idx:end_idx]\n            else:\n                content_type = 'images' if normalized_type == 'image' else 'videos'\n                result = self.sqlite_handler.get_records(content_type, limit, offset) or []\n                result.sort(key=self._record_sort_key, reverse=True)\n\n            normalized = self._normalize_records(result, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n\n            return normalized\n\n        except Exception as e:\n            self.error_handler.log_error(f\"倒序分页查询失败: {e}\")\n            return []\n\n    def get_records_count_optimized(self, record_type='all'):\n        \"\"\"\n        优化的记录计数方法 - 瀑布流1000条方案专用\n        \n        提供快速的记录计数，支持1000条限制逻辑\n        \n        Args:\n            record_type: 记录类型 ('image', 'video', 'all')\n        \n        Returns:\n            Dict: {'total': int, 'capped_at_1000': bool}\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'image':\n                total = self.sqlite_handler.get_total_count('images')\n            elif normalized_type == 'video':\n                total = self.sqlite_handler.get_total_count('videos')\n            else:\n                total = (\n                    self.sqlite_handler.get_total_count('images') +\n                    self.sqlite_handler.get_total_count('videos')\n                )\n\n            # 1000条限制逻辑\n            capped_at_1000 = total > 1000\n            effective_total = min(total, 1000)\n            \n            return {\n                'total': effective_total,\n                'actual_total': total,\n                'capped_at_1000': capped_at_1000\n            }\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"优化记录计数失败: {e}\")\n            return {'total': 0, 'actual_total': 0, 'capped_at_1000': False}\n\n    # =========================\n    # 游标分页协议（初版实现）\n    # 接口：get_records(page_size, cursor, record_type) -> { items, next_cursor }\n    # 说明：当前实现基于现有CSV读取能力合并排序后切片，后续可在存储层优化为限窗/游标扫描。\n    # =========================\n    def get_records(self, page_size: int = 40, cursor: Optional[str] = None, record_type: str = 'all') -> Dict[str, Any]:\n        \"\"\"\n        游标分页获取记录\n\n        Args:\n            page_size: 每页大小\n            cursor: 上一页游标（格式：\"<created_at>|<file_id>|<type>\"），None表示第一页\n            record_type: 'image' | 'video' | 'all'\n\n        Returns:\n            dict: { items: List[Dict], next_cursor: Optional[str] }\n        \"\"\"\n        try:\n            # 解析游标\n            cursor_tuple: Optional[Tuple[str, str, str]] = None\n            if cursor:\n                try:\n                    parts = cursor.split('|')\n                    if len(parts) >= 3:\n                        cursor_tuple = (parts[0], parts[1], parts[2])  # created_at, file_id, type\n                except Exception:\n                    cursor_tuple = None\n\n            # 拉取候选数据（按需窗口，尽量少取）\n            fetch_limit = max(page_size * 3, 60)\n\n            def _load(ct: str) -> List[Dict[str, Any]]:\n                return self._normalize_records(\n                    self.sqlite_handler.get_records(ct, fetch_limit, 0) or [],\n                    ct\n                )\n\n            if record_type == 'image':\n                records = _load('images')\n            elif record_type == 'video':\n                records = _load('videos')\n            else:\n                records = _load('images') + _load('videos')\n\n            # 排序：created_at DESC, file_id DESC\n            records.sort(key=self._record_sort_key, reverse=True)\n\n            # 光标过滤：跳过光标及其之前的元素（保持稳定倒序）\n            filtered: List[Dict[str, Any]] = []\n            if cursor_tuple:\n                cur_created, cur_id, cur_type = cursor_tuple\n                passed = False\n                for rec in records:\n                    rec_type = 'image' if (rec.get('content_type') == 'images') else ('video' if rec.get('content_type') == 'videos' else 'unknown')\n                    rec_key = (rec.get('created_at', '1970-01-01T00:00:00'), rec.get('file_id', ''), rec_type)\n                    # 记录严格小于游标（因为倒序），才加入\n                    if passed:\n                        filtered.append(rec)\n                    else:\n                        if (rec_key[0] < cur_created) or (rec_key[0] == cur_created and rec_key[1] < cur_id) or (rec_key[0] == cur_created and rec_key[1] == cur_id and rec_key[2] < cur_type):\n                            passed = True\n                            filtered.append(rec)\n                candidates = filtered\n            else:\n                candidates = records\n\n            # 取一页\n            page_items = candidates[:page_size]\n            self._attach_reference_assets(page_items, absolute=True)\n\n            # 生成 next_cursor\n            if page_items:\n                last = page_items[-1]\n                last_type = 'image' if (last.get('content_type') == 'images') else ('video' if last.get('content_type') == 'videos' else 'unknown')\n                next_cursor = f\"{last.get('created_at','')}|{last.get('file_id','')}|{last_type}\"\n            else:\n                next_cursor = None\n\n            return {\n                'items': page_items,\n                'next_cursor': next_cursor\n            }\n\n        except Exception as e:\n            self.error_handler.log_error(f\"游标分页获取记录失败: {e}\")\n            return {\n                'items': [],\n                'next_cursor': None\n            }\n\n    def get_total_count(self, record_type='all'):\n        \"\"\"\n        获取总记录数\n        \n        Args:\n            record_type: 记录类型 ('image', 'video', 'all')\n            \n        Returns:\n            int: 总记录数\n        \"\"\"\n        try:\n            normalized_type = (record_type or 'all').lower()\n            if normalized_type == 'image':\n                return self.sqlite_handler.get_total_count('images')\n            if normalized_type == 'video':\n                return self.sqlite_handler.get_total_count('videos')\n\n            return (\n                self.sqlite_handler.get_total_count('images') +\n                self.sqlite_handler.get_total_count('videos')\n            )\n        except Exception as e:\n            self.error_handler.log_error(f\"获取记录总数失败: {e}\")\n            return 0\n\n    def _resolve_reference_assets(self, record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n        if not isinstance(record, dict):\n            return []\n\n        params_raw = record.get('parameters')\n        params_dict: Dict[str, Any] = {}\n        if isinstance(params_raw, dict):\n            params_dict = params_raw\n        elif isinstance(params_raw, str):\n            try:\n                params_dict = json.loads(params_raw) or {}\n            except Exception:\n                params_dict = {}\n\n        assets = []\n        if isinstance(params_dict, dict):\n            assets = params_dict.get('reference_assets') or []\n        if not assets:\n            fallback = record.get('reference_assets')\n            assets = fallback if isinstance(fallback, list) else []\n        if not assets:\n            return []\n\n        resolved: List[Dict[str, Any]] = []\n        for item in assets:\n            if not isinstance(item, dict):\n                continue\n            rec = dict(item)\n            rel_path = rec.get('relative_path') or rec.get('asset_path')\n            if rel_path and absolute:\n                abs_path = Path(self.storage_root) / rel_path\n                rec['absolute_path'] = str(abs_path)\n                rec['asset_path'] = str(abs_path)\n            resolved.append(rec)\n        return resolved\n\n    \n    def _resolve_video_reference_assets(self, record: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"\n        解析视频记录中的参考图资产\n        \n        从parameters.first_frame和image_path提取参考图信息\n        \"\"\"\n        if not isinstance(record, dict):\n            return []\n            \n        params = record.get('parameters', {})\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n\n        # 收集参考图路径\n        ref_paths = []\n\n        storage_root = self.storage_root\n\n        def _resolve_path(path_str: Optional[str]) -> Optional[Path]:\n            if not path_str:\n                return None\n            candidate = Path(path_str).expanduser()\n            if candidate.is_absolute():\n                return candidate if candidate.exists() else None\n            combined = storage_root / path_str.lstrip('/\\\\')\n            return combined if combined.exists() else None\n\n        # 从first_frame提取\n        first_frame = params.get('first_frame')\n        resolved_first = _resolve_path(first_frame) if isinstance(first_frame, str) else None\n        if resolved_first:\n            ref_paths.append(('first_frame', str(resolved_first)))\n\n        # 从last_frame提取（首尾帧模式）\n        last_frame = params.get('last_frame')\n        resolved_last = _resolve_path(last_frame) if isinstance(last_frame, str) else None\n        if resolved_last:\n            ref_paths.append(('last_frame', str(resolved_last)))\n\n        # 从image_path提取\n        image_path = params.get('image_path')\n        resolved_image = _resolve_path(image_path) if isinstance(image_path, str) else None\n        if resolved_image and all(str(resolved_image) != existing_path for _, existing_path in ref_paths):\n            ref_paths.append(('image', str(resolved_image)))\n\n        # 构建参考图资产信息\n        resolved_assets = []\n        for i, (kind, path) in enumerate(ref_paths):\n            try:\n                file_path = Path(path)\n                if file_path.exists():\n                    stat = file_path.stat()\n                    try:\n                        rel = file_path.resolve().relative_to(storage_root)\n                        rel_str = str(rel).replace('\\\\', '/')\n                    except ValueError:\n                        rel_str = str(file_path)\n                    asset = {\n                        'id': f'ref_video_{record.get(\"generation_id\", \"unknown\")}_{i}',\n                        'path': rel_str,\n                        'relative_path': rel_str,\n                        'absolute_path': str(file_path.resolve()),\n                        'type': 'image',\n                        'kind': kind or 'image',\n                        'source': file_path.name,\n                        'order': i,\n                        'size': stat.st_size,\n                        'exists': True,\n                        'created_at': record.get('created_at', datetime.now().isoformat())\n                    }\n\n                    # 尝试获取图片尺寸\n                    try:\n                        from PIL import Image\n                        with Image.open(path) as img:\n                            asset['width'] = img.width\n                            asset['height'] = img.height\n                    except:\n                        asset['width'] = None\n                        asset['height'] = None\n                        \n                    resolved_assets.append(asset)\n            except Exception as e:\n                print(f\"  ⚠️ 解析参考图失败: {path} - {e}\")\n                \n        return resolved_assets\n\n    def _attach_reference_assets(self, records: List[Dict[str, Any]], *, absolute: bool = False) -> None:\n        if not records:\n            return\n        for record in records:\n            try:\n                # 先尝试原有的解析逻辑\n                resolved = self._resolve_reference_assets(record, absolute=absolute)\n                \n                # 如果原有逻辑没有找到参考图，尝试视频参考图解析\n                if not resolved and record.get('content_type') == 'videos':\n                    video_refs = self._resolve_video_reference_assets(record)\n                    if video_refs:\n                        resolved = video_refs\n                        # 更新_reference_info\n                        record['_reference_info'] = {\n                            'count': len(video_refs),\n                            'summary': f'{len(video_refs)}个参考图',\n                            'labels': ['参考图'],\n                            'assets': video_refs\n                        }\n                \n                if absolute:\n                    record['_resolved_reference_assets_abs'] = resolved\n                record['_resolved_reference_assets'] = resolved\n                \n                # 确保_reference_info存在\n                if '_reference_info' not in record:\n                    record['_reference_info'] = {\n                        'count': len(resolved),\n                        'summary': f'{len(resolved)}个参考图' if resolved else '',\n                        'labels': ['参考图'] if resolved else [],\n                        'assets': resolved\n                    }\n                    \n            except Exception as exc:\n                logger.debug(f\"attach_reference_assets failed: {exc}\")\n\n    def search_content(self, query: str, content_type: Optional[str] = None,\n                      tags: Optional[List[str]] = None, \n                      limit: int = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        搜索仓库内容\n        \n        Args:\n            query: 搜索关键词\n            content_type: 内容类型过滤\n            tags: 标签过滤\n            limit: 结果数量限制\n        \n        Returns:\n            搜索结果列表\n        \"\"\"\n        try:\n            if limit is None or limit <= 0:\n                limit = self.config.get(\"search_result_limit\", 100)\n\n            keyword = (query or \"\").strip()\n            if not keyword:\n                return []\n\n            normalized_type = 'all'\n            sqlite_type: Optional[str] = None\n            if content_type:\n                ct = content_type.lower()\n                if ct in {'image', 'images'}:\n                    sqlite_type = 'images'\n                    normalized_type = 'image'\n                elif ct in {'video', 'videos'}:\n                    sqlite_type = 'videos'\n                    normalized_type = 'video'\n\n            results = self.sqlite_handler.search_records(keyword, sqlite_type, limit) or []\n            normalized = self._normalize_records(results, normalized_type)\n            self._attach_reference_assets(normalized, absolute=True)\n            return normalized\n        except Exception as e:\n            logger.error(f\"搜索内容失败: {e}\")\n            return []\n    \n    def get_content_tags(self, content_id: str) -> List[str]:\n        \"\"\"\n        获取内容的所有标签\n        \n        Args:\n            content_id: 内容ID\n        \n        Returns:\n            标签列表\n        \"\"\"\n        return self.tag_manager.get_content_tags(content_id)\n    \n    def add_tag_to_content(self, content_id: str, tag: str, \n                          category: str = \"自定义标签\") -> bool:\n        \"\"\"\n        为内容添加标签\n        \n        Args:\n            content_id: 内容ID\n            tag: 标签名称\n            category: 标签分类\n        \n        Returns:\n            是否添加成功\n        \"\"\"\n        return self.tag_manager.add_tag_to_content(content_id, tag, category)\n    \n    def remove_tag_from_content(self, content_id: str, tag: str) -> bool:\n        \"\"\"\n        从内容中移除标签\n        \n        Args:\n            content_id: 内容ID\n            tag: 标签名称\n        \n        Returns:\n            是否移除成功\n        \"\"\"\n        return self.tag_manager.remove_tag_from_content(content_id, tag)\n    \n    def get_all_tags(self, category: Optional[str] = None) -> List[str]:\n        \"\"\"\n        获取所有标签\n        \n        Args:\n            category: 标签分类过滤\n        \n        Returns:\n            标签列表\n        \"\"\"\n        return self.tag_manager.get_all_tags(category)\n    \n    def get_tag_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取标签统计信息\n        \n        Returns:\n            统计信息字典\n        \"\"\"\n        return self.tag_manager.get_statistics()\n    \n    def export_repository_data(self, export_format: str = \"json\") -> str:\n        \"\"\"\n        导出仓库数据\n\n        Args:\n            export_format: 导出格式 (json/csv/xlsx)\n\n        Returns:\n            导出文件路径\n        \"\"\"\n        try:\n            export_dir = self.repository_root / \"exports\"\n            export_dir.mkdir(exist_ok=True)\n            \n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"repository_export_{timestamp}.{export_format}\"\n            export_path = export_dir / filename\n            \n            # 收集所有数据\n            storage_stats = {\n                \"images\": self.sqlite_handler.get_total_count('images'),\n                \"videos\": self.sqlite_handler.get_total_count('videos')\n            }\n            data = {\n                \"config\": self.config,\n                \"tags\": self.tag_manager.export_data(),\n                \"search_index\": self.search_engine.export_data(),\n                \"storage_stats\": storage_stats,\n                \"export_time\": datetime.now().isoformat()\n            }\n            \n            if export_format == \"json\":\n                with open(export_path, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, ensure_ascii=False, indent=2)\n            \n            return str(export_path)\n            \n        except Exception as e:\n            self.error_handler.log_error(f\"导出仓库数据失败: {e}\")\n            return \"\"\n\n    def export_generation_bundle(\n        self,\n        file_ids: List[str],\n        record_type: str = \"image\",\n        *,\n        destination_dir: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"导出指定文件ID的生成记录及参考图。\"\"\"\n        def _mask(value: Any) -> str:\n            if value in (None, \"\"):\n                return \"-\"\n            text = str(value)\n            return f\"{text[:6]}***\"\n\n        record_type = (record_type or \"\").lower()\n        if record_type not in {\"image\", \"video\"}:\n            raise ValueError(f\"不支持的记录类型: {record_type}\")\n\n        exports_dir = Path(self.storage_root) / \"exports\"\n        exports_dir.mkdir(parents=True, exist_ok=True)\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        output_base = exports_dir / f\"{record_type}_bundle_{timestamp}\"\n\n        normalized_ids = [str(fid) for fid in file_ids if fid]\n        export_result = export_records(record_type, normalized_ids, output_base)\n        if not export_result:\n            masked_ids = \",\".join(_mask(fid) for fid in normalized_ids) or \"-\"\n            logger.warning(\n                \"摘要|operation=export_bundle status=failed record_type={rtype} record_ids={ids} reason={reason}\",\n                rtype=record_type,\n                ids=masked_ids,\n                reason=\"no_result\",\n            )\n            raise RuntimeError(\"导出参考图失败\")\n\n        zip_path = Path(export_result[\"zip_path\"])\n        manifest_json = Path(export_result[\"manifest_json\"])\n        manifest_csv = Path(export_result[\"manifest_csv\"])\n\n        destination_zip = None\n        destination_manifest_json = None\n        destination_manifest_csv = None\n\n        if destination_dir:\n            dest_dir_path = Path(destination_dir).expanduser()\n            dest_dir_path.mkdir(parents=True, exist_ok=True)\n            try:\n                destination_zip = dest_dir_path / zip_path.name\n                shutil.copy2(zip_path, destination_zip)\n                destination_manifest_json = dest_dir_path / manifest_json.name\n                shutil.copy2(manifest_json, destination_manifest_json)\n                destination_manifest_csv = dest_dir_path / manifest_csv.name\n                shutil.copy2(manifest_csv, destination_manifest_csv)\n            except PermissionError as exc:\n                logger.warning(\n                    \"摘要|operation=export_bundle status=failed reason=permission_denied record_type={rtype} dest={dest}\",\n                    rtype=record_type,\n                    dest=dest_dir_path.name,\n                )\n                raise PermissionError(\"导出目录无写入权限\") from exc\n\n        reference_ids = export_result.get(\"reference_ids\", [])\n        masked_refs = \",\".join(_mask(rid) for rid in reference_ids if rid) or \"-\"\n        status = export_result.get(\"status\", \"success\") or \"success\"\n        missing_records = export_result.get(\"missing_records\", []) or []\n        missing_main_files = export_result.get(\"missing_main_files\", []) or []\n        missing_references = export_result.get(\"missing_references\", []) or []\n        dest_hint_path = destination_zip.parent if destination_zip else zip_path.parent\n        try:\n            dest_hint_text = Path(dest_hint_path).name or Path(dest_hint_path).parent.name\n        except Exception:\n            dest_hint_text = \"-\"\n        logger.info(\n            \"摘要|operation=export_bundle status={status} record_type={rtype} record_ids={ids} ref_count={ref_count} ref_ids={refs} missing_records={miss_rec} missing_files={miss_files} missing_refs={miss_refs} dest={dest}\",\n            status=status,\n            rtype=record_type,\n            ids=\",\".join(_mask(fid) for fid in normalized_ids) or \"-\",\n            ref_count=export_result.get(\"reference_count\", 0),\n            refs=masked_refs,\n            miss_rec=len(missing_records),\n            miss_files=len(missing_main_files),\n            miss_refs=len(missing_references),\n            dest=dest_hint_text or \"-\",\n        )\n\n        return {\n            \"zip_path\": str(zip_path),\n            \"manifest_json\": str(manifest_json),\n            \"manifest_csv\": str(manifest_csv),\n            \"destination_zip\": str(destination_zip) if destination_zip else None,\n            \"destination_manifest_json\": str(destination_manifest_json) if destination_manifest_json else None,\n            \"destination_manifest_csv\": str(destination_manifest_csv) if destination_manifest_csv else None,\n            \"status\": status,\n            \"reference_count\": export_result.get(\"reference_count\", 0),\n            \"reference_ids\": reference_ids,\n            \"missing_records\": missing_records,\n            \"missing_main_files\": missing_main_files,\n            \"missing_references\": missing_references,\n            \"records\": export_result.get(\"records\", []),\n            \"exported_record_ids\": export_result.get(\"exported_record_ids\", normalized_ids),\n        }\n    \n    def get_repository_status(self) -> Dict[str, Any]:\n        \"\"\"\n        获取仓库状态信息\n        \n        Returns:\n            状态信息字典\n        \"\"\"\n        try:\n            return {\n                \"version\": self.config.get(\"version\", \"0.1.5\"),\n                \"storage_root\": str(self.storage_root),\n                \"repository_root\": str(self.repository_root),\n                \"total_content_count\": self.get_total_count('all'),\n                \"total_tags_count\": len(self.tag_manager.get_all_tags()),\n                \"tag_categories\": self.config.get(\"tag_categories\", []),\n                \"last_updated\": self.config.get(\"last_updated\"),\n                \"auto_tag_enabled\": self.config.get(\"auto_tag_enabled\", True),\n                \"search_index_enabled\": self.config.get(\"search_index_enabled\", True)\n            }\n        except Exception as e:\n            self.error_handler.log_error(f\"获取仓库状态失败: {e}\")\n            return {}\n    \n    def update_config(self, new_config: Dict[str, Any]) -> bool:\n        \"\"\"\n        更新仓库配置\n        \n        Args:\n            new_config: 新配置字典\n        \n        Returns:\n            是否更新成功\n        \"\"\"\n        try:\n            self.config.update(new_config)\n            self._save_config(self.config)\n            return True\n        except Exception as e:\n            self.error_handler.log_error(f\"更新仓库配置失败: {e}\")\n            return False\n","numLines":1155,"startLine":1,"totalLines":1155}}}
{"parentUuid":"18bf93cd-a451-4449-ac6e-9e23afda0c7b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016A3WwNppi64os5QE8fo384","type":"tool_result","content":"     1→# Seedream图像生成管理器\n     2→# 负责图像生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→from datetime import datetime\n    13→from pathlib import Path\n    14→from typing import Dict, Any, List, Optional, Callable, Tuple\n    15→from PIL import Image\n    16→from loguru import logger\n    17→from urllib.parse import urlparse\n    18→import base64\n    19→import asyncio\n    20→import aiohttp\n    21→import threading\n    22→from concurrent.futures import ThreadPoolExecutor, as_completed\n    23→import time\n    24→\n    25→from .client import SeedreamClient\n    26→from ..storage import get_v2_storage_manager\n    27→from ..provider.schema import (\n    28→    TextToImageParams,\n    29→    ImageToImageParams,\n    30→    validate_and_normalize_t2i,\n    31→    validate_and_normalize_i2i,\n    32→    MAX_REFERENCE_IMAGES,\n    33→    MAX_REFERENCE_BUNDLE,\n    34→)\n    35→from config_api import get_storage_dir\n    36→\n    37→# 使用统一水印服务（edition/watermark_service.py）\n    38→from edition.watermark_service import (\n    39→    should_add_watermark,\n    40→    get_watermark_text,\n    41→    get_watermark_opacity,\n    42→)\n    43→\n    44→\n    45→class SeedreamManager:\n    46→    \"\"\"Seedream图像生成管理器\"\"\"\n    47→\n    48→    def __init__(self, api_key: str = None):\n    49→        \"\"\"\n    50→        初始化Seedream管理器\n    51→\n    52→        Args:\n    53→            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n    54→        \"\"\"\n    55→        self.client = SeedreamClient(api_key)\n    56→        \n    57→        # 使用V2统一存储管理器（与单一真源对齐）\n    58→        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n    59→        \n    60→        # 保持兼容性别名\n    61→        self.file_manager = self.storage_manager\n    62→        self.metadata_manager = self.storage_manager\n    63→        self.image_storage_manager = self.storage_manager\n    64→        \n    65→        # 保留原有的目录属性以保持兼容性\n    66→        self.data_dir = Path(self.storage_manager.root_path)\n    67→        self.images_dir = self.data_dir / \"images\"\n    68→        self.metadata_dir = self.data_dir / \"metadata\"\n    69→\n    70→        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    71→\n    72→    def generate_text_to_image(\n    73→        self,\n    74→        prompt: str,\n    75→        size: str = \"1024x1024\",\n    76→        guidance_scale: float = 2.5,\n    77→        seed: int = -1,\n    78→        save_local: bool = True,\n    79→        reference_images: Optional[List[Any]] = None,\n    80→        model_variant: Optional[str] = None,\n    81→        generation_id: Optional[str] = None,\n    82→        count: int = 1,\n    83→        sequential_mode: bool = False,\n    84→        derived_ids: Optional[List[str]] = None,\n    85→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    86→    ) -> Dict[str, Any]:\n    87→        \"\"\"\n    88→        生成文生图并保存到本地\n    89→\n    90→        Args:\n    91→            prompt: 图像生成提示词\n    92→            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n    93→            guidance_scale: 引导强度，范围[1.0, 10.0]\n    94→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n    95→            response_format: 返回格式，\"url\"或\"b64_json\"\n    96→            save_local: 是否保存到本地\n    97→            reference_images: 参考图列表\n    98→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n    99→            count: 生成图片数量（组图模式下生效）\n   100→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   101→            derived_ids: 组图生成的ID列表（用于关联）\n   102→\n   103→        Returns:\n   104→            Dict: 生成结果，包含本地文件路径\n   105→\n   106→        Note:\n   107→            model和watermark参数已固定，不再需要前端控制\n   108→        \"\"\"\n   109→        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n   110→        \n   111→        # 根据 model_variant 设置环境变量\n   112→        if model_variant == 'seedream_v4':\n   113→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4\"\n   114→        elif model_variant == 'seedream_v4_5':\n   115→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4_5\"\n   116→        else:\n   117→            # 默认使用 volc_v3\n   118→            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v3\"\n   119→\n   120→        # 生成唯一ID，优先使用外部传入的generation_id\n   121→        task_id = generation_id or str(uuid.uuid4())\n   122→\n   123→        ref_assets: List[Dict[str, Any]] = []\n   124→        ref_paths: List[str] = []\n   125→        ref_summary: Dict[str, Any] = {}\n   126→        ref_payloads: List[str] = []\n   127→\n   128→        try:\n   129→            if reference_images:\n   130→                ref_summary = self._process_reference_assets(\n   131→                    reference_images,\n   132→                    max_refs=MAX_REFERENCE_IMAGES,\n   133→                    expected_outputs=1,\n   134→                )\n   135→                ref_assets = list(ref_summary.get('assets', []))\n   136→                ref_paths = list(ref_summary.get('paths', []))\n   137→                ref_payloads = self._build_reference_payloads(ref_assets)\n   138→\n   139→                if ref_summary.get('errors'):\n   140→                    logger.warning(\n   141→                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   142→                    )\n   143→                if ref_summary.get('warnings'):\n   144→                    for warn in ref_summary['warnings']:\n   145→                        logger.warning(f\"参考图提示: {warn}\")\n   146→\n   147→            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n   148→            try:\n   149→                norm, fb, reason = validate_and_normalize_t2i(\n   150→                    TextToImageParams(\n   151→                        prompt=prompt,\n   152→                        size=size,\n   153→                        guidance_scale=guidance_scale,\n   154→                        seed=(None if seed == -1 else seed),\n   155→                    )\n   156→                )\n   157→                logger.info(\n   158→                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   159→                )\n   160→                if fb:\n   161→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   162→            except Exception as _e:\n   163→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   164→            # 调用API生成图像（model和watermark参数已在客户端固定）\n   165→            actual_count = max(1, count)\n   166→            use_group_mode = bool(sequential_mode and actual_count > 1)\n   167→\n   168→            api_result = self.client.text_to_image(\n   169→                prompt=prompt,\n   170→                size=size,\n   171→                guidance_scale=guidance_scale,\n   172→                seed=seed,\n   173→                reference_images=ref_payloads or None,\n   174→                n=actual_count if use_group_mode else 1,\n   175→                sequential_mode=sequential_mode,\n   176→            )\n   177→\n   178→            # 组图模式：API 返回多张图，需要逐一保存\n   179→            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n   180→            images_count = len(images_list)\n   181→            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n   182→\n   183→            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n   184→            if use_group_mode and images_count < actual_count:\n   185→                logger.warning(\n   186→                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n   187→                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n   188→                )\n   189→\n   190→            if use_group_mode and images_count > 1:\n   191→                results_batch = []\n   192→                success_count = 0\n   193→                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n   194→                total_images = len(images_list)\n   195→\n   196→                for idx, img_data in enumerate(images_list):\n   197→                    # 发送下载进度（每张图开始下载时）\n   198→                    if progress_callback:\n   199→                        try:\n   200→                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n   201→                        except Exception:\n   202→                            pass\n   203→\n   204→                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n   205→                    per_result = {\n   206→                        \"task_id\": per_id,\n   207→                        \"success\": True,\n   208→                        \"type\": \"text_to_image\",\n   209→                        \"prompt\": prompt,\n   210→                        \"image_url\": img_data[\"url\"],\n   211→                        \"parameters\": {\n   212→                            \"size\": size,\n   213→                            \"guidance_scale\": guidance_scale,\n   214→                            \"seed\": seed,\n   215→                            \"response_format\": \"url\",\n   216→                            \"watermark\": False,\n   217→                            \"model\": self._resolve_model_id(\n   218→                                \"doubao-seedream-3-0-t2i-250415\",\n   219→                                \"doubao-seedream-4-0-250828\",\n   220→                                \"doubao-seedream-4-5-251128\",\n   221→                            ),\n   222→                            \"sequential_mode\": True,\n   223→                            \"group_index\": idx + 1,\n   224→                            \"group_total\": total_images,\n   225→                        },\n   226→                        \"created_at\": datetime.now().isoformat(),\n   227→                        \"usage\": api_result.get(\"usage\", {}),\n   228→                    }\n   229→\n   230→                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   231→                    if sanitized_refs:\n   232→                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   233→                        per_result[\"reference_assets\"] = sanitized_refs\n   234→\n   235→                    if save_local and per_result.get(\"image_url\"):\n   236→                        local_result = self._save_image_locally(per_result)\n   237→                        per_result.update(local_result)\n   238→                        if not local_result.get('local_save_error'):\n   239→                            success_count += 1\n   240→\n   241→                    results_batch.append(per_result)\n   242→\n   243→                    # 发送下载完成进度\n   244→                    if progress_callback:\n   245→                        try:\n   246→                            progress_callback(idx + 1, total_images, per_result)\n   247→                        except Exception:\n   248→                            pass\n   249→\n   250→                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n   251→                return {\n   252→                    \"batch\": True,\n   253→                    \"results\": results_batch,\n   254→                    \"success_count\": success_count,\n   255→                    \"total_count\": len(results_batch),\n   256→                    \"derived_ids\": group_ids,\n   257→                }\n   258→\n   259→            # 单图模式（默认）\n   260→            result = {\n   261→                \"task_id\": task_id,\n   262→                \"success\": True,\n   263→                \"type\": \"text_to_image\",\n   264→                \"prompt\": prompt,\n   265→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   266→                \"parameters\": {\n   267→                    \"size\": size,\n   268→                    \"guidance_scale\": guidance_scale,\n   269→                    \"seed\": seed,\n   270→                    \"response_format\": \"url\",  # 固定值\n   271→                    \"watermark\": False,  # 固定值\n   272→                    \"model\": self._resolve_model_id(\n   273→                        \"doubao-seedream-3-0-t2i-250415\",\n   274→                        \"doubao-seedream-4-0-250828\",\n   275→                        \"doubao-seedream-4-5-251128\",\n   276→                    )\n   277→                },\n   278→                \"created_at\": datetime.now().isoformat(),\n   279→                \"usage\": api_result.get(\"usage\", {}),\n   280→            }\n   281→\n   282→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   283→            if sanitized_refs:\n   284→                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   285→                result[\"reference_assets\"] = sanitized_refs\n   286→                masked_ids = self._summarize_reference_ids(sanitized_refs)\n   287→                logger.info(\n   288→                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n   289→                    len(sanitized_refs),\n   290→                    masked_ids or \"-\",\n   291→                    self._provider_used(),\n   292→                )\n   293→            else:\n   294→                result[\"parameters\"][\"reference_assets\"] = []\n   295→                result[\"reference_assets\"] = []\n   296→\n   297→            # 保存到本地\n   298→            if save_local and result.get(\"image_url\"):\n   299→                local_result = self._save_image_locally(result)\n   300→                result.update(local_result)\n   301→                if local_result.get('local_save_error') and sanitized_refs:\n   302→                    self._cleanup_reference_paths(ref_paths)\n   303→                    result[\"parameters\"][\"reference_assets\"] = []\n   304→                    result[\"reference_assets\"] = []\n   305→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   306→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   307→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   308→\n   309→            logger.success(f\"文生图任务完成: {task_id}\")\n   310→            return result\n   311→\n   312→        except Exception as e:\n   313→            logger.error(f\"文生图API调用失败: {str(e)}\")\n   314→            self._cleanup_reference_paths(ref_paths)\n   315→            return {\n   316→                \"task_id\": task_id,\n   317→                \"success\": False,\n   318→                \"error\": str(e),\n   319→                \"type\": \"text_to_image\"\n   320→            }\n   321→\n   322→    def generate_image_to_image(\n   323→        self,\n   324→        prompt: str,\n   325→        image: str,\n   326→        guidance_scale: float = 5.5,\n   327→        seed: int = -1,\n   328→        save_local: bool = True,\n   329→        reference_images: Optional[List[Any]] = None,\n   330→        generation_id: Optional[str] = None,\n   331→    ) -> Dict[str, Any]:\n   332→        \"\"\"\n   333→        生成图生图并保存到本地\n   334→\n   335→        Args:\n   336→            prompt: 编辑提示词\n   337→            image_path: 原始图像路径（本地路径或URL）\n   338→            guidance_scale: 引导强度，范围[1.0, 10.0]\n   339→            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n   340→            response_format: 返回格式，\"url\"或\"b64_json\"\n   341→            save_local: 是否保存到本地\n   342→\n   343→        Returns:\n   344→            Dict: 生成结果\n   345→        \n   346→        Note:\n   347→            model、size、watermark参数已固定，不再需要前端控制\n   348→        \"\"\"\n   349→        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n   350→\n   351→        # 生成唯一ID，优先使用外部传入的generation_id\n   352→        task_id = generation_id or str(uuid.uuid4())\n   353→\n   354→        ref_paths: List[str] = []\n   355→\n   356→        try:\n   357→            # 处理输入图像\n   358→            image_data = self._prepare_input_image(image)\n   359→            if not image_data:\n   360→                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n   361→\n   362→            # 处理参考图（复制到 references 并准备 API 载荷）\n   363→            ref_summary = self._process_reference_assets(\n   364→                reference_images,\n   365→                max_refs=MAX_REFERENCE_IMAGES,\n   366→                expected_outputs=1,\n   367→            )\n   368→            ref_assets = ref_summary.get('assets', [])\n   369→            ref_paths = list(ref_summary.get('paths', []))\n   370→            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n   371→            if ref_summary.get('errors'):\n   372→                logger.warning(\n   373→                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   374→                )\n   375→            if ref_summary.get('warnings'):\n   376→                for warn in ref_summary['warnings']:\n   377→                    logger.warning(f\"参考图提示: {warn}\")\n   378→\n   379→            # 前置参数校验（不改变流程，仅记录摘要）\n   380→            fb = False\n   381→            reason = \"\"\n   382→            try:\n   383→                norm, fb, reason = validate_and_normalize_i2i(\n   384→                    ImageToImageParams(\n   385→                        prompt=prompt,\n   386→                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n   387→                        guidance_scale=guidance_scale,\n   388→                        seed=(None if seed == -1 else seed),\n   389→                        reference_images=ref_payloads,\n   390→                    )\n   391→                )\n   392→                logger.info(\n   393→                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   394→                )\n   395→                if fb:\n   396→                    logger.warning(f\"前置参数回退建议: {reason}\")\n   397→            except Exception as _e:\n   398→                logger.debug(f\"前置参数校验跳过: {_e}\")\n   399→\n   400→            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n   401→            api_result = self.client.image_to_image(\n   402→                prompt=prompt,\n   403→                image=image_data,\n   404→                guidance_scale=guidance_scale,\n   405→                seed=seed,\n   406→                reference_images=(ref_payloads or None),\n   407→            )\n   408→\n   409→            # 处理input_image字段，避免在日志中输出大量base64数据\n   410→            input_image_info = \"[图像数据]\"\n   411→            if image:\n   412→                if image.startswith(\"data:image/\"):\n   413→                    # 如果是base64数据，只保留格式信息\n   414→                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   415→                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   416→                elif image.startswith((\"http://\", \"https://\")):\n   417→                    # 如果是URL，保留URL\n   418→                    input_image_info = image\n   419→                else:\n   420→                    # 如果是文件路径，只保留文件名\n   421→                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n   422→            \n   423→            result = {\n   424→                \"task_id\": task_id,\n   425→                \"success\": True,\n   426→                \"type\": \"image_to_image\",\n   427→                \"prompt\": prompt,\n   428→                \"input_image\": input_image_info,\n   429→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   430→                \"parameters\": {\n   431→                    \"guidance_scale\": guidance_scale, \n   432→                    \"seed\": seed, \n   433→                    \"response_format\": \"url\",  # 固定值\n   434→                    \"watermark\": False,  # 固定值\n   435→                    \"size\": \"adaptive\",  # 固定值\n   436→                    \"model\": self._resolve_model_id(\n   437→                        \"doubao-seededit-3-0-i2i-250628\",\n   438→                        \"doubao-seedream-4-0-250828\",\n   439→                        \"doubao-seedream-4-5-251128\",\n   440→                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n   441→                },\n   442→                \"created_at\": datetime.now().isoformat(),\n   443→                \"usage\": api_result.get(\"usage\", {}),\n   444→            }\n   445→\n   446→            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   447→            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n   448→            result[\"reference_assets\"] = sanitized_refs\n   449→            if ref_summary.get('errors'):\n   450→                result[\"reference_asset_errors\"] = ref_summary['errors']\n   451→            if ref_summary.get('warnings'):\n   452→                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n   453→            if fb and reason:\n   454→                result[\"fallback_applied\"] = True\n   455→                result[\"fallback_reason\"] = reason\n   456→\n   457→            masked_ids = self._summarize_reference_ids(sanitized_refs)\n   458→            logger.info(\n   459→                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n   460→                len(sanitized_refs),\n   461→                masked_ids or \"-\",\n   462→                self._provider_used(),\n   463→            )\n   464→\n   465→            # 保存到本地\n   466→            if save_local and result.get(\"image_url\"):\n   467→                local_result = self._save_image_locally(result)\n   468→                result.update(local_result)\n   469→                if local_result.get('local_save_error'):\n   470→                    self._cleanup_reference_paths(ref_paths)\n   471→                    result[\"parameters\"][\"reference_assets\"] = []\n   472→                    result[\"reference_assets\"] = []\n   473→                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n   474→                    warnings.append(\"主图保存失败，参考图已回滚\")\n   475→                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   476→\n   477→            logger.success(f\"图生图任务完成: {task_id}\")\n   478→            return result\n   479→\n   480→        except Exception as e:\n   481→            # 避免在日志中显示可能包含base64数据的异常信息\n   482→            error_msg = str(e)\n   483→            if len(error_msg) > 200:\n   484→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   485→            logger.error(f\"图生图API调用失败: {error_msg}\")\n   486→            self._cleanup_reference_paths(ref_paths)\n   487→            return {\n   488→                \"task_id\": task_id,\n   489→                \"success\": False,\n   490→                \"error\": error_msg,\n   491→                \"type\": \"image_to_image\"\n   492→            }\n   493→\n   494→    def batch_generate_text_to_image(\n   495→        self,\n   496→        prompts: List[str],\n   497→        size: str = \"1024x1024\",\n   498→        guidance_scale: float = 2.5,\n   499→        save_local: bool = True,\n   500→    ) -> List[Dict[str, Any]]:\n   501→        \"\"\"\n   502→        批量生成文生图（顺序执行，保持向后兼容）\n   503→\n   504→        Args:\n   505→            prompts: 提示词列表\n   506→            size: 图像尺寸\n   507→            guidance_scale: 提示词一致性\n   508→            save_local: 是否保存到本地\n   509→\n   510→        Returns:\n   511→            List[Dict]: 生成结果列表\n   512→        \n   513→        Note:\n   514→            水印参数已固定为False，不再需要前端控制\n   515→            如需并发执行，请使用concurrent_generate_text_to_image方法\n   516→        \"\"\"\n   517→        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n   518→\n   519→        results = []\n   520→        for i, prompt in enumerate(prompts, 1):\n   521→            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n   522→\n   523→            result = self.generate_text_to_image(\n   524→                prompt=prompt,\n   525→                size=size,\n   526→                guidance_scale=guidance_scale,\n   527→                save_local=save_local,\n   528→                generation_id=None,\n   529→            )\n   530→\n   531→            results.append(result)\n   532→\n   533→        success_count = sum(1 for r in results if r[\"success\"])\n   534→        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n   535→\n   536→        return results\n   537→\n   538→    def concurrent_generate_text_to_image(\n   539→        self,\n   540→        prompt: str,\n   541→        count: int = 4,\n   542→        size: str = \"1024x1024\",\n   543→        guidance_scale: float = 2.5,\n   544→        seed: int = -1,\n   545→        save_local: bool = True,\n   546→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   547→        max_workers: int = 5,\n   548→        derived_ids: Optional[List[str]] = None,\n   549→        generation_id: Optional[str] = None,\n   550→        model_variant: Optional[str] = None,\n   551→        sequential_mode: bool = False,\n   552→    ) -> Dict[str, Any]:\n   553→        \"\"\"\n   554→        并发生成多张文生图\n   555→\n   556→        Args:\n   557→            prompt: 图像生成提示词\n   558→            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n   559→            size: 图像尺寸\n   560→            guidance_scale: 引导强度\n   561→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   562→            save_local: 是否保存到本地\n   563→            progress_callback: 进度回调函数，参数为(completed, total, result)\n   564→            max_workers: 最大并发数\n   565→            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n   566→            sequential_mode: 是否启用组图模式（Seedream 4.5）\n   567→\n   568→        Returns:\n   569→            Dict: 包含所有任务结果的字典\n   570→        \"\"\"\n   571→        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n   572→        max_allowed = 15 if sequential_mode else 10\n   573→        if count < 1 or count > max_allowed:\n   574→            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n   575→\n   576→        # 组图模式：单次 API 调用返回多张图\n   577→        if sequential_mode:\n   578→            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n   579→            return self.generate_text_to_image(\n   580→                prompt=prompt,\n   581→                size=size,\n   582→                guidance_scale=guidance_scale,\n   583→                seed=seed,\n   584→                save_local=save_local,\n   585→                model_variant=model_variant,\n   586→                generation_id=generation_id,\n   587→                count=count,\n   588→                sequential_mode=True,\n   589→                derived_ids=derived_ids,\n   590→                progress_callback=progress_callback,\n   591→            )\n   592→        \n   593→        if max_workers > count:\n   594→            max_workers = count\n   595→        \n   596→        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n   597→        \n   598→        # 生成批次ID\n   599→        batch_id = str(uuid.uuid4())\n   600→        start_time = time.time()\n   601→\n   602→        slots = max(1, count)\n   603→        per_ids: List[str] = list(derived_ids or [])\n   604→        if len(per_ids) < slots:\n   605→            base = generation_id or batch_id\n   606→            for idx in range(len(per_ids), slots):\n   607→                per_ids.append(f\"{base}_{idx + 1}\")\n   608→        \n   609→        # 准备任务参数\n   610→        tasks = []\n   611→        for i in range(count):\n   612→            # 为每个任务生成不同的种子（如果seed为-1）\n   613→            task_seed = seed if seed != -1 else None\n   614→            gen_id = per_ids[i] if i < len(per_ids) else None\n   615→            tasks.append({\n   616→                'prompt': prompt,\n   617→                'size': size,\n   618→                'guidance_scale': guidance_scale,\n   619→                'seed': task_seed,\n   620→                'save_local': save_local,\n   621→                'task_index': i + 1,\n   622→                'generation_id': gen_id,\n   623→                'model_variant': model_variant,\n   624→            })\n   625→        \n   626→        # 使用线程池并发执行\n   627→        results = []\n   628→        completed_count = 0\n   629→        \n   630→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   631→            # 提交所有任务\n   632→            future_to_task = {\n   633→                executor.submit(self._execute_single_text_to_image_task, task): task \n   634→                for task in tasks\n   635→            }\n   636→            \n   637→            # 收集结果\n   638→            for future in as_completed(future_to_task):\n   639→                task = future_to_task[future]\n   640→                try:\n   641→                    result = future.result()\n   642→                    result['task_index'] = task['task_index']\n   643→                    result['batch_id'] = batch_id\n   644→                    results.append(result)\n   645→                    \n   646→                    completed_count += 1\n   647→                    \n   648→                    # 调用进度回调\n   649→                    if progress_callback:\n   650→                        try:\n   651→                            progress_callback(completed_count, count, result)\n   652→                        except Exception as e:\n   653→                            logger.warning(f\"进度回调执行失败: {e}\")\n   654→                    \n   655→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   656→                    \n   657→                except Exception as e:\n   658→                    error_result = {\n   659→                        'task_index': task['task_index'],\n   660→                        'batch_id': batch_id,\n   661→                        'success': False,\n   662→                        'error': str(e),\n   663→                        'type': 'text_to_image'\n   664→                    }\n   665→                    results.append(error_result)\n   666→                    completed_count += 1\n   667→                    \n   668→                    if progress_callback:\n   669→                        try:\n   670→                            progress_callback(completed_count, count, error_result)\n   671→                        except Exception as e:\n   672→                            logger.warning(f\"进度回调执行失败: {e}\")\n   673→                    \n   674→                    # 避免在日志中显示可能包含base64数据的异常信息\n   675→                    error_msg = str(e)\n   676→                    if len(error_msg) > 200:\n   677→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   678→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   679→        \n   680→        # 按task_index排序\n   681→        results.sort(key=lambda x: x.get('task_index', 0))\n   682→        \n   683→        # 统计结果\n   684→        success_count = sum(1 for r in results if r.get('success', False))\n   685→        total_time = time.time() - start_time\n   686→        \n   687→        batch_result = {\n   688→            'batch_id': batch_id,\n   689→            'success': True,\n   690→            'prompt': prompt,\n   691→            'total_count': count,\n   692→            'success_count': success_count,\n   693→            'failed_count': count - success_count,\n   694→            'total_time': round(total_time, 2),\n   695→            'average_time': round(total_time / count, 2),\n   696→            'results': results,\n   697→            'parameters': {\n   698→                'size': size,\n   699→                'guidance_scale': guidance_scale,\n   700→                'seed': seed,\n   701→                'max_workers': max_workers\n   702→            },\n   703→            'derived_ids': per_ids,\n   704→            'created_at': datetime.now().isoformat()\n   705→        }\n   706→        \n   707→        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   708→        return batch_result\n   709→\n   710→    def concurrent_generate_image_to_image(\n   711→        self,\n   712→        prompt: str,\n   713→        image: str,\n   714→        count: int = 4,\n   715→        guidance_scale: float = 5.5,\n   716→        seed: int = -1,\n   717→        save_local: bool = True,\n   718→        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n   719→        max_workers: int = 5,\n   720→        derived_ids: Optional[List[str]] = None,\n   721→        generation_id: Optional[str] = None,\n   722→    ) -> Dict[str, Any]:\n   723→        \"\"\"\n   724→        并发生成多张图生图\n   725→\n   726→        Args:\n   727→            prompt: 编辑提示词\n   728→            image: 输入图像路径或URL\n   729→            count: 生成图片数量，默认4张，最多10张\n   730→            guidance_scale: 引导强度\n   731→            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n   732→            save_local: 是否保存到本地\n   733→            progress_callback: 进度回调函数\n   734→            max_workers: 最大并发数\n   735→\n   736→        Returns:\n   737→            Dict: 包含所有任务结果的字典\n   738→        \"\"\"\n   739→        # 验证参数\n   740→        if count < 1 or count > 10:\n   741→            raise ValueError(\"生成数量必须在1-10之间\")\n   742→        \n   743→        if max_workers > count:\n   744→            max_workers = count\n   745→        \n   746→        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n   747→        \n   748→        # 生成批次ID\n   749→        batch_id = str(uuid.uuid4())\n   750→        start_time = time.time()\n   751→        \n   752→        slots = max(1, count)\n   753→        per_ids: List[str] = list(derived_ids or [])\n   754→        if len(per_ids) < slots:\n   755→            base = generation_id or batch_id\n   756→            for idx in range(len(per_ids), slots):\n   757→                per_ids.append(f\"{base}_{idx + 1}\")\n   758→        \n   759→        # 准备输入图像\n   760→        image_data = self._prepare_input_image(image)\n   761→        if not image_data:\n   762→            return {\n   763→                'batch_id': batch_id,\n   764→                'success': False,\n   765→                'error': '无法处理输入图像',\n   766→                'type': 'image_to_image'\n   767→            }\n   768→        \n   769→        # 准备任务参数\n   770→        tasks = []\n   771→        for i in range(count):\n   772→            task_seed = seed if seed != -1 else None\n   773→            gen_id = per_ids[i] if i < len(per_ids) else None\n   774→            tasks.append({\n   775→                'prompt': prompt,\n   776→                'image': image_data,\n   777→                'guidance_scale': guidance_scale,\n   778→                'seed': task_seed,\n   779→                'save_local': save_local,\n   780→                'task_index': i + 1,\n   781→                'generation_id': gen_id\n   782→            })\n   783→        \n   784→        # 使用线程池并发执行\n   785→        results = []\n   786→        completed_count = 0\n   787→        \n   788→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   789→            # 提交所有任务\n   790→            future_to_task = {\n   791→                executor.submit(self._execute_single_image_to_image_task, task): task \n   792→                for task in tasks\n   793→            }\n   794→            \n   795→            # 收集结果\n   796→            for future in as_completed(future_to_task):\n   797→                task = future_to_task[future]\n   798→                try:\n   799→                    result = future.result()\n   800→                    result['task_index'] = task['task_index']\n   801→                    result['batch_id'] = batch_id\n   802→                    results.append(result)\n   803→                    \n   804→                    completed_count += 1\n   805→                    \n   806→                    # 调用进度回调\n   807→                    if progress_callback:\n   808→                        try:\n   809→                            progress_callback(completed_count, count, result)\n   810→                        except Exception as e:\n   811→                            logger.warning(f\"进度回调执行失败: {e}\")\n   812→                    \n   813→                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n   814→                    \n   815→                except Exception as e:\n   816→                    error_result = {\n   817→                        'task_index': task['task_index'],\n   818→                        'batch_id': batch_id,\n   819→                        'success': False,\n   820→                        'error': str(e),\n   821→                        'type': 'image_to_image'\n   822→                    }\n   823→                    results.append(error_result)\n   824→                    completed_count += 1\n   825→                    \n   826→                    if progress_callback:\n   827→                        try:\n   828→                            progress_callback(completed_count, count, error_result)\n   829→                        except Exception as e:\n   830→                            logger.warning(f\"进度回调执行失败: {e}\")\n   831→                    \n   832→                    # 避免在日志中显示可能包含base64数据的异常信息\n   833→                    error_msg = str(e)\n   834→                    if len(error_msg) > 200:\n   835→                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   836→                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n   837→        \n   838→        # 按task_index排序\n   839→        results.sort(key=lambda x: x.get('task_index', 0))\n   840→        \n   841→        # 统计结果\n   842→        success_count = sum(1 for r in results if r.get('success', False))\n   843→        total_time = time.time() - start_time\n   844→        \n   845→        # 处理input_image字段，避免在日志中输出大量base64数据\n   846→        input_image_info = \"[图像数据]\"\n   847→        if image:\n   848→            if image.startswith(\"data:image/\"):\n   849→                # 如果是base64数据，只保留格式信息\n   850→                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n   851→                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n   852→            elif image.startswith((\"http://\", \"https://\")):\n   853→                # 如果是URL，保留URL\n   854→                input_image_info = image\n   855→            else:\n   856→                # 如果是文件路径，只保留文件名\n   857→                input_image_info = f\"[本地文件: {Path(image).name}]\"\n   858→        \n   859→        batch_result = {\n   860→            'batch_id': batch_id,\n   861→            'success': True,\n   862→            'prompt': prompt,\n   863→            'input_image': input_image_info,\n   864→            'total_count': count,\n   865→            'success_count': success_count,\n   866→            'failed_count': count - success_count,\n   867→            'total_time': round(total_time, 2),\n   868→            'average_time': round(total_time / count, 2),\n   869→            'results': results,\n   870→            'parameters': {\n   871→                'guidance_scale': guidance_scale,\n   872→                'seed': seed,\n   873→                'max_workers': max_workers\n   874→            },\n   875→            'derived_ids': per_ids,\n   876→            'created_at': datetime.now().isoformat()\n   877→        }\n   878→        \n   879→        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n   880→        return batch_result\n   881→\n   882→    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   883→        \"\"\"\n   884→        执行单个文生图任务\n   885→        \n   886→        Args:\n   887→            task: 任务参数字典\n   888→            \n   889→        Returns:\n   890→            Dict: 任务执行结果\n   891→        \"\"\"\n   892→        return self.generate_text_to_image(\n   893→            prompt=task['prompt'],\n   894→            size=task['size'],\n   895→            guidance_scale=task['guidance_scale'],\n   896→            seed=task['seed'],\n   897→            save_local=task['save_local'],\n   898→            generation_id=task.get('generation_id'),\n   899→            model_variant=task.get('model_variant'),\n   900→        )\n   901→    \n   902→    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n   903→        \"\"\"\n   904→        执行单个图生图任务\n   905→        \n   906→        Args:\n   907→            task: 任务参数字典\n   908→            \n   909→        Returns:\n   910→            Dict: 任务执行结果\n   911→        \"\"\"\n   912→        # 生成唯一ID，优先使用外部传入的generation_id\n   913→        task_id = task.get('generation_id') or str(uuid.uuid4())\n   914→        \n   915→        try:\n   916→            # 直接使用已经处理好的图片数据，避免重复处理\n   917→            image_data = task['image']\n   918→            \n   919→            # 调用API生成图像\n   920→            api_result = self.client.image_to_image(\n   921→                prompt=task['prompt'], \n   922→                image=image_data, \n   923→                guidance_scale=task['guidance_scale'], \n   924→                seed=task['seed']\n   925→            )\n   926→            \n   927→            result = {\n   928→                \"task_id\": task_id,\n   929→                \"success\": True,\n   930→                \"type\": \"image_to_image\",\n   931→                \"prompt\": task['prompt'],\n   932→                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n   933→                \"parameters\": {\n   934→                    \"guidance_scale\": task['guidance_scale'], \n   935→                    \"seed\": task['seed'], \n   936→                    \"response_format\": \"url\",\n   937→                    \"watermark\": False,\n   938→                    \"size\": \"adaptive\",\n   939→                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n   940→                },\n   941→                \"created_at\": datetime.now().isoformat(),\n   942→                \"usage\": api_result.get(\"usage\", {}),\n   943→            }\n   944→            \n   945→            # 保存到本地\n   946→            if task['save_local'] and result.get(\"image_url\"):\n   947→                local_result = self._save_image_locally(result)\n   948→                result.update(local_result)\n   949→            \n   950→            return result\n   951→            \n   952→        except Exception as e:\n   953→            # 避免在日志中显示可能包含base64数据的异常信息\n   954→            error_msg = str(e)\n   955→            if len(error_msg) > 200:\n   956→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n   957→            return {\n   958→                \"task_id\": task_id,\n   959→                \"success\": False,\n   960→                \"error\": error_msg,\n   961→                \"type\": \"image_to_image\"\n   962→            }\n   963→\n   964→    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   965→        \"\"\"\n   966→        保存图像到本地并记录元数据\n   967→\n   968→        Args:\n   969→            result: API生成结果\n   970→\n   971→        Returns:\n   972→            Dict: 包含本地文件信息的字典\n   973→        \"\"\"\n   974→        try:\n   975→            # 下载图像\n   976→            image_url = result[\"image_url\"]\n   977→            response = safe_requests_get(image_url, timeout=30)\n   978→\n   979→            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n   980→            from io import BytesIO\n   981→            real_w, real_h = None, None\n   982→            try:\n   983→                with Image.open(BytesIO(response.content)) as img:\n   984→                    real_w, real_h = int(img.width), int(img.height)\n   985→            except Exception as _e:\n   986→                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n   987→                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   988→                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n   989→\n   990→            # 组装元数据（适配UnifiedStorageManager的格式）\n   991→            params = result.get(\"parameters\", {}) or {}\n   992→            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n   993→            try:\n   994→                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n   995→                    from math import gcd\n   996→                    g = gcd(real_w, real_h)\n   997→                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n   998→            except Exception:\n   999→                pass\n  1000→\n  1001→            metadata = {\n  1002→                'generation_id': result.get(\"task_id\", \"\"),\n  1003→                'prompt': result.get(\"prompt\", \"\"),\n  1004→                'parameters': params,\n  1005→                'model': params.get(\"model\", \"seedream\"),\n  1006→                'width': real_w,\n  1007→                'height': real_h,\n  1008→                'generation_time': result.get(\"generation_time\", 0),\n  1009→                'batch_id': result.get(\"batch_id\", \"\"),\n  1010→                'status': 'completed'\n  1011→            }\n  1012→            \n  1013→            # 使用统一存储管理器保存文件\n  1014→            save_result = self.storage_manager.save_content_file(\n  1015→                content_type='images',\n  1016→                file_data=response.content,\n  1017→                url=image_url,\n  1018→                metadata=metadata\n  1019→            )\n  1020→\n  1021→            # 获取图像信息（再次确认像素尺寸）\n  1022→            image_info = self._get_image_info(Path(save_result['local_path']))\n  1023→            file_size = Path(save_result['local_path']).stat().st_size\n  1024→\n  1025→            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n  1026→\n  1027→            result_obj = {\n  1028→                \"local_path\": save_result['local_path'],\n  1029→                \"filename\": Path(save_result['local_path']).name,\n  1030→                \"file_size\": file_size,\n  1031→                \"image_info\": image_info,\n  1032→                \"file_path\": save_result['local_path'],  # 保持兼容性\n  1033→                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n  1034→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n  1035→                \"file_id\": save_result.get('file_id'),\n  1036→                \"relative_path\": save_result.get('relative_path'),\n  1037→            }\n  1038→            try:\n  1039→                w = image_info.get('width') if isinstance(image_info, dict) else None\n  1040→                h = image_info.get('height') if isinstance(image_info, dict) else None\n  1041→                logger.info(\n  1042→                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n  1043→                )\n  1044→            except Exception:\n  1045→                pass\n  1046→\n  1047→            # 体验版本地图片水印（使用统一水印服务）\n  1048→            if should_add_watermark():\n  1049→                try:\n  1050→                    from edition.watermark_service import WatermarkService\n  1051→\n  1052→                    watermark_text = get_watermark_text() or \"PIGEON\"\n  1053→                    try:\n  1054→                        opacity = get_watermark_opacity()\n  1055→                    except Exception:\n  1056→                        opacity = 0.3\n  1057→                    opacity = max(0.0, min(opacity, 1.0))\n  1058→\n  1059→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n  1060→                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n  1061→                    if watermark_applied:\n  1062→                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n  1063→                        result_obj[\"watermark_applied\"] = True\n  1064→                    else:\n  1065→                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n  1066→                        result_obj[\"watermark_applied\"] = False\n  1067→                except Exception as e:\n  1068→                    logger.warning(f\"添加图片水印时出错: {e}\")\n  1069→                    result_obj[\"watermark_applied\"] = False\n  1070→\n  1071→            return result_obj\n  1072→\n  1073→        except Exception as e:\n  1074→            logger.error(f\"保存图像到本地失败: {e}\")\n  1075→            try:\n  1076→                logger.info(\"摘要|operation=save_image status=failed\")\n  1077→            except Exception:\n  1078→                pass\n  1079→            return {\"local_save_error\": str(e)}\n  1080→\n  1081→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n  1082→        checksum = hashlib.sha1(file_data).hexdigest()\n  1083→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n  1084→        return f\"ref_{ts}_{checksum[:8]}\"\n  1085→\n  1086→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n  1087→        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n  1088→        source_meta: Dict[str, Any] = {}\n  1089→        raw = ref\n  1090→        if isinstance(ref, dict):\n  1091→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n  1092→                if ref.get(key) is not None:\n  1093→                    source_meta[key] = ref.get(key)\n  1094→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n  1095→        if raw is None:\n  1096→            return None\n  1097→\n  1098→        extension = source_meta.get('extension')\n  1099→        data = None\n  1100→        source_repr = source_meta.get('source')\n  1101→\n  1102→        try:\n  1103→            if isinstance(raw, bytes):\n  1104→                data = raw\n  1105→            elif isinstance(raw, str):\n  1106→                stripped = raw.strip()\n  1107→                if stripped.startswith('data:') and ';base64,' in stripped:\n  1108→                    header, payload = stripped.split(';base64,', 1)\n  1109→                    mime_part = header[5:]\n  1110→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n  1111→                    data = base64.b64decode(payload)\n  1112→                    source_repr = source_repr or mime_part\n  1113→                    source_meta.setdefault('type', 'image')\n  1114→                elif stripped.startswith(('http://', 'https://')):\n  1115→                    resp = safe_requests_get(stripped, timeout=15)\n  1116→                    data = resp.content\n  1117→                    parsed = urlparse(stripped)\n  1118→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n  1119→                    source_repr = source_repr or stripped\n  1120→                    source_meta.setdefault('source_url', stripped)\n  1121→                else:\n  1122→                    path = Path(stripped)\n  1123→                    if not path.exists():\n  1124→                        logger.warning(f\"引用图像不存在: {stripped}\")\n  1125→                        return None\n  1126→                    data = path.read_bytes()\n  1127→                    extension = extension or path.suffix or '.png'\n  1128→                    source_repr = source_repr or path.name\n  1129→                    source_meta.setdefault('source_path', str(path))\n  1130→            else:\n  1131→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n  1132→                return None\n  1133→        except Exception as exc:\n  1134→            logger.warning(f\"加载参考图失败: {exc}\")\n  1135→            return None\n  1136→\n  1137→        if data is None:\n  1138→            return None\n  1139→\n  1140→        width = source_meta.get('width')\n  1141→        height = source_meta.get('height')\n  1142→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n  1143→            try:\n  1144→                from io import BytesIO\n  1145→\n  1146→                with Image.open(BytesIO(data)) as img:\n  1147→                    width = img.width\n  1148→                    height = img.height\n  1149→            except Exception:\n  1150→                pass\n  1151→\n  1152→        source_meta['width'] = width\n  1153→        source_meta['height'] = height\n  1154→        source_meta.setdefault('type', 'image')\n  1155→        source_meta['source'] = source_repr or source_meta.get('source')\n  1156→\n  1157→        return data, extension, source_meta\n  1158→\n  1159→    def _process_reference_assets(\n  1160→        self,\n  1161→        references: Optional[List[Any]],\n  1162→        *,\n  1163→        max_refs: int = MAX_REFERENCE_IMAGES,\n  1164→        expected_outputs: int = 1,\n  1165→    ) -> Dict[str, Any]:\n  1166→        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n  1167→        stored: List[Dict[str, Any]] = []\n  1168→        absolute_paths: List[str] = []\n  1169→        errors: List[str] = []\n  1170→        warnings: List[str] = []\n  1171→\n  1172→        if not references:\n  1173→            return {\n  1174→                'assets': stored,\n  1175→                'paths': absolute_paths,\n  1176→                'errors': errors,\n  1177→                'warnings': warnings,\n  1178→            }\n  1179→\n  1180→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n  1181→            warnings.append(\n  1182→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n  1183→            )\n  1184→            references = references[:max_refs]\n  1185→\n  1186→        for order, item in enumerate(references):\n  1187→            load_result = self._load_reference_source(item)\n  1188→            if not load_result:\n  1189→                errors.append(f\"ref[{order}] 加载失败\")\n  1190→                continue\n  1191→\n  1192→            file_data, extension, meta = load_result\n  1193→            meta.setdefault('order', order)\n  1194→            meta.setdefault('kind', meta.get('type', 'image'))\n  1195→\n  1196→            try:\n  1197→                asset_id = self._generate_reference_asset_id(file_data)\n  1198→                record = self.storage_manager.save_reference_asset(\n  1199→                    'images',\n  1200→                    file_data,\n  1201→                    asset_id=asset_id,\n  1202→                    extension=extension,\n  1203→                    metadata=meta,\n  1204→                )\n  1205→                try:\n  1206→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n  1207→                except Exception:\n  1208→                    record['_payload_b64'] = None\n  1209→                record['_source_meta'] = meta\n  1210→                stored.append(record)\n  1211→                if record.get('absolute_path'):\n  1212→                    absolute_paths.append(record['absolute_path'])\n  1213→            except Exception as exc:\n  1214→                logger.warning(f\"保存参考图失败: {exc}\")\n  1215→                errors.append(f\"ref[{order}] 保存失败\")\n  1216→\n  1217→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n  1218→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n  1219→            if len(stored) > allowed:\n  1220→                warnings.append(\n  1221→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n  1222→                )\n  1223→                stored = stored[:allowed]\n  1224→                absolute_paths = absolute_paths[:allowed]\n  1225→\n  1226→        return {\n  1227→            'assets': stored,\n  1228→            'paths': absolute_paths,\n  1229→            'errors': errors,\n  1230→            'warnings': warnings,\n  1231→        }\n  1232→\n  1233→    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n  1234→        payloads: List[str] = []\n  1235→        for asset in assets or []:\n  1236→            payload = asset.get('_payload_b64')\n  1237→            if not payload:\n  1238→                continue\n  1239→            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n  1240→            mime = 'image/png'\n  1241→            try:\n  1242→                if path_hint:\n  1243→                    suffix = Path(path_hint).suffix.lower()\n  1244→                    if suffix in {'.jpg', '.jpeg'}:\n  1245→                        mime = 'image/jpeg'\n  1246→                    elif suffix == '.webp':\n  1247→                        mime = 'image/webp'\n  1248→                    elif suffix == '.bmp':\n  1249→                        mime = 'image/bmp'\n  1250→                    elif suffix == '.gif':\n  1251→                        mime = 'image/gif'\n  1252→            except Exception:\n  1253→                pass\n  1254→            payloads.append(f\"data:{mime};base64,{payload}\")\n  1255→        return payloads\n  1256→\n  1257→    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n  1258→        provider = (self.client.last_provider() or \"\").lower()\n  1259→        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n  1260→            return v4_5_model or v4_model\n  1261→        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n  1262→            return v4_model\n  1263→        return default_model\n  1264→\n  1265→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n  1266→        cleaned: List[Dict[str, Any]] = []\n  1267→        for rec in assets or []:\n  1268→            rec.pop('_payload_b64', None)\n  1269→            rec.pop('_source_meta', None)\n  1270→            rec.pop('absolute_path', None)\n  1271→            cleaned.append({\n  1272→                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n  1273→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n  1274→                'type': rec.get('type'),\n  1275→                'kind': rec.get('kind'),\n  1276→                'source': rec.get('source'),\n  1277→                'order': rec.get('order'),\n  1278→                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n  1279→                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n  1280→                'width': rec.get('width'),\n  1281→                'height': rec.get('height'),\n  1282→                'created_at': rec.get('created_at'),\n  1283→            })\n  1284→        return cleaned\n  1285→\n  1286→    @staticmethod\n  1287→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1288→        masked: List[str] = []\n  1289→        for rec in assets or []:\n  1290→            rid = rec.get('id') or ''\n  1291→            if not rid:\n  1292→                continue\n  1293→            masked.append(f\"{rid[:6]}***\")\n  1294→        return \",\".join(masked)\n  1295→\n  1296→    @staticmethod\n  1297→    def _provider_hint() -> str:\n  1298→        try:\n  1299→            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n  1300→        except Exception:\n  1301→            return \"unknown\"\n  1302→\n  1303→    def _provider_used(self) -> str:\n  1304→        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n  1305→        if provider:\n  1306→            return provider\n  1307→        return self._provider_hint()\n  1308→\n  1309→    @staticmethod\n  1310→    def _cleanup_reference_paths(paths: List[str]):\n  1311→        for path in paths or []:\n  1312→            try:\n  1313→                if path and Path(path).exists():\n  1314→                    Path(path).unlink(missing_ok=True)\n  1315→            except Exception as exc:\n  1316→                logger.debug(f\"参考图清理失败: {exc}\")\n  1317→\n  1318→    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n  1319→        \"\"\"\n  1320→        准备输入图像，支持本地文件和URL\n  1321→        \n  1322→        Args:\n  1323→            image_path: 图像路径（本地路径或URL）\n  1324→            \n  1325→        Returns:\n  1326→            str: 图像URL、base64数据或None\n  1327→        \"\"\"\n  1328→        try:\n  1329→            # 如果是URL，直接返回\n  1330→            if image_path.startswith((\"http://\", \"https://\")):\n  1331→                return image_path\n  1332→\n  1333→            # 如果是本地文件，转换为Base64\n  1334→            local_path = Path(image_path)\n  1335→            if local_path.exists():\n  1336→                with open(local_path, \"rb\") as f:\n  1337→                    image_data = f.read()\n  1338→\n  1339→                # 检测图像格式\n  1340→                image = Image.open(local_path)\n  1341→                format_name = image.format.lower()\n  1342→\n  1343→                # 转换为Base64\n  1344→                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n  1345→                return f\"data:image/{format_name};base64,{base64_data}\"\n  1346→\n  1347→            logger.error(f\"图像文件不存在: {image_path}\")\n  1348→            return None\n  1349→\n  1350→        except Exception as e:\n  1351→            logger.error(f\"处理输入图像失败: {e}\")\n  1352→            return None\n  1353→\n  1354→    def _extract_width_from_size(self, size: str) -> int:\n  1355→        \"\"\"\n  1356→        从尺寸字符串中提取宽度\n  1357→        \n  1358→        Args:\n  1359→            size: 尺寸字符串，如 \"1024x1024\"\n  1360→            \n  1361→        Returns:\n  1362→            int: 宽度值\n  1363→        \"\"\"\n  1364→        try:\n  1365→            return int(size.split('x')[0])\n  1366→        except (ValueError, IndexError):\n  1367→            return 1024  # 默认值\n  1368→    \n  1369→    def _extract_height_from_size(self, size: str) -> int:\n  1370→        \"\"\"\n  1371→        从尺寸字符串中提取高度\n  1372→        \n  1373→        Args:\n  1374→            size: 尺寸字符串，如 \"1024x1024\"\n  1375→            \n  1376→        Returns:\n  1377→            int: 高度值\n  1378→        \"\"\"\n  1379→        try:\n  1380→            return int(size.split('x')[1])\n  1381→        except (ValueError, IndexError):\n  1382→            return 1024  # 默认值\n  1383→\n  1384→    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n  1385→        \"\"\"\n  1386→        获取图像信息\n  1387→\n  1388→        Args:\n  1389→            image_path: 图像文件路径\n  1390→\n  1391→        Returns:\n  1392→            Dict: 图像信息\n  1393→        \"\"\"\n  1394→        try:\n  1395→            with Image.open(image_path) as img:\n  1396→                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n  1397→        except Exception as e:\n  1398→            logger.error(f\"获取图像信息失败: {e}\")\n  1399→            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n  1400→\n  1401→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1402→        \"\"\"\n  1403→        获取图像生成历史记录\n  1404→\n  1405→        Args:\n  1406→            limit: 返回记录数量限制\n  1407→\n  1408→        Returns:\n  1409→            List[Dict]: 历史记录列表\n  1410→        \"\"\"\n  1411→        return self.storage_manager.load_history('images', limit=limit)\n  1412→\n  1413→    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n  1414→        \"\"\"\n  1415→        根据提示词关键字搜索历史记录\n  1416→\n  1417→        Args:\n  1418→            keyword: 搜索关键字\n  1419→\n  1420→        Returns:\n  1421→            List[Dict]: 匹配的记录列表\n  1422→        \"\"\"\n  1423→        # 获取所有历史记录并在内存中过滤\n  1424→        all_records = self.storage_manager.load_history('images', limit=1000)\n  1425→        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n  1426→\n  1427→    def get_statistics(self) -> Dict[str, Any]:\n  1428→        \"\"\"\n  1429→        获取生成统计信息\n  1430→\n  1431→        Returns:\n  1432→            Dict: 统计信息\n  1433→        \"\"\"\n  1434→        try:\n  1435→            # 使用统一存储管理器获取存储统计\n  1436→            storage_stats = self.storage_manager.get_storage_stats()\n  1437→            image_stats = storage_stats.get('content_types', {}).get('images', {})\n  1438→            \n  1439→            # 获取历史记录进行详细统计\n  1440→            all_records = self.storage_manager.load_history('images', limit=1000)\n  1441→            \n  1442→            if not all_records:\n  1443→                return {\n  1444→                    \"total_images\": 0,\n  1445→                    \"text_to_image_count\": 0,\n  1446→                    \"image_to_image_count\": 0,\n  1447→                    \"total_file_size\": 0,\n  1448→                    \"average_file_size\": 0,\n  1449→                    \"most_common_size\": \"unknown\"\n  1450→                }\n  1451→\n  1452→            # 统计不同类型的图片数量\n  1453→            text_to_image_count = 0\n  1454→            image_to_image_count = 0\n  1455→            total_file_size = 0\n  1456→            sizes = []\n  1457→            \n  1458→            for record in all_records:\n  1459→                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n  1460→                if 'input_image' in record.get('parameters', {}):\n  1461→                    image_to_image_count += 1\n  1462→                else:\n  1463→                    text_to_image_count += 1\n  1464→                \n  1465→                # 计算文件大小\n  1466→                file_size = record.get('file_size', 0)\n  1467→                if isinstance(file_size, str) and file_size.isdigit():\n  1468→                    file_size = int(file_size)\n  1469→                elif not isinstance(file_size, (int, float)):\n  1470→                    file_size = 0\n  1471→                total_file_size += file_size\n  1472→                \n  1473→                # 收集尺寸信息\n  1474→                width = record.get('width', 0)\n  1475→                height = record.get('height', 0)\n  1476→                if width and height:\n  1477→                    sizes.append(f\"{width}x{height}\")\n  1478→\n  1479→            stats = {\n  1480→                \"total_images\": len(all_records),\n  1481→                \"text_to_image_count\": text_to_image_count,\n  1482→                \"image_to_image_count\": image_to_image_count,\n  1483→                \"total_file_size\": total_file_size,\n  1484→                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n  1485→                \"most_common_size\": \"unknown\",\n  1486→                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n  1487→            }\n  1488→\n  1489→            # 最常用的尺寸\n  1490→            if sizes:\n  1491→                from collections import Counter\n  1492→                size_counts = Counter(sizes)\n  1493→                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n  1494→\n  1495→            return stats\n  1496→\n  1497→        except Exception as e:\n  1498→            logger.error(f\"获取统计信息失败: {e}\")\n  1499→            return {\n  1500→                \"total_images\": 0,\n  1501→                \"text_to_image_count\": 0,\n  1502→                \"image_to_image_count\": 0,\n  1503→                \"total_file_size\": 0,\n  1504→                \"average_file_size\": 0,\n  1505→                \"most_common_size\": \"unknown\"\n  1506→            }\n  1507→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c7a461e9-a752-43ea-a9db-af82809be48f","timestamp":"2025-12-11T08:09:28.769Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedream/manager.py","content":"# Seedream图像生成管理器\n# 负责图像生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Callable, Tuple\nfrom PIL import Image\nfrom loguru import logger\nfrom urllib.parse import urlparse\nimport base64\nimport asyncio\nimport aiohttp\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\n\nfrom .client import SeedreamClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    TextToImageParams,\n    ImageToImageParams,\n    validate_and_normalize_t2i,\n    validate_and_normalize_i2i,\n    MAX_REFERENCE_IMAGES,\n    MAX_REFERENCE_BUNDLE,\n)\nfrom config_api import get_storage_dir\n\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n\nclass SeedreamManager:\n    \"\"\"Seedream图像生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedream管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从ConfigManager获取\n        \"\"\"\n        self.client = SeedreamClient(api_key)\n        \n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(get_storage_dir())\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.image_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.images_dir = self.data_dir / \"images\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedream管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_text_to_image(\n        self,\n        prompt: str,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        model_variant: Optional[str] = None,\n        generation_id: Optional[str] = None,\n        count: int = 1,\n        sequential_mode: bool = False,\n        derived_ids: Optional[List[str]] = None,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成文生图并保存到本地\n\n        Args:\n            prompt: 图像生成提示词\n            size: 图像尺寸，支持的尺寸见client.get_supported_sizes()\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n            reference_images: 参考图列表\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            count: 生成图片数量（组图模式下生效）\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n            derived_ids: 组图生成的ID列表（用于关联）\n\n        Returns:\n            Dict: 生成结果，包含本地文件路径\n\n        Note:\n            model和watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\n        \n        # 根据 model_variant 设置环境变量\n        if model_variant == 'seedream_v4':\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4\"\n        elif model_variant == 'seedream_v4_5':\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v4_5\"\n        else:\n            # 默认使用 volc_v3\n            os.environ[\"GEMENG_SEEDREAM_PROVIDER\"] = \"volc_v3\"\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_assets: List[Dict[str, Any]] = []\n        ref_paths: List[str] = []\n        ref_summary: Dict[str, Any] = {}\n        ref_payloads: List[str] = []\n\n        try:\n            if reference_images:\n                ref_summary = self._process_reference_assets(\n                    reference_images,\n                    max_refs=MAX_REFERENCE_IMAGES,\n                    expected_outputs=1,\n                )\n                ref_assets = list(ref_summary.get('assets', []))\n                ref_paths = list(ref_summary.get('paths', []))\n                ref_payloads = self._build_reference_payloads(ref_assets)\n\n                if ref_summary.get('errors'):\n                    logger.warning(\n                        f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                    )\n                if ref_summary.get('warnings'):\n                    for warn in ref_summary['warnings']:\n                        logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变业务流程，仅记录摘要与回退建议）\n            try:\n                norm, fb, reason = validate_and_normalize_t2i(\n                    TextToImageParams(\n                        prompt=prompt,\n                        size=size,\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_t2i size={norm.size} gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n            # 调用API生成图像（model和watermark参数已在客户端固定）\n            actual_count = max(1, count)\n            use_group_mode = bool(sequential_mode and actual_count > 1)\n\n            api_result = self.client.text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=ref_payloads or None,\n                n=actual_count if use_group_mode else 1,\n                sequential_mode=sequential_mode,\n            )\n\n            # 组图模式：API 返回多张图，需要逐一保存\n            images_list = api_result.get(\"data\", {}).get(\"images\", [])\n            images_count = len(images_list)\n            logger.info(f\"组图模式: use_group_mode={use_group_mode}, API返回图片数={images_count}, 请求数={actual_count}\")\n\n            # 警告：API 返回数量少于请求数量（auto 模式下由 API 自主判断）\n            if use_group_mode and images_count < actual_count:\n                logger.warning(\n                    f\"[组图] API 仅返回 {images_count} 张图（请求了 {actual_count} 张）。\"\n                    f\"提示：在 prompt 中明确描述每张图的内容（如：生成{actual_count}张...，分别是...）\"\n                )\n\n            if use_group_mode and images_count > 1:\n                results_batch = []\n                success_count = 0\n                group_ids = derived_ids or [str(uuid.uuid4()) for _ in range(actual_count)]\n                total_images = len(images_list)\n\n                for idx, img_data in enumerate(images_list):\n                    # 发送下载进度（每张图开始下载时）\n                    if progress_callback:\n                        try:\n                            progress_callback(idx, total_images, {\"status\": \"downloading\", \"index\": idx + 1})\n                        except Exception:\n                            pass\n\n                    per_id = group_ids[idx] if idx < len(group_ids) else str(uuid.uuid4())\n                    per_result = {\n                        \"task_id\": per_id,\n                        \"success\": True,\n                        \"type\": \"text_to_image\",\n                        \"prompt\": prompt,\n                        \"image_url\": img_data[\"url\"],\n                        \"parameters\": {\n                            \"size\": size,\n                            \"guidance_scale\": guidance_scale,\n                            \"seed\": seed,\n                            \"response_format\": \"url\",\n                            \"watermark\": False,\n                            \"model\": self._resolve_model_id(\n                                \"doubao-seedream-3-0-t2i-250415\",\n                                \"doubao-seedream-4-0-250828\",\n                                \"doubao-seedream-4-5-251128\",\n                            ),\n                            \"sequential_mode\": True,\n                            \"group_index\": idx + 1,\n                            \"group_total\": total_images,\n                        },\n                        \"created_at\": datetime.now().isoformat(),\n                        \"usage\": api_result.get(\"usage\", {}),\n                    }\n\n                    sanitized_refs = self._sanitize_reference_assets(ref_assets)\n                    if sanitized_refs:\n                        per_result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                        per_result[\"reference_assets\"] = sanitized_refs\n\n                    if save_local and per_result.get(\"image_url\"):\n                        local_result = self._save_image_locally(per_result)\n                        per_result.update(local_result)\n                        if not local_result.get('local_save_error'):\n                            success_count += 1\n\n                    results_batch.append(per_result)\n\n                    # 发送下载完成进度\n                    if progress_callback:\n                        try:\n                            progress_callback(idx + 1, total_images, per_result)\n                        except Exception:\n                            pass\n\n                logger.success(f\"组图任务完成: {success_count}/{len(results_batch)} 张成功\")\n                return {\n                    \"batch\": True,\n                    \"results\": results_batch,\n                    \"success_count\": success_count,\n                    \"total_count\": len(results_batch),\n                    \"derived_ids\": group_ids,\n                }\n\n            # 单图模式（默认）\n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"text_to_image\",\n                \"prompt\": prompt,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"size\": size,\n                    \"guidance_scale\": guidance_scale,\n                    \"seed\": seed,\n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seedream-3-0-t2i-250415\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            if sanitized_refs:\n                result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n                result[\"reference_assets\"] = sanitized_refs\n                masked_ids = self._summarize_reference_ids(sanitized_refs)\n                logger.info(\n                    \"摘要|operation=t2i_reference reference_count={} ref_ids={} provider={}\",\n                    len(sanitized_refs),\n                    masked_ids or \"-\",\n                    self._provider_used(),\n                )\n            else:\n                result[\"parameters\"][\"reference_assets\"] = []\n                result[\"reference_assets\"] = []\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error') and sanitized_refs:\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"文生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            logger.error(f\"文生图API调用失败: {str(e)}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": str(e),\n                \"type\": \"text_to_image\"\n            }\n\n    def generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成图生图并保存到本地\n\n        Args:\n            prompt: 编辑提示词\n            image_path: 原始图像路径（本地路径或URL）\n            guidance_scale: 引导强度，范围[1.0, 10.0]\n            seed: 随机种子，范围[-1, 2147483647]，None表示随机\n            response_format: 返回格式，\"url\"或\"b64_json\"\n            save_local: 是否保存到本地\n\n        Returns:\n            Dict: 生成结果\n        \n        Note:\n            model、size、watermark参数已固定，不再需要前端控制\n        \"\"\"\n        logger.info(f\"开始图生图任务: {prompt[:50]}...\")\n\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        ref_paths: List[str] = []\n\n        try:\n            # 处理输入图像\n            image_data = self._prepare_input_image(image)\n            if not image_data:\n                return {\"success\": False, \"error\": \"无法处理输入图像\", \"task_id\": task_id}\n\n            # 处理参考图（复制到 references 并准备 API 载荷）\n            ref_summary = self._process_reference_assets(\n                reference_images,\n                max_refs=MAX_REFERENCE_IMAGES,\n                expected_outputs=1,\n            )\n            ref_assets = ref_summary.get('assets', [])\n            ref_paths = list(ref_summary.get('paths', []))\n            ref_payloads: List[str] = self._build_reference_payloads(ref_assets)\n            if ref_summary.get('errors'):\n                logger.warning(\n                    f\"参考图处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n                )\n            if ref_summary.get('warnings'):\n                for warn in ref_summary['warnings']:\n                    logger.warning(f\"参考图提示: {warn}\")\n\n            # 前置参数校验（不改变流程，仅记录摘要）\n            fb = False\n            reason = \"\"\n            try:\n                norm, fb, reason = validate_and_normalize_i2i(\n                    ImageToImageParams(\n                        prompt=prompt,\n                        image=\"<omitted>\",  # 避免在校验阶段传递大数据\n                        guidance_scale=guidance_scale,\n                        seed=(None if seed == -1 else seed),\n                        reference_images=ref_payloads,\n                    )\n                )\n                logger.info(\n                    f\"摘要|operation=precheck_i2i gs={norm.guidance_scale} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n                )\n                if fb:\n                    logger.warning(f\"前置参数回退建议: {reason}\")\n            except Exception as _e:\n                logger.debug(f\"前置参数校验跳过: {_e}\")\n\n            # 调用API生成图像（model、size、watermark参数已在客户端固定）\n            api_result = self.client.image_to_image(\n                prompt=prompt,\n                image=image_data,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                reference_images=(ref_payloads or None),\n            )\n\n            # 处理input_image字段，避免在日志中输出大量base64数据\n            input_image_info = \"[图像数据]\"\n            if image:\n                if image.startswith(\"data:image/\"):\n                    # 如果是base64数据，只保留格式信息\n                    format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                    input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n                elif image.startswith((\"http://\", \"https://\")):\n                    # 如果是URL，保留URL\n                    input_image_info = image\n                else:\n                    # 如果是文件路径，只保留文件名\n                    input_image_info = f\"[本地文件: {Path(image).name}]\"\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": prompt,\n                \"input_image\": input_image_info,\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": guidance_scale, \n                    \"seed\": seed, \n                    \"response_format\": \"url\",  # 固定值\n                    \"watermark\": False,  # 固定值\n                    \"size\": \"adaptive\",  # 固定值\n                    \"model\": self._resolve_model_id(\n                        \"doubao-seededit-3-0-i2i-250628\",\n                        \"doubao-seedream-4-0-250828\",\n                        \"doubao-seedream-4-5-251128\",\n                    )  # v4/v4.5 路径统一使用 Seedream 4.x 模型\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n\n            sanitized_refs = self._sanitize_reference_assets(ref_assets)\n            result[\"parameters\"][\"reference_assets\"] = sanitized_refs\n            result[\"reference_assets\"] = sanitized_refs\n            if ref_summary.get('errors'):\n                result[\"reference_asset_errors\"] = ref_summary['errors']\n            if ref_summary.get('warnings'):\n                result[\"reference_asset_warnings\"] = ref_summary['warnings']\n            if fb and reason:\n                result[\"fallback_applied\"] = True\n                result[\"fallback_reason\"] = reason\n\n            masked_ids = self._summarize_reference_ids(sanitized_refs)\n            logger.info(\n                \"摘要|operation=i2i_reference reference_count={} ref_ids={} provider={}\",\n                len(sanitized_refs),\n                masked_ids or \"-\",\n                self._provider_used(),\n            )\n\n            # 保存到本地\n            if save_local and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n                if local_result.get('local_save_error'):\n                    self._cleanup_reference_paths(ref_paths)\n                    result[\"parameters\"][\"reference_assets\"] = []\n                    result[\"reference_assets\"] = []\n                    warnings = result.setdefault(\"reference_asset_warnings\", [])\n                    warnings.append(\"主图保存失败，参考图已回滚\")\n                    logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n            logger.success(f\"图生图任务完成: {task_id}\")\n            return result\n\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图生图API调用失败: {error_msg}\")\n            self._cleanup_reference_paths(ref_paths)\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def batch_generate_text_to_image(\n        self,\n        prompts: List[str],\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        save_local: bool = True,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成文生图（顺序执行，保持向后兼容）\n\n        Args:\n            prompts: 提示词列表\n            size: 图像尺寸\n            guidance_scale: 提示词一致性\n            save_local: 是否保存到本地\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \n        Note:\n            水印参数已固定为False，不再需要前端控制\n            如需并发执行，请使用concurrent_generate_text_to_image方法\n        \"\"\"\n        logger.info(f\"开始批量文生图，共{len(prompts)}个任务\")\n\n        results = []\n        for i, prompt in enumerate(prompts, 1):\n            logger.info(f\"处理第{i}/{len(prompts)}个任务\")\n\n            result = self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                save_local=save_local,\n                generation_id=None,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量文生图完成，成功{success_count}/{len(prompts)}个\")\n\n        return results\n\n    def concurrent_generate_text_to_image(\n        self,\n        prompt: str,\n        count: int = 4,\n        size: str = \"1024x1024\",\n        guidance_scale: float = 2.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        sequential_mode: bool = False,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张文生图\n\n        Args:\n            prompt: 图像生成提示词\n            count: 生成图片数量，默认4张，最多10张（组图模式最多15张）\n            size: 图像尺寸\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数，参数为(completed, total, result)\n            max_workers: 最大并发数\n            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\n            sequential_mode: 是否启用组图模式（Seedream 4.5）\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数（组图模式最多 15 张，普通模式最多 10 张）\n        max_allowed = 15 if sequential_mode else 10\n        if count < 1 or count > max_allowed:\n            raise ValueError(f\"生成数量必须在1-{max_allowed}之间\")\n\n        # 组图模式：单次 API 调用返回多张图\n        if sequential_mode:\n            logger.info(f\"使用组图模式生成 {count} 张图: {prompt[:50]}...\")\n            return self.generate_text_to_image(\n                prompt=prompt,\n                size=size,\n                guidance_scale=guidance_scale,\n                seed=seed,\n                save_local=save_local,\n                model_variant=model_variant,\n                generation_id=generation_id,\n                count=count,\n                sequential_mode=True,\n                derived_ids=derived_ids,\n                progress_callback=progress_callback,\n            )\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张文生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n\n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            # 为每个任务生成不同的种子（如果seed为-1）\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id,\n                'model_variant': model_variant,\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_text_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'text_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'size': size,\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发文生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def concurrent_generate_image_to_image(\n        self,\n        prompt: str,\n        image: str,\n        count: int = 4,\n        guidance_scale: float = 5.5,\n        seed: int = -1,\n        save_local: bool = True,\n        progress_callback: Optional[Callable[[int, int, Dict[str, Any]], None]] = None,\n        max_workers: int = 5,\n        derived_ids: Optional[List[str]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        并发生成多张图生图\n\n        Args:\n            prompt: 编辑提示词\n            image: 输入图像路径或URL\n            count: 生成图片数量，默认4张，最多10张\n            guidance_scale: 引导强度\n            seed: 随机种子，-1表示为每张图片生成不同的随机种子\n            save_local: 是否保存到本地\n            progress_callback: 进度回调函数\n            max_workers: 最大并发数\n\n        Returns:\n            Dict: 包含所有任务结果的字典\n        \"\"\"\n        # 验证参数\n        if count < 1 or count > 10:\n            raise ValueError(\"生成数量必须在1-10之间\")\n        \n        if max_workers > count:\n            max_workers = count\n        \n        logger.info(f\"开始并发生成{count}张图生图: {prompt[:50]}...\")\n        \n        # 生成批次ID\n        batch_id = str(uuid.uuid4())\n        start_time = time.time()\n        \n        slots = max(1, count)\n        per_ids: List[str] = list(derived_ids or [])\n        if len(per_ids) < slots:\n            base = generation_id or batch_id\n            for idx in range(len(per_ids), slots):\n                per_ids.append(f\"{base}_{idx + 1}\")\n        \n        # 准备输入图像\n        image_data = self._prepare_input_image(image)\n        if not image_data:\n            return {\n                'batch_id': batch_id,\n                'success': False,\n                'error': '无法处理输入图像',\n                'type': 'image_to_image'\n            }\n        \n        # 准备任务参数\n        tasks = []\n        for i in range(count):\n            task_seed = seed if seed != -1 else None\n            gen_id = per_ids[i] if i < len(per_ids) else None\n            tasks.append({\n                'prompt': prompt,\n                'image': image_data,\n                'guidance_scale': guidance_scale,\n                'seed': task_seed,\n                'save_local': save_local,\n                'task_index': i + 1,\n                'generation_id': gen_id\n            })\n        \n        # 使用线程池并发执行\n        results = []\n        completed_count = 0\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有任务\n            future_to_task = {\n                executor.submit(self._execute_single_image_to_image_task, task): task \n                for task in tasks\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    result['task_index'] = task['task_index']\n                    result['batch_id'] = batch_id\n                    results.append(result)\n                    \n                    completed_count += 1\n                    \n                    # 调用进度回调\n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    logger.info(f\"任务 {task['task_index']}/{count} 完成\")\n                    \n                except Exception as e:\n                    error_result = {\n                        'task_index': task['task_index'],\n                        'batch_id': batch_id,\n                        'success': False,\n                        'error': str(e),\n                        'type': 'image_to_image'\n                    }\n                    results.append(error_result)\n                    completed_count += 1\n                    \n                    if progress_callback:\n                        try:\n                            progress_callback(completed_count, count, error_result)\n                        except Exception as e:\n                            logger.warning(f\"进度回调执行失败: {e}\")\n                    \n                    # 避免在日志中显示可能包含base64数据的异常信息\n                    error_msg = str(e)\n                    if len(error_msg) > 200:\n                        error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n                    logger.error(f\"任务 {task['task_index']}/{count} 失败: {error_msg}\")\n        \n        # 按task_index排序\n        results.sort(key=lambda x: x.get('task_index', 0))\n        \n        # 统计结果\n        success_count = sum(1 for r in results if r.get('success', False))\n        total_time = time.time() - start_time\n        \n        # 处理input_image字段，避免在日志中输出大量base64数据\n        input_image_info = \"[图像数据]\"\n        if image:\n            if image.startswith(\"data:image/\"):\n                # 如果是base64数据，只保留格式信息\n                format_part = image.split(';')[0] if ';' in image else \"data:image/unknown\"\n                input_image_info = f\"{format_part};base64,[数据已隐藏]\"\n            elif image.startswith((\"http://\", \"https://\")):\n                # 如果是URL，保留URL\n                input_image_info = image\n            else:\n                # 如果是文件路径，只保留文件名\n                input_image_info = f\"[本地文件: {Path(image).name}]\"\n        \n        batch_result = {\n            'batch_id': batch_id,\n            'success': True,\n            'prompt': prompt,\n            'input_image': input_image_info,\n            'total_count': count,\n            'success_count': success_count,\n            'failed_count': count - success_count,\n            'total_time': round(total_time, 2),\n            'average_time': round(total_time / count, 2),\n            'results': results,\n            'parameters': {\n                'guidance_scale': guidance_scale,\n                'seed': seed,\n                'max_workers': max_workers\n            },\n            'derived_ids': per_ids,\n            'created_at': datetime.now().isoformat()\n        }\n        \n        logger.success(f\"并发图生图完成: {success_count}/{count} 成功，耗时 {total_time:.2f}s\")\n        return batch_result\n\n    def _execute_single_text_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个文生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        return self.generate_text_to_image(\n            prompt=task['prompt'],\n            size=task['size'],\n            guidance_scale=task['guidance_scale'],\n            seed=task['seed'],\n            save_local=task['save_local'],\n            generation_id=task.get('generation_id'),\n            model_variant=task.get('model_variant'),\n        )\n    \n    def _execute_single_image_to_image_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        执行单个图生图任务\n        \n        Args:\n            task: 任务参数字典\n            \n        Returns:\n            Dict: 任务执行结果\n        \"\"\"\n        # 生成唯一ID，优先使用外部传入的generation_id\n        task_id = task.get('generation_id') or str(uuid.uuid4())\n        \n        try:\n            # 直接使用已经处理好的图片数据，避免重复处理\n            image_data = task['image']\n            \n            # 调用API生成图像\n            api_result = self.client.image_to_image(\n                prompt=task['prompt'], \n                image=image_data, \n                guidance_scale=task['guidance_scale'], \n                seed=task['seed']\n            )\n            \n            result = {\n                \"task_id\": task_id,\n                \"success\": True,\n                \"type\": \"image_to_image\",\n                \"prompt\": task['prompt'],\n                \"image_url\": api_result[\"data\"][\"images\"][0][\"url\"],\n                \"parameters\": {\n                    \"guidance_scale\": task['guidance_scale'], \n                    \"seed\": task['seed'], \n                    \"response_format\": \"url\",\n                    \"watermark\": False,\n                    \"size\": \"adaptive\",\n                    \"model\": \"doubao-seededit-3-0-i2i-250628\"\n                },\n                \"created_at\": datetime.now().isoformat(),\n                \"usage\": api_result.get(\"usage\", {}),\n            }\n            \n            # 保存到本地\n            if task['save_local'] and result.get(\"image_url\"):\n                local_result = self._save_image_locally(result)\n                result.update(local_result)\n            \n            return result\n            \n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            return {\n                \"task_id\": task_id,\n                \"success\": False,\n                \"error\": error_msg,\n                \"type\": \"image_to_image\"\n            }\n\n    def _save_image_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存图像到本地并记录元数据\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            # 下载图像\n            image_url = result[\"image_url\"]\n            response = safe_requests_get(image_url, timeout=30)\n\n            # 先解析真实像素尺寸（以真实像素为准，避免使用size推测）\n            from io import BytesIO\n            real_w, real_h = None, None\n            try:\n                with Image.open(BytesIO(response.content)) as img:\n                    real_w, real_h = int(img.width), int(img.height)\n            except Exception as _e:\n                logger.warning(f\"无法从图像数据读取真实尺寸，回退至size参数: {_e}\")\n                real_w = self._extract_width_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n                real_h = self._extract_height_from_size(result.get(\"parameters\", {}).get(\"size\", \"1024x1024\"))\n\n            # 组装元数据（适配UnifiedStorageManager的格式）\n            params = result.get(\"parameters\", {}) or {}\n            # 若无比例信息，按真实像素计算一个 ratio 文本（约分）\n            try:\n                if not params.get('ratio') and real_w and real_h and real_w > 0 and real_h > 0:\n                    from math import gcd\n                    g = gcd(real_w, real_h)\n                    params['ratio'] = f\"{real_w//g}:{real_h//g}\"\n            except Exception:\n                pass\n\n            metadata = {\n                'generation_id': result.get(\"task_id\", \"\"),\n                'prompt': result.get(\"prompt\", \"\"),\n                'parameters': params,\n                'model': params.get(\"model\", \"seedream\"),\n                'width': real_w,\n                'height': real_h,\n                'generation_time': result.get(\"generation_time\", 0),\n                'batch_id': result.get(\"batch_id\", \"\"),\n                'status': 'completed'\n            }\n            \n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='images',\n                file_data=response.content,\n                url=image_url,\n                metadata=metadata\n            )\n\n            # 获取图像信息（再次确认像素尺寸）\n            image_info = self._get_image_info(Path(save_result['local_path']))\n            file_size = Path(save_result['local_path']).stat().st_size\n\n            logger.success(f\"图像已保存到本地: {Path(save_result['local_path']).name}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": Path(save_result['local_path']).name,\n                \"file_size\": file_size,\n                \"image_info\": image_info,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"thumbnail_path\": save_result.get('thumbnail_path'),  # 缩略图路径\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                w = image_info.get('width') if isinstance(image_info, dict) else None\n                h = image_info.get('height') if isinstance(image_info, dict) else None\n                logger.info(\n                    f\"摘要|operation=save_image status=success file={result_obj['filename']} size={file_size}B width={w} height={h}\"\n                )\n            except Exception:\n                pass\n\n            # 体验版本地图片水印（使用统一水印服务）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_image(Path(save_result['local_path']))\n                    if watermark_applied:\n                        logger.success(f\"图片水印添加成功: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = True\n                    else:\n                        logger.warning(f\"图片水印添加失败: {Path(save_result['local_path']).name}\")\n                        result_obj[\"watermark_applied\"] = False\n                except Exception as e:\n                    logger.warning(f\"添加图片水印时出错: {e}\")\n                    result_obj[\"watermark_applied\"] = False\n\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存图像到本地失败: {e}\")\n            try:\n                logger.info(\"摘要|operation=save_image status=failed\")\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        \"\"\"解析参考图来源，返回 (bytes, 扩展名, 元信息)。\"\"\"\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"引用图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        \"\"\"拷贝参考图到 references 目录并返回处理结果摘要。\"\"\"\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _build_reference_payloads(self, assets: List[Dict[str, Any]]) -> List[str]:\n        payloads: List[str] = []\n        for asset in assets or []:\n            payload = asset.get('_payload_b64')\n            if not payload:\n                continue\n            path_hint = asset.get('path') or asset.get('_source_meta', {}).get('source_path')\n            mime = 'image/png'\n            try:\n                if path_hint:\n                    suffix = Path(path_hint).suffix.lower()\n                    if suffix in {'.jpg', '.jpeg'}:\n                        mime = 'image/jpeg'\n                    elif suffix == '.webp':\n                        mime = 'image/webp'\n                    elif suffix == '.bmp':\n                        mime = 'image/bmp'\n                    elif suffix == '.gif':\n                        mime = 'image/gif'\n            except Exception:\n                pass\n            payloads.append(f\"data:{mime};base64,{payload}\")\n        return payloads\n\n    def _resolve_model_id(self, default_model: str, v4_model: str, v4_5_model: str = None) -> str:\n        provider = (self.client.last_provider() or \"\").lower()\n        if provider in {\"volc_v4_5\", \"volcengine_v4_5\"}:\n            return v4_5_model or v4_model\n        if provider in {\"volc_v4\", \"volcengine_v4\"}:\n            return v4_model\n        return default_model\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('asset_id') or rec.get('reference_id'),  # 兼容多种ID字段名\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),  # 确保有path字段\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum') or rec.get('file_hash'),  # 兼容不同的哈希字段名\n                'size': rec.get('size') or rec.get('file_size'),  # 兼容不同的大小字段名\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDREAM_PROVIDER\", \"volc_v3\")\n        except Exception:\n            return \"unknown\"\n\n    def _provider_used(self) -> str:\n        provider = self.client.last_provider() if hasattr(self.client, \"last_provider\") else None\n        if provider:\n            return provider\n        return self._provider_hint()\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _prepare_input_image(self, image_path: str) -> Optional[str]:\n        \"\"\"\n        准备输入图像，支持本地文件和URL\n        \n        Args:\n            image_path: 图像路径（本地路径或URL）\n            \n        Returns:\n            str: 图像URL、base64数据或None\n        \"\"\"\n        try:\n            # 如果是URL，直接返回\n            if image_path.startswith((\"http://\", \"https://\")):\n                return image_path\n\n            # 如果是本地文件，转换为Base64\n            local_path = Path(image_path)\n            if local_path.exists():\n                with open(local_path, \"rb\") as f:\n                    image_data = f.read()\n\n                # 检测图像格式\n                image = Image.open(local_path)\n                format_name = image.format.lower()\n\n                # 转换为Base64\n                base64_data = base64.b64encode(image_data).decode(\"utf-8\")\n                return f\"data:image/{format_name};base64,{base64_data}\"\n\n            logger.error(f\"图像文件不存在: {image_path}\")\n            return None\n\n        except Exception as e:\n            logger.error(f\"处理输入图像失败: {e}\")\n            return None\n\n    def _extract_width_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取宽度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(size.split('x')[0])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n    \n    def _extract_height_from_size(self, size: str) -> int:\n        \"\"\"\n        从尺寸字符串中提取高度\n        \n        Args:\n            size: 尺寸字符串，如 \"1024x1024\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(size.split('x')[1])\n        except (ValueError, IndexError):\n            return 1024  # 默认值\n\n    def _get_image_info(self, image_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取图像信息\n\n        Args:\n            image_path: 图像文件路径\n\n        Returns:\n            Dict: 图像信息\n        \"\"\"\n        try:\n            with Image.open(image_path) as img:\n                return {\"width\": img.width, \"height\": img.height, \"format\": img.format, \"mode\": img.mode}\n        except Exception as e:\n            logger.error(f\"获取图像信息失败: {e}\")\n            return {\"width\": 0, \"height\": 0, \"format\": \"unknown\", \"mode\": \"unknown\"}\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取图像生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('images', limit=limit)\n\n    def search_by_prompt(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据提示词关键字搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        # 获取所有历史记录并在内存中过滤\n        all_records = self.storage_manager.load_history('images', limit=1000)\n        return [record for record in all_records if keyword.lower() in record.get('prompt', '').lower()]\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            # 使用统一存储管理器获取存储统计\n            storage_stats = self.storage_manager.get_storage_stats()\n            image_stats = storage_stats.get('content_types', {}).get('images', {})\n            \n            # 获取历史记录进行详细统计\n            all_records = self.storage_manager.load_history('images', limit=1000)\n            \n            if not all_records:\n                return {\n                    \"total_images\": 0,\n                    \"text_to_image_count\": 0,\n                    \"image_to_image_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"most_common_size\": \"unknown\"\n                }\n\n            # 统计不同类型的图片数量\n            text_to_image_count = 0\n            image_to_image_count = 0\n            total_file_size = 0\n            sizes = []\n            \n            for record in all_records:\n                # 从参数中判断类型（因为新格式可能没有直接的type字段）\n                if 'input_image' in record.get('parameters', {}):\n                    image_to_image_count += 1\n                else:\n                    text_to_image_count += 1\n                \n                # 计算文件大小\n                file_size = record.get('file_size', 0)\n                if isinstance(file_size, str) and file_size.isdigit():\n                    file_size = int(file_size)\n                elif not isinstance(file_size, (int, float)):\n                    file_size = 0\n                total_file_size += file_size\n                \n                # 收集尺寸信息\n                width = record.get('width', 0)\n                height = record.get('height', 0)\n                if width and height:\n                    sizes.append(f\"{width}x{height}\")\n\n            stats = {\n                \"total_images\": len(all_records),\n                \"text_to_image_count\": text_to_image_count,\n                \"image_to_image_count\": image_to_image_count,\n                \"total_file_size\": total_file_size,\n                \"average_file_size\": total_file_size / len(all_records) if all_records else 0,\n                \"most_common_size\": \"unknown\",\n                \"creation_dates\": [record.get('created_at', '') for record in all_records[-10:]]  # 最近10次\n            }\n\n            # 最常用的尺寸\n            if sizes:\n                from collections import Counter\n                size_counts = Counter(sizes)\n                stats[\"most_common_size\"] = size_counts.most_common(1)[0][0]\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"total_images\": 0,\n                \"text_to_image_count\": 0,\n                \"image_to_image_count\": 0,\n                \"total_file_size\": 0,\n                \"average_file_size\": 0,\n                \"most_common_size\": \"unknown\"\n            }\n","numLines":1507,"startLine":1,"totalLines":1507}}}
{"parentUuid":"c7a461e9-a752-43ea-a9db-af82809be48f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011tZmfaWzd7fbn5xtA7pVEh","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我搜索 model_variant 和 model_type 是如何被处理和保存的："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16459,"cache_creation_input_tokens":46680,"cache_read_input_tokens":20430,"cache_creation":{"ephemeral_5m_input_tokens":46680,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e7a2dffd-1206-436c-a966-76694ac109b1","timestamp":"2025-12-11T08:09:33.648Z"}
{"parentUuid":"e7a2dffd-1206-436c-a966-76694ac109b1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011tZmfaWzd7fbn5xtA7pVEh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TUmv2CXUM4B1ofy2UiWhTg","name":"Grep","input":{"pattern":"model_variant|model_type.*seedance_pro","path":"/Users/yunchang/Documents/GitHub/gemeng2","type":"py","output_mode":"content","head_limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16459,"cache_creation_input_tokens":46680,"cache_read_input_tokens":20430,"cache_creation":{"ephemeral_5m_input_tokens":46680,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"08ca7a21-44f4-4df7-bf42-68772ccfe69a","timestamp":"2025-12-11T08:09:34.549Z"}
{"parentUuid":"08ca7a21-44f4-4df7-bf42-68772ccfe69a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011tZmfaWzd7fbn5xtA7pVEh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YUrp4agvAhUkqmfqp2ZTvg","name":"Grep","input":{"pattern":"_get_display_model_name","path":"/Users/yunchang/Documents/GitHub/gemeng2","type":"py","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16459,"cache_creation_input_tokens":46680,"cache_read_input_tokens":20430,"cache_creation":{"ephemeral_5m_input_tokens":46680,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"eccaa368-c567-4f9c-8cca-94987263d58c","timestamp":"2025-12-11T08:09:35.017Z"}
{"parentUuid":"eccaa368-c567-4f9c-8cca-94987263d58c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TUmv2CXUM4B1ofy2UiWhTg","type":"tool_result","content":"services/image_service.py:87:        model_variant = params.get(\"model_variant\")\nservices/image_service.py:100:                    model_variant=model_variant,\nservices/image_service.py:118:                    model_variant=model_variant,\nservices/image_service.py:156:        model_variant: Optional[str],\nservices/image_service.py:187:            model_variant=model_variant,\nservices/image_service.py:203:        model_variant: Optional[str],\nservices/image_service.py:247:                        model_variant=model_variant,\nservices/image_service.py:306:            model_variant=model_variant,\nservices/video_service.py:106:        model_variant = params.get(\"model_variant\") or \"seedance_pro\"\nservices/video_service.py:175:            model_variant=model_variant,\nservices/video_service.py:243:        model_variant: str,\nservices/video_service.py:277:            \"model_variant\": model_variant,\nmodules/seedance/manager.py:1201:        model_variant = params.get('model_variant', '')\r\nmodules/seedance/manager.py:1205:        if 'seedance_pro' in model_variant or (use_pro_model and not model_variant):\r\nmodules/seedance/manager.py:1207:        elif 'seedance_lite' in model_variant or (not use_pro_model and not model_variant):\r\nmodules/seedream/manager.py:80:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:98:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:109:        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\nmodules/seedream/manager.py:111:        # 根据 model_variant 设置环境变量\nmodules/seedream/manager.py:112:        if model_variant == 'seedream_v4':\nmodules/seedream/manager.py:114:        elif model_variant == 'seedream_v4_5':\nmodules/seedream/manager.py:550:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:565:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:585:                model_variant=model_variant,\nmodules/seedream/manager.py:623:                'model_variant': model_variant,\nmodules/seedream/manager.py:899:            model_variant=task.get('model_variant'),\narchive/refactoring_20250924/qt_app_modified.py:4871:                            model_variant=self.params.get('model_variant'),\narchive/refactoring_20250924/qt_app_modified.py:4899:                                    model_variant=self.params.get('model_variant'),\narchive/refactoring_20250924/qt_app_modified.py:6342:            'model_variant': form_values.get('model_variant') or self._image_schema_variant,\narchive/refactoring_20250924/qt_app_modified.py:7740:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\narchive/refactoring_20250924/qt_app_modified.py:7745:            use_pro_model = str(model_variant).endswith('pro')\narchive/refactoring_20250924/qt_app_modified.py:7776:            \"model_variant\": model_variant,\narchive/refactoring_20250924/qt_app_modified.py:7818:                model_variant=None,\narchive/refactoring_20250924/qt_app_modified.py:7833:                self.model_variant = model_variant\narchive/refactoring_20250924/qt_app_modified.py:7995:            model_variant=model_variant,\narchive/refactoring_20250924/qt_app_modified.py:8136:                    \"model_variant\": self.current_generation_params.get(\"model_variant\", \"seedance_pro\"),\nmodules/provider/schema.py:408:            name=\"model_variant\",\r\nmodules/provider/schema.py:486:                visible_if=[_dependency(\"model_variant\", equals=\"seedream_v4_5\")],\r\nmodules/provider/schema.py:560:        {\"name\": \"model_variant\", \"stretch\": 3, \"label_width\": 70, \"min_width\": 220},\r\nmodules/provider/schema.py:607:            meta={\"use_pro_model\": True, \"model_type\": \"pro\", \"ui_variant\": \"seedance_pro\"},\r\nmodules/provider/schema.py:613:            meta={\"use_pro_model\": True, \"model_type\": \"pro_fast\", \"ui_variant\": \"seedance_pro_fast\"},\r\nmodules/provider/schema.py:625:            name=\"model_variant\",\r\nmodules/provider/schema.py:724:        \"model_type\": \"pro_fast\" if variant == \"seedance_pro_fast\" else (\"pro\" if variant == \"seedance_pro\" else \"lite\"),\r\nmodules/provider/schema.py:732:                    {\"name\": \"model_variant\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 160},\r\narchive/refactoring_20250924/image_mode_widget.py:58:            \"model_variants\": [\"seedream-3.0\", \"seedream-4.0\"]\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4866:                            model_variant=self.params.get('model_variant'),\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4894:                                    model_variant=self.params.get('model_variant'),\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6337:            'model_variant': form_values.get('model_variant') or self._image_schema_variant,\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:7735:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:7740:            use_pro_model = str(model_variant).endswith('pro')\n\n[Showing results with pagination = limit: 50, offset: 0]"}]},"uuid":"fb15f80d-148c-418d-a4fe-64e7dcdf260c","timestamp":"2025-12-11T08:09:35.102Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"services/image_service.py:87:        model_variant = params.get(\"model_variant\")\nservices/image_service.py:100:                    model_variant=model_variant,\nservices/image_service.py:118:                    model_variant=model_variant,\nservices/image_service.py:156:        model_variant: Optional[str],\nservices/image_service.py:187:            model_variant=model_variant,\nservices/image_service.py:203:        model_variant: Optional[str],\nservices/image_service.py:247:                        model_variant=model_variant,\nservices/image_service.py:306:            model_variant=model_variant,\nservices/video_service.py:106:        model_variant = params.get(\"model_variant\") or \"seedance_pro\"\nservices/video_service.py:175:            model_variant=model_variant,\nservices/video_service.py:243:        model_variant: str,\nservices/video_service.py:277:            \"model_variant\": model_variant,\nmodules/seedance/manager.py:1201:        model_variant = params.get('model_variant', '')\r\nmodules/seedance/manager.py:1205:        if 'seedance_pro' in model_variant or (use_pro_model and not model_variant):\r\nmodules/seedance/manager.py:1207:        elif 'seedance_lite' in model_variant or (not use_pro_model and not model_variant):\r\nmodules/seedream/manager.py:80:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:98:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:109:        logger.info(f\"开始文生图任务: {prompt[:50]}... (model_variant: {model_variant})\")\nmodules/seedream/manager.py:111:        # 根据 model_variant 设置环境变量\nmodules/seedream/manager.py:112:        if model_variant == 'seedream_v4':\nmodules/seedream/manager.py:114:        elif model_variant == 'seedream_v4_5':\nmodules/seedream/manager.py:550:        model_variant: Optional[str] = None,\nmodules/seedream/manager.py:565:            model_variant: 模型变体，如 'seedream_v4' 使用 Seedream 4.0\nmodules/seedream/manager.py:585:                model_variant=model_variant,\nmodules/seedream/manager.py:623:                'model_variant': model_variant,\nmodules/seedream/manager.py:899:            model_variant=task.get('model_variant'),\narchive/refactoring_20250924/qt_app_modified.py:4871:                            model_variant=self.params.get('model_variant'),\narchive/refactoring_20250924/qt_app_modified.py:4899:                                    model_variant=self.params.get('model_variant'),\narchive/refactoring_20250924/qt_app_modified.py:6342:            'model_variant': form_values.get('model_variant') or self._image_schema_variant,\narchive/refactoring_20250924/qt_app_modified.py:7740:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\narchive/refactoring_20250924/qt_app_modified.py:7745:            use_pro_model = str(model_variant).endswith('pro')\narchive/refactoring_20250924/qt_app_modified.py:7776:            \"model_variant\": model_variant,\narchive/refactoring_20250924/qt_app_modified.py:7818:                model_variant=None,\narchive/refactoring_20250924/qt_app_modified.py:7833:                self.model_variant = model_variant\narchive/refactoring_20250924/qt_app_modified.py:7995:            model_variant=model_variant,\narchive/refactoring_20250924/qt_app_modified.py:8136:                    \"model_variant\": self.current_generation_params.get(\"model_variant\", \"seedance_pro\"),\nmodules/provider/schema.py:408:            name=\"model_variant\",\r\nmodules/provider/schema.py:486:                visible_if=[_dependency(\"model_variant\", equals=\"seedream_v4_5\")],\r\nmodules/provider/schema.py:560:        {\"name\": \"model_variant\", \"stretch\": 3, \"label_width\": 70, \"min_width\": 220},\r\nmodules/provider/schema.py:607:            meta={\"use_pro_model\": True, \"model_type\": \"pro\", \"ui_variant\": \"seedance_pro\"},\r\nmodules/provider/schema.py:613:            meta={\"use_pro_model\": True, \"model_type\": \"pro_fast\", \"ui_variant\": \"seedance_pro_fast\"},\r\nmodules/provider/schema.py:625:            name=\"model_variant\",\r\nmodules/provider/schema.py:724:        \"model_type\": \"pro_fast\" if variant == \"seedance_pro_fast\" else (\"pro\" if variant == \"seedance_pro\" else \"lite\"),\r\nmodules/provider/schema.py:732:                    {\"name\": \"model_variant\", \"stretch\": 2, \"label_width\": 70, \"min_width\": 160},\r\narchive/refactoring_20250924/image_mode_widget.py:58:            \"model_variants\": [\"seedream-3.0\", \"seedream-4.0\"]\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4866:                            model_variant=self.params.get('model_variant'),\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4894:                                    model_variant=self.params.get('model_variant'),\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:6337:            'model_variant': form_values.get('model_variant') or self._image_schema_variant,\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:7735:        model_variant = form_values.get('model_variant') or self._video_schema_variant or 'seedance_pro'\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:7740:            use_pro_model = str(model_variant).endswith('pro')","numLines":50,"appliedLimit":50}}
{"parentUuid":"fb15f80d-148c-418d-a4fe-64e7dcdf260c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YUrp4agvAhUkqmfqp2ZTvg","type":"tool_result","content":"modules/seedance/manager.py:660:                'model': self._get_display_model_name(result),\r\nmodules/seedance/manager.py:1197:    def _get_display_model_name(self, result: Dict[str, Any]) -> str:"}]},"uuid":"64e3b0c2-42dc-4577-a3b3-e9a59a261611","timestamp":"2025-12-11T08:09:35.103Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"modules/seedance/manager.py:660:                'model': self._get_display_model_name(result),\r\nmodules/seedance/manager.py:1197:    def _get_display_model_name(self, result: Dict[str, Any]) -> str:","numLines":2}}
{"parentUuid":"64e3b0c2-42dc-4577-a3b3-e9a59a261611","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01CuQhRgZgs7roo7ELGJwBJt","type":"message","role":"assistant","content":[{"type":"text","text":"让我查看详情页面读取模型信息的位置："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":18718,"cache_read_input_tokens":67110,"cache_creation":{"ephemeral_5m_input_tokens":18718,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"fc9e6bef-e9ce-4001-81d0-788164d32b5a","timestamp":"2025-12-11T08:09:39.815Z"}
{"parentUuid":"fc9e6bef-e9ce-4001-81d0-788164d32b5a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01CuQhRgZgs7roo7ELGJwBJt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019QSfLKBVjct4qLVV3JaZVW","name":"Grep","input":{"pattern":"parameters.*model|display.*model|详情|detail","path":"/Users/yunchang/Documents/GitHub/gemeng2","type":"py","output_mode":"files_with_matches","head_limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":18718,"cache_read_input_tokens":67110,"cache_creation":{"ephemeral_5m_input_tokens":18718,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"2578347c-1086-4f5a-938a-503e133b134e","timestamp":"2025-12-11T08:09:40.952Z"}
{"parentUuid":"2578347c-1086-4f5a-938a-503e133b134e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01CuQhRgZgs7roo7ELGJwBJt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017BGCs5Ag5pLxVEZZBFJKDW","name":"Glob","input":{"pattern":"**/{detail*,*detail*}.{py,tsx,jsx}","path":"/Users/yunchang/Documents/GitHub/gemeng2"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":18718,"cache_read_input_tokens":67110,"cache_creation":{"ephemeral_5m_input_tokens":18718,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f9d3110c-331a-4125-bf03-5fd6b89b260f","timestamp":"2025-12-11T08:09:41.396Z"}
{"parentUuid":"f9d3110c-331a-4125-bf03-5fd6b89b260f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019QSfLKBVjct4qLVV3JaZVW","type":"tool_result","content":"Found 20 files limit: 20, offset: 0\nmodules/seedance/manager.py\nservices/video_service.py\ncomponents/modes/video_mode_widget.py\nmodules/seedance/client.py\nmodules/seedream/client.py\ncomponents/modes/image_mode_widget.py\nservices/image_service.py\ncomponents/views/image_history_view.py\nmodules/storage/unified_storage_manager_v2.py\ncomponents/views/video_history_view.py\nutils/ui_utils.py\nutils/reference_display.py\nutils/image_format_validator.py\nutils/error_handler.py\ntools/style_migration_tool.py\ntools/storage_migration.py\ntools/final_fixes_summary.py\ntools/diagnose_video_reference_panel.py\ntools/diagnose_reference_display_issue.py\ntools/diagnose_parameter_panel_spacing.py"}]},"uuid":"5c2cbffb-8c6a-4362-b0e3-f290ffad9c3d","timestamp":"2025-12-11T08:09:41.474Z","toolUseResult":{"mode":"files_with_matches","filenames":["modules/seedance/manager.py","services/video_service.py","components/modes/video_mode_widget.py","modules/seedance/client.py","modules/seedream/client.py","components/modes/image_mode_widget.py","services/image_service.py","components/views/image_history_view.py","modules/storage/unified_storage_manager_v2.py","components/views/video_history_view.py","utils/ui_utils.py","utils/reference_display.py","utils/image_format_validator.py","utils/error_handler.py","tools/style_migration_tool.py","tools/storage_migration.py","tools/final_fixes_summary.py","tools/diagnose_video_reference_panel.py","tools/diagnose_reference_display_issue.py","tools/diagnose_parameter_panel_spacing.py"],"numFiles":20,"appliedLimit":20}}
{"parentUuid":"5c2cbffb-8c6a-4362-b0e3-f290ffad9c3d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017BGCs5Ag5pLxVEZZBFJKDW","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py\n/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py\n/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_detail_dialog_issue.py"}]},"uuid":"4a128ce2-5bf6-4495-b9c5-1e7560ea9450","timestamp":"2025-12-11T08:09:41.493Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py","/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py","/Users/yunchang/Documents/GitHub/gemeng2/tools/diagnose_detail_dialog_issue.py"],"durationMs":38,"numFiles":3,"truncated":false}}
{"parentUuid":"4a128ce2-5bf6-4495-b9c5-1e7560ea9450","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01P5RedeQrehL9TzXFMZbuZT","type":"message","role":"assistant","content":[{"type":"text","text":"完美！现在让我读取详情页面的代码："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":999,"cache_read_input_tokens":85828,"cache_creation":{"ephemeral_5m_input_tokens":999,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"5ccbb8dd-8676-4aaa-b97c-0c7264cd302a","timestamp":"2025-12-11T08:09:47.225Z"}
{"parentUuid":"5ccbb8dd-8676-4aaa-b97c-0c7264cd302a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01P5RedeQrehL9TzXFMZbuZT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UNNsp2nUTsvh318MgnN3zo","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":999,"cache_read_input_tokens":85828,"cache_creation":{"ephemeral_5m_input_tokens":999,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"52c0517e-dacf-4784-81f6-7848dbcdcaf8","timestamp":"2025-12-11T08:09:47.664Z"}
{"parentUuid":"52c0517e-dacf-4784-81f6-7848dbcdcaf8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01P5RedeQrehL9TzXFMZbuZT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N8SENEjUUR1jUwQGC2kGoG","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":999,"cache_read_input_tokens":85828,"cache_creation":{"ephemeral_5m_input_tokens":999,"ephemeral_1h_input_tokens":0},"output_tokens":159,"service_tier":"standard"}},"type":"assistant","uuid":"406f76b3-36de-4f4f-9e72-7d21d35b9113","timestamp":"2025-12-11T08:09:47.873Z"}
{"parentUuid":"406f76b3-36de-4f4f-9e72-7d21d35b9113","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UNNsp2nUTsvh318MgnN3zo","type":"tool_result","content":"     1→import os\n     2→import json\n     3→from pathlib import Path\n     4→from datetime import datetime\n     5→from typing import Dict, Any, List, Optional\n     6→\n     7→from PyQt5.QtWidgets import (\n     8→    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n     9→    QTextEdit, QFileDialog, QMessageBox, QStackedWidget, QSplitter,\n    10→    QApplication, QShortcut\n    11→)\n    12→from PyQt5.QtCore import Qt, QTimer, QUrl, QSize, QEvent\n    13→from PyQt5.QtGui import QPixmap, QFont, QKeySequence, QPainter, QImage\n    14→from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent\n    15→from PyQt5.QtMultimediaWidgets import QVideoWidget\n    16→\n    17→# OpenCV条件导入\n    18→try:\n    19→    import cv2\n    20→    OPENCV_AVAILABLE = True\n    21→except Exception:\n    22→    cv2 = None\n    23→    OPENCV_AVAILABLE = False\n    24→\n    25→from utils.logger import logger\n    26→from components.reference_assets import (\n    27→    ReferenceGalleryWidget,\n    28→    export_reference_asset,\n    29→    open_reference_preview,\n    30→    _find_reference_asset_index,\n    31→)\n    32→from components.controllers import ExportBundleController\n    33→from utils.reference_display import (\n    34→    build_resolution_text,\n    35→    ensure_reference_info,\n    36→    get_model_display_name,\n    37→    pick_model_code,\n    38→    resolve_reference_assets,\n    39→)\n    40→\n    41→class VideoDetailDialog(QDialog):\n    42→    \"\"\"视频详细信息对话框\"\"\"\n    43→    \n    44→    def __init__(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n    45→        super().__init__(parent)\n    46→        self.video_data = video_data\n    47→        self.video_list = video_list or [video_data]  # 视频列表\n    48→        self.current_index = current_index  # 当前视频索引\n    49→        self.is_fullscreen = False  # 全屏状态\n    50→        self.original_geometry = None  # 原始窗口几何\n    51→        self.param_value_labels = {}  # 存储参数值标签的引用\n    52→        self._reference_summary = ensure_reference_info(self.video_data)\n    53→        self._reference_assets: List[Dict[str, Any]] = []\n    54→        self._export_controller = ExportBundleController(self, \"video\")\n    55→        self.setup_ui()\n    56→        \n    57→    def setup_ui(self):\n    58→        \"\"\"设置UI\"\"\"\n    59→        self.setWindowTitle(\"视频详细信息\")\n    60→        self.resize(1100, 800)  # 改为可调整大小\n    61→        self.setMinimumSize(800, 600)  # 设置最小尺寸\n    62→        \n    63→        # 设置焦点策略，确保能接收键盘事件\n    64→        self.setFocusPolicy(Qt.StrongFocus)\n    65→        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n    66→        self.setFocus()\n    67→\n    68→        # 确保窗口激活时获得焦点\n    69→        self.activateWindow()\n    70→        self.raise_()\n    71→\n    72→        try:\n    73→            self.setObjectName(\"DetailDialog\")\n    74→        except Exception:\n    75→            pass\n    76→\n    77→        self._focus_timer = QTimer(self)\n    78→        self._focus_timer.setSingleShot(True)\n    79→        self._focus_timer.timeout.connect(self._ensure_focus)\n    80→\n    81→        layout = QHBoxLayout(self)\n    82→        \n    83→        # 左侧：视频播放器（占70%宽度）\n    84→        left_widget = QWidget()\n    85→        left_layout = QVBoxLayout(left_widget)\n    86→        left_layout.setContentsMargins(0, 0, 0, 0)\n    87→        \n    88→        # 视频播放区域\n    89→        video_container = QWidget()\n    90→        video_container.setObjectName(\"VideoContainer\")\n    91→        \n    92→        container_layout = QVBoxLayout(video_container)\n    93→        container_layout.setContentsMargins(0, 0, 0, 0)\n    94→        \n    95→        # 创建堆叠布局，用于缩略图和视频播放器的切换\n    96→        from PyQt5.QtWidgets import QStackedWidget\n    97→        self.video_stack = QStackedWidget()\n    98→        \n    99→        # 缩略图页面\n   100→        self.thumbnail_widget = QWidget()\n   101→        self.thumbnail_widget.setObjectName(\"ThumbnailWidget\")\n   102→        thumbnail_layout = QVBoxLayout(self.thumbnail_widget)\n   103→        thumbnail_layout.setContentsMargins(0, 0, 0, 0)\n   104→        thumbnail_layout.setAlignment(Qt.AlignCenter)\n   105→        \n   106→        # 缩略图标签\n   107→        self.thumbnail_label = QLabel()\n   108→        self.thumbnail_label.setAlignment(Qt.AlignCenter)\n   109→        self.thumbnail_label.setStyleSheet(\"\"\"\n   110→            QLabel {\n   111→                border: none;\n   112→                background-color: #000000;\n   113→                color: #ffffff;\n   114→            }\n   115→        \"\"\")\n   116→        self.thumbnail_label.setMinimumSize(400, 300)\n   117→        # 不使用setScaledContents，改为手动缩放\n   118→        # self.thumbnail_label.setScaledContents(True)\n   119→        \n   120→        # 播放按钮覆盖层\n   121→        self.play_overlay = QLabel(\"▶\")\n   122→        self.play_overlay.setAlignment(Qt.AlignCenter)\n   123→        self.play_overlay.setObjectName(\"PlayOverlay\")\n   124→        \n   125→        # 创建缩略图容器，使用相对定位\n   126→        thumbnail_container = QWidget()\n   127→        thumbnail_container.setStyleSheet(\"border: none; background-color: #000000;\")\n   128→        # 设置固定尺寸确保容器有正确的大小\n   129→        thumbnail_container.setFixedSize(640, 480)\n   130→        \n   131→        # 使用绝对定位放置播放按钮\n   132→        def setup_thumbnail_layout():\n   133→            self.thumbnail_label.setParent(thumbnail_container)\n   134→            self.play_overlay.setParent(thumbnail_container)\n   135→            \n   136→            # 确保标签可见\n   137→            self.thumbnail_label.show()\n   138→            self.play_overlay.show()\n   139→            \n   140→            def resize_thumbnail_container():\n   141→                if hasattr(self, 'thumbnail_label') and hasattr(self, 'play_overlay'):\n   142→                    container_size = thumbnail_container.size()\n   143→                    logger.debug(f\"[UI] 详情缩略图容器尺寸: {container_size}\")\n   144→                    \n   145→                    # 设置缩略图标签尺寸和位置\n   146→                    self.thumbnail_label.setGeometry(0, 0, container_size.width(), container_size.height())\n   147→                    \n   148→                    # 播放按钮居中\n   149→                    overlay_x = max(0, (container_size.width() - 70) // 2)\n   150→                    overlay_y = max(0, (container_size.height() - 70) // 2)\n   151→                    self.play_overlay.setGeometry(overlay_x, overlay_y, 70, 70)\n   152→                    \n   153→                    logger.debug(f\"[UI] 缩略图标签位置: {self.thumbnail_label.geometry()}\")\n   154→                    logger.debug(f\"[UI] 播放按钮位置: {self.play_overlay.geometry()}\")\n   155→            \n   156→            def handle_resize_event(event):\n   157→                resize_thumbnail_container()\n   158→                QWidget.resizeEvent(thumbnail_container, event)\n   159→            \n   160→            thumbnail_container.resizeEvent = handle_resize_event\n   161→            \n   162→            # 立即调用布局函数\n   163→            resize_thumbnail_container()\n   164→        \n   165→        setup_thumbnail_layout()\n   166→        \n   167→        # 点击事件\n   168→        self.thumbnail_label.mousePressEvent = self.on_thumbnail_click\n   169→        self.play_overlay.mousePressEvent = self.on_thumbnail_click\n   170→        \n   171→        thumbnail_layout.addWidget(thumbnail_container)\n   172→        \n   173→        # 视频播放器页面\n   174→        self.video_widget = QVideoWidget()\n   175→        self.video_widget.setObjectName(\"VideoWidget\")\n   176→        \n   177→        # OpenCV视频播放器页面（备选方案）\n   178→        self.opencv_video_label = QLabel()\n   179→        self.opencv_video_label.setObjectName(\"OpenCVVideoLabel\")\n   180→        self.opencv_video_label.setAlignment(Qt.AlignCenter)\n   181→        self.opencv_video_label.setMinimumSize(640, 480)\n   182→        \n   183→        # 创建视频播放器\n   184→        logger.debug(\"[UI] 创建QMediaPlayer…\")\n   185→        self.media_player = QMediaPlayer(None, QMediaPlayer.VideoSurface)\n   186→        logger.debug(\"[UI] QMediaPlayer创建完成\")\n   187→        \n   188→        # 设置视频输出\n   189→        logger.debug(\"[UI] 设置视频输出…\")\n   190→        self.media_player.setVideoOutput(self.video_widget)\n   191→        logger.debug(\"[UI] 视频输出设置完成\")\n   192→        \n   193→        # OpenCV播放器变量\n   194→        self.cv_cap = None\n   195→        self.cv_timer = QTimer()\n   196→        self.cv_timer.timeout.connect(self.update_opencv_frame)\n   197→        self.is_using_opencv = False\n   198→        \n   199→        # 添加错误处理\n   200→        self.media_player.error.connect(self.on_media_error)\n   201→        logger.debug(\"[UI] 媒体错误处理连接完成\")\n   202→        \n   203→        # 添加状态监听\n   204→        self.media_player.stateChanged.connect(self.on_state_changed)\n   205→        self.media_player.positionChanged.connect(self.on_position_changed)\n   206→        self.media_player.durationChanged.connect(self.on_duration_changed)\n   207→        self.media_player.mediaStatusChanged.connect(self.on_media_status_changed)\n   208→        logger.debug(\"[UI] 媒体状态监听连接完成\")\n   209→        \n   210→        # 添加到堆叠布局\n   211→        self.video_stack.addWidget(self.thumbnail_widget)  # 索引0：缩略图\n   212→        self.video_stack.addWidget(self.video_widget)      # 索引1：Qt视频播放器\n   213→        self.video_stack.addWidget(self.opencv_video_label) # 索引2：OpenCV视频播放器\n   214→        \n   215→        # 默认显示缩略图\n   216→        self.video_stack.setCurrentIndex(0)\n   217→        self.is_playing = False\n   218→        \n   219→        # 加载视频和缩略图\n   220→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   221→        if video_path and os.path.exists(video_path):\n   222→            from PyQt5.QtCore import QUrl\n   223→            self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(video_path)))\n   224→            self.load_thumbnail()\n   225→        \n   226→        container_layout.addWidget(self.video_stack)\n   227→        \n   228→        # 视频区域占据所有可用空间\n   229→        left_splitter = QSplitter(Qt.Vertical)\n   230→        left_splitter.addWidget(video_container)\n   231→\n   232→        self.reference_gallery = ReferenceGalleryWidget()\n   233→        try:\n   234→            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n   235→            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n   236→            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n   237→        except Exception:\n   238→            pass\n   239→        # 参考图区域容器，包含画廊与操作按钮\n   240→        reference_section = QWidget()\n   241→        reference_section_layout = QVBoxLayout(reference_section)\n   242→        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n   243→        reference_section_layout.setSpacing(6)\n   244→        reference_section_layout.addWidget(self.reference_gallery)\n   245→        # 将左侧分割器先加入主布局（第二块稍后补充按钮区后再添加）\n   246→        # 注意：最终会把 reference_section 放入分割器\n   247→\n   248→        reference_button_layout = QHBoxLayout()\n   249→        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n   250→        reference_button_layout.setSpacing(6)\n   251→        self.export_status_label = QLabel(\"\")\n   252→        self.export_status_label.setStyleSheet(\"color: #bbbbbb; ;\")\n   253→        reference_button_layout.addWidget(self.export_status_label)\n   254→        reference_button_layout.addStretch(1)\n   255→        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n   256→        self.reference_export_btn.setEnabled(False)\n   257→        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n   258→        reference_button_layout.addWidget(self.reference_export_btn)\n   259→        self.export_bundle_btn = QPushButton(\"导出记录\")\n   260→        self.export_bundle_btn.setEnabled(False)\n   261→        self._export_controller.configure(\n   262→            self.export_bundle_btn,\n   263→            self.export_status_label,\n   264→            self._resolve_video_record_id,\n   265→            context_widget=self,\n   266→        )\n   267→        reference_button_layout.addWidget(self.export_bundle_btn)\n   268→        reference_section_layout.addLayout(reference_button_layout)\n   269→        # 将参考图区域加入分割器，并把分割器加入左侧布局\n   270→        left_splitter.addWidget(reference_section)\n   271→        try:\n   272→            left_splitter.setStretchFactor(0, 3)\n   273→            left_splitter.setStretchFactor(1, 2)\n   274→            left_splitter.setSizes([520, 280])\n   275→        except Exception:\n   276→            pass\n   277→        left_layout.addWidget(left_splitter, 1)\n   278→\n   279→        # 底部控制区域\n   280→        controls_layout = QHBoxLayout()\n   281→        controls_layout.setContentsMargins(0, 5, 0, 5)\n   282→        controls_layout.setSpacing(10)\n   283→        \n   284→        # 播放/暂停按钮\n   285→        self.play_button = QPushButton(\"▶\")\n   286→        self.play_button.setFixedSize(40, 30)\n   287→        self.play_button.setObjectName(\"PlayButton\")\n   288→        self.play_button.clicked.connect(self.toggle_play_pause)\n   289→        controls_layout.addWidget(self.play_button)\n   290→        \n   291→        # 进度条（简单的标签显示）\n   292→        self.progress_label = QLabel(\"00:00 / 00:00\")\n   293→        self.progress_label.setObjectName(\"ProgressLabel\")\n   294→        controls_layout.addWidget(self.progress_label, 1)\n   295→        \n   296→        # 音量控制\n   297→        volume_label = QLabel(\"🔊\")\n   298→        volume_label.setStyleSheet(\"color: #cccccc; ;\")\n   299→        controls_layout.addWidget(volume_label)\n   300→        \n   301→        # 导航按钮\n   302→        self.prev_btn = QPushButton(\"◀\")\n   303→        self.prev_btn.setFixedSize(30, 30)\n   304→        self.prev_btn.setObjectName(\"NavButton\")\n   305→        self.prev_btn.clicked.connect(self.show_previous_video)\n   306→        controls_layout.addWidget(self.prev_btn)\n   307→        \n   308→        self.next_btn = QPushButton(\"▶\")\n   309→        self.next_btn.setFixedSize(30, 30)\n   310→        self.next_btn.setObjectName(\"NavButton\")\n   311→        self.next_btn.clicked.connect(self.show_next_video)\n   312→        controls_layout.addWidget(self.next_btn)\n   313→        \n   314→        left_layout.addLayout(controls_layout)\n   315→\n   316→        # 更新导航按钮状态\n   317→        self.update_navigation_buttons()\n   318→        self._refresh_reference_gallery()\n   319→        self._export_controller.refresh()\n   320→\n   321→        # 右侧：详细信息（固定30%宽度）\n   322→        right_layout = QVBoxLayout()\n   323→        \n   324→        # 创建参数显示区域\n   325→        params_widget = QWidget()\n   326→        params_widget.setFixedWidth(int(self.width() * 0.3))\n   327→        params_widget.setObjectName(\"ParamsWidget\")\n   328→        params_layout = QVBoxLayout(params_widget)\n   329→        params_layout.setSpacing(0)\n   330→        params_layout.setContentsMargins(5, 5, 5, 5)\n   331→        \n   332→        # 解析生成参数\n   333→        params = self.video_data.get('parameters', '{}')\n   334→        if isinstance(params, str):\n   335→            try:\n   336→                params = json.loads(params)\n   337→            except:\n   338→                params = {}\n   339→        \n   340→        # 提示词区域\n   341→        prompt_label = QLabel(\"<b>提示词:</b>\")\n   342→        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n   343→        params_layout.addWidget(prompt_label)\n   344→        \n   345→        # 提示词文本框\n   346→        prompt_content = self.video_data.get('prompt', '无提示词')\n   347→        self.prompt_text_edit = QTextEdit()\n   348→        self.prompt_text_edit.setPlainText(prompt_content)\n   349→        self.prompt_text_edit.setReadOnly(True)\n   350→        self.prompt_text_edit.setMaximumHeight(120)\n   351→        self.prompt_text_edit.setMinimumHeight(120)\n   352→        self.prompt_text_edit.setStyleSheet(\"\"\"\n   353→            QTextEdit {\n   354→                background-color: #2a2a3e;\n   355→                color: #ffffff;\n   356→                border: 1px solid #555;\n   357→                border-radius: 4px;\n   358→                padding: 8px;\n   359→                margin: 0px;\n   360→                ;\n   361→                line-height: 1.4;\n   362→            }\n   363→        \"\"\")\n   364→        params_layout.addWidget(self.prompt_text_edit)\n   365→        \n   366→        # 复制提示词按钮\n   367→        copy_prompt_btn = QPushButton(\"复制提示词\")\n   368→        copy_prompt_btn.setMaximumHeight(30)\n   369→        copy_prompt_btn.clicked.connect(self.copy_prompt)\n   370→        params_layout.addWidget(copy_prompt_btn)\n   371→        \n   372→        # 详细信息 - 保存标签引用以便后续更新\n   373→        self.param_labels = {}  # 存储参数值标签的引用\n   374→        \n   375→        info_items = [\n   376→            (\"分辨率\", build_resolution_text(self.video_data)),\n   377→            (\"时长\", f\"{self.video_data.get('duration', '未知')}秒\"),\n   378→            (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n   379→            (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n   380→            (\"文件大小\", self.format_file_size(self.video_data.get('file_size', 0))),\n   381→            (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n   382→        ]\n   383→        \n   384→        for label, value in info_items:\n   385→            label_widget = QLabel(f\"<b>{label}:</b>\")\n   386→            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n   387→            params_layout.addWidget(label_widget)\n   388→            \n   389→            value_label = QLabel(str(value))\n   390→            value_label.setWordWrap(True)\n   391→            value_label.setStyleSheet(\"\"\"\n   392→                QLabel {\n   393→                    margin: 0px;\n   394→                    padding: 6px;\n   395→                    background-color: #2a2a3e;\n   396→                    color: #ffffff;\n   397→                    border: 1px solid #555;\n   398→                    border-radius: 4px;\n   399→                    ;\n   400→                    min-height: 20px;\n   401→                }\n   402→            \"\"\")\n   403→            params_layout.addWidget(value_label)\n   404→            \n   405→            # 保存参数值标签引用，用于后续更新\n   406→            self.param_value_labels[label] = value_label\n   407→        \n   408→        right_layout.addWidget(params_widget)\n   409→        \n   410→        # 控制按钮\n   411→        button_layout = QHBoxLayout()\n   412→        \n   413→        fullscreen_btn = QPushButton(\"全屏 (F11)\")\n   414→        fullscreen_btn.setMaximumHeight(30)\n   415→        fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n   416→        button_layout.addWidget(fullscreen_btn)\n   417→        \n   418→        download_btn = QPushButton(\"下载视频\")\n   419→        download_btn.setMaximumHeight(30)\n   420→        download_btn.clicked.connect(self.download_video)\n   421→        button_layout.addWidget(download_btn)\n   422→        \n   423→        right_layout.addLayout(button_layout)\n   424→        \n   425→        close_btn = QPushButton(\"关闭（ESC）\")\n   426→        close_btn.clicked.connect(self.accept)\n   427→        right_layout.addWidget(close_btn)\n   428→        \n   429→        # 设置布局比例：左侧70%，右侧30%\n   430→        layout.addWidget(left_widget, 7)\n   431→        layout.addLayout(right_layout, 3)\n   432→        \n   433→        # 添加键盘快捷键\n   434→        self.setup_shortcuts()\n   435→\n   436→        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n   437→        self._focus_timer.start(100)\n   438→\n   439→        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n   440→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   441→        \n   442→        # 连接媒体播放器信号\n   443→        self.media_player.stateChanged.connect(self.on_state_changed)\n   444→        self.media_player.positionChanged.connect(self.on_position_changed)\n   445→        self.media_player.durationChanged.connect(self.on_duration_changed)\n   446→        self.media_player.mediaStatusChanged.connect(self.on_media_status_changed)\n   447→    \n   448→    def load_thumbnail(self):\n   449→        \"\"\"加载视频缩略图\"\"\"\n   450→        import os  # 将os导入移到函数开头\n   451→        try:\n   452→            logger.debug(\"开始加载缩略图...\")\n   453→            logger.debug(f\"视频数据: {self.video_data}\")\n   454→            \n   455→            # 获取缩略图路径\n   456→            thumbnail_path = self.video_data.get('thumbnail_local_path', '')\n   457→            logger.debug(f\"从video_data获取的thumbnail_local_path: {thumbnail_path}\")\n   458→            \n   459→            if thumbnail_path and os.path.exists(thumbnail_path):\n   460→                logger.debug(f\"找到现有缩略图文件: {thumbnail_path}\")\n   461→                # 使用现有缩略图\n   462→                pixmap = QPixmap(thumbnail_path)\n   463→                logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n   464→            else:\n   465→                logger.debug(\"缩略图文件不存在或路径为空，开始生成缩略图...\")\n   466→                # 生成缩略图\n   467→                video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   468→                logger.debug(f\"视频文件路径: {video_path}\")\n   469→                \n   470→                if video_path and os.path.exists(video_path):\n   471→                    logger.debug(\"视频文件存在，开始生成缩略图...\")\n   472→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   473→                    from config.app_config import get_storage_dir\n   474→                    storage_dir = get_storage_dir()\n   475→                    thumbnails_dir = os.path.join(storage_dir, 'thumbnails')\n   476→                    logger.debug(f\"缩略图目录: {thumbnails_dir}\")\n   477→                    \n   478→                    generator = VideoThumbnailGenerator(thumbnails_dir)\n   479→                    video_id = self.video_data.get('id', os.path.basename(video_path).split('.')[0])\n   480→                    logger.debug(f\"视频ID: {video_id}\")\n   481→                    \n   482→                    thumbnail_path = generator.generate_thumbnail_for_video(video_path, video_id)\n   483→                    logger.debug(f\"生成的缩略图路径: {thumbnail_path}\")\n   484→                    \n   485→                    if thumbnail_path and os.path.exists(thumbnail_path):\n   486→                        logger.debug(\"缩略图生成成功，加载到QPixmap...\")\n   487→                        pixmap = QPixmap(thumbnail_path)\n   488→                        logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n   489→                    else:\n   490→                        logger.debug(\"缩略图生成失败，使用默认图片\")\n   491→                        # 使用默认图片\n   492→                        pixmap = self.create_default_thumbnail()\n   493→                else:\n   494→                    logger.debug(\"视频文件不存在，使用默认图片\")\n   495→                    pixmap = self.create_default_thumbnail()\n   496→            \n   497→            if not pixmap.isNull():\n   498→                logger.debug(\"开始缩放图片...\")\n   499→                # 缩放图片以适应标签大小\n   500→                label_size = self.thumbnail_label.size()\n   501→                logger.debug(f\"标签大小: {label_size}\")\n   502→                \n   503→                scaled_pixmap = pixmap.scaled(\n   504→                    label_size,\n   505→                    Qt.KeepAspectRatio,\n   506→                    Qt.SmoothTransformation\n   507→                )\n   508→                logger.debug(f\"缩放后图片大小: {scaled_pixmap.size()}\")\n   509→                \n   510→                self.thumbnail_label.setPixmap(scaled_pixmap)\n   511→                logger.debug(\"缩略图设置成功\")\n   512→            else:\n   513→                logger.debug(\"QPixmap为空，显示错误文本\")\n   514→                self.thumbnail_label.setText(\"无法加载缩略图\")\n   515→                \n   516→        except Exception as e:\n   517→            logger.debug(f\"加载缩略图异常: {e}\")\n   518→            import traceback\n   519→            traceback.print_exc()\n   520→            self.thumbnail_label.setText(\"缩略图加载失败\")\n   521→    \n   522→    def create_default_thumbnail(self):\n   523→        \"\"\"创建默认缩略图\"\"\"\n   524→        pixmap = QPixmap(400, 300)\n   525→        pixmap.fill(Qt.black)\n   526→        \n   527→        from PyQt5.QtGui import QPainter, QFont\n   528→        painter = QPainter(pixmap)\n   529→        painter.setPen(Qt.white)\n   530→        painter.setFont(QFont())  # Font configuration handled by unified style system\n   531→        painter.drawText(pixmap.rect(), Qt.AlignCenter, \"视频预览\")\n   532→        painter.end()\n   533→        \n   534→        return pixmap\n   535→    \n   536→    def on_thumbnail_click(self, event):\n   537→        \"\"\"缩略图点击事件\"\"\"\n   538→        self.start_video_playback()\n   539→    \n   540→    def start_video_playback(self):\n   541→        \"\"\"开始视频播放\"\"\"\n   542→        logger.debug(\"[UI] 开始视频播放…\")\n   543→        \n   544→        # 检查视频文件\n   545→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   546→        logger.debug(f\"[UI] 视频文件路径: {video_path}\")\n   547→        \n   548→        if not video_path or not os.path.exists(video_path):\n   549→            logger.warning(f\"[UI] 视频文件不存在: {video_path}\")\n   550→            from PyQt5.QtWidgets import QMessageBox\n   551→            QMessageBox.critical(self, \"错误\", \"视频文件不存在\")\n   552→            return\n   553→        \n   554→        # 切换到视频播放器\n   555→        logger.debug(\"[UI] 切换到视频播放器\")\n   556→        self.video_stack.setCurrentIndex(1)\n   557→        self.is_playing = True\n   558→        \n   559→        # 重新设置媒体内容\n   560→        from PyQt5.QtCore import QUrl\n   561→        from PyQt5.QtMultimedia import QMediaContent\n   562→        logger.debug(\"[UI] 重新设置媒体内容\")\n   563→        self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(video_path)))\n   564→        \n   565→        # 开始播放\n   566→        logger.debug(\"[UI] 开始播放视频\")\n   567→        self.media_player.play()\n   568→    \n   569→    def toggle_play_pause(self):\n   570→        \"\"\"切换播放/暂停\"\"\"\n   571→        if not self.is_playing:\n   572→            # 如果还在缩略图模式，开始播放\n   573→            self.start_video_playback()\n   574→        else:\n   575→            # 在播放模式下切换播放/暂停\n   576→            if self.is_using_opencv:\n   577→                # OpenCV播放器暂停/继续\n   578→                if self.cv_timer.isActive():\n   579→                    self.cv_timer.stop()\n   580→                    self.play_button.setText(\"▶\")\n   581→                else:\n   582→                    # 重新启动定时器\n   583→                    fps = self.cv_cap.get(cv2.CAP_PROP_FPS) if self.cv_cap else 30\n   584→                    if fps <= 0:\n   585→                        fps = 30\n   586→                    interval = int(1000 / fps)\n   587→                    self.cv_timer.start(interval)\n   588→                    self.play_button.setText(\"⏸\")\n   589→            else:\n   590→                # Qt播放器暂停/继续\n   591→                if self.media_player.state() == QMediaPlayer.PlayingState:\n   592→                    self.media_player.pause()\n   593→                else:\n   594→                    self.media_player.play()\n   595→    \n   596→    def on_state_changed(self, state):\n   597→        \"\"\"播放状态改变\"\"\"\n   598→        if state == QMediaPlayer.PlayingState:\n   599→            self.play_button.setText(\"⏸\")\n   600→        else:\n   601→            self.play_button.setText(\"▶\")\n   602→    \n   603→    def on_position_changed(self, position):\n   604→        \"\"\"播放位置改变\"\"\"\n   605→        duration = self.media_player.duration()\n   606→        if duration > 0:\n   607→            current_time = self.format_duration(position)\n   608→            total_time = self.format_duration(duration)\n   609→            self.progress_label.setText(f\"{current_time} / {total_time}\")\n   610→    \n   611→    def on_duration_changed(self, duration):\n   612→        \"\"\"视频时长改变\"\"\"\n   613→        if duration > 0:\n   614→            total_time = self.format_duration(duration)\n   615→            self.progress_label.setText(f\"00:00 / {total_time}\")\n   616→    \n   617→    def on_media_error(self, error):\n   618→        \"\"\"媒体播放错误处理\"\"\"\n   619→        error_string = self.media_player.errorString()\n   620→        logger.error(f\"[MEDIA] 播放错误: {error}, 信息: {error_string}\")\n   621→        \n   622→        # 尝试使用OpenCV播放器作为备选方案\n   623→        if not self.is_using_opencv:\n   624→            logger.warning(\"[MEDIA] 尝试使用OpenCV播放器…\")\n   625→            if self.start_opencv_playback():\n   626→                return\n   627→        \n   628→        # 如果OpenCV也失败，显示错误信息\n   629→        from PyQt5.QtWidgets import QMessageBox\n   630→        msg_box = QMessageBox()\n   631→        msg_box.setIcon(QMessageBox.Critical)\n   632→        msg_box.setText(\"视频播放错误\")\n   633→        msg_box.setInformativeText(f\"无法播放视频: {error_string}\\n\\n可能的原因:\\n1. 系统缺少必要的视频编解码器\\n2. 视频文件损坏\\n3. 视频格式不支持\\n\\n建议解决方案:\\n1. 安装K-Lite Codec Pack\\n2. 使用其他视频播放器测试文件\")\n   634→        msg_box.exec_()\n   635→        \n   636→        # 返回缩略图模式\n   637→        self.video_stack.setCurrentIndex(0)\n   638→        self.is_playing = False\n   639→    \n   640→    def on_media_status_changed(self, status):\n   641→        \"\"\"媒体状态改变\"\"\"\n   642→        from PyQt5.QtMultimedia import QMediaPlayer\n   643→        \n   644→        logger.debug(f\"[MEDIA] 状态改变: {status}\")\n   645→        \n   646→        if status == QMediaPlayer.EndOfMedia:\n   647→            # 视频播放结束，返回缩略图模式\n   648→            logger.debug(\"[MEDIA] 播放结束，切回缩略图模式\")\n   649→            self.video_stack.setCurrentIndex(0)\n   650→            self.is_playing = False\n   651→            self.media_player.setPosition(0)  # 重置播放位置\n   652→            self.progress_label.setText(\"00:00 / 00:00\")\n   653→        elif status == QMediaPlayer.InvalidMedia:\n   654→            logger.warning(\"[MEDIA] 媒体文件无效\")\n   655→        elif status == QMediaPlayer.BufferedMedia:\n   656→            logger.debug(\"[MEDIA] 媒体缓冲完成\")\n   657→        elif status == QMediaPlayer.LoadingMedia:\n   658→            logger.debug(\"[MEDIA] 正在加载媒体\")\n   659→        elif status == QMediaPlayer.StalledMedia:\n   660→            logger.debug(\"[MEDIA] 播放卡顿\")\n   661→    \n   662→    def format_duration(self, ms):\n   663→        \"\"\"格式化时长显示\"\"\"\n   664→        seconds = ms // 1000\n   665→        minutes = seconds // 60\n   666→        seconds = seconds % 60\n   667→        return f\"{minutes:02d}:{seconds:02d}\"\n   668→    \n   669→    def start_opencv_playback(self):\n   670→        \"\"\"启动OpenCV视频播放器\"\"\"\n   671→        try:\n   672→            import cv2\n   673→            \n   674→            # 停止当前的Qt播放器\n   675→            self.media_player.stop()\n   676→            \n   677→            # 获取视频文件路径\n   678→            video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   679→            if not video_path or not os.path.exists(video_path):\n   680→                logger.warning(f\"[MEDIA] OpenCV：视频文件不存在: {video_path}\")\n   681→                return False\n   682→            \n   683→            # 打开视频文件\n   684→            self.cv_cap = cv2.VideoCapture(video_path)\n   685→            if not self.cv_cap.isOpened():\n   686→                logger.error(\"[MEDIA] OpenCV：无法打开视频文件\")\n   687→                return False\n   688→            \n   689→            # 获取视频信息\n   690→            fps = self.cv_cap.get(cv2.CAP_PROP_FPS)\n   691→            if fps <= 0:\n   692→                fps = 30  # 默认帧率\n   693→            \n   694→            # 设置帧更新定时器\n   695→            interval = int(1000 / fps)  # 毫秒\n   696→            self.cv_timer.start(interval)\n   697→            \n   698→            # 切换到OpenCV播放器\n   699→            self.video_stack.setCurrentIndex(2)\n   700→            self.is_using_opencv = True\n   701→            self.is_playing = True\n   702→            \n   703→            logger.debug(f\"[MEDIA] OpenCV播放器启动成功，FPS: {fps}\")\n   704→            return True\n   705→            \n   706→        except ImportError:\n   707→            logger.warning(\"[MEDIA] OpenCV未安装，无法使用OpenCV播放器\")\n   708→            return False\n   709→        except Exception as e:\n   710→            logger.error(f\"[MEDIA] OpenCV播放器启动失败: {e}\")\n   711→            import traceback\n   712→            traceback.print_exc()\n   713→            return False\n   714→    \n   715→    def update_opencv_frame(self):\n   716→        \"\"\"更新OpenCV视频帧\"\"\"\n   717→        try:\n   718→            if not self.cv_cap or not self.cv_cap.isOpened():\n   719→                logger.error(\"[MEDIA] OpenCV：视频捕获器未打开\")\n   720→                self.stop_opencv_playback()\n   721→                return\n   722→            \n   723→            # 读取帧\n   724→            ret, frame = self.cv_cap.read()\n   725→            if not ret:\n   726→                logger.debug(\"[MEDIA] OpenCV：播放结束\")\n   727→                self.stop_opencv_playback()\n   728→                return\n   729→            \n   730→            # 转换颜色空间（BGR到RGB）\n   731→            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n   732→            \n   733→            # 转换为QImage\n   734→            height, width, channel = frame_rgb.shape\n   735→            bytes_per_line = 3 * width\n   736→            from PyQt5.QtGui import QImage\n   737→            q_img = QImage(frame_rgb.data, width, height, bytes_per_line, QImage.Format_RGB888)\n   738→            \n   739→            # 转换为QPixmap并显示\n   740→            from PyQt5.QtGui import QPixmap\n   741→            pixmap = QPixmap.fromImage(q_img)\n   742→            \n   743→            # 缩放以适应标签大小\n   744→            label_size = self.opencv_video_label.size()\n   745→            scaled_pixmap = pixmap.scaled(\n   746→                label_size,\n   747→                Qt.KeepAspectRatio,\n   748→                Qt.SmoothTransformation\n   749→            )\n   750→            \n   751→            self.opencv_video_label.setPixmap(scaled_pixmap)\n   752→            \n   753→        except Exception as e:\n   754→            logger.error(f\"[MEDIA] OpenCV更新帧失败: {e}\")\n   755→            import traceback\n   756→            traceback.print_exc()\n   757→            self.stop_opencv_playback()\n   758→    \n   759→    def stop_opencv_playback(self):\n   760→        \"\"\"停止OpenCV视频播放\"\"\"\n   761→        try:\n   762→            # 停止定时器\n   763→            self.cv_timer.stop()\n   764→            \n   765→            # 释放视频捕获器\n   766→            if self.cv_cap:\n   767→                self.cv_cap.release()\n   768→                self.cv_cap = None\n   769→            \n   770→            # 清空显示\n   771→            self.opencv_video_label.clear()\n   772→            self.opencv_video_label.setText(\"视频播放结束\")\n   773→            \n   774→            # 返回缩略图模式\n   775→            self.video_stack.setCurrentIndex(0)\n   776→            self.is_using_opencv = False\n   777→            self.is_playing = False\n   778→            \n   779→            logger.debug(\"[MEDIA] OpenCV播放器停止\")\n   780→            \n   781→        except Exception as e:\n   782→            logger.error(f\"[MEDIA] OpenCV播放器停止失败: {e}\")\n   783→    \n   784→    def format_time(self, time_str: str) -> str:\n   785→        \"\"\"格式化时间显示\"\"\"\n   786→        if not time_str:\n   787→            return '未知时间'\n   788→        try:\n   789→            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n   790→            return dt.strftime('%Y-%m-%d %H:%M:%S')\n   791→        except:\n   792→            return time_str[:19] if len(time_str) > 19 else time_str\n   793→    \n   794→    def format_file_size(self, size) -> str:\n   795→        \"\"\"格式化文件大小显示\"\"\"\n   796→        try:\n   797→            size = float(size) if size else 0\n   798→        except (ValueError, TypeError):\n   799→            return '未知大小'\n   800→            \n   801→        if size == 0:\n   802→            return '未知大小'\n   803→        \n   804→        for unit in ['B', 'KB', 'MB', 'GB']:\n   805→            if size < 1024.0:\n   806→                return f\"{size:.1f} {unit}\"\n   807→            size /= 1024.0\n   808→        return f\"{size:.1f} TB\"\n   809→    \n   810→    def setup_shortcuts(self):\n   811→        \"\"\"设置键盘快捷键\"\"\"\n   812→        # 移除所有QShortcut，统一使用keyPressEvent处理\n   813→        # 避免快捷键冲突问题\n   814→        pass\n   815→    \n   816→    def _ensure_focus(self):\n   817→        \"\"\"确保窗口获得焦点\"\"\"\n   818→        self.activateWindow()\n   819→        self.raise_()\n   820→        self.setFocus()\n   821→        logger.debug(f\"[FOCUS] VideoDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n   822→    \n   823→    def keyPressEvent(self, event):\n   824→        \"\"\"键盘事件处理\"\"\"\n   825→        from PyQt5.QtCore import Qt\n   826→        \n   827→        logger.debug(f\"[KEYBOARD] VideoDetailDialog键盘事件: {event.key()}\")\n   828→        \n   829→        if event.key() == Qt.Key_Left:\n   830→            # 左方向键：上一个视频\n   831→            logger.debug(f\"[KEYBOARD] 左键pressed，prev_btn enabled: {self.prev_btn.isEnabled()}\")\n   832→            if self.prev_btn.isEnabled():\n   833→                self.show_previous_video()\n   834→            event.accept()\n   835→        elif event.key() == Qt.Key_Right:\n   836→            # 右方向键：下一个视频\n   837→            logger.debug(f\"[KEYBOARD] 右键pressed，next_btn enabled: {self.next_btn.isEnabled()}\")\n   838→            if self.next_btn.isEnabled():\n   839→                self.show_next_video()\n   840→            event.accept()\n   841→        elif event.key() == Qt.Key_Escape:\n   842→            # ESC键：关闭对话框（保持原有功能）\n   843→            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n   844→            if self.is_fullscreen:\n   845→                self.exit_fullscreen()\n   846→            else:\n   847→                self.accept()\n   848→            event.accept()\n   849→        elif event.key() == Qt.Key_F11:\n   850→            # F11键：全屏切换（保持原有功能）\n   851→            self.toggle_fullscreen()\n   852→            event.accept()\n   853→        elif event.key() == Qt.Key_Space:\n   854→            # 空格键：播放/暂停\n   855→            self.toggle_play_pause()\n   856→            event.accept()\n   857→        else:\n   858→            # 其他按键交给父类处理\n   859→            super().keyPressEvent(event)\n   860→    \n   861→    def toggle_fullscreen(self):\n   862→        \"\"\"切换全屏模式\"\"\"\n   863→        if self.is_fullscreen:\n   864→            self.exit_fullscreen()\n   865→        else:\n   866→            self.enter_fullscreen()\n   867→    \n   868→    def enter_fullscreen(self):\n   869→        \"\"\"进入全屏模式\"\"\"\n   870→        if not self.is_fullscreen:\n   871→            self.original_geometry = self.geometry()\n   872→            self.showFullScreen()\n   873→            self.is_fullscreen = True\n   874→    \n   875→    def exit_fullscreen(self):\n   876→        \"\"\"退出全屏模式\"\"\"\n   877→        if self.is_fullscreen:\n   878→            self.showNormal()\n   879→            if self.original_geometry:\n   880→                self.setGeometry(self.original_geometry)\n   881→            self.is_fullscreen = False\n   882→    \n   883→    def handle_escape_key(self):\n   884→        \"\"\"处理ESC键\"\"\"\n   885→        if self.is_fullscreen:\n   886→            self.exit_fullscreen()\n   887→        else:\n   888→            self.accept()\n   889→    \n   890→    def copy_prompt(self):\n   891→        \"\"\"复制提示词到剪贴板\"\"\"\n   892→        prompt_content = self.prompt_text_edit.toPlainText()\n   893→        clipboard = QApplication.clipboard()\n   894→        clipboard.setText(prompt_content)\n   895→        self.show_copy_toast(\"提示词已复制到剪贴板\")\n   896→    \n   897→    def show_copy_toast(self, message: str):\n   898→        \"\"\"显示复制成功的轻量提示\"\"\"\n   899→        toast = QLabel(message, self)\n   900→        toast.setObjectName(\"ToastLabel\")\n   901→        toast.setAlignment(Qt.AlignCenter)\n   902→        toast.adjustSize()\n   903→        \n   904→        x = (self.width() - toast.width()) // 2\n   905→        y = self.height() // 4\n   906→        toast.move(x, y)\n   907→        toast.show()\n   908→        \n   909→        QTimer.singleShot(2000, toast.deleteLater)\n   910→\n   911→    def _on_reference_clicked(self, asset: Dict[str, Any]):\n   912→        assets = list(self._reference_assets) if self._reference_assets else [asset]\n   913→        start_idx = _find_reference_asset_index(assets, asset)\n   914→        open_reference_preview(\n   915→            self,\n   916→            asset,\n   917→            title_prefix=\"参考图\",\n   918→            asset_list=assets,\n   919→            start_index=start_idx,\n   920→            on_asset_changed=self._sync_reference_selection,\n   921→        )\n   922→\n   923→    def _on_reference_export(self, asset: Dict[str, Any]):\n   924→        export_reference_asset(self, asset)\n   925→\n   926→    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n   927→        asset_path = None\n   928→        if isinstance(asset, dict):\n   929→            asset_path = asset.get('absolute_path') or asset.get('path')\n   930→        has_path = bool(asset_path and os.path.exists(asset_path))\n   931→        if hasattr(self, 'reference_export_btn'):\n   932→            self.reference_export_btn.setEnabled(has_path)\n   933→\n   934→    def _export_selected_reference(self):\n   935→        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n   936→        if not asset:\n   937→            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n   938→            return\n   939→        export_reference_asset(self, asset)\n   940→\n   941→    def _refresh_reference_gallery(self):\n   942→        if not hasattr(self, 'reference_gallery'):\n   943→            return\n   944→        self._reference_summary = ensure_reference_info(self.video_data)\n   945→        if self._reference_summary.get('count', 0) <= 0:\n   946→            self.reference_gallery.setVisible(False)\n   947→            self.reference_gallery.clear()\n   948→            if hasattr(self, 'reference_export_btn'):\n   949→                self.reference_export_btn.setEnabled(False)\n   950→            self._reference_assets = []\n   951→            self._export_controller.refresh()\n   952→            return\n   953→        try:\n   954→            self._reference_assets = resolve_reference_assets(self.video_data, absolute=True)\n   955→        except Exception:\n   956→            self._reference_assets = []\n   957→        self.reference_gallery.set_assets(self._reference_assets)\n   958→        self.reference_gallery.setVisible(True)\n   959→        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n   960→        self._export_controller.refresh()\n   961→\n   962→    def _sync_reference_selection(self, asset: Dict[str, Any]):\n   963→        try:\n   964→            self.reference_gallery.select_asset(asset)\n   965→        except Exception:\n   966→            pass\n   967→\n   968→    def _resolve_video_record_id(self) -> Optional[str]:\n   969→        for key in (\"file_id\", \"id\", \"generation_id\"):\n   970→            value = self.video_data.get(key)\n   971→            if value not in (None, \"\"):\n   972→                return str(value)\n   973→        return None\n   974→\n   975→    def download_video(self):\n   976→        \"\"\"下载视频到指定位置\"\"\"\n   977→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   978→        if not video_path or not os.path.exists(video_path):\n   979→            self.show_styled_message(\"错误\", \"视频文件不存在\", \"warning\")\n   980→            return\n   981→        \n   982→        file_dialog = QFileDialog()\n   983→        save_path, _ = file_dialog.getSaveFileName(\n   984→            self,\n   985→            \"保存视频\",\n   986→            f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4\",\n   987→            \"视频文件 (*.mp4)\"\n   988→        )\n   989→        \n   990→        if save_path:\n   991→            try:\n   992→                import shutil\n   993→                shutil.copy2(video_path, save_path)\n   994→                self.show_copy_toast(f\"视频已保存到: {os.path.basename(save_path)}\")\n   995→            except Exception as e:\n   996→                self.show_styled_message(\"错误\", f\"保存视频失败: {str(e)}\", \"critical\")\n   997→    \n   998→    def update_navigation_buttons(self):\n   999→        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n  1000→        logger.debug(f\"[NAV] 更新导航按钮：当前索引{self.current_index}，总记录数{len(self.video_list)}\")\n  1001→        \n  1002→        has_prev = self._has_valid_previous_record()\n  1003→        has_next = self._has_valid_next_record()\n  1004→        \n  1005→        logger.debug(f\"[NAV] 有效记录检查：prev={has_prev}, next={has_next}\")\n  1006→        \n  1007→        self.prev_btn.setEnabled(has_prev)\n  1008→        self.next_btn.setEnabled(has_next)\n  1009→    \n  1010→    def _has_valid_previous_record(self):\n  1011→        \"\"\"检查是否有有效的上一个记录\"\"\"\n  1012→        logger.debug(f\"[NAV] 检查上一个记录：从索引{self.current_index - 1}到0\")\n  1013→        for i in range(self.current_index - 1, -1, -1):\n  1014→            candidate_data = self.video_list[i]\n  1015→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1016→            content_type = candidate_data.get('content_type', '')\n  1017→            \n  1018→            # 检查文件扩展名，确保是视频文件\n  1019→            is_video = False\n  1020→            if file_path:\n  1021→                from pathlib import Path\n  1022→                file_ext = Path(file_path).suffix.lower()\n  1023→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1024→            \n  1025→            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n  1026→            \n  1027→            if file_path and os.path.exists(file_path) and is_video:\n  1028→                logger.debug(f\"[NAV] 找到有效的上一个视频记录：索引{i}\")\n  1029→                return True\n  1030→        logger.debug(f\"[NAV] 没有找到有效的上一个视频记录\")\n  1031→        return False\n  1032→    \n  1033→    def _has_valid_next_record(self):\n  1034→        \"\"\"检查是否有有效的下一个记录\"\"\"\n  1035→        logger.debug(f\"[NAV] 检查下一个记录：从索引{self.current_index + 1}到{len(self.video_list) - 1}\")\n  1036→        for i in range(self.current_index + 1, len(self.video_list)):\n  1037→            candidate_data = self.video_list[i]\n  1038→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1039→            content_type = candidate_data.get('content_type', '')\n  1040→            \n  1041→            # 检查文件扩展名，确保是视频文件\n  1042→            is_video = False\n  1043→            if file_path:\n  1044→                from pathlib import Path\n  1045→                file_ext = Path(file_path).suffix.lower()\n  1046→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1047→            \n  1048→            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n  1049→            \n  1050→            if file_path and os.path.exists(file_path) and is_video:\n  1051→                logger.debug(f\"[NAV] 找到有效的下一个视频记录：索引{i}\")\n  1052→                return True\n  1053→        logger.debug(f\"[NAV] 没有找到有效的下一个视频记录\")\n  1054→        return False\n  1055→    \n  1056→    def show_previous_video(self):\n  1057→        \"\"\"显示上一个视频（带有效性验证）\"\"\"\n  1058→        # 寻找上一个有效视频记录\n  1059→        for i in range(self.current_index - 1, -1, -1):\n  1060→            candidate_data = self.video_list[i]\n  1061→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1062→            \n  1063→            # 检查是否为视频文件\n  1064→            is_video = False\n  1065→            if file_path:\n  1066→                from pathlib import Path\n  1067→                file_ext = Path(file_path).suffix.lower()\n  1068→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1069→            \n  1070→            if file_path and os.path.exists(file_path) and is_video:\n  1071→                # 找到有效视频记录\n  1072→                logger.debug(f\"[NAV] 切换到上一个视频：索引{i}\")\n  1073→                self.current_index = i\n  1074→                self.video_data = self.video_list[i]\n  1075→                self.load_video()\n  1076→                self.update_navigation_buttons()\n  1077→                return\n  1078→        \n  1079→        # 没有找到有效的上一个视频记录，保持当前状态\n  1080→        logger.debug(f\"[NAV] 没有上一个视频可切换\")\n  1081→        self.update_navigation_buttons()\n  1082→    \n  1083→    def show_next_video(self):\n  1084→        \"\"\"显示下一个视频（带有效性验证）\"\"\"\n  1085→        # 寻找下一个有效视频记录\n  1086→        for i in range(self.current_index + 1, len(self.video_list)):\n  1087→            candidate_data = self.video_list[i]\n  1088→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1089→            \n  1090→            # 检查是否为视频文件\n  1091→            is_video = False\n  1092→            if file_path:\n  1093→                from pathlib import Path\n  1094→                file_ext = Path(file_path).suffix.lower()\n  1095→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1096→            \n  1097→            if file_path and os.path.exists(file_path) and is_video:\n  1098→                # 找到有效视频记录\n  1099→                logger.debug(f\"[NAV] 切换到下一个视频：索引{i}\")\n  1100→                self.current_index = i\n  1101→                self.video_data = self.video_list[i]\n  1102→                self.load_video()\n  1103→                self.update_navigation_buttons()\n  1104→                return\n  1105→        \n  1106→        # 没有找到有效的下一个视频记录，保持当前状态\n  1107→        logger.debug(f\"[NAV] 没有下一个视频可切换\")\n  1108→        self.update_navigation_buttons()\n  1109→    \n  1110→    def load_video(self):\n  1111→        \"\"\"加载新视频\"\"\"\n  1112→        logger.debug(\"[UI] 加载新视频…\")\n  1113→        \n  1114→        # 停止当前播放器\n  1115→        if hasattr(self, 'is_using_opencv') and self.is_using_opencv:\n  1116→            logger.debug(\"[MEDIA] 停止OpenCV播放器\")\n  1117→            self.stop_opencv_playback()\n  1118→        else:\n  1119→            logger.debug(\"[MEDIA] 停止Qt播放器\")\n  1120→            if self.media_player:\n  1121→                self.media_player.stop()\n  1122→        \n  1123→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n  1124→        if video_path and os.path.exists(video_path):\n  1125→            from PyQt5.QtCore import QUrl\n  1126→            self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(video_path)))\n  1127→            \n  1128→            # 重置到缩略图模式\n  1129→            self.video_stack.setCurrentIndex(0)\n  1130→            self.is_playing = False\n  1131→            \n  1132→            # 重新加载缩略图\n  1133→            self.load_thumbnail()\n  1134→            \n  1135→            # 更新右侧信息\n  1136→            prompt_content = self.video_data.get('prompt', '无提示词')\n  1137→            self.prompt_text_edit.setPlainText(prompt_content)\n  1138→            \n  1139→            # 更新参数信息\n  1140→            self.update_video_params()\n  1141→            \n  1142→            logger.debug(\"[UI] 新视频加载完成\")\n  1143→        else:\n  1144→            self.video_stack.setCurrentIndex(0)\n  1145→            self.is_playing = False\n  1146→\n  1147→        self._refresh_reference_gallery()\n  1148→        self._export_controller.refresh()\n  1149→    \n  1150→    def update_video_params(self):\n  1151→        \"\"\"更新视频参数显示（切换视频时调用）\"\"\"\n  1152→        try:\n  1153→            # 解析生成参数\n  1154→            params = self.video_data.get('parameters', '{}')\n  1155→            if isinstance(params, str):\n  1156→                try:\n  1157→                    params = json.loads(params)\n  1158→                except:\n  1159→                    params = {}\n  1160→            \n  1161→            # 重新构建参数信息\n  1162→            info_items = [\n  1163→                (\"分辨率\", build_resolution_text(self.video_data)),\n  1164→                (\"时长\", f\"{self.video_data.get('duration', '未知')}秒\"),\n  1165→                (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n  1166→                (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n  1167→                (\"文件大小\", self.format_file_size(self.video_data.get('file_size', 0))),\n  1168→                (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n  1169→            ]\n  1170→            \n  1171→            # 更新已保存的标签\n  1172→            for label, new_value in info_items:\n  1173→                if label in self.param_value_labels:\n  1174→                    self.param_value_labels[label].setText(str(new_value))\n  1175→            \n  1176→            logger.debug(\"视频参数已更新\")\n  1177→            \n  1178→        except Exception as e:\n  1179→            logger.error(f\"更新视频参数失败: {e}\")\n  1180→    \n  1181→    def update_param_labels(self):\n  1182→        \"\"\"更新参数标签内容\"\"\"\n  1183→        try:\n  1184→            # 更新各个参数标签\n  1185→            param_updates = {\n  1186→                \"分辨率\": build_resolution_text(self.video_data),\n  1187→                \"时长\": f\"{self.video_data.get('duration', '未知')}秒\",\n  1188→                \"模型\": get_model_display_name(pick_model_code(self.video_data)),\n  1189→                \"生成时间\": self.format_time(self.video_data.get('created_at', '')),\n  1190→                \"文件大小\": self.format_file_size(self.video_data.get('file_size', 0)),\n  1191→                \"文件路径\": self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n  1192→            }\n  1193→            \n  1194→            for param_name, new_value in param_updates.items():\n  1195→                if param_name in self.param_labels:\n  1196→                    self.param_labels[param_name].setText(str(new_value))\n  1197→                    logger.debug(f\"已更新参数 {param_name}: {new_value}\")\n  1198→            \n  1199→            logger.debug(\"视频参数标签更新完成\")\n  1200→        except Exception as e:\n  1201→            logger.error(f\"更新视频参数标签失败: {e}\")\n  1202→    \n  1203→    def closeEvent(self, event):\n  1204→        \"\"\"窗口关闭事件\"\"\"\n  1205→        # 停止OpenCV播放器\n  1206→        if self.is_using_opencv:\n  1207→            self.stop_opencv_playback()\n  1208→\n  1209→        # 停止Qt播放器\n  1210→        if self.media_player:\n  1211→            self.media_player.stop()\n  1212→\n  1213→        try:\n  1214→            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n  1215→                self._focus_timer.stop()\n  1216→        except Exception:\n  1217→            pass\n  1218→\n  1219→        try:\n  1220→            self._export_controller.dispose()\n  1221→        except Exception:\n  1222→            pass\n  1223→\n  1224→        super().closeEvent(event)\n  1225→    \n  1226→    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n  1227→        \"\"\"显示带有深色主题样式的消息框\"\"\"\n  1228→        from PyQt5.QtWidgets import QMessageBox\n  1229→        \n  1230→        msg_box = QMessageBox(self)\n  1231→        msg_box.setWindowTitle(title)\n  1232→        msg_box.setText(message)\n  1233→        \n  1234→        # 设置图标\n  1235→        if icon_type == \"warning\":\n  1236→            msg_box.setIcon(QMessageBox.Warning)\n  1237→        elif icon_type == \"critical\":\n  1238→            msg_box.setIcon(QMessageBox.Critical)\n  1239→        elif icon_type == \"question\":\n  1240→            msg_box.setIcon(QMessageBox.Question)\n  1241→        else:\n  1242→            msg_box.setIcon(QMessageBox.Information)\n  1243→        \n  1244→        # 样式由全局QSS控制\n  1245→        \n  1246→        msg_box.exec_()\n  1247→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f6439311-4f33-460a-8150-8dc7a7ec7f6b","timestamp":"2025-12-11T08:09:49.838Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py","content":"import os\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\n\nfrom PyQt5.QtWidgets import (\n    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n    QTextEdit, QFileDialog, QMessageBox, QStackedWidget, QSplitter,\n    QApplication, QShortcut\n)\nfrom PyQt5.QtCore import Qt, QTimer, QUrl, QSize, QEvent\nfrom PyQt5.QtGui import QPixmap, QFont, QKeySequence, QPainter, QImage\nfrom PyQt5.QtMultimedia import QMediaPlayer, QMediaContent\nfrom PyQt5.QtMultimediaWidgets import QVideoWidget\n\n# OpenCV条件导入\ntry:\n    import cv2\n    OPENCV_AVAILABLE = True\nexcept Exception:\n    cv2 = None\n    OPENCV_AVAILABLE = False\n\nfrom utils.logger import logger\nfrom components.reference_assets import (\n    ReferenceGalleryWidget,\n    export_reference_asset,\n    open_reference_preview,\n    _find_reference_asset_index,\n)\nfrom components.controllers import ExportBundleController\nfrom utils.reference_display import (\n    build_resolution_text,\n    ensure_reference_info,\n    get_model_display_name,\n    pick_model_code,\n    resolve_reference_assets,\n)\n\nclass VideoDetailDialog(QDialog):\n    \"\"\"视频详细信息对话框\"\"\"\n    \n    def __init__(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n        super().__init__(parent)\n        self.video_data = video_data\n        self.video_list = video_list or [video_data]  # 视频列表\n        self.current_index = current_index  # 当前视频索引\n        self.is_fullscreen = False  # 全屏状态\n        self.original_geometry = None  # 原始窗口几何\n        self.param_value_labels = {}  # 存储参数值标签的引用\n        self._reference_summary = ensure_reference_info(self.video_data)\n        self._reference_assets: List[Dict[str, Any]] = []\n        self._export_controller = ExportBundleController(self, \"video\")\n        self.setup_ui()\n        \n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        self.setWindowTitle(\"视频详细信息\")\n        self.resize(1100, 800)  # 改为可调整大小\n        self.setMinimumSize(800, 600)  # 设置最小尺寸\n        \n        # 设置焦点策略，确保能接收键盘事件\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n        self.setFocus()\n\n        # 确保窗口激活时获得焦点\n        self.activateWindow()\n        self.raise_()\n\n        try:\n            self.setObjectName(\"DetailDialog\")\n        except Exception:\n            pass\n\n        self._focus_timer = QTimer(self)\n        self._focus_timer.setSingleShot(True)\n        self._focus_timer.timeout.connect(self._ensure_focus)\n\n        layout = QHBoxLayout(self)\n        \n        # 左侧：视频播放器（占70%宽度）\n        left_widget = QWidget()\n        left_layout = QVBoxLayout(left_widget)\n        left_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 视频播放区域\n        video_container = QWidget()\n        video_container.setObjectName(\"VideoContainer\")\n        \n        container_layout = QVBoxLayout(video_container)\n        container_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 创建堆叠布局，用于缩略图和视频播放器的切换\n        from PyQt5.QtWidgets import QStackedWidget\n        self.video_stack = QStackedWidget()\n        \n        # 缩略图页面\n        self.thumbnail_widget = QWidget()\n        self.thumbnail_widget.setObjectName(\"ThumbnailWidget\")\n        thumbnail_layout = QVBoxLayout(self.thumbnail_widget)\n        thumbnail_layout.setContentsMargins(0, 0, 0, 0)\n        thumbnail_layout.setAlignment(Qt.AlignCenter)\n        \n        # 缩略图标签\n        self.thumbnail_label = QLabel()\n        self.thumbnail_label.setAlignment(Qt.AlignCenter)\n        self.thumbnail_label.setStyleSheet(\"\"\"\n            QLabel {\n                border: none;\n                background-color: #000000;\n                color: #ffffff;\n            }\n        \"\"\")\n        self.thumbnail_label.setMinimumSize(400, 300)\n        # 不使用setScaledContents，改为手动缩放\n        # self.thumbnail_label.setScaledContents(True)\n        \n        # 播放按钮覆盖层\n        self.play_overlay = QLabel(\"▶\")\n        self.play_overlay.setAlignment(Qt.AlignCenter)\n        self.play_overlay.setObjectName(\"PlayOverlay\")\n        \n        # 创建缩略图容器，使用相对定位\n        thumbnail_container = QWidget()\n        thumbnail_container.setStyleSheet(\"border: none; background-color: #000000;\")\n        # 设置固定尺寸确保容器有正确的大小\n        thumbnail_container.setFixedSize(640, 480)\n        \n        # 使用绝对定位放置播放按钮\n        def setup_thumbnail_layout():\n            self.thumbnail_label.setParent(thumbnail_container)\n            self.play_overlay.setParent(thumbnail_container)\n            \n            # 确保标签可见\n            self.thumbnail_label.show()\n            self.play_overlay.show()\n            \n            def resize_thumbnail_container():\n                if hasattr(self, 'thumbnail_label') and hasattr(self, 'play_overlay'):\n                    container_size = thumbnail_container.size()\n                    logger.debug(f\"[UI] 详情缩略图容器尺寸: {container_size}\")\n                    \n                    # 设置缩略图标签尺寸和位置\n                    self.thumbnail_label.setGeometry(0, 0, container_size.width(), container_size.height())\n                    \n                    # 播放按钮居中\n                    overlay_x = max(0, (container_size.width() - 70) // 2)\n                    overlay_y = max(0, (container_size.height() - 70) // 2)\n                    self.play_overlay.setGeometry(overlay_x, overlay_y, 70, 70)\n                    \n                    logger.debug(f\"[UI] 缩略图标签位置: {self.thumbnail_label.geometry()}\")\n                    logger.debug(f\"[UI] 播放按钮位置: {self.play_overlay.geometry()}\")\n            \n            def handle_resize_event(event):\n                resize_thumbnail_container()\n                QWidget.resizeEvent(thumbnail_container, event)\n            \n            thumbnail_container.resizeEvent = handle_resize_event\n            \n            # 立即调用布局函数\n            resize_thumbnail_container()\n        \n        setup_thumbnail_layout()\n        \n        # 点击事件\n        self.thumbnail_label.mousePressEvent = self.on_thumbnail_click\n        self.play_overlay.mousePressEvent = self.on_thumbnail_click\n        \n        thumbnail_layout.addWidget(thumbnail_container)\n        \n        # 视频播放器页面\n        self.video_widget = QVideoWidget()\n        self.video_widget.setObjectName(\"VideoWidget\")\n        \n        # OpenCV视频播放器页面（备选方案）\n        self.opencv_video_label = QLabel()\n        self.opencv_video_label.setObjectName(\"OpenCVVideoLabel\")\n        self.opencv_video_label.setAlignment(Qt.AlignCenter)\n        self.opencv_video_label.setMinimumSize(640, 480)\n        \n        # 创建视频播放器\n        logger.debug(\"[UI] 创建QMediaPlayer…\")\n        self.media_player = QMediaPlayer(None, QMediaPlayer.VideoSurface)\n        logger.debug(\"[UI] QMediaPlayer创建完成\")\n        \n        # 设置视频输出\n        logger.debug(\"[UI] 设置视频输出…\")\n        self.media_player.setVideoOutput(self.video_widget)\n        logger.debug(\"[UI] 视频输出设置完成\")\n        \n        # OpenCV播放器变量\n        self.cv_cap = None\n        self.cv_timer = QTimer()\n        self.cv_timer.timeout.connect(self.update_opencv_frame)\n        self.is_using_opencv = False\n        \n        # 添加错误处理\n        self.media_player.error.connect(self.on_media_error)\n        logger.debug(\"[UI] 媒体错误处理连接完成\")\n        \n        # 添加状态监听\n        self.media_player.stateChanged.connect(self.on_state_changed)\n        self.media_player.positionChanged.connect(self.on_position_changed)\n        self.media_player.durationChanged.connect(self.on_duration_changed)\n        self.media_player.mediaStatusChanged.connect(self.on_media_status_changed)\n        logger.debug(\"[UI] 媒体状态监听连接完成\")\n        \n        # 添加到堆叠布局\n        self.video_stack.addWidget(self.thumbnail_widget)  # 索引0：缩略图\n        self.video_stack.addWidget(self.video_widget)      # 索引1：Qt视频播放器\n        self.video_stack.addWidget(self.opencv_video_label) # 索引2：OpenCV视频播放器\n        \n        # 默认显示缩略图\n        self.video_stack.setCurrentIndex(0)\n        self.is_playing = False\n        \n        # 加载视频和缩略图\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if video_path and os.path.exists(video_path):\n            from PyQt5.QtCore import QUrl\n            self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(video_path)))\n            self.load_thumbnail()\n        \n        container_layout.addWidget(self.video_stack)\n        \n        # 视频区域占据所有可用空间\n        left_splitter = QSplitter(Qt.Vertical)\n        left_splitter.addWidget(video_container)\n\n        self.reference_gallery = ReferenceGalleryWidget()\n        try:\n            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n        except Exception:\n            pass\n        # 参考图区域容器，包含画廊与操作按钮\n        reference_section = QWidget()\n        reference_section_layout = QVBoxLayout(reference_section)\n        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n        reference_section_layout.setSpacing(6)\n        reference_section_layout.addWidget(self.reference_gallery)\n        # 将左侧分割器先加入主布局（第二块稍后补充按钮区后再添加）\n        # 注意：最终会把 reference_section 放入分割器\n\n        reference_button_layout = QHBoxLayout()\n        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n        reference_button_layout.setSpacing(6)\n        self.export_status_label = QLabel(\"\")\n        self.export_status_label.setStyleSheet(\"color: #bbbbbb; ;\")\n        reference_button_layout.addWidget(self.export_status_label)\n        reference_button_layout.addStretch(1)\n        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n        self.reference_export_btn.setEnabled(False)\n        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n        reference_button_layout.addWidget(self.reference_export_btn)\n        self.export_bundle_btn = QPushButton(\"导出记录\")\n        self.export_bundle_btn.setEnabled(False)\n        self._export_controller.configure(\n            self.export_bundle_btn,\n            self.export_status_label,\n            self._resolve_video_record_id,\n            context_widget=self,\n        )\n        reference_button_layout.addWidget(self.export_bundle_btn)\n        reference_section_layout.addLayout(reference_button_layout)\n        # 将参考图区域加入分割器，并把分割器加入左侧布局\n        left_splitter.addWidget(reference_section)\n        try:\n            left_splitter.setStretchFactor(0, 3)\n            left_splitter.setStretchFactor(1, 2)\n            left_splitter.setSizes([520, 280])\n        except Exception:\n            pass\n        left_layout.addWidget(left_splitter, 1)\n\n        # 底部控制区域\n        controls_layout = QHBoxLayout()\n        controls_layout.setContentsMargins(0, 5, 0, 5)\n        controls_layout.setSpacing(10)\n        \n        # 播放/暂停按钮\n        self.play_button = QPushButton(\"▶\")\n        self.play_button.setFixedSize(40, 30)\n        self.play_button.setObjectName(\"PlayButton\")\n        self.play_button.clicked.connect(self.toggle_play_pause)\n        controls_layout.addWidget(self.play_button)\n        \n        # 进度条（简单的标签显示）\n        self.progress_label = QLabel(\"00:00 / 00:00\")\n        self.progress_label.setObjectName(\"ProgressLabel\")\n        controls_layout.addWidget(self.progress_label, 1)\n        \n        # 音量控制\n        volume_label = QLabel(\"🔊\")\n        volume_label.setStyleSheet(\"color: #cccccc; ;\")\n        controls_layout.addWidget(volume_label)\n        \n        # 导航按钮\n        self.prev_btn = QPushButton(\"◀\")\n        self.prev_btn.setFixedSize(30, 30)\n        self.prev_btn.setObjectName(\"NavButton\")\n        self.prev_btn.clicked.connect(self.show_previous_video)\n        controls_layout.addWidget(self.prev_btn)\n        \n        self.next_btn = QPushButton(\"▶\")\n        self.next_btn.setFixedSize(30, 30)\n        self.next_btn.setObjectName(\"NavButton\")\n        self.next_btn.clicked.connect(self.show_next_video)\n        controls_layout.addWidget(self.next_btn)\n        \n        left_layout.addLayout(controls_layout)\n\n        # 更新导航按钮状态\n        self.update_navigation_buttons()\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n\n        # 右侧：详细信息（固定30%宽度）\n        right_layout = QVBoxLayout()\n        \n        # 创建参数显示区域\n        params_widget = QWidget()\n        params_widget.setFixedWidth(int(self.width() * 0.3))\n        params_widget.setObjectName(\"ParamsWidget\")\n        params_layout = QVBoxLayout(params_widget)\n        params_layout.setSpacing(0)\n        params_layout.setContentsMargins(5, 5, 5, 5)\n        \n        # 解析生成参数\n        params = self.video_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 提示词区域\n        prompt_label = QLabel(\"<b>提示词:</b>\")\n        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n        params_layout.addWidget(prompt_label)\n        \n        # 提示词文本框\n        prompt_content = self.video_data.get('prompt', '无提示词')\n        self.prompt_text_edit = QTextEdit()\n        self.prompt_text_edit.setPlainText(prompt_content)\n        self.prompt_text_edit.setReadOnly(True)\n        self.prompt_text_edit.setMaximumHeight(120)\n        self.prompt_text_edit.setMinimumHeight(120)\n        self.prompt_text_edit.setStyleSheet(\"\"\"\n            QTextEdit {\n                background-color: #2a2a3e;\n                color: #ffffff;\n                border: 1px solid #555;\n                border-radius: 4px;\n                padding: 8px;\n                margin: 0px;\n                ;\n                line-height: 1.4;\n            }\n        \"\"\")\n        params_layout.addWidget(self.prompt_text_edit)\n        \n        # 复制提示词按钮\n        copy_prompt_btn = QPushButton(\"复制提示词\")\n        copy_prompt_btn.setMaximumHeight(30)\n        copy_prompt_btn.clicked.connect(self.copy_prompt)\n        params_layout.addWidget(copy_prompt_btn)\n        \n        # 详细信息 - 保存标签引用以便后续更新\n        self.param_labels = {}  # 存储参数值标签的引用\n        \n        info_items = [\n            (\"分辨率\", build_resolution_text(self.video_data)),\n            (\"时长\", f\"{self.video_data.get('duration', '未知')}秒\"),\n            (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n            (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n            (\"文件大小\", self.format_file_size(self.video_data.get('file_size', 0))),\n            (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n        ]\n        \n        for label, value in info_items:\n            label_widget = QLabel(f\"<b>{label}:</b>\")\n            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n            params_layout.addWidget(label_widget)\n            \n            value_label = QLabel(str(value))\n            value_label.setWordWrap(True)\n            value_label.setStyleSheet(\"\"\"\n                QLabel {\n                    margin: 0px;\n                    padding: 6px;\n                    background-color: #2a2a3e;\n                    color: #ffffff;\n                    border: 1px solid #555;\n                    border-radius: 4px;\n                    ;\n                    min-height: 20px;\n                }\n            \"\"\")\n            params_layout.addWidget(value_label)\n            \n            # 保存参数值标签引用，用于后续更新\n            self.param_value_labels[label] = value_label\n        \n        right_layout.addWidget(params_widget)\n        \n        # 控制按钮\n        button_layout = QHBoxLayout()\n        \n        fullscreen_btn = QPushButton(\"全屏 (F11)\")\n        fullscreen_btn.setMaximumHeight(30)\n        fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n        button_layout.addWidget(fullscreen_btn)\n        \n        download_btn = QPushButton(\"下载视频\")\n        download_btn.setMaximumHeight(30)\n        download_btn.clicked.connect(self.download_video)\n        button_layout.addWidget(download_btn)\n        \n        right_layout.addLayout(button_layout)\n        \n        close_btn = QPushButton(\"关闭（ESC）\")\n        close_btn.clicked.connect(self.accept)\n        right_layout.addWidget(close_btn)\n        \n        # 设置布局比例：左侧70%，右侧30%\n        layout.addWidget(left_widget, 7)\n        layout.addLayout(right_layout, 3)\n        \n        # 添加键盘快捷键\n        self.setup_shortcuts()\n\n        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n        self._focus_timer.start(100)\n\n        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n        \n        # 连接媒体播放器信号\n        self.media_player.stateChanged.connect(self.on_state_changed)\n        self.media_player.positionChanged.connect(self.on_position_changed)\n        self.media_player.durationChanged.connect(self.on_duration_changed)\n        self.media_player.mediaStatusChanged.connect(self.on_media_status_changed)\n    \n    def load_thumbnail(self):\n        \"\"\"加载视频缩略图\"\"\"\n        import os  # 将os导入移到函数开头\n        try:\n            logger.debug(\"开始加载缩略图...\")\n            logger.debug(f\"视频数据: {self.video_data}\")\n            \n            # 获取缩略图路径\n            thumbnail_path = self.video_data.get('thumbnail_local_path', '')\n            logger.debug(f\"从video_data获取的thumbnail_local_path: {thumbnail_path}\")\n            \n            if thumbnail_path and os.path.exists(thumbnail_path):\n                logger.debug(f\"找到现有缩略图文件: {thumbnail_path}\")\n                # 使用现有缩略图\n                pixmap = QPixmap(thumbnail_path)\n                logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n            else:\n                logger.debug(\"缩略图文件不存在或路径为空，开始生成缩略图...\")\n                # 生成缩略图\n                video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n                logger.debug(f\"视频文件路径: {video_path}\")\n                \n                if video_path and os.path.exists(video_path):\n                    logger.debug(\"视频文件存在，开始生成缩略图...\")\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    from config.app_config import get_storage_dir\n                    storage_dir = get_storage_dir()\n                    thumbnails_dir = os.path.join(storage_dir, 'thumbnails')\n                    logger.debug(f\"缩略图目录: {thumbnails_dir}\")\n                    \n                    generator = VideoThumbnailGenerator(thumbnails_dir)\n                    video_id = self.video_data.get('id', os.path.basename(video_path).split('.')[0])\n                    logger.debug(f\"视频ID: {video_id}\")\n                    \n                    thumbnail_path = generator.generate_thumbnail_for_video(video_path, video_id)\n                    logger.debug(f\"生成的缩略图路径: {thumbnail_path}\")\n                    \n                    if thumbnail_path and os.path.exists(thumbnail_path):\n                        logger.debug(\"缩略图生成成功，加载到QPixmap...\")\n                        pixmap = QPixmap(thumbnail_path)\n                        logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n                    else:\n                        logger.debug(\"缩略图生成失败，使用默认图片\")\n                        # 使用默认图片\n                        pixmap = self.create_default_thumbnail()\n                else:\n                    logger.debug(\"视频文件不存在，使用默认图片\")\n                    pixmap = self.create_default_thumbnail()\n            \n            if not pixmap.isNull():\n                logger.debug(\"开始缩放图片...\")\n                # 缩放图片以适应标签大小\n                label_size = self.thumbnail_label.size()\n                logger.debug(f\"标签大小: {label_size}\")\n                \n                scaled_pixmap = pixmap.scaled(\n                    label_size,\n                    Qt.KeepAspectRatio,\n                    Qt.SmoothTransformation\n                )\n                logger.debug(f\"缩放后图片大小: {scaled_pixmap.size()}\")\n                \n                self.thumbnail_label.setPixmap(scaled_pixmap)\n                logger.debug(\"缩略图设置成功\")\n            else:\n                logger.debug(\"QPixmap为空，显示错误文本\")\n                self.thumbnail_label.setText(\"无法加载缩略图\")\n                \n        except Exception as e:\n            logger.debug(f\"加载缩略图异常: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.thumbnail_label.setText(\"缩略图加载失败\")\n    \n    def create_default_thumbnail(self):\n        \"\"\"创建默认缩略图\"\"\"\n        pixmap = QPixmap(400, 300)\n        pixmap.fill(Qt.black)\n        \n        from PyQt5.QtGui import QPainter, QFont\n        painter = QPainter(pixmap)\n        painter.setPen(Qt.white)\n        painter.setFont(QFont())  # Font configuration handled by unified style system\n        painter.drawText(pixmap.rect(), Qt.AlignCenter, \"视频预览\")\n        painter.end()\n        \n        return pixmap\n    \n    def on_thumbnail_click(self, event):\n        \"\"\"缩略图点击事件\"\"\"\n        self.start_video_playback()\n    \n    def start_video_playback(self):\n        \"\"\"开始视频播放\"\"\"\n        logger.debug(\"[UI] 开始视频播放…\")\n        \n        # 检查视频文件\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        logger.debug(f\"[UI] 视频文件路径: {video_path}\")\n        \n        if not video_path or not os.path.exists(video_path):\n            logger.warning(f\"[UI] 视频文件不存在: {video_path}\")\n            from PyQt5.QtWidgets import QMessageBox\n            QMessageBox.critical(self, \"错误\", \"视频文件不存在\")\n            return\n        \n        # 切换到视频播放器\n        logger.debug(\"[UI] 切换到视频播放器\")\n        self.video_stack.setCurrentIndex(1)\n        self.is_playing = True\n        \n        # 重新设置媒体内容\n        from PyQt5.QtCore import QUrl\n        from PyQt5.QtMultimedia import QMediaContent\n        logger.debug(\"[UI] 重新设置媒体内容\")\n        self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(video_path)))\n        \n        # 开始播放\n        logger.debug(\"[UI] 开始播放视频\")\n        self.media_player.play()\n    \n    def toggle_play_pause(self):\n        \"\"\"切换播放/暂停\"\"\"\n        if not self.is_playing:\n            # 如果还在缩略图模式，开始播放\n            self.start_video_playback()\n        else:\n            # 在播放模式下切换播放/暂停\n            if self.is_using_opencv:\n                # OpenCV播放器暂停/继续\n                if self.cv_timer.isActive():\n                    self.cv_timer.stop()\n                    self.play_button.setText(\"▶\")\n                else:\n                    # 重新启动定时器\n                    fps = self.cv_cap.get(cv2.CAP_PROP_FPS) if self.cv_cap else 30\n                    if fps <= 0:\n                        fps = 30\n                    interval = int(1000 / fps)\n                    self.cv_timer.start(interval)\n                    self.play_button.setText(\"⏸\")\n            else:\n                # Qt播放器暂停/继续\n                if self.media_player.state() == QMediaPlayer.PlayingState:\n                    self.media_player.pause()\n                else:\n                    self.media_player.play()\n    \n    def on_state_changed(self, state):\n        \"\"\"播放状态改变\"\"\"\n        if state == QMediaPlayer.PlayingState:\n            self.play_button.setText(\"⏸\")\n        else:\n            self.play_button.setText(\"▶\")\n    \n    def on_position_changed(self, position):\n        \"\"\"播放位置改变\"\"\"\n        duration = self.media_player.duration()\n        if duration > 0:\n            current_time = self.format_duration(position)\n            total_time = self.format_duration(duration)\n            self.progress_label.setText(f\"{current_time} / {total_time}\")\n    \n    def on_duration_changed(self, duration):\n        \"\"\"视频时长改变\"\"\"\n        if duration > 0:\n            total_time = self.format_duration(duration)\n            self.progress_label.setText(f\"00:00 / {total_time}\")\n    \n    def on_media_error(self, error):\n        \"\"\"媒体播放错误处理\"\"\"\n        error_string = self.media_player.errorString()\n        logger.error(f\"[MEDIA] 播放错误: {error}, 信息: {error_string}\")\n        \n        # 尝试使用OpenCV播放器作为备选方案\n        if not self.is_using_opencv:\n            logger.warning(\"[MEDIA] 尝试使用OpenCV播放器…\")\n            if self.start_opencv_playback():\n                return\n        \n        # 如果OpenCV也失败，显示错误信息\n        from PyQt5.QtWidgets import QMessageBox\n        msg_box = QMessageBox()\n        msg_box.setIcon(QMessageBox.Critical)\n        msg_box.setText(\"视频播放错误\")\n        msg_box.setInformativeText(f\"无法播放视频: {error_string}\\n\\n可能的原因:\\n1. 系统缺少必要的视频编解码器\\n2. 视频文件损坏\\n3. 视频格式不支持\\n\\n建议解决方案:\\n1. 安装K-Lite Codec Pack\\n2. 使用其他视频播放器测试文件\")\n        msg_box.exec_()\n        \n        # 返回缩略图模式\n        self.video_stack.setCurrentIndex(0)\n        self.is_playing = False\n    \n    def on_media_status_changed(self, status):\n        \"\"\"媒体状态改变\"\"\"\n        from PyQt5.QtMultimedia import QMediaPlayer\n        \n        logger.debug(f\"[MEDIA] 状态改变: {status}\")\n        \n        if status == QMediaPlayer.EndOfMedia:\n            # 视频播放结束，返回缩略图模式\n            logger.debug(\"[MEDIA] 播放结束，切回缩略图模式\")\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n            self.media_player.setPosition(0)  # 重置播放位置\n            self.progress_label.setText(\"00:00 / 00:00\")\n        elif status == QMediaPlayer.InvalidMedia:\n            logger.warning(\"[MEDIA] 媒体文件无效\")\n        elif status == QMediaPlayer.BufferedMedia:\n            logger.debug(\"[MEDIA] 媒体缓冲完成\")\n        elif status == QMediaPlayer.LoadingMedia:\n            logger.debug(\"[MEDIA] 正在加载媒体\")\n        elif status == QMediaPlayer.StalledMedia:\n            logger.debug(\"[MEDIA] 播放卡顿\")\n    \n    def format_duration(self, ms):\n        \"\"\"格式化时长显示\"\"\"\n        seconds = ms // 1000\n        minutes = seconds // 60\n        seconds = seconds % 60\n        return f\"{minutes:02d}:{seconds:02d}\"\n    \n    def start_opencv_playback(self):\n        \"\"\"启动OpenCV视频播放器\"\"\"\n        try:\n            import cv2\n            \n            # 停止当前的Qt播放器\n            self.media_player.stop()\n            \n            # 获取视频文件路径\n            video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n            if not video_path or not os.path.exists(video_path):\n                logger.warning(f\"[MEDIA] OpenCV：视频文件不存在: {video_path}\")\n                return False\n            \n            # 打开视频文件\n            self.cv_cap = cv2.VideoCapture(video_path)\n            if not self.cv_cap.isOpened():\n                logger.error(\"[MEDIA] OpenCV：无法打开视频文件\")\n                return False\n            \n            # 获取视频信息\n            fps = self.cv_cap.get(cv2.CAP_PROP_FPS)\n            if fps <= 0:\n                fps = 30  # 默认帧率\n            \n            # 设置帧更新定时器\n            interval = int(1000 / fps)  # 毫秒\n            self.cv_timer.start(interval)\n            \n            # 切换到OpenCV播放器\n            self.video_stack.setCurrentIndex(2)\n            self.is_using_opencv = True\n            self.is_playing = True\n            \n            logger.debug(f\"[MEDIA] OpenCV播放器启动成功，FPS: {fps}\")\n            return True\n            \n        except ImportError:\n            logger.warning(\"[MEDIA] OpenCV未安装，无法使用OpenCV播放器\")\n            return False\n        except Exception as e:\n            logger.error(f\"[MEDIA] OpenCV播放器启动失败: {e}\")\n            import traceback\n            traceback.print_exc()\n            return False\n    \n    def update_opencv_frame(self):\n        \"\"\"更新OpenCV视频帧\"\"\"\n        try:\n            if not self.cv_cap or not self.cv_cap.isOpened():\n                logger.error(\"[MEDIA] OpenCV：视频捕获器未打开\")\n                self.stop_opencv_playback()\n                return\n            \n            # 读取帧\n            ret, frame = self.cv_cap.read()\n            if not ret:\n                logger.debug(\"[MEDIA] OpenCV：播放结束\")\n                self.stop_opencv_playback()\n                return\n            \n            # 转换颜色空间（BGR到RGB）\n            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            \n            # 转换为QImage\n            height, width, channel = frame_rgb.shape\n            bytes_per_line = 3 * width\n            from PyQt5.QtGui import QImage\n            q_img = QImage(frame_rgb.data, width, height, bytes_per_line, QImage.Format_RGB888)\n            \n            # 转换为QPixmap并显示\n            from PyQt5.QtGui import QPixmap\n            pixmap = QPixmap.fromImage(q_img)\n            \n            # 缩放以适应标签大小\n            label_size = self.opencv_video_label.size()\n            scaled_pixmap = pixmap.scaled(\n                label_size,\n                Qt.KeepAspectRatio,\n                Qt.SmoothTransformation\n            )\n            \n            self.opencv_video_label.setPixmap(scaled_pixmap)\n            \n        except Exception as e:\n            logger.error(f\"[MEDIA] OpenCV更新帧失败: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.stop_opencv_playback()\n    \n    def stop_opencv_playback(self):\n        \"\"\"停止OpenCV视频播放\"\"\"\n        try:\n            # 停止定时器\n            self.cv_timer.stop()\n            \n            # 释放视频捕获器\n            if self.cv_cap:\n                self.cv_cap.release()\n                self.cv_cap = None\n            \n            # 清空显示\n            self.opencv_video_label.clear()\n            self.opencv_video_label.setText(\"视频播放结束\")\n            \n            # 返回缩略图模式\n            self.video_stack.setCurrentIndex(0)\n            self.is_using_opencv = False\n            self.is_playing = False\n            \n            logger.debug(\"[MEDIA] OpenCV播放器停止\")\n            \n        except Exception as e:\n            logger.error(f\"[MEDIA] OpenCV播放器停止失败: {e}\")\n    \n    def format_time(self, time_str: str) -> str:\n        \"\"\"格式化时间显示\"\"\"\n        if not time_str:\n            return '未知时间'\n        try:\n            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n            return dt.strftime('%Y-%m-%d %H:%M:%S')\n        except:\n            return time_str[:19] if len(time_str) > 19 else time_str\n    \n    def format_file_size(self, size) -> str:\n        \"\"\"格式化文件大小显示\"\"\"\n        try:\n            size = float(size) if size else 0\n        except (ValueError, TypeError):\n            return '未知大小'\n            \n        if size == 0:\n            return '未知大小'\n        \n        for unit in ['B', 'KB', 'MB', 'GB']:\n            if size < 1024.0:\n                return f\"{size:.1f} {unit}\"\n            size /= 1024.0\n        return f\"{size:.1f} TB\"\n    \n    def setup_shortcuts(self):\n        \"\"\"设置键盘快捷键\"\"\"\n        # 移除所有QShortcut，统一使用keyPressEvent处理\n        # 避免快捷键冲突问题\n        pass\n    \n    def _ensure_focus(self):\n        \"\"\"确保窗口获得焦点\"\"\"\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        logger.debug(f\"[FOCUS] VideoDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n    \n    def keyPressEvent(self, event):\n        \"\"\"键盘事件处理\"\"\"\n        from PyQt5.QtCore import Qt\n        \n        logger.debug(f\"[KEYBOARD] VideoDetailDialog键盘事件: {event.key()}\")\n        \n        if event.key() == Qt.Key_Left:\n            # 左方向键：上一个视频\n            logger.debug(f\"[KEYBOARD] 左键pressed，prev_btn enabled: {self.prev_btn.isEnabled()}\")\n            if self.prev_btn.isEnabled():\n                self.show_previous_video()\n            event.accept()\n        elif event.key() == Qt.Key_Right:\n            # 右方向键：下一个视频\n            logger.debug(f\"[KEYBOARD] 右键pressed，next_btn enabled: {self.next_btn.isEnabled()}\")\n            if self.next_btn.isEnabled():\n                self.show_next_video()\n            event.accept()\n        elif event.key() == Qt.Key_Escape:\n            # ESC键：关闭对话框（保持原有功能）\n            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n            if self.is_fullscreen:\n                self.exit_fullscreen()\n            else:\n                self.accept()\n            event.accept()\n        elif event.key() == Qt.Key_F11:\n            # F11键：全屏切换（保持原有功能）\n            self.toggle_fullscreen()\n            event.accept()\n        elif event.key() == Qt.Key_Space:\n            # 空格键：播放/暂停\n            self.toggle_play_pause()\n            event.accept()\n        else:\n            # 其他按键交给父类处理\n            super().keyPressEvent(event)\n    \n    def toggle_fullscreen(self):\n        \"\"\"切换全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.enter_fullscreen()\n    \n    def enter_fullscreen(self):\n        \"\"\"进入全屏模式\"\"\"\n        if not self.is_fullscreen:\n            self.original_geometry = self.geometry()\n            self.showFullScreen()\n            self.is_fullscreen = True\n    \n    def exit_fullscreen(self):\n        \"\"\"退出全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.showNormal()\n            if self.original_geometry:\n                self.setGeometry(self.original_geometry)\n            self.is_fullscreen = False\n    \n    def handle_escape_key(self):\n        \"\"\"处理ESC键\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.accept()\n    \n    def copy_prompt(self):\n        \"\"\"复制提示词到剪贴板\"\"\"\n        prompt_content = self.prompt_text_edit.toPlainText()\n        clipboard = QApplication.clipboard()\n        clipboard.setText(prompt_content)\n        self.show_copy_toast(\"提示词已复制到剪贴板\")\n    \n    def show_copy_toast(self, message: str):\n        \"\"\"显示复制成功的轻量提示\"\"\"\n        toast = QLabel(message, self)\n        toast.setObjectName(\"ToastLabel\")\n        toast.setAlignment(Qt.AlignCenter)\n        toast.adjustSize()\n        \n        x = (self.width() - toast.width()) // 2\n        y = self.height() // 4\n        toast.move(x, y)\n        toast.show()\n        \n        QTimer.singleShot(2000, toast.deleteLater)\n\n    def _on_reference_clicked(self, asset: Dict[str, Any]):\n        assets = list(self._reference_assets) if self._reference_assets else [asset]\n        start_idx = _find_reference_asset_index(assets, asset)\n        open_reference_preview(\n            self,\n            asset,\n            title_prefix=\"参考图\",\n            asset_list=assets,\n            start_index=start_idx,\n            on_asset_changed=self._sync_reference_selection,\n        )\n\n    def _on_reference_export(self, asset: Dict[str, Any]):\n        export_reference_asset(self, asset)\n\n    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n        asset_path = None\n        if isinstance(asset, dict):\n            asset_path = asset.get('absolute_path') or asset.get('path')\n        has_path = bool(asset_path and os.path.exists(asset_path))\n        if hasattr(self, 'reference_export_btn'):\n            self.reference_export_btn.setEnabled(has_path)\n\n    def _export_selected_reference(self):\n        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n        if not asset:\n            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n            return\n        export_reference_asset(self, asset)\n\n    def _refresh_reference_gallery(self):\n        if not hasattr(self, 'reference_gallery'):\n            return\n        self._reference_summary = ensure_reference_info(self.video_data)\n        if self._reference_summary.get('count', 0) <= 0:\n            self.reference_gallery.setVisible(False)\n            self.reference_gallery.clear()\n            if hasattr(self, 'reference_export_btn'):\n                self.reference_export_btn.setEnabled(False)\n            self._reference_assets = []\n            self._export_controller.refresh()\n            return\n        try:\n            self._reference_assets = resolve_reference_assets(self.video_data, absolute=True)\n        except Exception:\n            self._reference_assets = []\n        self.reference_gallery.set_assets(self._reference_assets)\n        self.reference_gallery.setVisible(True)\n        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n        self._export_controller.refresh()\n\n    def _sync_reference_selection(self, asset: Dict[str, Any]):\n        try:\n            self.reference_gallery.select_asset(asset)\n        except Exception:\n            pass\n\n    def _resolve_video_record_id(self) -> Optional[str]:\n        for key in (\"file_id\", \"id\", \"generation_id\"):\n            value = self.video_data.get(key)\n            if value not in (None, \"\"):\n                return str(value)\n        return None\n\n    def download_video(self):\n        \"\"\"下载视频到指定位置\"\"\"\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if not video_path or not os.path.exists(video_path):\n            self.show_styled_message(\"错误\", \"视频文件不存在\", \"warning\")\n            return\n        \n        file_dialog = QFileDialog()\n        save_path, _ = file_dialog.getSaveFileName(\n            self,\n            \"保存视频\",\n            f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4\",\n            \"视频文件 (*.mp4)\"\n        )\n        \n        if save_path:\n            try:\n                import shutil\n                shutil.copy2(video_path, save_path)\n                self.show_copy_toast(f\"视频已保存到: {os.path.basename(save_path)}\")\n            except Exception as e:\n                self.show_styled_message(\"错误\", f\"保存视频失败: {str(e)}\", \"critical\")\n    \n    def update_navigation_buttons(self):\n        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n        logger.debug(f\"[NAV] 更新导航按钮：当前索引{self.current_index}，总记录数{len(self.video_list)}\")\n        \n        has_prev = self._has_valid_previous_record()\n        has_next = self._has_valid_next_record()\n        \n        logger.debug(f\"[NAV] 有效记录检查：prev={has_prev}, next={has_next}\")\n        \n        self.prev_btn.setEnabled(has_prev)\n        self.next_btn.setEnabled(has_next)\n    \n    def _has_valid_previous_record(self):\n        \"\"\"检查是否有有效的上一个记录\"\"\"\n        logger.debug(f\"[NAV] 检查上一个记录：从索引{self.current_index - 1}到0\")\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            content_type = candidate_data.get('content_type', '')\n            \n            # 检查文件扩展名，确保是视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                logger.debug(f\"[NAV] 找到有效的上一个视频记录：索引{i}\")\n                return True\n        logger.debug(f\"[NAV] 没有找到有效的上一个视频记录\")\n        return False\n    \n    def _has_valid_next_record(self):\n        \"\"\"检查是否有有效的下一个记录\"\"\"\n        logger.debug(f\"[NAV] 检查下一个记录：从索引{self.current_index + 1}到{len(self.video_list) - 1}\")\n        for i in range(self.current_index + 1, len(self.video_list)):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            content_type = candidate_data.get('content_type', '')\n            \n            # 检查文件扩展名，确保是视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                logger.debug(f\"[NAV] 找到有效的下一个视频记录：索引{i}\")\n                return True\n        logger.debug(f\"[NAV] 没有找到有效的下一个视频记录\")\n        return False\n    \n    def show_previous_video(self):\n        \"\"\"显示上一个视频（带有效性验证）\"\"\"\n        # 寻找上一个有效视频记录\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            # 检查是否为视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                # 找到有效视频记录\n                logger.debug(f\"[NAV] 切换到上一个视频：索引{i}\")\n                self.current_index = i\n                self.video_data = self.video_list[i]\n                self.load_video()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的上一个视频记录，保持当前状态\n        logger.debug(f\"[NAV] 没有上一个视频可切换\")\n        self.update_navigation_buttons()\n    \n    def show_next_video(self):\n        \"\"\"显示下一个视频（带有效性验证）\"\"\"\n        # 寻找下一个有效视频记录\n        for i in range(self.current_index + 1, len(self.video_list)):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            # 检查是否为视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                # 找到有效视频记录\n                logger.debug(f\"[NAV] 切换到下一个视频：索引{i}\")\n                self.current_index = i\n                self.video_data = self.video_list[i]\n                self.load_video()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的下一个视频记录，保持当前状态\n        logger.debug(f\"[NAV] 没有下一个视频可切换\")\n        self.update_navigation_buttons()\n    \n    def load_video(self):\n        \"\"\"加载新视频\"\"\"\n        logger.debug(\"[UI] 加载新视频…\")\n        \n        # 停止当前播放器\n        if hasattr(self, 'is_using_opencv') and self.is_using_opencv:\n            logger.debug(\"[MEDIA] 停止OpenCV播放器\")\n            self.stop_opencv_playback()\n        else:\n            logger.debug(\"[MEDIA] 停止Qt播放器\")\n            if self.media_player:\n                self.media_player.stop()\n        \n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if video_path and os.path.exists(video_path):\n            from PyQt5.QtCore import QUrl\n            self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(video_path)))\n            \n            # 重置到缩略图模式\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n            \n            # 重新加载缩略图\n            self.load_thumbnail()\n            \n            # 更新右侧信息\n            prompt_content = self.video_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n            \n            # 更新参数信息\n            self.update_video_params()\n            \n            logger.debug(\"[UI] 新视频加载完成\")\n        else:\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n    \n    def update_video_params(self):\n        \"\"\"更新视频参数显示（切换视频时调用）\"\"\"\n        try:\n            # 解析生成参数\n            params = self.video_data.get('parameters', '{}')\n            if isinstance(params, str):\n                try:\n                    params = json.loads(params)\n                except:\n                    params = {}\n            \n            # 重新构建参数信息\n            info_items = [\n                (\"分辨率\", build_resolution_text(self.video_data)),\n                (\"时长\", f\"{self.video_data.get('duration', '未知')}秒\"),\n                (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n                (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n                (\"文件大小\", self.format_file_size(self.video_data.get('file_size', 0))),\n                (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n            ]\n            \n            # 更新已保存的标签\n            for label, new_value in info_items:\n                if label in self.param_value_labels:\n                    self.param_value_labels[label].setText(str(new_value))\n            \n            logger.debug(\"视频参数已更新\")\n            \n        except Exception as e:\n            logger.error(f\"更新视频参数失败: {e}\")\n    \n    def update_param_labels(self):\n        \"\"\"更新参数标签内容\"\"\"\n        try:\n            # 更新各个参数标签\n            param_updates = {\n                \"分辨率\": build_resolution_text(self.video_data),\n                \"时长\": f\"{self.video_data.get('duration', '未知')}秒\",\n                \"模型\": get_model_display_name(pick_model_code(self.video_data)),\n                \"生成时间\": self.format_time(self.video_data.get('created_at', '')),\n                \"文件大小\": self.format_file_size(self.video_data.get('file_size', 0)),\n                \"文件路径\": self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n            }\n            \n            for param_name, new_value in param_updates.items():\n                if param_name in self.param_labels:\n                    self.param_labels[param_name].setText(str(new_value))\n                    logger.debug(f\"已更新参数 {param_name}: {new_value}\")\n            \n            logger.debug(\"视频参数标签更新完成\")\n        except Exception as e:\n            logger.error(f\"更新视频参数标签失败: {e}\")\n    \n    def closeEvent(self, event):\n        \"\"\"窗口关闭事件\"\"\"\n        # 停止OpenCV播放器\n        if self.is_using_opencv:\n            self.stop_opencv_playback()\n\n        # 停止Qt播放器\n        if self.media_player:\n            self.media_player.stop()\n\n        try:\n            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n                self._focus_timer.stop()\n        except Exception:\n            pass\n\n        try:\n            self._export_controller.dispose()\n        except Exception:\n            pass\n\n        super().closeEvent(event)\n    \n    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n        \"\"\"显示带有深色主题样式的消息框\"\"\"\n        from PyQt5.QtWidgets import QMessageBox\n        \n        msg_box = QMessageBox(self)\n        msg_box.setWindowTitle(title)\n        msg_box.setText(message)\n        \n        # 设置图标\n        if icon_type == \"warning\":\n            msg_box.setIcon(QMessageBox.Warning)\n        elif icon_type == \"critical\":\n            msg_box.setIcon(QMessageBox.Critical)\n        elif icon_type == \"question\":\n            msg_box.setIcon(QMessageBox.Question)\n        else:\n            msg_box.setIcon(QMessageBox.Information)\n        \n        # 样式由全局QSS控制\n        \n        msg_box.exec_()\n","numLines":1247,"startLine":1,"totalLines":1247}}}
{"parentUuid":"f6439311-4f33-460a-8150-8dc7a7ec7f6b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01N8SENEjUUR1jUwQGC2kGoG","type":"tool_result","content":"     1→import os\n     2→import json\n     3→from datetime import datetime\n     4→from typing import Dict, Any, List, Optional\n     5→\n     6→from PyQt5.QtWidgets import (\n     7→    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n     8→    QTextEdit, QFileDialog, QMessageBox, QSplitter, QApplication,\n     9→    QShortcut, QMenu, QAction, QSizePolicy\n    10→)\n    11→from PyQt5.QtCore import Qt, QTimer, QSize, QEvent\n    12→from PyQt5.QtGui import QPixmap, QKeySequence\n    13→\n    14→from utils.logger import logger\n    15→from components.widgets import ZoomableImageLabel, ZoomableTextEdit, ClickableLabel\n    16→from components.reference_assets import (\n    17→    ReferenceGalleryWidget,\n    18→    export_reference_asset,\n    19→    open_reference_preview,\n    20→    _find_reference_asset_index,\n    21→)\n    22→from components.controllers import ExportBundleController\n    23→from utils.reference_display import ensure_reference_info, resolve_reference_assets\n    24→\n    25→class ImageDetailDialog(QDialog):\n    26→    \"\"\"图片详细信息对话框\"\"\"\n    27→    \n    28→    def __init__(self, image_data: Dict[str, Any], image_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n    29→        super().__init__(parent)\n    30→        self.image_data = image_data\n    31→        self.image_list = image_list or [image_data]  # 图片列表\n    32→        self.current_index = current_index  # 当前图片索引\n    33→        self.zoom_factor = 1.0  # 缩放因子\n    34→        self.is_fullscreen = False  # 全屏状态\n    35→        self.original_geometry = None  # 原始窗口几何\n    36→        self._reference_summary = ensure_reference_info(self.image_data)\n    37→        self._reference_assets: List[Dict[str, Any]] = []\n    38→        self._export_controller = ExportBundleController(self, \"image\")\n    39→        self.setup_ui()\n    40→        \n    41→    def setup_ui(self):\n    42→        \"\"\"设置UI\"\"\"\n    43→        self.setWindowTitle(\"图片详细信息\")\n    44→        self.resize(1100, 800)  # 改为可调整大小\n    45→        self.setMinimumSize(800, 600)  # 设置最小尺寸\n    46→        \n    47→        # 设置焦点策略，确保能接收键盘事件\n    48→        self.setFocusPolicy(Qt.StrongFocus)\n    49→        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n    50→        self.setFocus()\n    51→\n    52→        # 确保窗口激活时获得焦点\n    53→        self.activateWindow()\n    54→        self.raise_()\n    55→\n    56→        try:\n    57→            self.setObjectName(\"DetailDialog\")\n    58→        except Exception:\n    59→            pass\n    60→\n    61→        self._focus_timer = QTimer(self)\n    62→        self._focus_timer.setSingleShot(True)\n    63→        self._focus_timer.timeout.connect(self._ensure_focus)\n    64→\n    65→        layout = QHBoxLayout(self)\n    66→        \n    67→        # 左侧：大图显示（占70%宽度）\n    68→        left_widget = QWidget()\n    69→        left_layout = QVBoxLayout(left_widget)\n    70→        left_layout.setContentsMargins(0, 0, 0, 0)\n    71→        \n    72→        # 图片显示区域（占据上方全部空间）\n    73→        image_container = QWidget()\n    74→        image_container.setObjectName(\"ImageContainer\")\n    75→        image_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n    76→\n    77→        # 在容器内创建布局\n    78→        container_layout = QVBoxLayout(image_container)\n    79→        container_layout.setContentsMargins(0, 0, 0, 0)\n    80→        container_layout.setSpacing(0)\n    81→\n    82→        # 使用可缩放的图片标签，自适应容器大小\n    83→        self.large_image_label = ZoomableImageLabel()\n    84→        self.large_image_label.setAlignment(Qt.AlignCenter)\n    85→        self.large_image_label.setStyleSheet(\"border: none; background-color: transparent;\")\n    86→        \n    87→        # 设置右键菜单\n    88→        self.large_image_label.setContextMenuPolicy(Qt.CustomContextMenu)\n    89→        self.large_image_label.customContextMenuRequested.connect(self.show_context_menu)\n    90→        \n    91→        # 加载大图\n    92→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n    93→        if image_path and os.path.exists(image_path):\n    94→            pixmap = QPixmap(image_path)\n    95→            if not pixmap.isNull():\n    96→                self.large_image_label.setPixmap(pixmap)\n    97→        \n    98→        container_layout.addWidget(self.large_image_label, 1)\n    99→\n   100→        reference_section = QWidget()\n   101→        reference_section.setObjectName(\"ReferenceSection\")\n   102→        reference_section.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   103→        reference_section_layout = QVBoxLayout(reference_section)\n   104→        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n   105→        reference_section_layout.setSpacing(8)\n   106→\n   107→        self.reference_gallery = ReferenceGalleryWidget()\n   108→        self.reference_gallery.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   109→        try:\n   110→            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n   111→            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n   112→            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n   113→        except Exception:\n   114→            pass\n   115→        reference_section_layout.addWidget(self.reference_gallery, 1)\n   116→\n   117→        reference_button_layout = QHBoxLayout()\n   118→        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n   119→        reference_button_layout.setSpacing(6)\n   120→        self.export_status_label = QLabel(\"\")\n   121→        self.export_status_label.setStyleSheet(\"color: #bbbbbb; ;\")\n   122→        reference_button_layout.addWidget(self.export_status_label)\n   123→        reference_button_layout.addStretch(1)\n   124→        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n   125→        self.reference_export_btn.setEnabled(False)\n   126→        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n   127→        reference_button_layout.addWidget(self.reference_export_btn)\n   128→        self.export_bundle_btn = QPushButton(\"导出记录\")\n   129→        self.export_bundle_btn.setEnabled(False)\n   130→        self._export_controller.configure(\n   131→            self.export_bundle_btn,\n   132→            self.export_status_label,\n   133→            self._resolve_record_id,\n   134→            context_widget=self,\n   135→        )\n   136→        reference_button_layout.addWidget(self.export_bundle_btn)\n   137→        reference_section_layout.addLayout(reference_button_layout)\n   138→\n   139→        self._image_reference_splitter = QSplitter(Qt.Vertical)\n   140→        self._image_reference_splitter.setObjectName(\"ImageReferenceSplitter\")\n   141→        self._image_reference_splitter.setChildrenCollapsible(False)\n   142→        self._image_reference_splitter.setHandleWidth(6)\n   143→        self._image_reference_splitter.addWidget(image_container)\n   144→        self._image_reference_splitter.addWidget(reference_section)\n   145→        self._image_reference_splitter.setStretchFactor(0, 3)\n   146→        self._image_reference_splitter.setStretchFactor(1, 2)\n   147→        self._image_reference_splitter.setSizes([520, 280])\n   148→\n   149→        left_layout.addWidget(self._image_reference_splitter, 1)\n   150→\n   151→        # 底部区域：导航按钮 + 说明文本框（与右侧参数栏高度对齐）\n   152→        bottom_layout = QHBoxLayout()\n   153→        bottom_layout.setContentsMargins(0, 5, 0, 5)\n   154→        bottom_layout.setSpacing(10)\n   155→        \n   156→        # 向左按钮\n   157→        self.prev_btn = QPushButton(\"◀\")\n   158→        self.prev_btn.setFixedSize(30, 30)  # 固定尺寸\n   159→        self.prev_btn.setObjectName(\"NavButton\")\n   160→        self.prev_btn.clicked.connect(self.show_previous_image)\n   161→        bottom_layout.addWidget(self.prev_btn)\n   162→        \n   163→        # 中间的说明文本框（完全透明设计）\n   164→        zoom_info = QLabel(\"提示：鼠标位置缩放，点击拖拽，双击重置\")\n   165→        zoom_info.setStyleSheet(\"\"\"\n   166→            QLabel {\n   167→                color: #cccccc; \n   168→                ; \n   169→                padding: 0px;\n   170→                margin: 0px;\n   171→                background-color: transparent;\n   172→                border: none;\n   173→                border-radius: 0px;\n   174→                line-height: 1.2;\n   175→            }\n   176→        \"\"\")\n   177→        zoom_info.setAlignment(Qt.AlignCenter)\n   178→        zoom_info.setMinimumHeight(30)  # 与按钮高度一致\n   179→        zoom_info.setMaximumHeight(30)  # 固定高度，防止文字被压缩\n   180→        bottom_layout.addWidget(zoom_info, 1)  # 占据中间所有空间\n   181→        \n   182→        # 向右按钮\n   183→        self.next_btn = QPushButton(\"▶\")\n   184→        self.next_btn.setFixedSize(30, 30)  # 固定尺寸\n   185→        self.next_btn.setObjectName(\"NavButton\")\n   186→        self.next_btn.clicked.connect(self.show_next_image)\n   187→        bottom_layout.addWidget(self.next_btn)\n   188→        \n   189→        left_layout.addLayout(bottom_layout)\n   190→\n   191→        # 更新导航按钮状态\n   192→        self.update_navigation_buttons()\n   193→        self._refresh_reference_gallery()\n   194→        self._export_controller.refresh()\n   195→\n   196→        # 右侧：详细信息（固定30%宽度）\n   197→        right_layout = QVBoxLayout()\n   198→        \n   199→        # 创建参数显示区域（不使用滚动条）\n   200→        params_widget = QWidget()\n   201→        params_widget.setFixedWidth(int(self.width() * 0.3))  # 固定30%宽度\n   202→        params_widget.setObjectName(\"ParamsWidget\")\n   203→        self.params_layout = QVBoxLayout(params_widget)  # 保存引用以便后续更新\n   204→        self.params_layout.setSpacing(0)  # 设置间距为0\n   205→        self.params_layout.setContentsMargins(5, 5, 5, 5)  # 设置紧凑的边距\n   206→        \n   207→        # 初始化参数显示区域\n   208→        self.setup_params_area()\n   209→        \n   210→        \n   211→        right_layout.addWidget(params_widget)\n   212→        \n   213→        # 全屏和复制图片按钮（与参数区底部对齐）\n   214→        image_control_layout = QHBoxLayout()\n   215→        \n   216→        fullscreen_btn = QPushButton(\"全屏 (F11)\")\n   217→        fullscreen_btn.setMaximumHeight(30)\n   218→        fullscreen_btn.setStyleSheet(\"\"\"\n   219→            QPushButton {\n   220→                background-color: transparent;\n   221→                color: #ffffff;\n   222→                border: 1px solid #666;\n   223→                border-radius: 4px;\n   224→                padding: 5px 10px;\n   225→                ;\n   226→            }\n   227→            QPushButton:hover {\n   228→                background-color: #3a3a4e;\n   229→                border-color: #888;\n   230→            }\n   231→        \"\"\")\n   232→        fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n   233→        image_control_layout.addWidget(fullscreen_btn)\n   234→        \n   235→        copy_image_btn = QPushButton(\"复制图片\")\n   236→        copy_image_btn.setMaximumHeight(30)\n   237→        copy_image_btn.setStyleSheet(\"\"\"\n   238→            QPushButton {\n   239→                background-color: transparent;\n   240→                color: #ffffff;\n   241→                border: 1px solid #666;\n   242→                border-radius: 4px;\n   243→                padding: 5px 10px;\n   244→                ;\n   245→            }\n   246→            QPushButton:hover {\n   247→                background-color: #3a3a4e;\n   248→                border-color: #888;\n   249→            }\n   250→        \"\"\")\n   251→        copy_image_btn.clicked.connect(self.copy_image)\n   252→        image_control_layout.addWidget(copy_image_btn)\n   253→        \n   254→        right_layout.addLayout(image_control_layout)\n   255→        \n   256→        # 其他按钮\n   257→        button_layout = QHBoxLayout()\n   258→        \n   259→        copy_all_btn = QPushButton(\"复制所有信息\")\n   260→        copy_all_btn.clicked.connect(self.copy_all_info)\n   261→        button_layout.addWidget(copy_all_btn)\n   262→        \n   263→        close_btn = QPushButton(\"关闭（ESC）\")\n   264→        close_btn.clicked.connect(self.accept)\n   265→        button_layout.addWidget(close_btn)\n   266→        \n   267→        right_layout.addLayout(button_layout)\n   268→        \n   269→        # 设置布局比例：左侧70%，右侧30%\n   270→        layout.addWidget(left_widget, 7)\n   271→        layout.addLayout(right_layout, 3)\n   272→        \n   273→        # 添加键盘快捷键\n   274→        self.setup_shortcuts()\n   275→\n   276→        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n   277→        self._focus_timer.start(100)\n   278→\n   279→        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n   280→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   281→    \n   282→    def format_time(self, time_str: str) -> str:\n   283→        \"\"\"格式化时间显示\"\"\"\n   284→        if not time_str:\n   285→            return '未知时间'\n   286→        try:\n   287→            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n   288→            return dt.strftime('%Y-%m-%d %H:%M:%S')\n   289→        except:\n   290→            return time_str[:19] if len(time_str) > 19 else time_str\n   291→    \n   292→    def format_file_size(self, size) -> str:\n   293→        \"\"\"格式化文件大小显示\"\"\"\n   294→        # 处理字符串类型的size\n   295→        try:\n   296→            size = float(size) if size else 0\n   297→        except (ValueError, TypeError):\n   298→            return '未知大小'\n   299→            \n   300→        if size == 0:\n   301→            return '未知大小'\n   302→        \n   303→        for unit in ['B', 'KB', 'MB', 'GB']:\n   304→            if size < 1024.0:\n   305→                return f\"{size:.1f} {unit}\"\n   306→            size /= 1024.0\n   307→        return f\"{size:.1f} TB\"\n   308→    \n   309→    def setup_shortcuts(self):\n   310→        \"\"\"设置键盘快捷键\"\"\"\n   311→        # 移除所有QShortcut，统一使用keyPressEvent处理\n   312→        # 避免快捷键冲突问题\n   313→        pass\n   314→    \n   315→    def _ensure_focus(self):\n   316→        \"\"\"确保窗口获得焦点\"\"\"\n   317→        self.activateWindow()\n   318→        self.raise_()\n   319→        self.setFocus()\n   320→        logger.debug(f\"[FOCUS] ImageDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n   321→        \n   322→    def toggle_fullscreen(self):\n   323→        \"\"\"切换全屏模式\"\"\"\n   324→        if self.is_fullscreen:\n   325→            self.exit_fullscreen()\n   326→        else:\n   327→            self.enter_fullscreen()\n   328→            \n   329→    def enter_fullscreen(self):\n   330→        \"\"\"进入全屏模式\"\"\"\n   331→        if not self.is_fullscreen:\n   332→            self.original_geometry = self.geometry()\n   333→            self.showFullScreen()\n   334→            self.is_fullscreen = True\n   335→            \n   336→    def exit_fullscreen(self):\n   337→        \"\"\"退出全屏模式\"\"\"\n   338→        if self.is_fullscreen:\n   339→            self.showNormal()\n   340→            if self.original_geometry:\n   341→                self.setGeometry(self.original_geometry)\n   342→            self.is_fullscreen = False\n   343→            \n   344→    def handle_escape_key(self):\n   345→        \"\"\"处理ESC键：如果是全屏则退出全屏，否则关闭对话框\"\"\"\n   346→        if self.is_fullscreen:\n   347→            self.exit_fullscreen()\n   348→        else:\n   349→            self.accept()  # 关闭对话框\n   350→            \n   351→    def copy_text_to_clipboard(self, text: str):\n   352→        \"\"\"复制文本到剪贴板并显示提示\"\"\"\n   353→        from PyQt5.QtWidgets import QApplication\n   354→        clipboard = QApplication.clipboard()\n   355→        clipboard.setText(text)\n   356→        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n   357→        \n   358→    def show_copy_toast(self, message: str):\n   359→        \"\"\"显示复制成功的轻量提示\"\"\"\n   360→        # 创建一个临时的提示标签\n   361→        toast = QLabel(message, self)\n   362→        toast.setObjectName(\"ToastLabel\")\n   363→        toast.setAlignment(Qt.AlignCenter)\n   364→        toast.adjustSize()\n   365→        \n   366→        # 定位到窗口中央偏上\n   367→        x = (self.width() - toast.width()) // 2\n   368→        y = self.height() // 4\n   369→        toast.move(x, y)\n   370→        toast.show()\n   371→        \n   372→        # 2秒后自动隐藏\n   373→        QTimer.singleShot(2000, toast.deleteLater)\n   374→        \n   375→    def copy_prompt(self):\n   376→        \"\"\"复制提示词到剪贴板\"\"\"\n   377→        prompt_content = self.prompt_text_edit.toPlainText()\n   378→        self.copy_text_to_clipboard(prompt_content)\n   379→    \n   380→    def copy_image(self):\n   381→        \"\"\"复制图片到剪贴板\"\"\"\n   382→        from PyQt5.QtWidgets import QApplication\n   383→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   384→        if image_path and os.path.exists(image_path):\n   385→            pixmap = QPixmap(image_path)\n   386→            if not pixmap.isNull():\n   387→                clipboard = QApplication.clipboard()\n   388→                clipboard.setPixmap(pixmap)\n   389→                self.show_copy_toast(\"图片已复制到剪贴板\")\n   390→            else:\n   391→                self.show_copy_toast(\"无法复制图片\")\n   392→        else:\n   393→            self.show_copy_toast(\"图片文件不存在\")\n   394→    \n   395→    def copy_all_info(self):\n   396→        \"\"\"复制所有信息到剪贴板\"\"\"\n   397→        from PyQt5.QtWidgets import QApplication\n   398→        \n   399→        params = self.image_data.get('parameters', '{}')\n   400→        if isinstance(params, str):\n   401→            try:\n   402→                params = json.loads(params)\n   403→            except:\n   404→                params = {}\n   405→        \n   406→        info_text = f\"\"\"图片详细信息\n   407→===================\n   408→提示词: {self.image_data.get('prompt', '无提示词')}\n   409→尺寸: {params.get('size', '未知')}\n   410→种子值: {params.get('seed', '未知')}\n   411→引导强度: {params.get('guidance_scale', '未知')}\n   412→生成模型: {params.get('model', '未知模型')}\n   413→生成时间: {self.format_time(self.image_data.get('created_at', ''))}\n   414→文件大小: {self.format_file_size(self.image_data.get('file_size', 0))}\n   415→文件路径: {self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')}\n   416→\"\"\"\n   417→        \n   418→        clipboard = QApplication.clipboard()\n   419→        clipboard.setText(info_text)\n   420→        self.show_copy_toast(\"所有信息已复制到剪贴板\")\n   421→\n   422→    def show_copy_message(self, message: str):\n   423→        \"\"\"显示复制成功消息（已弃用，使用show_copy_toast代替）\"\"\"\n   424→        # 直接使用轻量级Toast提示\n   425→        self.show_copy_toast(message)\n   426→\n   427→    def _on_reference_clicked(self, asset: Dict[str, Any]):\n   428→        assets = list(self._reference_assets) if self._reference_assets else [asset]\n   429→        start_idx = _find_reference_asset_index(assets, asset)\n   430→        open_reference_preview(\n   431→            self,\n   432→            asset,\n   433→            title_prefix=\"参考图\",\n   434→            asset_list=assets,\n   435→            start_index=start_idx,\n   436→            on_asset_changed=self._sync_reference_selection,\n   437→        )\n   438→\n   439→    def _on_reference_export(self, asset: Dict[str, Any]):\n   440→        export_reference_asset(self, asset)\n   441→\n   442→    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n   443→        asset_path = None\n   444→        if isinstance(asset, dict):\n   445→            asset_path = asset.get('absolute_path') or asset.get('path')\n   446→        has_path = bool(asset_path and os.path.exists(asset_path))\n   447→        if hasattr(self, 'reference_export_btn'):\n   448→            self.reference_export_btn.setEnabled(has_path)\n   449→\n   450→    def _export_selected_reference(self):\n   451→        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n   452→        if not asset:\n   453→            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n   454→            return\n   455→        export_reference_asset(self, asset)\n   456→\n   457→    def _refresh_reference_gallery(self):\n   458→        if not hasattr(self, 'reference_gallery'):\n   459→            return\n   460→        self._reference_summary = ensure_reference_info(self.image_data)\n   461→        if self._reference_summary.get('count', 0) <= 0:\n   462→            self.reference_gallery.clear()\n   463→            self.reference_gallery.setVisible(False)\n   464→            if hasattr(self, 'reference_export_btn'):\n   465→                self.reference_export_btn.setEnabled(False)\n   466→            self._reference_assets = []\n   467→            self._export_controller.refresh()\n   468→            return\n   469→        try:\n   470→            self._reference_assets = resolve_reference_assets(self.image_data, absolute=True)\n   471→        except Exception:\n   472→            self._reference_assets = []\n   473→        self.reference_gallery.setVisible(True)\n   474→        self.reference_gallery.set_assets(self._reference_assets)\n   475→        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n   476→        self._export_controller.refresh()\n   477→\n   478→    def _sync_reference_selection(self, asset: Dict[str, Any]):\n   479→        try:\n   480→            self.reference_gallery.select_asset(asset)\n   481→        except Exception:\n   482→            pass\n   483→\n   484→    def _resolve_record_id(self) -> Optional[str]:\n   485→        for key in (\"file_id\", \"id\", \"generation_id\"):\n   486→            value = self.image_data.get(key)\n   487→            if value not in (None, \"\"):\n   488→                return str(value)\n   489→        return None\n   490→\n   491→    def show_context_menu(self, position):\n   492→        \"\"\"显示右键菜单\"\"\"\n   493→        from PyQt5.QtWidgets import QMenu, QAction\n   494→        \n   495→        menu = QMenu(self)\n   496→        menu.setStyleSheet(\"\"\"\n   497→            QMenu {\n   498→                background-color: #2a2a3e;\n   499→                color: #ffffff;\n   500→                border: 1px solid #555;\n   501→                border-radius: 4px;\n   502→                padding: 5px;\n   503→            }\n   504→            QMenu::item {\n   505→                padding: 8px 16px;\n   506→                border-radius: 4px;\n   507→            }\n   508→            QMenu::item:selected {\n   509→                background-color: #4CAF50;\n   510→            }\n   511→        \"\"\")\n   512→        \n   513→        # 复制图片动作\n   514→        copy_action = QAction(\"复制图片\", self)\n   515→        copy_action.triggered.connect(self.copy_image)\n   516→        menu.addAction(copy_action)\n   517→        \n   518→        # 下载图片动作\n   519→        download_action = QAction(\"下载图片\", self)\n   520→        download_action.triggered.connect(self.download_image)\n   521→        menu.addAction(download_action)\n   522→        \n   523→        # 显示菜单\n   524→        menu.exec_(self.large_image_label.mapToGlobal(position))\n   525→    \n   526→    def download_image(self):\n   527→        \"\"\"下载图片到指定位置\"\"\"\n   528→        from PyQt5.QtWidgets import QFileDialog, QMessageBox\n   529→        import shutil\n   530→        \n   531→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   532→        if not image_path or not os.path.exists(image_path):\n   533→            self.show_styled_message(\"错误\", \"图片文件不存在\", \"warning\")\n   534→            return\n   535→        \n   536→        # 获取原始文件名\n   537→        original_filename = os.path.basename(image_path)\n   538→        \n   539→        # 打开保存对话框\n   540→        save_path, _ = QFileDialog.getSaveFileName(\n   541→            self,\n   542→            \"保存图片\",\n   543→            original_filename,\n   544→            \"图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)\"\n   545→        )\n   546→        \n   547→        if save_path:\n   548→            try:\n   549→                shutil.copy2(image_path, save_path)\n   550→                self.show_styled_message(\"成功\", f\"图片已保存到:\\n{save_path}\", \"information\")\n   551→            except Exception as e:\n   552→                self.show_styled_message(\"错误\", f\"保存图片失败:\\n{str(e)}\", \"critical\")\n   553→    \n   554→    def update_navigation_buttons(self):\n   555→        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n   556→        # 检查是否有图片列表\n   557→        if len(self.image_list) <= 1:\n   558→            self.prev_btn.setEnabled(False)\n   559→            self.next_btn.setEnabled(False)\n   560→            self.prev_btn.setToolTip(\"没有更多图片\")\n   561→            self.next_btn.setToolTip(\"没有更多图片\")\n   562→            return\n   563→        \n   564→        # 更新按钮状态（基于有效记录检查）\n   565→        self.prev_btn.setEnabled(self._has_valid_previous_record())\n   566→        self.next_btn.setEnabled(self._has_valid_next_record())\n   567→        \n   568→        # 更新工具提示显示当前位置和快捷键信息\n   569→        current_pos = f\"({self.current_index + 1}/{len(self.image_list)})\"\n   570→        self.prev_btn.setToolTip(f\"上一张 {current_pos} - 快捷键: ←\")\n   571→        self.next_btn.setToolTip(f\"下一张 {current_pos} - 快捷键: →\")\n   572→        \n   573→        # 按钮文本保持简洁的箭头符号\n   574→        self.prev_btn.setText(\"◀\")\n   575→    \n   576→    def _has_valid_previous_record(self):\n   577→        \"\"\"检查是否有有效的上一个记录\"\"\"\n   578→        for i in range(self.current_index - 1, -1, -1):\n   579→            candidate_data = self.image_list[i]\n   580→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   581→            if file_path and os.path.exists(file_path):\n   582→                return True\n   583→        return False\n   584→    \n   585→    def _has_valid_next_record(self):\n   586→        \"\"\"检查是否有有效的下一个记录\"\"\"\n   587→        for i in range(self.current_index + 1, len(self.image_list)):\n   588→            candidate_data = self.image_list[i]\n   589→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   590→            if file_path and os.path.exists(file_path):\n   591→                return True\n   592→        return False\n   593→    \n   594→    def show_previous_image(self):\n   595→        \"\"\"显示上一张图片（带有效性验证）\"\"\"\n   596→        # 寻找上一个有效记录\n   597→        for i in range(self.current_index - 1, -1, -1):\n   598→            candidate_data = self.image_list[i]\n   599→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   600→            \n   601→            if file_path and os.path.exists(file_path):\n   602→                # 找到有效记录\n   603→                self.current_index = i\n   604→                self.load_current_image()\n   605→                self.update_navigation_buttons()\n   606→                return\n   607→        \n   608→        # 没有找到有效的上一个记录，保持当前状态\n   609→        self.update_navigation_buttons()\n   610→    \n   611→    def show_next_image(self):\n   612→        \"\"\"显示下一张图片（带有效性验证）\"\"\"\n   613→        # 寻找下一个有效记录\n   614→        for i in range(self.current_index + 1, len(self.image_list)):\n   615→            candidate_data = self.image_list[i]\n   616→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   617→            \n   618→            if file_path and os.path.exists(file_path):\n   619→                # 找到有效记录\n   620→                self.current_index = i\n   621→                self.load_current_image()\n   622→                self.update_navigation_buttons()\n   623→                return\n   624→        \n   625→        # 没有找到有效的下一个记录，保持当前状态\n   626→        self.update_navigation_buttons()\n   627→    \n   628→    def load_current_image(self):\n   629→        \"\"\"加载当前索引的图片\"\"\"\n   630→        if 0 <= self.current_index < len(self.image_list):\n   631→            # 更新当前图片数据\n   632→            self.image_data = self.image_list[self.current_index]\n   633→            \n   634→            # 重新加载图片\n   635→            image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '') or self.image_data.get('file_path', '')\n   636→            if image_path and os.path.exists(image_path):\n   637→                pixmap = QPixmap(image_path)\n   638→                if not pixmap.isNull():\n   639→                    self.large_image_label.setPixmap(pixmap)\n   640→                else:\n   641→                    self.large_image_label.setText(\"图片加载失败\")\n   642→            else:\n   643→                self.large_image_label.setText(\"图片不存在\")\n   644→            \n   645→            # 更新窗口标题\n   646→            self.setWindowTitle(f\"图片详细信息 ({self.current_index + 1}/{len(self.image_list)})\")\n   647→            \n   648→            # 更新提示词内容\n   649→            prompt_content = self.image_data.get('prompt', '无提示词')\n   650→            self.prompt_text_edit.setPlainText(prompt_content)\n   651→            \n   652→            # 更新参数信息\n   653→            self.update_params_area()\n   654→            self._refresh_reference_gallery()\n   655→\n   656→        self._export_controller.refresh()\n   657→    \n   658→    def setup_params_area(self):\n   659→        \"\"\"初始化参数显示区域\"\"\"\n   660→        # 解析生成参数\n   661→        params = self.image_data.get('parameters', '{}')\n   662→        if isinstance(params, str):\n   663→            try:\n   664→                params = json.loads(params)\n   665→            except:\n   666→                params = {}\n   667→        \n   668→        # 提示词区域（可滚动查看全文）\n   669→        prompt_label = QLabel(\"<b>提示词:</b>\")\n   670→        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n   671→        self.params_layout.addWidget(prompt_label)\n   672→        \n   673→        # 创建可滚动和缩放的提示词文本框\n   674→        prompt_content = self.image_data.get('prompt', '无提示词')\n   675→        self.prompt_text_edit = ZoomableTextEdit()\n   676→        self.prompt_text_edit.setPlainText(prompt_content)\n   677→        self.prompt_text_edit.setReadOnly(True)  # 只读模式\n   678→        self.prompt_text_edit.setMaximumHeight(120)  # 约5-6行的高度\n   679→        self.prompt_text_edit.setMinimumHeight(120)\n   680→        self.prompt_text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n   681→        self.prompt_text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n   682→        self.prompt_text_edit.setStyleSheet(\"\"\"\n   683→            QTextEdit {\n   684→                background-color: #2a2a3e;\n   685→                color: #ffffff;\n   686→                border: 1px solid #555;\n   687→                border-radius: 4px;\n   688→                padding: 8px;\n   689→                margin: 0px;\n   690→                ;\n   691→                line-height: 1.4;\n   692→            }\n   693→            QTextEdit:focus {\n   694→                border-color: #4CAF50;\n   695→            }\n   696→            QScrollBar:vertical {\n   697→                background-color: #1a1a1a;\n   698→                width: 12px;\n   699→                border-radius: 6px;\n   700→            }\n   701→            QScrollBar::handle:vertical {\n   702→                background-color: #555;\n   703→                border-radius: 6px;\n   704→                min-height: 20px;\n   705→            }\n   706→            QScrollBar::handle:vertical:hover {\n   707→                background-color: #777;\n   708→            }\n   709→        \"\"\")\n   710→        \n   711→        # 添加使用提示\n   712→        font_tip_label = QLabel(\"<i>提示：按住Ctrl键+滚轮可缩放字体</i>\")\n   713→        font_tip_label.setStyleSheet(\"color: #888; ; margin: 2px 0px;\")\n   714→        self.params_layout.addWidget(font_tip_label)\n   715→        \n   716→        self.params_layout.addWidget(self.prompt_text_edit)\n   717→        \n   718→        # 添加复制提示词按钮\n   719→        copy_prompt_btn = QPushButton(\"复制提示词\")\n   720→        copy_prompt_btn.setMaximumHeight(30)\n   721→        copy_prompt_btn.setObjectName(\"CopyButton\")\n   722→        copy_prompt_btn.clicked.connect(self.copy_prompt)\n   723→        self.params_layout.addWidget(copy_prompt_btn)\n   724→        \n   725→        # 存储参数标签列表，用于后续更新\n   726→        self.param_labels = []\n   727→        self.create_param_labels()\n   728→    \n   729→    def create_param_labels(self):\n   730→        \"\"\"创建参数标签（初始化或更新时调用）\"\"\"\n   731→        # 清除旧的参数标签\n   732→        for label_pair in self.param_labels:\n   733→            label_pair[0].deleteLater()  # 删除标题标签\n   734→            label_pair[1].deleteLater()  # 删除值标签\n   735→        self.param_labels.clear()\n   736→        \n   737→        # 解析生成参数\n   738→        params = self.image_data.get('parameters', '{}')\n   739→        if isinstance(params, str):\n   740→            try:\n   741→                params = json.loads(params)\n   742→            except:\n   743→                params = {}\n   744→        \n   745→        # 详细信息\n   746→        info_items = [\n   747→            (\"尺寸\", f\"{params.get('size', '未知')}\"),\n   748→            (\"种子值\", f\"{params.get('seed', '未知')}\"),\n   749→            (\"引导强度\", f\"{params.get('guidance_scale', '未知')}\"),\n   750→            (\"生成模型\", f\"{params.get('model', '未知模型')}\"),\n   751→            (\"生成时间\", self.format_time(self.image_data.get('created_at', ''))),\n   752→            (\"文件大小\", self.format_file_size(self.image_data.get('file_size', 0))),\n   753→            (\"文件路径\", self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')),\n   754→        ]\n   755→        \n   756→        # 如果是图生图，显示参考图信息\n   757→        if params.get('model', '').find('i2i') != -1:\n   758→            info_items.insert(-2, (\"生成类型\", \"图生图\"))\n   759→            input_image = self.image_data.get('input_image', '')\n   760→            if input_image:\n   761→                info_items.insert(-2, (\"参考图片\", input_image))\n   762→        else:\n   763→            info_items.insert(-2, (\"生成类型\", \"文生图\"))\n   764→        \n   765→        for label, value in info_items:\n   766→            label_widget = QLabel(f\"<b>{label}:</b>\")\n   767→            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n   768→            self.params_layout.addWidget(label_widget)\n   769→            \n   770→            # 使用可点击的标签\n   771→            value_clickable = ClickableLabel(str(value))\n   772→            value_clickable.set_text_with_ellipsis(str(value), int(self.width() * 0.25))\n   773→            value_clickable.setWordWrap(True)\n   774→            value_clickable.setStyleSheet(\"\"\"\n   775→                QLabel {\n   776→                    margin: 0px; \n   777→                    padding: 6px; \n   778→                    background-color: #2a2a3e; \n   779→                    color: #ffffff;\n   780→                    border: 1px solid #555;\n   781→                    border-radius: 4px;\n   782→                    ;\n   783→                    min-height: 20px;\n   784→                }\n   785→                QLabel:hover {\n   786→                    background-color: #3a3a4e;\n   787→                    border-color: #4CAF50;\n   788→                }\n   789→            \"\"\")\n   790→            value_clickable.clicked.connect(self.copy_text_to_clipboard)\n   791→            self.params_layout.addWidget(value_clickable)\n   792→            \n   793→            # 保存标签引用\n   794→            self.param_labels.append((label_widget, value_clickable))\n   795→    \n   796→    def update_params_area(self):\n   797→        \"\"\"更新参数显示区域（切换图片时调用）\"\"\"\n   798→        # 重新创建所有参数标签\n   799→        self.create_param_labels()\n   800→\n   801→    def closeEvent(self, event):\n   802→        try:\n   803→            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n   804→                self._focus_timer.stop()\n   805→        except Exception:\n   806→            pass\n   807→\n   808→        try:\n   809→            self._export_controller.dispose()\n   810→        except Exception:\n   811→            pass\n   812→\n   813→        super().closeEvent(event)\n   814→    \n   815→    def keyPressEvent(self, event):\n   816→        \"\"\"键盘事件处理\"\"\"\n   817→        from PyQt5.QtCore import Qt\n   818→        \n   819→        logger.debug(f\"[KEYBOARD] ImageDetailDialog键盘事件: {event.key()}\")\n   820→        \n   821→        if event.key() == Qt.Key_Left:\n   822→            # 左方向键：上一张图片\n   823→            if self.prev_btn.isEnabled():\n   824→                self.show_previous_image()\n   825→            event.accept()\n   826→        elif event.key() == Qt.Key_Right:\n   827→            # 右方向键：下一张图片\n   828→            if self.next_btn.isEnabled():\n   829→                self.show_next_image()\n   830→            event.accept()\n   831→        elif event.key() == Qt.Key_Escape:\n   832→            # ESC键：关闭对话框（保持原有功能）\n   833→            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n   834→            if self.is_fullscreen:\n   835→                self.exit_fullscreen()\n   836→            else:\n   837→                self.accept()\n   838→            event.accept()\n   839→        elif event.key() == Qt.Key_F11:\n   840→            # F11键：全屏切换（保持原有功能）\n   841→            self.toggle_fullscreen()\n   842→            event.accept()\n   843→        else:\n   844→            # 其他按键交给父类处理\n   845→            super().keyPressEvent(event)\n   846→\n   847→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"71a792b0-23b1-4f53-a6a6-a9b8489e6e2f","timestamp":"2025-12-11T08:09:50.059Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py","content":"import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\n\nfrom PyQt5.QtWidgets import (\n    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n    QTextEdit, QFileDialog, QMessageBox, QSplitter, QApplication,\n    QShortcut, QMenu, QAction, QSizePolicy\n)\nfrom PyQt5.QtCore import Qt, QTimer, QSize, QEvent\nfrom PyQt5.QtGui import QPixmap, QKeySequence\n\nfrom utils.logger import logger\nfrom components.widgets import ZoomableImageLabel, ZoomableTextEdit, ClickableLabel\nfrom components.reference_assets import (\n    ReferenceGalleryWidget,\n    export_reference_asset,\n    open_reference_preview,\n    _find_reference_asset_index,\n)\nfrom components.controllers import ExportBundleController\nfrom utils.reference_display import ensure_reference_info, resolve_reference_assets\n\nclass ImageDetailDialog(QDialog):\n    \"\"\"图片详细信息对话框\"\"\"\n    \n    def __init__(self, image_data: Dict[str, Any], image_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n        super().__init__(parent)\n        self.image_data = image_data\n        self.image_list = image_list or [image_data]  # 图片列表\n        self.current_index = current_index  # 当前图片索引\n        self.zoom_factor = 1.0  # 缩放因子\n        self.is_fullscreen = False  # 全屏状态\n        self.original_geometry = None  # 原始窗口几何\n        self._reference_summary = ensure_reference_info(self.image_data)\n        self._reference_assets: List[Dict[str, Any]] = []\n        self._export_controller = ExportBundleController(self, \"image\")\n        self.setup_ui()\n        \n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        self.setWindowTitle(\"图片详细信息\")\n        self.resize(1100, 800)  # 改为可调整大小\n        self.setMinimumSize(800, 600)  # 设置最小尺寸\n        \n        # 设置焦点策略，确保能接收键盘事件\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n        self.setFocus()\n\n        # 确保窗口激活时获得焦点\n        self.activateWindow()\n        self.raise_()\n\n        try:\n            self.setObjectName(\"DetailDialog\")\n        except Exception:\n            pass\n\n        self._focus_timer = QTimer(self)\n        self._focus_timer.setSingleShot(True)\n        self._focus_timer.timeout.connect(self._ensure_focus)\n\n        layout = QHBoxLayout(self)\n        \n        # 左侧：大图显示（占70%宽度）\n        left_widget = QWidget()\n        left_layout = QVBoxLayout(left_widget)\n        left_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 图片显示区域（占据上方全部空间）\n        image_container = QWidget()\n        image_container.setObjectName(\"ImageContainer\")\n        image_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        # 在容器内创建布局\n        container_layout = QVBoxLayout(image_container)\n        container_layout.setContentsMargins(0, 0, 0, 0)\n        container_layout.setSpacing(0)\n\n        # 使用可缩放的图片标签，自适应容器大小\n        self.large_image_label = ZoomableImageLabel()\n        self.large_image_label.setAlignment(Qt.AlignCenter)\n        self.large_image_label.setStyleSheet(\"border: none; background-color: transparent;\")\n        \n        # 设置右键菜单\n        self.large_image_label.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.large_image_label.customContextMenuRequested.connect(self.show_context_menu)\n        \n        # 加载大图\n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if image_path and os.path.exists(image_path):\n            pixmap = QPixmap(image_path)\n            if not pixmap.isNull():\n                self.large_image_label.setPixmap(pixmap)\n        \n        container_layout.addWidget(self.large_image_label, 1)\n\n        reference_section = QWidget()\n        reference_section.setObjectName(\"ReferenceSection\")\n        reference_section.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        reference_section_layout = QVBoxLayout(reference_section)\n        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n        reference_section_layout.setSpacing(8)\n\n        self.reference_gallery = ReferenceGalleryWidget()\n        self.reference_gallery.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        try:\n            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n        except Exception:\n            pass\n        reference_section_layout.addWidget(self.reference_gallery, 1)\n\n        reference_button_layout = QHBoxLayout()\n        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n        reference_button_layout.setSpacing(6)\n        self.export_status_label = QLabel(\"\")\n        self.export_status_label.setStyleSheet(\"color: #bbbbbb; ;\")\n        reference_button_layout.addWidget(self.export_status_label)\n        reference_button_layout.addStretch(1)\n        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n        self.reference_export_btn.setEnabled(False)\n        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n        reference_button_layout.addWidget(self.reference_export_btn)\n        self.export_bundle_btn = QPushButton(\"导出记录\")\n        self.export_bundle_btn.setEnabled(False)\n        self._export_controller.configure(\n            self.export_bundle_btn,\n            self.export_status_label,\n            self._resolve_record_id,\n            context_widget=self,\n        )\n        reference_button_layout.addWidget(self.export_bundle_btn)\n        reference_section_layout.addLayout(reference_button_layout)\n\n        self._image_reference_splitter = QSplitter(Qt.Vertical)\n        self._image_reference_splitter.setObjectName(\"ImageReferenceSplitter\")\n        self._image_reference_splitter.setChildrenCollapsible(False)\n        self._image_reference_splitter.setHandleWidth(6)\n        self._image_reference_splitter.addWidget(image_container)\n        self._image_reference_splitter.addWidget(reference_section)\n        self._image_reference_splitter.setStretchFactor(0, 3)\n        self._image_reference_splitter.setStretchFactor(1, 2)\n        self._image_reference_splitter.setSizes([520, 280])\n\n        left_layout.addWidget(self._image_reference_splitter, 1)\n\n        # 底部区域：导航按钮 + 说明文本框（与右侧参数栏高度对齐）\n        bottom_layout = QHBoxLayout()\n        bottom_layout.setContentsMargins(0, 5, 0, 5)\n        bottom_layout.setSpacing(10)\n        \n        # 向左按钮\n        self.prev_btn = QPushButton(\"◀\")\n        self.prev_btn.setFixedSize(30, 30)  # 固定尺寸\n        self.prev_btn.setObjectName(\"NavButton\")\n        self.prev_btn.clicked.connect(self.show_previous_image)\n        bottom_layout.addWidget(self.prev_btn)\n        \n        # 中间的说明文本框（完全透明设计）\n        zoom_info = QLabel(\"提示：鼠标位置缩放，点击拖拽，双击重置\")\n        zoom_info.setStyleSheet(\"\"\"\n            QLabel {\n                color: #cccccc; \n                ; \n                padding: 0px;\n                margin: 0px;\n                background-color: transparent;\n                border: none;\n                border-radius: 0px;\n                line-height: 1.2;\n            }\n        \"\"\")\n        zoom_info.setAlignment(Qt.AlignCenter)\n        zoom_info.setMinimumHeight(30)  # 与按钮高度一致\n        zoom_info.setMaximumHeight(30)  # 固定高度，防止文字被压缩\n        bottom_layout.addWidget(zoom_info, 1)  # 占据中间所有空间\n        \n        # 向右按钮\n        self.next_btn = QPushButton(\"▶\")\n        self.next_btn.setFixedSize(30, 30)  # 固定尺寸\n        self.next_btn.setObjectName(\"NavButton\")\n        self.next_btn.clicked.connect(self.show_next_image)\n        bottom_layout.addWidget(self.next_btn)\n        \n        left_layout.addLayout(bottom_layout)\n\n        # 更新导航按钮状态\n        self.update_navigation_buttons()\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n\n        # 右侧：详细信息（固定30%宽度）\n        right_layout = QVBoxLayout()\n        \n        # 创建参数显示区域（不使用滚动条）\n        params_widget = QWidget()\n        params_widget.setFixedWidth(int(self.width() * 0.3))  # 固定30%宽度\n        params_widget.setObjectName(\"ParamsWidget\")\n        self.params_layout = QVBoxLayout(params_widget)  # 保存引用以便后续更新\n        self.params_layout.setSpacing(0)  # 设置间距为0\n        self.params_layout.setContentsMargins(5, 5, 5, 5)  # 设置紧凑的边距\n        \n        # 初始化参数显示区域\n        self.setup_params_area()\n        \n        \n        right_layout.addWidget(params_widget)\n        \n        # 全屏和复制图片按钮（与参数区底部对齐）\n        image_control_layout = QHBoxLayout()\n        \n        fullscreen_btn = QPushButton(\"全屏 (F11)\")\n        fullscreen_btn.setMaximumHeight(30)\n        fullscreen_btn.setStyleSheet(\"\"\"\n            QPushButton {\n                background-color: transparent;\n                color: #ffffff;\n                border: 1px solid #666;\n                border-radius: 4px;\n                padding: 5px 10px;\n                ;\n            }\n            QPushButton:hover {\n                background-color: #3a3a4e;\n                border-color: #888;\n            }\n        \"\"\")\n        fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n        image_control_layout.addWidget(fullscreen_btn)\n        \n        copy_image_btn = QPushButton(\"复制图片\")\n        copy_image_btn.setMaximumHeight(30)\n        copy_image_btn.setStyleSheet(\"\"\"\n            QPushButton {\n                background-color: transparent;\n                color: #ffffff;\n                border: 1px solid #666;\n                border-radius: 4px;\n                padding: 5px 10px;\n                ;\n            }\n            QPushButton:hover {\n                background-color: #3a3a4e;\n                border-color: #888;\n            }\n        \"\"\")\n        copy_image_btn.clicked.connect(self.copy_image)\n        image_control_layout.addWidget(copy_image_btn)\n        \n        right_layout.addLayout(image_control_layout)\n        \n        # 其他按钮\n        button_layout = QHBoxLayout()\n        \n        copy_all_btn = QPushButton(\"复制所有信息\")\n        copy_all_btn.clicked.connect(self.copy_all_info)\n        button_layout.addWidget(copy_all_btn)\n        \n        close_btn = QPushButton(\"关闭（ESC）\")\n        close_btn.clicked.connect(self.accept)\n        button_layout.addWidget(close_btn)\n        \n        right_layout.addLayout(button_layout)\n        \n        # 设置布局比例：左侧70%，右侧30%\n        layout.addWidget(left_widget, 7)\n        layout.addLayout(right_layout, 3)\n        \n        # 添加键盘快捷键\n        self.setup_shortcuts()\n\n        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n        self._focus_timer.start(100)\n\n        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n    \n    def format_time(self, time_str: str) -> str:\n        \"\"\"格式化时间显示\"\"\"\n        if not time_str:\n            return '未知时间'\n        try:\n            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n            return dt.strftime('%Y-%m-%d %H:%M:%S')\n        except:\n            return time_str[:19] if len(time_str) > 19 else time_str\n    \n    def format_file_size(self, size) -> str:\n        \"\"\"格式化文件大小显示\"\"\"\n        # 处理字符串类型的size\n        try:\n            size = float(size) if size else 0\n        except (ValueError, TypeError):\n            return '未知大小'\n            \n        if size == 0:\n            return '未知大小'\n        \n        for unit in ['B', 'KB', 'MB', 'GB']:\n            if size < 1024.0:\n                return f\"{size:.1f} {unit}\"\n            size /= 1024.0\n        return f\"{size:.1f} TB\"\n    \n    def setup_shortcuts(self):\n        \"\"\"设置键盘快捷键\"\"\"\n        # 移除所有QShortcut，统一使用keyPressEvent处理\n        # 避免快捷键冲突问题\n        pass\n    \n    def _ensure_focus(self):\n        \"\"\"确保窗口获得焦点\"\"\"\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        logger.debug(f\"[FOCUS] ImageDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n        \n    def toggle_fullscreen(self):\n        \"\"\"切换全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.enter_fullscreen()\n            \n    def enter_fullscreen(self):\n        \"\"\"进入全屏模式\"\"\"\n        if not self.is_fullscreen:\n            self.original_geometry = self.geometry()\n            self.showFullScreen()\n            self.is_fullscreen = True\n            \n    def exit_fullscreen(self):\n        \"\"\"退出全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.showNormal()\n            if self.original_geometry:\n                self.setGeometry(self.original_geometry)\n            self.is_fullscreen = False\n            \n    def handle_escape_key(self):\n        \"\"\"处理ESC键：如果是全屏则退出全屏，否则关闭对话框\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.accept()  # 关闭对话框\n            \n    def copy_text_to_clipboard(self, text: str):\n        \"\"\"复制文本到剪贴板并显示提示\"\"\"\n        from PyQt5.QtWidgets import QApplication\n        clipboard = QApplication.clipboard()\n        clipboard.setText(text)\n        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n        \n    def show_copy_toast(self, message: str):\n        \"\"\"显示复制成功的轻量提示\"\"\"\n        # 创建一个临时的提示标签\n        toast = QLabel(message, self)\n        toast.setObjectName(\"ToastLabel\")\n        toast.setAlignment(Qt.AlignCenter)\n        toast.adjustSize()\n        \n        # 定位到窗口中央偏上\n        x = (self.width() - toast.width()) // 2\n        y = self.height() // 4\n        toast.move(x, y)\n        toast.show()\n        \n        # 2秒后自动隐藏\n        QTimer.singleShot(2000, toast.deleteLater)\n        \n    def copy_prompt(self):\n        \"\"\"复制提示词到剪贴板\"\"\"\n        prompt_content = self.prompt_text_edit.toPlainText()\n        self.copy_text_to_clipboard(prompt_content)\n    \n    def copy_image(self):\n        \"\"\"复制图片到剪贴板\"\"\"\n        from PyQt5.QtWidgets import QApplication\n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if image_path and os.path.exists(image_path):\n            pixmap = QPixmap(image_path)\n            if not pixmap.isNull():\n                clipboard = QApplication.clipboard()\n                clipboard.setPixmap(pixmap)\n                self.show_copy_toast(\"图片已复制到剪贴板\")\n            else:\n                self.show_copy_toast(\"无法复制图片\")\n        else:\n            self.show_copy_toast(\"图片文件不存在\")\n    \n    def copy_all_info(self):\n        \"\"\"复制所有信息到剪贴板\"\"\"\n        from PyQt5.QtWidgets import QApplication\n        \n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        info_text = f\"\"\"图片详细信息\n===================\n提示词: {self.image_data.get('prompt', '无提示词')}\n尺寸: {params.get('size', '未知')}\n种子值: {params.get('seed', '未知')}\n引导强度: {params.get('guidance_scale', '未知')}\n生成模型: {params.get('model', '未知模型')}\n生成时间: {self.format_time(self.image_data.get('created_at', ''))}\n文件大小: {self.format_file_size(self.image_data.get('file_size', 0))}\n文件路径: {self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')}\n\"\"\"\n        \n        clipboard = QApplication.clipboard()\n        clipboard.setText(info_text)\n        self.show_copy_toast(\"所有信息已复制到剪贴板\")\n\n    def show_copy_message(self, message: str):\n        \"\"\"显示复制成功消息（已弃用，使用show_copy_toast代替）\"\"\"\n        # 直接使用轻量级Toast提示\n        self.show_copy_toast(message)\n\n    def _on_reference_clicked(self, asset: Dict[str, Any]):\n        assets = list(self._reference_assets) if self._reference_assets else [asset]\n        start_idx = _find_reference_asset_index(assets, asset)\n        open_reference_preview(\n            self,\n            asset,\n            title_prefix=\"参考图\",\n            asset_list=assets,\n            start_index=start_idx,\n            on_asset_changed=self._sync_reference_selection,\n        )\n\n    def _on_reference_export(self, asset: Dict[str, Any]):\n        export_reference_asset(self, asset)\n\n    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n        asset_path = None\n        if isinstance(asset, dict):\n            asset_path = asset.get('absolute_path') or asset.get('path')\n        has_path = bool(asset_path and os.path.exists(asset_path))\n        if hasattr(self, 'reference_export_btn'):\n            self.reference_export_btn.setEnabled(has_path)\n\n    def _export_selected_reference(self):\n        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n        if not asset:\n            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n            return\n        export_reference_asset(self, asset)\n\n    def _refresh_reference_gallery(self):\n        if not hasattr(self, 'reference_gallery'):\n            return\n        self._reference_summary = ensure_reference_info(self.image_data)\n        if self._reference_summary.get('count', 0) <= 0:\n            self.reference_gallery.clear()\n            self.reference_gallery.setVisible(False)\n            if hasattr(self, 'reference_export_btn'):\n                self.reference_export_btn.setEnabled(False)\n            self._reference_assets = []\n            self._export_controller.refresh()\n            return\n        try:\n            self._reference_assets = resolve_reference_assets(self.image_data, absolute=True)\n        except Exception:\n            self._reference_assets = []\n        self.reference_gallery.setVisible(True)\n        self.reference_gallery.set_assets(self._reference_assets)\n        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n        self._export_controller.refresh()\n\n    def _sync_reference_selection(self, asset: Dict[str, Any]):\n        try:\n            self.reference_gallery.select_asset(asset)\n        except Exception:\n            pass\n\n    def _resolve_record_id(self) -> Optional[str]:\n        for key in (\"file_id\", \"id\", \"generation_id\"):\n            value = self.image_data.get(key)\n            if value not in (None, \"\"):\n                return str(value)\n        return None\n\n    def show_context_menu(self, position):\n        \"\"\"显示右键菜单\"\"\"\n        from PyQt5.QtWidgets import QMenu, QAction\n        \n        menu = QMenu(self)\n        menu.setStyleSheet(\"\"\"\n            QMenu {\n                background-color: #2a2a3e;\n                color: #ffffff;\n                border: 1px solid #555;\n                border-radius: 4px;\n                padding: 5px;\n            }\n            QMenu::item {\n                padding: 8px 16px;\n                border-radius: 4px;\n            }\n            QMenu::item:selected {\n                background-color: #4CAF50;\n            }\n        \"\"\")\n        \n        # 复制图片动作\n        copy_action = QAction(\"复制图片\", self)\n        copy_action.triggered.connect(self.copy_image)\n        menu.addAction(copy_action)\n        \n        # 下载图片动作\n        download_action = QAction(\"下载图片\", self)\n        download_action.triggered.connect(self.download_image)\n        menu.addAction(download_action)\n        \n        # 显示菜单\n        menu.exec_(self.large_image_label.mapToGlobal(position))\n    \n    def download_image(self):\n        \"\"\"下载图片到指定位置\"\"\"\n        from PyQt5.QtWidgets import QFileDialog, QMessageBox\n        import shutil\n        \n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if not image_path or not os.path.exists(image_path):\n            self.show_styled_message(\"错误\", \"图片文件不存在\", \"warning\")\n            return\n        \n        # 获取原始文件名\n        original_filename = os.path.basename(image_path)\n        \n        # 打开保存对话框\n        save_path, _ = QFileDialog.getSaveFileName(\n            self,\n            \"保存图片\",\n            original_filename,\n            \"图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)\"\n        )\n        \n        if save_path:\n            try:\n                shutil.copy2(image_path, save_path)\n                self.show_styled_message(\"成功\", f\"图片已保存到:\\n{save_path}\", \"information\")\n            except Exception as e:\n                self.show_styled_message(\"错误\", f\"保存图片失败:\\n{str(e)}\", \"critical\")\n    \n    def update_navigation_buttons(self):\n        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n        # 检查是否有图片列表\n        if len(self.image_list) <= 1:\n            self.prev_btn.setEnabled(False)\n            self.next_btn.setEnabled(False)\n            self.prev_btn.setToolTip(\"没有更多图片\")\n            self.next_btn.setToolTip(\"没有更多图片\")\n            return\n        \n        # 更新按钮状态（基于有效记录检查）\n        self.prev_btn.setEnabled(self._has_valid_previous_record())\n        self.next_btn.setEnabled(self._has_valid_next_record())\n        \n        # 更新工具提示显示当前位置和快捷键信息\n        current_pos = f\"({self.current_index + 1}/{len(self.image_list)})\"\n        self.prev_btn.setToolTip(f\"上一张 {current_pos} - 快捷键: ←\")\n        self.next_btn.setToolTip(f\"下一张 {current_pos} - 快捷键: →\")\n        \n        # 按钮文本保持简洁的箭头符号\n        self.prev_btn.setText(\"◀\")\n    \n    def _has_valid_previous_record(self):\n        \"\"\"检查是否有有效的上一个记录\"\"\"\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            if file_path and os.path.exists(file_path):\n                return True\n        return False\n    \n    def _has_valid_next_record(self):\n        \"\"\"检查是否有有效的下一个记录\"\"\"\n        for i in range(self.current_index + 1, len(self.image_list)):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            if file_path and os.path.exists(file_path):\n                return True\n        return False\n    \n    def show_previous_image(self):\n        \"\"\"显示上一张图片（带有效性验证）\"\"\"\n        # 寻找上一个有效记录\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            if file_path and os.path.exists(file_path):\n                # 找到有效记录\n                self.current_index = i\n                self.load_current_image()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的上一个记录，保持当前状态\n        self.update_navigation_buttons()\n    \n    def show_next_image(self):\n        \"\"\"显示下一张图片（带有效性验证）\"\"\"\n        # 寻找下一个有效记录\n        for i in range(self.current_index + 1, len(self.image_list)):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            if file_path and os.path.exists(file_path):\n                # 找到有效记录\n                self.current_index = i\n                self.load_current_image()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的下一个记录，保持当前状态\n        self.update_navigation_buttons()\n    \n    def load_current_image(self):\n        \"\"\"加载当前索引的图片\"\"\"\n        if 0 <= self.current_index < len(self.image_list):\n            # 更新当前图片数据\n            self.image_data = self.image_list[self.current_index]\n            \n            # 重新加载图片\n            image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '') or self.image_data.get('file_path', '')\n            if image_path and os.path.exists(image_path):\n                pixmap = QPixmap(image_path)\n                if not pixmap.isNull():\n                    self.large_image_label.setPixmap(pixmap)\n                else:\n                    self.large_image_label.setText(\"图片加载失败\")\n            else:\n                self.large_image_label.setText(\"图片不存在\")\n            \n            # 更新窗口标题\n            self.setWindowTitle(f\"图片详细信息 ({self.current_index + 1}/{len(self.image_list)})\")\n            \n            # 更新提示词内容\n            prompt_content = self.image_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n            \n            # 更新参数信息\n            self.update_params_area()\n            self._refresh_reference_gallery()\n\n        self._export_controller.refresh()\n    \n    def setup_params_area(self):\n        \"\"\"初始化参数显示区域\"\"\"\n        # 解析生成参数\n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 提示词区域（可滚动查看全文）\n        prompt_label = QLabel(\"<b>提示词:</b>\")\n        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n        self.params_layout.addWidget(prompt_label)\n        \n        # 创建可滚动和缩放的提示词文本框\n        prompt_content = self.image_data.get('prompt', '无提示词')\n        self.prompt_text_edit = ZoomableTextEdit()\n        self.prompt_text_edit.setPlainText(prompt_content)\n        self.prompt_text_edit.setReadOnly(True)  # 只读模式\n        self.prompt_text_edit.setMaximumHeight(120)  # 约5-6行的高度\n        self.prompt_text_edit.setMinimumHeight(120)\n        self.prompt_text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n        self.prompt_text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        self.prompt_text_edit.setStyleSheet(\"\"\"\n            QTextEdit {\n                background-color: #2a2a3e;\n                color: #ffffff;\n                border: 1px solid #555;\n                border-radius: 4px;\n                padding: 8px;\n                margin: 0px;\n                ;\n                line-height: 1.4;\n            }\n            QTextEdit:focus {\n                border-color: #4CAF50;\n            }\n            QScrollBar:vertical {\n                background-color: #1a1a1a;\n                width: 12px;\n                border-radius: 6px;\n            }\n            QScrollBar::handle:vertical {\n                background-color: #555;\n                border-radius: 6px;\n                min-height: 20px;\n            }\n            QScrollBar::handle:vertical:hover {\n                background-color: #777;\n            }\n        \"\"\")\n        \n        # 添加使用提示\n        font_tip_label = QLabel(\"<i>提示：按住Ctrl键+滚轮可缩放字体</i>\")\n        font_tip_label.setStyleSheet(\"color: #888; ; margin: 2px 0px;\")\n        self.params_layout.addWidget(font_tip_label)\n        \n        self.params_layout.addWidget(self.prompt_text_edit)\n        \n        # 添加复制提示词按钮\n        copy_prompt_btn = QPushButton(\"复制提示词\")\n        copy_prompt_btn.setMaximumHeight(30)\n        copy_prompt_btn.setObjectName(\"CopyButton\")\n        copy_prompt_btn.clicked.connect(self.copy_prompt)\n        self.params_layout.addWidget(copy_prompt_btn)\n        \n        # 存储参数标签列表，用于后续更新\n        self.param_labels = []\n        self.create_param_labels()\n    \n    def create_param_labels(self):\n        \"\"\"创建参数标签（初始化或更新时调用）\"\"\"\n        # 清除旧的参数标签\n        for label_pair in self.param_labels:\n            label_pair[0].deleteLater()  # 删除标题标签\n            label_pair[1].deleteLater()  # 删除值标签\n        self.param_labels.clear()\n        \n        # 解析生成参数\n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 详细信息\n        info_items = [\n            (\"尺寸\", f\"{params.get('size', '未知')}\"),\n            (\"种子值\", f\"{params.get('seed', '未知')}\"),\n            (\"引导强度\", f\"{params.get('guidance_scale', '未知')}\"),\n            (\"生成模型\", f\"{params.get('model', '未知模型')}\"),\n            (\"生成时间\", self.format_time(self.image_data.get('created_at', ''))),\n            (\"文件大小\", self.format_file_size(self.image_data.get('file_size', 0))),\n            (\"文件路径\", self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')),\n        ]\n        \n        # 如果是图生图，显示参考图信息\n        if params.get('model', '').find('i2i') != -1:\n            info_items.insert(-2, (\"生成类型\", \"图生图\"))\n            input_image = self.image_data.get('input_image', '')\n            if input_image:\n                info_items.insert(-2, (\"参考图片\", input_image))\n        else:\n            info_items.insert(-2, (\"生成类型\", \"文生图\"))\n        \n        for label, value in info_items:\n            label_widget = QLabel(f\"<b>{label}:</b>\")\n            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px; ;\")\n            self.params_layout.addWidget(label_widget)\n            \n            # 使用可点击的标签\n            value_clickable = ClickableLabel(str(value))\n            value_clickable.set_text_with_ellipsis(str(value), int(self.width() * 0.25))\n            value_clickable.setWordWrap(True)\n            value_clickable.setStyleSheet(\"\"\"\n                QLabel {\n                    margin: 0px; \n                    padding: 6px; \n                    background-color: #2a2a3e; \n                    color: #ffffff;\n                    border: 1px solid #555;\n                    border-radius: 4px;\n                    ;\n                    min-height: 20px;\n                }\n                QLabel:hover {\n                    background-color: #3a3a4e;\n                    border-color: #4CAF50;\n                }\n            \"\"\")\n            value_clickable.clicked.connect(self.copy_text_to_clipboard)\n            self.params_layout.addWidget(value_clickable)\n            \n            # 保存标签引用\n            self.param_labels.append((label_widget, value_clickable))\n    \n    def update_params_area(self):\n        \"\"\"更新参数显示区域（切换图片时调用）\"\"\"\n        # 重新创建所有参数标签\n        self.create_param_labels()\n\n    def closeEvent(self, event):\n        try:\n            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n                self._focus_timer.stop()\n        except Exception:\n            pass\n\n        try:\n            self._export_controller.dispose()\n        except Exception:\n            pass\n\n        super().closeEvent(event)\n    \n    def keyPressEvent(self, event):\n        \"\"\"键盘事件处理\"\"\"\n        from PyQt5.QtCore import Qt\n        \n        logger.debug(f\"[KEYBOARD] ImageDetailDialog键盘事件: {event.key()}\")\n        \n        if event.key() == Qt.Key_Left:\n            # 左方向键：上一张图片\n            if self.prev_btn.isEnabled():\n                self.show_previous_image()\n            event.accept()\n        elif event.key() == Qt.Key_Right:\n            # 右方向键：下一张图片\n            if self.next_btn.isEnabled():\n                self.show_next_image()\n            event.accept()\n        elif event.key() == Qt.Key_Escape:\n            # ESC键：关闭对话框（保持原有功能）\n            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n            if self.is_fullscreen:\n                self.exit_fullscreen()\n            else:\n                self.accept()\n            event.accept()\n        elif event.key() == Qt.Key_F11:\n            # F11键：全屏切换（保持原有功能）\n            self.toggle_fullscreen()\n            event.accept()\n        else:\n            # 其他按键交给父类处理\n            super().keyPressEvent(event)\n\n","numLines":847,"startLine":1,"totalLines":847}}}
{"parentUuid":"71a792b0-23b1-4f53-a6a6-a9b8489e6e2f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017PPQqNRd3qmRn9EE2vUPHY","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我检查 `reference_display.py` 中的 `get_model_display_name` 和 `pick_model_code` 函数："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":32819,"cache_read_input_tokens":86827,"cache_creation":{"ephemeral_5m_input_tokens":32819,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"363033e1-3ffa-445d-93ea-b8ec9319e7c4","timestamp":"2025-12-11T08:09:58.167Z"}
{"parentUuid":"363033e1-3ffa-445d-93ea-b8ec9319e7c4","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017PPQqNRd3qmRn9EE2vUPHY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gq4jaQZXJGjbfs55kh1bQJ","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/utils/reference_display.py","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":32819,"cache_read_input_tokens":86827,"cache_creation":{"ephemeral_5m_input_tokens":32819,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"4a9501e7-3731-47bc-ba85-25e1af2483b9","timestamp":"2025-12-11T08:09:58.627Z"}
{"parentUuid":"4a9501e7-3731-47bc-ba85-25e1af2483b9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gq4jaQZXJGjbfs55kh1bQJ","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"Reference/record formatting helpers extracted from qt_app.\"\"\"\n     4→\n     5→from __future__ import annotations\n     6→\n     7→import json\n     8→from pathlib import Path\n     9→from typing import Any, Dict, List, Optional, Sequence\n    10→\n    11→from config_api import get_storage_dir\n    12→from utils.logger import logger\n    13→from utils.reference_assets import collect_reference_assets, summarize_reference_assets\n    14→\n    15→__all__ = [\n    16→    \"get_model_display_name\",\n    17→    \"build_resolution_text\",\n    18→    \"pick_model_code\",\n    19→    \"_evaluate_dependency_rules\",\n    20→    \"_mask_reference_ids\",\n    21→    \"_mask_record_id\",\n    22→    \"_summarize_masked_ids\",\n    23→    \"_format_dir_hint\",\n    24→    \"ensure_reference_info\",\n    25→    \"resolve_reference_assets\",\n    26→    \"format_reference_display_label\",\n    27→]\n    28→\n    29→\n    30→def get_model_display_name(model_code: str) -> str:\n    31→    \"\"\"将模型代码转换为完整的显示名称\"\"\"\n    32→    model_mapping = {\n    33→        \"pro\": \"Seedance Pro\",\n    34→        \"lite\": \"Seedance Lite\",\n    35→        \"doubao-seedance-1-0-pro\": \"Seedance Pro\",\n    36→        \"doubao-seedance-1-0-lite\": \"Seedance Lite\",\n    37→        \"doubao-seedance-1-0-pro-250528\": \"Seedance Pro\",\n    38→        \"doubao-seedance-1-0-lite-250528\": \"Seedance Lite\",\n    39→        \"cogview-3\": \"CogView-3\",\n    40→        \"cogview-3-plus\": \"CogView-3 Plus\",\n    41→    }\n    42→\n    43→    if model_code in model_mapping:\n    44→        return model_mapping[model_code]\n    45→\n    46→    model_lower = model_code.lower()\n    47→    if \"pro\" in model_lower:\n    48→        return \"Seedance Pro\"\n    49→    if \"lite\" in model_lower:\n    50→        return \"Seedance Lite\"\n    51→    if \"cogview\" in model_lower:\n    52→        return \"CogView\"\n    53→    return model_code.replace(\"_\", \" \").replace(\"-\", \" \").title() if model_code else \"未知模型\"\n    54→\n    55→\n    56→def _parse_parameters_field(rec: Dict[str, Any]) -> Dict[str, Any]:\n    57→    params = rec.get(\"parameters\", {})\n    58→    if isinstance(params, str):\n    59→        try:\n    60→            return json.loads(params) or {}\n    61→        except Exception:\n    62→            return {}\n    63→    return params or {}\n    64→\n    65→\n    66→def build_resolution_text(rec: Dict[str, Any]) -> str:\n    67→    \"\"\"优先显示 '分辨率档位 + 比例'，否则回退为 'widthxheight'.\"\"\"\n    68→    try:\n    69→        params = _parse_parameters_field(rec)\n    70→        rg = params.get(\"resolution_grade\") or rec.get(\"resolution_grade\")\n    71→        rt = params.get(\"ratio\") or rec.get(\"ratio\")\n    72→        if rg and rt:\n    73→            return f\"{str(rg)} {str(rt)}\"\n    74→        if rg:\n    75→            return str(rg)\n    76→\n    77→        def _to_int(value: Any) -> Optional[int]:\n    78→            try:\n    79→                return int(float(value))\n    80→            except Exception:\n    81→                return None\n    82→\n    83→        width = rec.get(\"width\") or params.get(\"width\")\n    84→        height = rec.get(\"height\") or params.get(\"height\")\n    85→        w = _to_int(width)\n    86→        h = _to_int(height)\n    87→        if w and h:\n    88→            return f\"{w}x{h}\"\n    89→        res = rec.get(\"resolution\")\n    90→        if isinstance(res, str) and res.strip():\n    91→            return res\n    92→        return \"未知\"\n    93→    except Exception:\n    94→        return \"未知\"\n    95→\n    96→\n    97→def pick_model_code(rec: Dict[str, Any]) -> str:\n    98→    \"\"\"优先顶层 model；否则从 parameters 中推断.\"\"\"\n    99→    try:\n   100→        top = rec.get(\"model\")\n   101→        if top:\n   102→            return str(top)\n   103→        params = _parse_parameters_field(rec)\n   104→        cand = params.get(\"model\") or params.get(\"model_id\")\n   105→        if cand:\n   106→            return str(cand)\n   107→        mt = params.get(\"model_type\") or rec.get(\"model_type\")\n   108→        if isinstance(mt, str) and mt.strip():\n   109→            return mt.strip()\n   110→        mode_txt = params.get(\"mode\") or rec.get(\"mode\") or \"\"\n   111→        lower_mode = str(mode_txt).lower()\n   112→        if \"pro\" in lower_mode:\n   113→            return \"pro\"\n   114→        if \"lite\" in lower_mode or \"i2v\" in lower_mode or \"t2v\" in lower_mode:\n   115→            return \"lite\"\n   116→        return \"seedance\"\n   117→    except Exception:\n   118→        return \"seedance\"\n   119→\n   120→\n   121→def _evaluate_dependency_rules(rules: Sequence[Dict[str, Any]], values: Dict[str, Any]) -> bool:\n   122→    if not rules:\n   123→        return True\n   124→\n   125→    def _truthy(val: Any) -> bool:\n   126→        return bool(val) and val not in (\"\", None)\n   127→\n   128→    for rule in rules:\n   129→        field = rule.get(\"field\")\n   130→        if not field:\n   131→            continue\n   132→        current = values.get(field)\n   133→        if rule.get(\"exists\") and not _truthy(current):\n   134→            return False\n   135→        if \"equals\" in rule and current != rule.get(\"equals\"):\n   136→            return False\n   137→        if \"not_equals\" in rule and current == rule.get(\"not_equals\"):\n   138→            return False\n   139→    return True\n   140→\n   141→\n   142→def _mask_reference_ids(assets: Sequence[Dict[str, Any]]) -> str:\n   143→    masked: List[str] = []\n   144→    for rec in assets or []:\n   145→        rid = rec.get(\"id\") if isinstance(rec, dict) else None\n   146→        if rid:\n   147→            masked.append(f\"{str(rid)[:6]}***\")\n   148→    return \",\".join(masked) if masked else \"-\"\n   149→\n   150→\n   151→def _mask_record_id(record_id: Any) -> str:\n   152→    if not record_id:\n   153→        return \"-\"\n   154→    text = str(record_id)\n   155→    return f\"{text[:6]}***\"\n   156→\n   157→\n   158→def _summarize_masked_ids(ids: Sequence[str], limit: int = 5) -> str:\n   159→    masked = [f\"{str(rid)[:6]}***\" for rid in ids if rid]\n   160→    if not masked:\n   161→        return \"-\"\n   162→    if len(masked) > limit:\n   163→        return \",\".join(masked[:limit]) + \",...\"\n   164→    return \",\".join(masked)\n   165→\n   166→\n   167→def _format_dir_hint(path: Path) -> str:\n   168→    try:\n   169→        directory = Path(path)\n   170→        name = directory.name\n   171→    except Exception:\n   172→        return \"…\"\n   173→    return f\"…/{name}\" if name else \"…\"\n   174→\n   175→\n   176→def ensure_reference_info(record: Dict[str, Any]) -> Dict[str, Any]:\n   177→    if not isinstance(record, dict):\n   178→        return {}\n   179→    info = record.get(\"_reference_info\")\n   180→    if not isinstance(info, dict):\n   181→        info = summarize_reference_assets(record)\n   182→        record[\"_reference_info\"] = info\n   183→    return info or {}\n   184→\n   185→\n   186→def resolve_reference_assets(record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n   187→    logger.debug(f\"[resolve_reference_assets] 开始解析，absolute={absolute}\")\n   188→    if not isinstance(record, dict):\n   189→        return []\n   190→    cache_key = \"_resolved_reference_assets_abs\" if absolute else \"_resolved_reference_assets\"\n   191→    cached = record.get(cache_key)\n   192→    if isinstance(cached, list):\n   193→        logger.debug(f\"[resolve_reference_assets] 使用缓存数据，数量: {len(cached)}\")\n   194→        return cached\n   195→\n   196→    assets = collect_reference_assets(record)\n   197→    logger.debug(f\"[resolve_reference_assets] 收集到参考图数量: {len(assets)}\")\n   198→    if not assets:\n   199→        record[cache_key] = []\n   200→        return []\n   201→\n   202→    if assets:\n   203→        logger.debug(f\"[resolve_reference_assets] 第一个参考图原始数据: {assets[0]}\")\n   204→\n   205→    resolved: List[Dict[str, Any]] = []\n   206→    storage = None\n   207→    try:\n   208→        from modules.storage import get_v2_storage_manager\n   209→\n   210→        storage = get_v2_storage_manager(get_storage_dir())\n   211→        logger.debug(\"[resolve_reference_assets] 尝试调用 storage.resolve_reference_records\")\n   212→        resolved = storage.resolve_reference_records(assets, absolute=absolute)\n   213→        logger.debug(f\"[resolve_reference_assets] storage返回数量: {len(resolved)}\")\n   214→    except Exception as exc:\n   215→        logger.error(f\"[resolve_reference_assets] storage.resolve_reference_records 失败: {exc}\")\n   216→        logger.debug(f\"resolve_reference_assets failed: {exc}\")\n   217→        resolved = []\n   218→        for asset in assets:\n   219→            if not isinstance(asset, dict):\n   220→                continue\n   221→            clone = dict(asset)\n   222→            if absolute:\n   223→                rel_path = clone.get(\"path\") or clone.get(\"relative_path\")\n   224→                logger.debug(f\"[resolve_reference_assets] 尝试解析相对路径: {rel_path}\")\n   225→                if storage and rel_path:\n   226→                    try:\n   227→                        abs_path = storage.resolve_reference_path(rel_path)\n   228→                        clone[\"absolute_path\"] = str(abs_path)\n   229→                        logger.debug(f\"[resolve_reference_assets] 解析成功: {abs_path}\")\n   230→                    except Exception as err:\n   231→                        logger.error(f\"[resolve_reference_assets] 解析失败: {err}\")\n   232→                        clone.setdefault(\"absolute_path\", None)\n   233→            resolved.append(clone)\n   234→\n   235→    if resolved:\n   236→        logger.debug(f\"[resolve_reference_assets] 第一个解析后的参考图: {resolved[0]}\")\n   237→\n   238→    record[cache_key] = resolved\n   239→    if absolute:\n   240→        record[\"_resolved_reference_assets\"] = resolved\n   241→    return [dict(item) for item in resolved]\n   242→\n   243→\n   244→def format_reference_display_label(asset: Dict[str, Any], fallback_index: int) -> str:\n   245→    order = asset.get(\"order\")\n   246→    if isinstance(order, (int, float)):\n   247→        ordinal = int(order) + 1\n   248→    else:\n   249→        ordinal = fallback_index + 1\n   250→    kind = asset.get(\"kind\") or asset.get(\"type\") or \"\"\n   251→    prefix = f\"#{ordinal:02d}\"\n   252→    if isinstance(kind, str) and kind.strip():\n   253→        return f\"{prefix}({kind.strip()})\"\n   254→    return prefix\n   255→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e30af2e4-7f60-4dfc-b3de-b7b7e24ec996","timestamp":"2025-12-11T08:09:58.719Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/utils/reference_display.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Reference/record formatting helpers extracted from qt_app.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional, Sequence\n\nfrom config_api import get_storage_dir\nfrom utils.logger import logger\nfrom utils.reference_assets import collect_reference_assets, summarize_reference_assets\n\n__all__ = [\n    \"get_model_display_name\",\n    \"build_resolution_text\",\n    \"pick_model_code\",\n    \"_evaluate_dependency_rules\",\n    \"_mask_reference_ids\",\n    \"_mask_record_id\",\n    \"_summarize_masked_ids\",\n    \"_format_dir_hint\",\n    \"ensure_reference_info\",\n    \"resolve_reference_assets\",\n    \"format_reference_display_label\",\n]\n\n\ndef get_model_display_name(model_code: str) -> str:\n    \"\"\"将模型代码转换为完整的显示名称\"\"\"\n    model_mapping = {\n        \"pro\": \"Seedance Pro\",\n        \"lite\": \"Seedance Lite\",\n        \"doubao-seedance-1-0-pro\": \"Seedance Pro\",\n        \"doubao-seedance-1-0-lite\": \"Seedance Lite\",\n        \"doubao-seedance-1-0-pro-250528\": \"Seedance Pro\",\n        \"doubao-seedance-1-0-lite-250528\": \"Seedance Lite\",\n        \"cogview-3\": \"CogView-3\",\n        \"cogview-3-plus\": \"CogView-3 Plus\",\n    }\n\n    if model_code in model_mapping:\n        return model_mapping[model_code]\n\n    model_lower = model_code.lower()\n    if \"pro\" in model_lower:\n        return \"Seedance Pro\"\n    if \"lite\" in model_lower:\n        return \"Seedance Lite\"\n    if \"cogview\" in model_lower:\n        return \"CogView\"\n    return model_code.replace(\"_\", \" \").replace(\"-\", \" \").title() if model_code else \"未知模型\"\n\n\ndef _parse_parameters_field(rec: Dict[str, Any]) -> Dict[str, Any]:\n    params = rec.get(\"parameters\", {})\n    if isinstance(params, str):\n        try:\n            return json.loads(params) or {}\n        except Exception:\n            return {}\n    return params or {}\n\n\ndef build_resolution_text(rec: Dict[str, Any]) -> str:\n    \"\"\"优先显示 '分辨率档位 + 比例'，否则回退为 'widthxheight'.\"\"\"\n    try:\n        params = _parse_parameters_field(rec)\n        rg = params.get(\"resolution_grade\") or rec.get(\"resolution_grade\")\n        rt = params.get(\"ratio\") or rec.get(\"ratio\")\n        if rg and rt:\n            return f\"{str(rg)} {str(rt)}\"\n        if rg:\n            return str(rg)\n\n        def _to_int(value: Any) -> Optional[int]:\n            try:\n                return int(float(value))\n            except Exception:\n                return None\n\n        width = rec.get(\"width\") or params.get(\"width\")\n        height = rec.get(\"height\") or params.get(\"height\")\n        w = _to_int(width)\n        h = _to_int(height)\n        if w and h:\n            return f\"{w}x{h}\"\n        res = rec.get(\"resolution\")\n        if isinstance(res, str) and res.strip():\n            return res\n        return \"未知\"\n    except Exception:\n        return \"未知\"\n\n\ndef pick_model_code(rec: Dict[str, Any]) -> str:\n    \"\"\"优先顶层 model；否则从 parameters 中推断.\"\"\"\n    try:\n        top = rec.get(\"model\")\n        if top:\n            return str(top)\n        params = _parse_parameters_field(rec)\n        cand = params.get(\"model\") or params.get(\"model_id\")\n        if cand:\n            return str(cand)\n        mt = params.get(\"model_type\") or rec.get(\"model_type\")\n        if isinstance(mt, str) and mt.strip():\n            return mt.strip()\n        mode_txt = params.get(\"mode\") or rec.get(\"mode\") or \"\"\n        lower_mode = str(mode_txt).lower()\n        if \"pro\" in lower_mode:\n            return \"pro\"\n        if \"lite\" in lower_mode or \"i2v\" in lower_mode or \"t2v\" in lower_mode:\n            return \"lite\"\n        return \"seedance\"\n    except Exception:\n        return \"seedance\"\n\n\ndef _evaluate_dependency_rules(rules: Sequence[Dict[str, Any]], values: Dict[str, Any]) -> bool:\n    if not rules:\n        return True\n\n    def _truthy(val: Any) -> bool:\n        return bool(val) and val not in (\"\", None)\n\n    for rule in rules:\n        field = rule.get(\"field\")\n        if not field:\n            continue\n        current = values.get(field)\n        if rule.get(\"exists\") and not _truthy(current):\n            return False\n        if \"equals\" in rule and current != rule.get(\"equals\"):\n            return False\n        if \"not_equals\" in rule and current == rule.get(\"not_equals\"):\n            return False\n    return True\n\n\ndef _mask_reference_ids(assets: Sequence[Dict[str, Any]]) -> str:\n    masked: List[str] = []\n    for rec in assets or []:\n        rid = rec.get(\"id\") if isinstance(rec, dict) else None\n        if rid:\n            masked.append(f\"{str(rid)[:6]}***\")\n    return \",\".join(masked) if masked else \"-\"\n\n\ndef _mask_record_id(record_id: Any) -> str:\n    if not record_id:\n        return \"-\"\n    text = str(record_id)\n    return f\"{text[:6]}***\"\n\n\ndef _summarize_masked_ids(ids: Sequence[str], limit: int = 5) -> str:\n    masked = [f\"{str(rid)[:6]}***\" for rid in ids if rid]\n    if not masked:\n        return \"-\"\n    if len(masked) > limit:\n        return \",\".join(masked[:limit]) + \",...\"\n    return \",\".join(masked)\n\n\ndef _format_dir_hint(path: Path) -> str:\n    try:\n        directory = Path(path)\n        name = directory.name\n    except Exception:\n        return \"…\"\n    return f\"…/{name}\" if name else \"…\"\n\n\ndef ensure_reference_info(record: Dict[str, Any]) -> Dict[str, Any]:\n    if not isinstance(record, dict):\n        return {}\n    info = record.get(\"_reference_info\")\n    if not isinstance(info, dict):\n        info = summarize_reference_assets(record)\n        record[\"_reference_info\"] = info\n    return info or {}\n\n\ndef resolve_reference_assets(record: Dict[str, Any], *, absolute: bool = False) -> List[Dict[str, Any]]:\n    logger.debug(f\"[resolve_reference_assets] 开始解析，absolute={absolute}\")\n    if not isinstance(record, dict):\n        return []\n    cache_key = \"_resolved_reference_assets_abs\" if absolute else \"_resolved_reference_assets\"\n    cached = record.get(cache_key)\n    if isinstance(cached, list):\n        logger.debug(f\"[resolve_reference_assets] 使用缓存数据，数量: {len(cached)}\")\n        return cached\n\n    assets = collect_reference_assets(record)\n    logger.debug(f\"[resolve_reference_assets] 收集到参考图数量: {len(assets)}\")\n    if not assets:\n        record[cache_key] = []\n        return []\n\n    if assets:\n        logger.debug(f\"[resolve_reference_assets] 第一个参考图原始数据: {assets[0]}\")\n\n    resolved: List[Dict[str, Any]] = []\n    storage = None\n    try:\n        from modules.storage import get_v2_storage_manager\n\n        storage = get_v2_storage_manager(get_storage_dir())\n        logger.debug(\"[resolve_reference_assets] 尝试调用 storage.resolve_reference_records\")\n        resolved = storage.resolve_reference_records(assets, absolute=absolute)\n        logger.debug(f\"[resolve_reference_assets] storage返回数量: {len(resolved)}\")\n    except Exception as exc:\n        logger.error(f\"[resolve_reference_assets] storage.resolve_reference_records 失败: {exc}\")\n        logger.debug(f\"resolve_reference_assets failed: {exc}\")\n        resolved = []\n        for asset in assets:\n            if not isinstance(asset, dict):\n                continue\n            clone = dict(asset)\n            if absolute:\n                rel_path = clone.get(\"path\") or clone.get(\"relative_path\")\n                logger.debug(f\"[resolve_reference_assets] 尝试解析相对路径: {rel_path}\")\n                if storage and rel_path:\n                    try:\n                        abs_path = storage.resolve_reference_path(rel_path)\n                        clone[\"absolute_path\"] = str(abs_path)\n                        logger.debug(f\"[resolve_reference_assets] 解析成功: {abs_path}\")\n                    except Exception as err:\n                        logger.error(f\"[resolve_reference_assets] 解析失败: {err}\")\n                        clone.setdefault(\"absolute_path\", None)\n            resolved.append(clone)\n\n    if resolved:\n        logger.debug(f\"[resolve_reference_assets] 第一个解析后的参考图: {resolved[0]}\")\n\n    record[cache_key] = resolved\n    if absolute:\n        record[\"_resolved_reference_assets\"] = resolved\n    return [dict(item) for item in resolved]\n\n\ndef format_reference_display_label(asset: Dict[str, Any], fallback_index: int) -> str:\n    order = asset.get(\"order\")\n    if isinstance(order, (int, float)):\n        ordinal = int(order) + 1\n    else:\n        ordinal = fallback_index + 1\n    kind = asset.get(\"kind\") or asset.get(\"type\") or \"\"\n    prefix = f\"#{ordinal:02d}\"\n    if isinstance(kind, str) and kind.strip():\n        return f\"{prefix}({kind.strip()})\"\n    return prefix\n","numLines":255,"startLine":1,"totalLines":255}}}
{"parentUuid":"e30af2e4-7f60-4dfc-b3de-b7b7e24ec996","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"cce821a6-ea45-4561-9c97-dd9313e34b80","version":"2.0.65","gitBranch":"main","agentId":"aa22b3d","slug":"compiled-herding-bengio","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Q3yf4n16GWqoeJuCUeqXhe","type":"message","role":"assistant","content":[{"type":"text","text":"完美！现在我已经有了完整的信息。让我总结问题根源：\n\n## 问题根源分析报告\n\n我已经找到了 `model_variant` 在保存和显示时被覆盖或丢失的关键位置。以下是详细的问题分析：\n\n### 一、流程概览\n\n**用户选择 Pro-fast → 生成成功 → 保存参数 → 详情页显示错误**\n\n---\n\n### 二、核心问题位置\n\n#### 问题1: `_get_display_model_name()` 方法中的硬编码覆盖\n**文件:** `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py`\n**行号:** 1197-1211\n\n```python\ndef _get_display_model_name(self, result: Dict[str, Any]) -> str:\n    \"\"\"获取用于显示的模型名称\"\"\"\n    # 从参数中获取模型变体信息\n    params = result.get('parameters', {})\n    model_variant = params.get('model_variant', '')\n    use_pro_model = params.get('use_pro_model', True)\n    \n    # 根据模型变体返回友好的显示名称\n    if 'seedance_pro' in model_variant or (use_pro_model and not model_variant):\n        return 'seedance 1.0 pro'  # 硬编码!\n    elif 'seedance_lite' in model_variant or (not use_pro_model and not model_variant):\n        return 'seedance 1.0 lite'\n    else:\n        # 回退到原始模型名称或默认值\n        return result.get('model', 'seedance')\n```\n\n**问题:** 第1205行的条件 `if 'seedance_pro' in model_variant` 会同时匹配 `seedance_pro` 和 `seedance_pro_fast`，导致 `seedance_pro_fast` 被错误地显示为 `seedance 1.0 pro`。\n\n---\n\n#### 问题2: 保存到数据库时的模型信息处理\n**文件:** `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py`\n**行号:** 660\n\n```python\n'model': self._get_display_model_name(result),  # 使用显示名称而非原始 model_variant\n```\n\n**问题:** 保存的是 `_get_display_model_name()` 的返回值（\"seedance 1.0 pro\"），而不是原始的 `model_variant`（\"seedance_pro_fast\"）。\n\n---\n\n#### 问题3: 详情页显示逻辑依赖 `pick_model_code()` 函数\n**文件:** `/Users/yunchang/Documents/GitHub/gemeng2/utils/reference_display.py`\n**行号:** 97-118\n\n```python\ndef pick_model_code(rec: Dict[str, Any]) -> str:\n    \"\"\"优先顶层 model；否则从 parameters 中推断.\"\"\"\n    try:\n        top = rec.get(\"model\")  # 获取的是 \"seedance 1.0 pro\" 而非原始 model_variant\n        if top:\n            return str(top)\n        params = _parse_parameters_field(rec)\n        cand = params.get(\"model\") or params.get(\"model_id\")\n        # ... 后续逻辑...\n```\n\n**问题:** 这个函数优先读取 `record['model']` 字段，而这个字段在保存时已经被覆盖为显示名称 \"seedance 1.0 pro\"，永远无法恢复原始的 \"seedance_pro_fast\"。\n\n---\n\n#### 问题4: 详情页最终显示调用链\n**文件:** `/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py`\n**行号:** 378\n\n```python\n(\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n```\n\n**流程:**\n1. `pick_model_code(record)` → 返回 \"seedance 1.0 pro\"（已被破坏）\n2. `get_model_display_name(\"seedance 1.0 pro\")` → 返回 \"Seedance Pro\"（不区分 fast 版本）\n\n---\n\n### 三、为什么 Pro-fast 信息丢失\n\n| 阶段 | 文件位置 | 变量值 | 问题 |\n|------|---------|-------|------|\n| 参数输入 | video_service.py 106 | `model_variant = \"seedance_pro_fast\"` | ✅ 正确 |\n| 参数构建 | video_service.py 277 | `\"model_variant\": \"seedance_pro_fast\"` | ✅ 保存到 parameters |\n| 本地保存 | manager.py 660 | `'model': \"seedance 1.0 pro\"` (hardcoded) | ❌ **被覆盖** |\n| 数据库读取 | reference_display.py 100 | `record.get(\"model\")` → \"seedance 1.0 pro\" | ❌ 错误值 |\n| 详情页显示 | video_detail_dialog.py 378 | 最终显示 \"Seedance Pro\" | ❌ 无法区分 fast |\n\n---\n\n### 四、数据库中的实际存储结构\n\n**保存路径:** \n- 文件: `/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py` 行 644-668\n- 调用: `storage_manager.save_content_file()` 带上 metadata\n\n**metadata 结构 (行 645-668):**\n```python\nmetadata = {\n    'generation_id': task_id,\n    'task_id': task_id,\n    'prompt': result.get('parameters', {}).get('prompt', '...'),\n    'parameters': {\n        **result.get('parameters', {}),  # ✅ 包含 model_variant\n        # ...\n    },\n    'model': self._get_display_model_name(result),  # ❌ 被覆盖为显示名\n    # ...\n}\n```\n\n**问题:** `parameters` 字典中确实保存了原始 `model_variant`，但顶层的 `model` 字段被覆盖，导致 `pick_model_code()` 优先读取错误值。\n\n---\n\n### 五、model_variant 可能被进一步破坏的地方\n\n**在 video_service.py 的 _build_complete_result 中 (行 286):**\n```python\nparameters.update(status_result.get(\"parameters\", {}))\n```\n\n这行可能会用 API 返回的 parameters 覆盖原有的 `model_variant`（如果 API 响应中没有 `model_variant` 字段）。\n\n---\n\n## 修复建议\n\n1. **不要在顶层 `model` 字段保存显示名称** - 应该保存原始的 model_type 或 model_variant\n2. **修改 `_get_display_model_name()` 的匹配逻辑** - 使用精确匹配而非包含匹配，以区分 `seedance_pro` 和 `seedance_pro_fast`\n3. **在 `pick_model_code()` 中优先检查 `parameters.model_variant`** - 而不是依赖被破坏的顶层 `model` 字段\n4. **确保 `model_variant` 始终传递和保存** - 不被中间过程覆盖"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":3949,"cache_read_input_tokens":119646,"cache_creation":{"ephemeral_5m_input_tokens":3949,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"e7a06d21-1a24-4357-879e-ddafd421d2fb","timestamp":"2025-12-11T08:10:19.927Z"}
