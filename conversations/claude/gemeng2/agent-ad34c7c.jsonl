{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":"对比分析 `image_detail_dialog.py` 和 `video_detail_dialog.py` 中参数区域的实现差异：\n\n**重点对比**：\n1. `setup_params_area()` 方法的实现差异\n2. `_clear_params_layout()` 方法是否存在\n3. `copy_prompt_btn` 的创建和管理方式\n4. 记录切换时的更新逻辑（`update_params_area` vs `update_video_params`）\n5. `_update_theme()` 中对参数区的处理\n\n**需要找出**：\n- 视频模式为什么没有样式丢失问题\n- 两者在组件生命周期管理上的差异\n- 是否有更统一/优雅的设计模式可以借鉴\n\n请详细对比代码并给出分析。"},"uuid":"6787c2f5-5445-4c28-8865-2e3773a6c9ba","timestamp":"2025-12-22T04:32:16.597Z"}
{"parentUuid":"6787c2f5-5445-4c28-8865-2e3773a6c9ba","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GnfDuLgGcMf1qXPTzm8cP5","type":"message","role":"assistant","content":[{"type":"text","text":"我来详细对比这两个文件中参数区域的实现差异。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3291,"cache_read_input_tokens":17546,"cache_creation":{"ephemeral_5m_input_tokens":3291,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"d856adb4-64e7-48b1-9060-7784fca1d8e9","timestamp":"2025-12-22T04:32:21.628Z"}
{"parentUuid":"d856adb4-64e7-48b1-9060-7784fca1d8e9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GnfDuLgGcMf1qXPTzm8cP5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NsVyhQUiQ9GVzkxijd1Ba2","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3291,"cache_read_input_tokens":17546,"cache_creation":{"ephemeral_5m_input_tokens":3291,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"type":"assistant","uuid":"b3244444-654e-4376-bab5-9a764b42b0d0","timestamp":"2025-12-22T04:32:21.728Z"}
{"parentUuid":"b3244444-654e-4376-bab5-9a764b42b0d0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GnfDuLgGcMf1qXPTzm8cP5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xervi1yDiVgEWyxLYRHEQS","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3291,"cache_read_input_tokens":17546,"cache_creation":{"ephemeral_5m_input_tokens":3291,"ephemeral_1h_input_tokens":0},"output_tokens":165,"service_tier":"standard"},"context_management":{"applied_edits":[]}},"type":"assistant","uuid":"dde276b8-b864-4606-8c0e-a3fa88479df9","timestamp":"2025-12-22T04:32:21.777Z"}
{"parentUuid":"dde276b8-b864-4606-8c0e-a3fa88479df9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NsVyhQUiQ9GVzkxijd1Ba2","type":"tool_result","content":"     1→import os\n     2→import json\n     3→from datetime import datetime\n     4→from typing import Dict, Any, List, Optional\n     5→\n     6→from PySide6.QtWidgets import (\n     7→    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n     8→    QTextEdit, QFileDialog, QMessageBox, QSplitter, QApplication,\n     9→    QMenu, QSizePolicy\n    10→)\n    11→from PySide6.QtGui import QAction, QShortcut\n    12→from PySide6.QtCore import Qt, QTimer, QSize, QEvent\n    13→from PySide6.QtGui import QPixmap, QKeySequence\n    14→\n    15→from utils.logger import logger\n    16→from utils.style_system import unified_style_system\n    17→from components.widgets import ZoomableImageLabel, ClickableLabel\n    18→from components.reference_assets import (\n    19→    ReferenceGalleryWidget,\n    20→    export_reference_asset,\n    21→    open_reference_preview,\n    22→    _find_reference_asset_index,\n    23→)\n    24→from components.controllers import ExportBundleController\n    25→from utils.reference_display import ensure_reference_info, resolve_reference_assets\n    26→from PySide6.QtCore import Signal\n    27→\n    28→class ImageDetailDialog(QDialog):\n    29→    \"\"\"图片详细信息对话框\"\"\"\n    30→    \n    31→    # 删除记录后发出信号，通知父视图刷新\n    32→    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    33→    \n    34→    def __init__(self, image_data: Dict[str, Any], image_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n    35→        super().__init__(parent)\n    36→        self.image_data = image_data\n    37→        self.image_list = image_list or [image_data]  # 图片列表\n    38→        self.current_index = current_index  # 当前图片索引\n    39→        self.zoom_factor = 1.0  # 缩放因子\n    40→        self.is_fullscreen = False  # 全屏状态\n    41→        self.original_geometry = None  # 原始窗口几何\n    42→        self._reference_summary = ensure_reference_info(self.image_data)\n    43→        self._reference_assets: List[Dict[str, Any]] = []\n    44→        self._export_controller = ExportBundleController(self, \"image\")\n    45→        \n    46→        # Subscribe to theme changes\n    47→        unified_style_system.styleChanged.connect(self._update_theme)\n    48→        \n    49→        self.setup_ui()\n    50→        \n    51→    def setup_ui(self):\n    52→        \"\"\"设置UI\"\"\"\n    53→        self.setWindowTitle(\"图片详细信息\")\n    54→        self.resize(1100, 800)  # 改为可调整大小\n    55→        self.setMinimumSize(800, 600)  # 设置最小尺寸\n    56→        \n    57→        # 设置焦点策略，确保能接收键盘事件\n    58→        self.setFocusPolicy(Qt.StrongFocus)\n    59→        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n    60→        self.setFocus()\n    61→\n    62→        # 确保窗口激活时获得焦点\n    63→        self.activateWindow()\n    64→        self.raise_()\n    65→\n    66→        try:\n    67→            self.setObjectName(\"DetailDialog\")\n    68→        except Exception:\n    69→            pass\n    70→\n    71→        self._focus_timer = QTimer(self)\n    72→        self._focus_timer.setSingleShot(True)\n    73→        self._focus_timer.timeout.connect(self._ensure_focus)\n    74→\n    75→        layout = QHBoxLayout(self)\n    76→        \n    77→        # 左侧：大图显示（占70%宽度）\n    78→        left_widget = QWidget()\n    79→        left_layout = QVBoxLayout(left_widget)\n    80→        left_layout.setContentsMargins(0, 0, 0, 0)\n    81→        \n    82→        # 图片显示区域（占据上方全部空间）\n    83→        image_container = QWidget()\n    84→        image_container.setObjectName(\"ImageContainer\")\n    85→        image_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n    86→\n    87→        # 在容器内创建布局\n    88→        container_layout = QVBoxLayout(image_container)\n    89→        container_layout.setContentsMargins(0, 0, 0, 0)\n    90→        container_layout.setSpacing(0)\n    91→\n    92→        # 使用可缩放的图片标签，自适应容器大小\n    93→        self.large_image_label = ZoomableImageLabel()\n    94→        self.large_image_label.setAlignment(Qt.AlignCenter)\n    95→        self.large_image_label.setStyleSheet(\"border: none; background-color: transparent;\")\n    96→        \n    97→        # 设置右键菜单\n    98→        self.large_image_label.setContextMenuPolicy(Qt.CustomContextMenu)\n    99→        self.large_image_label.customContextMenuRequested.connect(self.show_context_menu)\n   100→        \n   101→        # 加载大图\n   102→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   103→        if image_path and os.path.exists(image_path):\n   104→            pixmap = QPixmap(image_path)\n   105→            if not pixmap.isNull():\n   106→                self.large_image_label.setPixmap(pixmap)\n   107→        \n   108→        container_layout.addWidget(self.large_image_label, 1)\n   109→\n   110→        reference_section = QWidget()\n   111→        reference_section.setObjectName(\"ReferenceSection\")\n   112→        reference_section.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   113→        reference_section_layout = QVBoxLayout(reference_section)\n   114→        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n   115→        reference_section_layout.setSpacing(8)\n   116→\n   117→        self.reference_gallery = ReferenceGalleryWidget()\n   118→        self.reference_gallery.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   119→        try:\n   120→            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n   121→            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n   122→            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n   123→        except Exception:\n   124→            pass\n   125→        reference_section_layout.addWidget(self.reference_gallery, 1)\n   126→\n   127→        reference_button_layout = QHBoxLayout()\n   128→        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n   129→        reference_button_layout.setSpacing(6)\n   130→        self.export_status_label = QLabel(\"\")\n   131→        self.export_status_label.setObjectName(\"infoLabel\")\n   132→        unified_style_system.apply_to_widget(self.export_status_label)\n   133→        reference_button_layout.addWidget(self.export_status_label)\n   134→        reference_button_layout.addStretch(1)\n   135→        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n   136→        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n   137→        self.reference_export_btn.setEnabled(False)\n   138→        unified_style_system.apply_to_widget(self.reference_export_btn)\n   139→        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n   140→        reference_button_layout.addWidget(self.reference_export_btn)\n   141→        self.export_bundle_btn = QPushButton(\"导出记录\")\n   142→        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n   143→        self.export_bundle_btn.setEnabled(False)\n   144→        unified_style_system.apply_to_widget(self.export_bundle_btn)\n   145→        self._export_controller.configure(\n   146→            self.export_bundle_btn,\n   147→            self.export_status_label,\n   148→            self._resolve_record_id,\n   149→            context_widget=self,\n   150→        )\n   151→        reference_button_layout.addWidget(self.export_bundle_btn)\n   152→        reference_section_layout.addLayout(reference_button_layout)\n   153→\n   154→        self._image_reference_splitter = QSplitter(Qt.Vertical)\n   155→        self._image_reference_splitter.setObjectName(\"ImageReferenceSplitter\")\n   156→        self._image_reference_splitter.setChildrenCollapsible(False)\n   157→        self._image_reference_splitter.setHandleWidth(6)\n   158→        self._image_reference_splitter.addWidget(image_container)\n   159→        self._image_reference_splitter.addWidget(reference_section)\n   160→        self._image_reference_splitter.setStretchFactor(0, 3)\n   161→        self._image_reference_splitter.setStretchFactor(1, 2)\n   162→        self._image_reference_splitter.setSizes([520, 280])\n   163→\n   164→        left_layout.addWidget(self._image_reference_splitter, 1)\n   165→\n   166→        # 底部区域：导航按钮 + 说明文本框（与右侧参数栏高度对齐）\n   167→        bottom_layout = QHBoxLayout()\n   168→        bottom_layout.setContentsMargins(0, 5, 0, 5)\n   169→        bottom_layout.setSpacing(10)\n   170→        \n   171→        # 向左按钮\n   172→        self.prev_btn = QPushButton(\"◀\")\n   173→        self.prev_btn.setFixedSize(30, 30)  # 固定尺寸\n   174→        self.prev_btn.setObjectName(\"NavButton\")\n   175→        unified_style_system.apply_to_widget(self.prev_btn)\n   176→        self.prev_btn.clicked.connect(self.show_previous_image)\n   177→        bottom_layout.addWidget(self.prev_btn)\n   178→        \n   179→        # 中间的说明文本框（完全透明设计）\n   180→        zoom_info = QLabel(\"提示：鼠标位置缩放，点击拖拽，双击重置\")\n   181→        zoom_info.setObjectName(\"infoLabel\")\n   182→        unified_style_system.apply_to_widget(zoom_info)\n   183→        zoom_info.setAlignment(Qt.AlignCenter)\n   184→        zoom_info.setMinimumHeight(30)  # 与按钮高度一致\n   185→        zoom_info.setMaximumHeight(30)  # 固定高度，防止文字被压缩\n   186→        bottom_layout.addWidget(zoom_info, 1)  # 占据中间所有空间\n   187→        \n   188→        # 向右按钮\n   189→        self.next_btn = QPushButton(\"▶\")\n   190→        self.next_btn.setFixedSize(30, 30)  # 固定尺寸\n   191→        self.next_btn.setObjectName(\"NavButton\")\n   192→        unified_style_system.apply_to_widget(self.next_btn)\n   193→        self.next_btn.clicked.connect(self.show_next_image)\n   194→        bottom_layout.addWidget(self.next_btn)\n   195→        \n   196→        left_layout.addLayout(bottom_layout)\n   197→\n   198→        # 更新导航按钮状态\n   199→        self.update_navigation_buttons()\n   200→        self._refresh_reference_gallery()\n   201→        self._export_controller.refresh()\n   202→\n   203→        # 右侧：详细信息（固定30%宽度）\n   204→        right_layout = QVBoxLayout()\n   205→        \n   206→        # 创建参数显示区域（不使用滚动条）\n   207→        params_widget = QWidget()\n   208→        params_widget.setFixedWidth(int(self.width() * 0.3))  # 固定30%宽度\n   209→        params_widget.setObjectName(\"ParamsWidget\")\n   210→        self.params_layout = QVBoxLayout(params_widget)  # 保存引用以便后续更新\n   211→        self.params_layout.setSpacing(0)  # 设置间距为0\n   212→        self.params_layout.setContentsMargins(5, 5, 5, 5)  # 设置紧凑的边距\n   213→        \n   214→        # 初始化参数显示区域\n   215→        self.setup_params_area()\n   216→        \n   217→        \n   218→        right_layout.addWidget(params_widget)\n   219→        \n   220→        # 全屏和复制图片按钮（与参数区底部对齐）\n   221→        image_control_layout = QHBoxLayout()\n   222→\n   223→        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n   224→        self.fullscreen_btn.setMaximumHeight(30)\n   225→        unified_style_system.apply_to_widget(self.fullscreen_btn)\n   226→        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n   227→        image_control_layout.addWidget(self.fullscreen_btn)\n   228→\n   229→        self.copy_image_btn = QPushButton(\"复制图片\")\n   230→        self.copy_image_btn.setMaximumHeight(30)\n   231→        unified_style_system.apply_to_widget(self.copy_image_btn)\n   232→        self.copy_image_btn.clicked.connect(self.copy_image)\n   233→        image_control_layout.addWidget(self.copy_image_btn)\n   234→\n   235→        right_layout.addLayout(image_control_layout)\n   236→\n   237→        # 其他按钮\n   238→        button_layout = QHBoxLayout()\n   239→\n   240→        self.delete_btn = QPushButton(\"删除记录\")\n   241→        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n   242→        self.delete_btn.clicked.connect(self._delete_current_record)\n   243→        button_layout.addWidget(self.delete_btn)\n   244→\n   245→        self.close_btn = QPushButton(\"关闭（ESC）\")\n   246→        unified_style_system.apply_to_widget(self.close_btn)\n   247→        self.close_btn.clicked.connect(self.accept)\n   248→        button_layout.addWidget(self.close_btn)\n   249→        \n   250→        right_layout.addLayout(button_layout)\n   251→        \n   252→        # 设置布局比例：左侧70%，右侧30%\n   253→        layout.addWidget(left_widget, 7)\n   254→        layout.addLayout(right_layout, 3)\n   255→        \n   256→        # 添加键盘快捷键\n   257→        self.setup_shortcuts()\n   258→\n   259→        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n   260→        self._focus_timer.start(100)\n   261→\n   262→        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n   263→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   264→        \n   265→        # Apply initial theme\n   266→        self._update_theme()\n   267→    \n   268→    def format_time(self, time_str: str) -> str:\n   269→        \"\"\"格式化时间显示\"\"\"\n   270→        if not time_str:\n   271→            return '未知时间'\n   272→        try:\n   273→            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n   274→            return dt.strftime('%Y-%m-%d %H:%M:%S')\n   275→        except:\n   276→            return time_str[:19] if len(time_str) > 19 else time_str\n   277→    \n   278→    def format_file_size(self, size) -> str:\n   279→        \"\"\"格式化文件大小显示\"\"\"\n   280→        # 处理字符串类型的size\n   281→        try:\n   282→            size = float(size) if size else 0\n   283→        except (ValueError, TypeError):\n   284→            return '未知大小'\n   285→            \n   286→        if size == 0:\n   287→            return '未知大小'\n   288→        \n   289→        for unit in ['B', 'KB', 'MB', 'GB']:\n   290→            if size < 1024.0:\n   291→                return f\"{size:.1f} {unit}\"\n   292→            size /= 1024.0\n   293→        return f\"{size:.1f} TB\"\n   294→    \n   295→    def setup_shortcuts(self):\n   296→        \"\"\"设置键盘快捷键\"\"\"\n   297→        # 移除所有QShortcut，统一使用keyPressEvent处理\n   298→        # 避免快捷键冲突问题\n   299→        pass\n   300→    \n   301→    def _ensure_focus(self):\n   302→        \"\"\"确保窗口获得焦点\"\"\"\n   303→        self.activateWindow()\n   304→        self.raise_()\n   305→        self.setFocus()\n   306→        logger.debug(f\"[FOCUS] ImageDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n   307→        \n   308→    def toggle_fullscreen(self):\n   309→        \"\"\"切换全屏模式\"\"\"\n   310→        if self.is_fullscreen:\n   311→            self.exit_fullscreen()\n   312→        else:\n   313→            self.enter_fullscreen()\n   314→            \n   315→    def enter_fullscreen(self):\n   316→        \"\"\"进入全屏模式\"\"\"\n   317→        if not self.is_fullscreen:\n   318→            self.original_geometry = self.geometry()\n   319→            self.showFullScreen()\n   320→            self.is_fullscreen = True\n   321→            \n   322→    def exit_fullscreen(self):\n   323→        \"\"\"退出全屏模式\"\"\"\n   324→        if self.is_fullscreen:\n   325→            self.showNormal()\n   326→            if self.original_geometry:\n   327→                self.setGeometry(self.original_geometry)\n   328→            self.is_fullscreen = False\n   329→            \n   330→    def handle_escape_key(self):\n   331→        \"\"\"处理ESC键：如果是全屏则退出全屏，否则关闭对话框\"\"\"\n   332→        if self.is_fullscreen:\n   333→            self.exit_fullscreen()\n   334→        else:\n   335→            self.accept()  # 关闭对话框\n   336→            \n   337→    def copy_text_to_clipboard(self, text: str):\n   338→        \"\"\"复制文本到剪贴板并显示提示\"\"\"\n   339→        from PySide6.QtWidgets import QApplication\n   340→        clipboard = QApplication.clipboard()\n   341→        clipboard.setText(text)\n   342→        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n   343→        \n   344→    def show_copy_toast(self, message: str):\n   345→        \"\"\"显示复制成功的轻量提示\"\"\"\n   346→        # 创建一个临时的提示标签\n   347→        toast = QLabel(message, self)\n   348→        toast.setObjectName(\"ToastLabel\")\n   349→        toast.setAlignment(Qt.AlignCenter)\n   350→        toast.adjustSize()\n   351→        \n   352→        # 定位到窗口中央偏上\n   353→        x = (self.width() - toast.width()) // 2\n   354→        y = self.height() // 4\n   355→        toast.move(x, y)\n   356→        toast.show()\n   357→        \n   358→        # 2秒后自动隐藏\n   359→        QTimer.singleShot(2000, toast.deleteLater)\n   360→        \n   361→    def copy_prompt(self):\n   362→        \"\"\"复制提示词到剪贴板\"\"\"\n   363→        prompt_content = self.prompt_text_edit.toPlainText()\n   364→        self.copy_text_to_clipboard(prompt_content)\n   365→    \n   366→    def copy_image(self):\n   367→        \"\"\"复制图片到剪贴板\"\"\"\n   368→        from PySide6.QtWidgets import QApplication\n   369→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   370→        if image_path and os.path.exists(image_path):\n   371→            pixmap = QPixmap(image_path)\n   372→            if not pixmap.isNull():\n   373→                clipboard = QApplication.clipboard()\n   374→                clipboard.setPixmap(pixmap)\n   375→                self.show_copy_toast(\"图片已复制到剪贴板\")\n   376→            else:\n   377→                self.show_copy_toast(\"无法复制图片\")\n   378→        else:\n   379→            self.show_copy_toast(\"图片文件不存在\")\n   380→    \n   381→    def copy_all_info(self):\n   382→        \"\"\"复制所有信息到剪贴板\"\"\"\n   383→        from PySide6.QtWidgets import QApplication\n   384→        \n   385→        params = self.image_data.get('parameters', '{}')\n   386→        if isinstance(params, str):\n   387→            try:\n   388→                params = json.loads(params)\n   389→            except:\n   390→                params = {}\n   391→        \n   392→        info_text = f\"\"\"图片详细信息\n   393→===================\n   394→提示词: {self.image_data.get('prompt', '无提示词')}\n   395→尺寸: {params.get('size', '未知')}\n   396→种子值: {params.get('seed', '未知')}\n   397→引导强度: {params.get('guidance_scale', '未知')}\n   398→生成模型: {params.get('model', '未知模型')}\n   399→生成时间: {self.format_time(self.image_data.get('created_at', ''))}\n   400→文件大小: {self.format_file_size(self.image_data.get('file_size', 0))}\n   401→文件路径: {self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')}\n   402→\"\"\"\n   403→        \n   404→        clipboard = QApplication.clipboard()\n   405→        clipboard.setText(info_text)\n   406→        self.show_copy_toast(\"所有信息已复制到剪贴板\")\n   407→\n   408→    def show_copy_message(self, message: str):\n   409→        \"\"\"显示复制成功消息（已弃用，使用show_copy_toast代替）\"\"\"\n   410→        # 直接使用轻量级Toast提示\n   411→        self.show_copy_toast(message)\n   412→\n   413→    def _delete_current_record(self):\n   414→        \"\"\"删除当前记录及相关文件\"\"\"\n   415→        record_id = self._resolve_record_id()\n   416→        if not record_id:\n   417→            self.show_copy_toast(\"无法获取记录ID\")\n   418→            return\n   419→        \n   420→        try:\n   421→            # 获取 RepositoryManager\n   422→            from config_api import get_storage_dir\n   423→            from modules.repository.manager import RepositoryManager\n   424→            \n   425→            storage_dir = get_storage_dir()\n   426→            repo = RepositoryManager(storage_dir)\n   427→            \n   428→            # 执行删除\n   429→            if repo.delete_record_with_files(record_id):\n   430→                self.show_copy_toast(\"记录已删除\")\n   431→                \n   432→                # 发出信号通知父视图刷新\n   433→                self.recordDeleted.emit(record_id)\n   434→                \n   435→                # 从列表中移除当前记录\n   436→                if len(self.image_list) > 1:\n   437→                    del self.image_list[self.current_index]\n   438→                    \n   439→                    # 导航到后一条记录（保持索引，指向原来的下一条）\n   440→                    # 只有当删除的是最后一条时，才需要调整索引\n   441→                    if self.current_index >= len(self.image_list):\n   442→                        self.current_index = len(self.image_list) - 1\n   443→                    \n   444→                    self.load_current_image()\n   445→                    self.update_navigation_buttons()\n   446→                else:\n   447→                    # 只剩一条记录，关闭对话框\n   448→                    self.accept()\n   449→            else:\n   450→                self.show_copy_toast(\"删除失败\")\n   451→        except Exception as e:\n   452→            from utils.logger import logger\n   453→            logger.error(f\"删除记录异常: {e}\")\n   454→            self.show_copy_toast(f\"删除失败: {str(e)}\")\n   455→\n   456→    def _on_reference_clicked(self, asset: Dict[str, Any]):\n   457→        assets = list(self._reference_assets) if self._reference_assets else [asset]\n   458→        start_idx = _find_reference_asset_index(assets, asset)\n   459→        open_reference_preview(\n   460→            self,\n   461→            asset,\n   462→            title_prefix=\"参考图\",\n   463→            asset_list=assets,\n   464→            start_index=start_idx,\n   465→            on_asset_changed=self._sync_reference_selection,\n   466→        )\n   467→\n   468→    def _on_reference_export(self, asset: Dict[str, Any]):\n   469→        export_reference_asset(self, asset)\n   470→\n   471→    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n   472→        asset_path = None\n   473→        if isinstance(asset, dict):\n   474→            asset_path = asset.get('absolute_path') or asset.get('path')\n   475→        has_path = bool(asset_path and os.path.exists(asset_path))\n   476→        if hasattr(self, 'reference_export_btn'):\n   477→            self.reference_export_btn.setEnabled(has_path)\n   478→\n   479→    def _export_selected_reference(self):\n   480→        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n   481→        if not asset:\n   482→            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n   483→            return\n   484→        export_reference_asset(self, asset)\n   485→\n   486→    def _refresh_reference_gallery(self):\n   487→        if not hasattr(self, 'reference_gallery'):\n   488→            return\n   489→        self._reference_summary = ensure_reference_info(self.image_data)\n   490→        if self._reference_summary.get('count', 0) <= 0:\n   491→            self.reference_gallery.clear()\n   492→            self.reference_gallery.setVisible(False)\n   493→            if hasattr(self, 'reference_export_btn'):\n   494→                self.reference_export_btn.setEnabled(False)\n   495→            self._reference_assets = []\n   496→            self._export_controller.refresh()\n   497→            return\n   498→        try:\n   499→            self._reference_assets = resolve_reference_assets(self.image_data, absolute=True)\n   500→        except Exception:\n   501→            self._reference_assets = []\n   502→        self.reference_gallery.setVisible(True)\n   503→        self.reference_gallery.set_assets(self._reference_assets)\n   504→        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n   505→        self._export_controller.refresh()\n   506→\n   507→    def _sync_reference_selection(self, asset: Dict[str, Any]):\n   508→        try:\n   509→            self.reference_gallery.select_asset(asset)\n   510→        except Exception:\n   511→            pass\n   512→\n   513→    def _resolve_record_id(self) -> Optional[str]:\n   514→        for key in (\"file_id\", \"id\", \"generation_id\"):\n   515→            value = self.image_data.get(key)\n   516→            if value not in (None, \"\"):\n   517→                return str(value)\n   518→        return None\n   519→\n   520→    def show_context_menu(self, position):\n   521→        \"\"\"显示右键菜单\"\"\"\n   522→        from PySide6.QtWidgets import QMenu\n   523→        from PySide6.QtGui import QAction, QShortcut\n   524→        \n   525→        menu = QMenu(self)\n   526→        \n   527→        # 复制图片动作\n   528→        copy_action = QAction(\"复制图片\", self)\n   529→        copy_action.triggered.connect(self.copy_image)\n   530→        menu.addAction(copy_action)\n   531→        \n   532→        # 下载图片动作\n   533→        download_action = QAction(\"下载图片\", self)\n   534→        download_action.triggered.connect(self.download_image)\n   535→        menu.addAction(download_action)\n   536→        \n   537→        # 显示菜单\n   538→        menu.exec(self.large_image_label.mapToGlobal(position))\n   539→    \n   540→    def download_image(self):\n   541→        \"\"\"下载图片到指定位置\"\"\"\n   542→        from PySide6.QtWidgets import QFileDialog, QMessageBox\n   543→        import shutil\n   544→        \n   545→        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n   546→        if not image_path or not os.path.exists(image_path):\n   547→            self.show_styled_message(\"错误\", \"图片文件不存在\", \"warning\")\n   548→            return\n   549→        \n   550→        # 获取原始文件名\n   551→        original_filename = os.path.basename(image_path)\n   552→        \n   553→        # 打开保存对话框\n   554→        save_path, _ = QFileDialog.getSaveFileName(\n   555→            self,\n   556→            \"保存图片\",\n   557→            original_filename,\n   558→            \"图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)\"\n   559→        )\n   560→        \n   561→        if save_path:\n   562→            try:\n   563→                shutil.copy2(image_path, save_path)\n   564→                self.show_styled_message(\"成功\", f\"图片已保存到:\\n{save_path}\", \"information\")\n   565→            except Exception as e:\n   566→                self.show_styled_message(\"错误\", f\"保存图片失败:\\n{str(e)}\", \"critical\")\n   567→    \n   568→    def update_navigation_buttons(self):\n   569→        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n   570→        # 检查是否有图片列表\n   571→        if len(self.image_list) <= 1:\n   572→            self.prev_btn.setEnabled(False)\n   573→            self.next_btn.setEnabled(False)\n   574→            self.prev_btn.setToolTip(\"没有更多图片\")\n   575→            self.next_btn.setToolTip(\"没有更多图片\")\n   576→            return\n   577→        \n   578→        # 更新按钮状态（基于有效记录检查）\n   579→        self.prev_btn.setEnabled(self._has_valid_previous_record())\n   580→        self.next_btn.setEnabled(self._has_valid_next_record())\n   581→        \n   582→        # 更新工具提示显示当前位置和快捷键信息\n   583→        current_pos = f\"({self.current_index + 1}/{len(self.image_list)})\"\n   584→        self.prev_btn.setToolTip(f\"上一张 {current_pos} - 快捷键: ←\")\n   585→        self.next_btn.setToolTip(f\"下一张 {current_pos} - 快捷键: →\")\n   586→        \n   587→        # 按钮文本保持简洁的箭头符号\n   588→        self.prev_btn.setText(\"◀\")\n   589→    \n   590→    def _has_valid_previous_record(self):\n   591→        \"\"\"检查是否有有效的上一个记录\"\"\"\n   592→        for i in range(self.current_index - 1, -1, -1):\n   593→            candidate_data = self.image_list[i]\n   594→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   595→            if file_path and os.path.exists(file_path):\n   596→                return True\n   597→        return False\n   598→    \n   599→    def _has_valid_next_record(self):\n   600→        \"\"\"检查是否有有效的下一个记录\"\"\"\n   601→        for i in range(self.current_index + 1, len(self.image_list)):\n   602→            candidate_data = self.image_list[i]\n   603→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   604→            if file_path and os.path.exists(file_path):\n   605→                return True\n   606→        return False\n   607→    \n   608→    def show_previous_image(self):\n   609→        \"\"\"显示上一张图片（带有效性验证）\"\"\"\n   610→        # 寻找上一个有效记录\n   611→        for i in range(self.current_index - 1, -1, -1):\n   612→            candidate_data = self.image_list[i]\n   613→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   614→            \n   615→            if file_path and os.path.exists(file_path):\n   616→                # 找到有效记录\n   617→                self.current_index = i\n   618→                self.load_current_image()\n   619→                self.update_navigation_buttons()\n   620→                return\n   621→        \n   622→        # 没有找到有效的上一个记录，保持当前状态\n   623→        self.update_navigation_buttons()\n   624→    \n   625→    def show_next_image(self):\n   626→        \"\"\"显示下一张图片（带有效性验证）\"\"\"\n   627→        # 寻找下一个有效记录\n   628→        for i in range(self.current_index + 1, len(self.image_list)):\n   629→            candidate_data = self.image_list[i]\n   630→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n   631→            \n   632→            if file_path and os.path.exists(file_path):\n   633→                # 找到有效记录\n   634→                self.current_index = i\n   635→                self.load_current_image()\n   636→                self.update_navigation_buttons()\n   637→                return\n   638→        \n   639→        # 没有找到有效的下一个记录，保持当前状态\n   640→        self.update_navigation_buttons()\n   641→    \n   642→    def load_current_image(self):\n   643→        \"\"\"加载当前索引的图片\"\"\"\n   644→        if 0 <= self.current_index < len(self.image_list):\n   645→            # 更新当前图片数据\n   646→            self.image_data = self.image_list[self.current_index]\n   647→            \n   648→            # 重新加载图片\n   649→            image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '') or self.image_data.get('file_path', '')\n   650→            if image_path and os.path.exists(image_path):\n   651→                pixmap = QPixmap(image_path)\n   652→                if not pixmap.isNull():\n   653→                    self.large_image_label.setPixmap(pixmap)\n   654→                else:\n   655→                    self.large_image_label.setText(\"图片加载失败\")\n   656→            else:\n   657→                self.large_image_label.setText(\"图片不存在\")\n   658→            \n   659→            # 更新窗口标题\n   660→            self.setWindowTitle(f\"图片详细信息 ({self.current_index + 1}/{len(self.image_list)})\")\n   661→            \n   662→            # 更新提示词内容\n   663→            prompt_content = self.image_data.get('prompt', '无提示词')\n   664→            self.prompt_text_edit.setPlainText(prompt_content)\n   665→            \n   666→            # 更新参数信息\n   667→            self.update_params_area()\n   668→            self._refresh_reference_gallery()\n   669→\n   670→        self._export_controller.refresh()\n   671→    \n   672→    def setup_params_area(self):\n   673→        \"\"\"初始化参数显示区域\"\"\"\n   674→        # Ensure this area is deterministic (avoid stale/duplicated widgets across refresh/theme changes)\n   675→        self._clear_params_layout()\n   676→\n   677→        # 解析生成参数\n   678→        params = self.image_data.get('parameters', '{}')\n   679→        if isinstance(params, str):\n   680→            try:\n   681→                params = json.loads(params)\n   682→            except:\n   683→                params = {}\n   684→        \n   685→        # 提示词区域（可滚动查看全文）\n   686→        prompt_label = QLabel(\"<b>提示词:</b>\")\n   687→        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   688→        unified_style_system.apply_to_widget(prompt_label)\n   689→        self.params_layout.addWidget(prompt_label)\n   690→        \n   691→        # 提示词文本框\n   692→        prompt_content = self.image_data.get('prompt', '无提示词')\n   693→        self.prompt_text_edit = QTextEdit()\n   694→        self.prompt_text_edit.setPlainText(prompt_content)\n   695→        self.prompt_text_edit.setReadOnly(True)  # 只读模式\n   696→        # 约 4 行高度（按当前字体动态计算），避免信息区过高压缩其它内容\n   697→        try:\n   698→            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n   699→            target_lines = 4\n   700→            vertical_padding = 16  # 与全局 QTextEdit padding (8*2) 对齐\n   701→            border = 2  # 1px*2\n   702→            height = line_height * target_lines + vertical_padding + border\n   703→            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n   704→        except Exception:\n   705→            self.prompt_text_edit.setMaximumHeight(96)\n   706→            self.prompt_text_edit.setMinimumHeight(96)\n   707→        self.prompt_text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n   708→        self.prompt_text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n   709→        unified_style_system.apply_to_widget(self.prompt_text_edit)\n   710→        # 应用与 _update_theme 一致的额外样式\n   711→        colors = unified_style_system.get_colors()\n   712→        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card')\n   713→        text_color = colors.get('text') or colors.get('palette.text.primary')\n   714→        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   715→        brand = colors.get('palette.brand.main') or colors.get('primary')\n   716→        self.prompt_text_edit.setStyleSheet(f\"\"\"\n   717→            QTextEdit {{\n   718→                background-color: {bg_input};\n   719→                color: {text_color};\n   720→                border: 1px solid {border_subtle};\n   721→                border-radius: 8px;\n   722→                padding: 8px;\n   723→            }}\n   724→            QTextEdit:focus {{\n   725→                border-color: {brand};\n   726→            }}\n   727→        \"\"\")\n   728→        self.params_layout.addWidget(self.prompt_text_edit)\n   729→        \n   730→        # 添加复制提示词按钮（使用统一的 SecondaryButton 样式）\n   731→        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n   732→        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n   733→        self.copy_prompt_btn.setMaximumHeight(30)\n   734→        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n   735→        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n   736→        self.params_layout.addWidget(self.copy_prompt_btn)\n   737→        \n   738→        # 存储参数标签列表，用于后续清理\n   739→        self.param_labels = []\n   740→        self.create_param_labels()\n   741→\n   742→    def _clear_params_layout(self):\n   743→        \"\"\"清空参数区布局中的所有控件（保留布局本身），避免重复/遮挡。\"\"\"\n   744→        if not hasattr(self, \"params_layout\") or self.params_layout is None:\n   745→            return\n   746→        while self.params_layout.count() > 0:\n   747→            item = self.params_layout.takeAt(0)\n   748→            w = item.widget()\n   749→            if w is not None:\n   750→                w.hide()  # 立即隐藏，避免 deleteLater 异步导致残留显示\n   751→                w.setParent(None)  # 断开父子关系\n   752→                w.deleteLater()\n   753→    \n   754→    def _update_theme(self):\n   755→        \"\"\"响应主题变化\"\"\"\n   756→        colors = unified_style_system.get_colors()\n   757→        logger.info(f\"[ImageDetailDialog] _update_theme called. Surface color: {colors.get('palette.neutral.bg_surface')}\")\n   758→        \n   759→        # Apply theme to self (Dialog)\n   760→        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n   761→        text_color = colors.get('text') or colors.get('palette.text.primary')\n   762→        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n   763→        bg_input = colors.get('palette.neutral.bg_input') or bg_card\n   764→        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   765→        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n   766→        \n   767→        self.setStyleSheet(f\"\"\"\n   768→            QDialog {{\n   769→                background-color: {bg_color};\n   770→                color: {text_color};\n   771→            }}\n   772→            QLabel {{\n   773→                color: {text_color};\n   774→            }}\n   775→            QWidget#ParamsWidget {{\n   776→                 background-color: {bg_card};\n   777→                 border-left: 1px solid {border_subtle};\n   778→            }}\n   779→        \"\"\")\n   780→\n   781→        if hasattr(self, 'prompt_text_edit'):\n   782→            self.prompt_text_edit.setStyleSheet(f\"\"\"\n   783→                QTextEdit {{\n   784→                    background-color: {bg_input};\n   785→                    color: {text_color};\n   786→                    border: 1px solid {border_subtle};\n   787→                    border-radius: 8px;\n   788→                    padding: 8px;\n   789→                }}\n   790→                QTextEdit:focus {{\n   791→                    border-color: {brand};\n   792→                }}\n   793→            \"\"\")\n   794→\n   795→        # Reapply button styles\n   796→        if hasattr(self, 'fullscreen_btn'):\n   797→            unified_style_system.apply_to_widget(self.fullscreen_btn)\n   798→        if hasattr(self, 'copy_image_btn'):\n   799→            unified_style_system.apply_to_widget(self.copy_image_btn)\n   800→        if hasattr(self, 'delete_btn'):\n   801→            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n   802→        if hasattr(self, 'close_btn'):\n   803→            unified_style_system.apply_to_widget(self.close_btn)\n   804→        if hasattr(self, 'reference_export_btn'):\n   805→            unified_style_system.apply_to_widget(self.reference_export_btn)\n   806→        if hasattr(self, 'export_bundle_btn'):\n   807→            unified_style_system.apply_to_widget(self.export_bundle_btn)\n   808→        if hasattr(self, 'prev_btn'):\n   809→            unified_style_system.apply_to_widget(self.prev_btn)\n   810→        if hasattr(self, 'next_btn'):\n   811→            unified_style_system.apply_to_widget(self.next_btn)\n   812→\n   813→        # Rebuild to ensure all param widgets pick up new palette and no stale widgets remain\n   814→        self.setup_params_area()\n   815→\n   816→    def create_param_labels(self):\n   817→        \"\"\"创建参数标签（初始化或更新时调用）\"\"\"\n   818→        # 清除旧的参数标签 - Fix Race Condition\n   819→        if hasattr(self, 'param_labels'):\n   820→            for label_pair in self.param_labels:\n   821→                # 必须先从布局中移除，防止 deleteLater 的异步销毁导致重影\n   822→                self.params_layout.removeWidget(label_pair[0])\n   823→                self.params_layout.removeWidget(label_pair[1])\n   824→                label_pair[0].deleteLater()  # 删除标题标签\n   825→                label_pair[1].deleteLater()  # 删除值标签\n   826→            self.param_labels.clear()\n   827→        else:\n   828→            self.param_labels = []\n   829→        \n   830→        # 解析生成参数\n   831→        params = self.image_data.get('parameters', '{}')\n   832→        if isinstance(params, str):\n   833→            try:\n   834→                params = json.loads(params)\n   835→            except:\n   836→                params = {}\n   837→        \n   838→        # 详细信息\n   839→        info_items = [\n   840→            (\"尺寸\", f\"{params.get('size', '未知')}\"),\n   841→            (\"种子值\", f\"{params.get('seed', '未知')}\"),\n   842→            (\"引导强度\", f\"{params.get('guidance_scale', '未知')}\"),\n   843→            (\"生成模型\", f\"{params.get('model', '未知模型')}\"),\n   844→            (\"生成时间\", self.format_time(self.image_data.get('created_at', ''))),\n   845→            (\"文件大小\", self.format_file_size(self.image_data.get('file_size', 0))),\n   846→            (\"文件路径\", self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')),\n   847→        ]\n   848→        \n   849→        # 如果是图生图，显示参考图信息\n   850→        if params.get('model', '').find('i2i') != -1:\n   851→            info_items.insert(-2, (\"生成类型\", \"图生图\"))\n   852→            input_image = self.image_data.get('input_image', '')\n   853→            if input_image:\n   854→                info_items.insert(-2, (\"参考图片\", input_image))\n   855→        else:\n   856→            info_items.insert(-2, (\"生成类型\", \"文生图\"))\n   857→        \n   858→        colors = unified_style_system.get_colors()\n   859→        bg_tag = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n   860→        border_tag = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   861→        text_tag = colors.get('text') or colors.get('palette.text.primary')\n   862→        hover_bg = colors.get('palette.neutral.bg_hover') or bg_tag\n   863→        hover_border = colors.get('palette.brand.main') or colors.get('primary') or border_tag\n   864→\n   865→        for label, value in info_items:\n   866→            label_widget = QLabel(f\"<b>{label}:</b>\")\n   867→            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   868→            unified_style_system.apply_to_widget(label_widget)\n   869→            self.params_layout.addWidget(label_widget)\n   870→            \n   871→            # 使用可点击的标签\n   872→            value_clickable = ClickableLabel(str(value))\n   873→            value_clickable.set_text_with_ellipsis(str(value), int(self.width() * 0.25))\n   874→            # File path is long and can otherwise expand to fill the panel, overlapping the prompt area.\n   875→            # Keep it single-line with ellipsis and fixed height.\n   876→            if label == \"文件路径\":\n   877→                value_clickable.setWordWrap(False)\n   878→                value_clickable.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n   879→                value_clickable.setFixedHeight(32)\n   880→                value_clickable.setToolTip(str(value))\n   881→            else:\n   882→                value_clickable.setWordWrap(True)\n   883→            # 使用动态样式\n   884→            value_clickable.setStyleSheet(f\"\"\"\n   885→                QLabel {{\n   886→                    margin: 0px; \n   887→                    padding: 6px; \n   888→                    background-color: {bg_tag}; \n   889→                    color: {text_tag};\n   890→                    border: 1px solid {border_tag};\n   891→                    border-radius: 4px;\n   892→                }}\n   893→                QLabel:hover {{\n   894→                    background-color: {hover_bg};\n   895→                    border-color: {hover_border};\n   896→                }}\n   897→            \"\"\")\n   898→            unified_style_system.apply_to_widget(value_clickable)\n   899→            value_clickable.clicked.connect(self.copy_text_to_clipboard)\n   900→            self.params_layout.addWidget(value_clickable)\n   901→            \n   902→            # 保存标签引用\n   903→            self.param_labels.append((label_widget, value_clickable))\n   904→\n   905→        # Ensure remaining vertical space doesn't get assigned to the last label widget.\n   906→        self.params_layout.addStretch(1)\n   907→    \n   908→    def update_params_area(self):\n   909→        \"\"\"更新参数显示区域（切换图片时调用）\"\"\"\n   910→        # Full rebuild avoids duplicated/stale widgets (e.g. file path blocks prompt area)\n   911→        self.setup_params_area()\n   912→\n   913→    def closeEvent(self, event):\n   914→        try:\n   915→            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n   916→                self._focus_timer.stop()\n   917→        except Exception:\n   918→            pass\n   919→\n   920→        try:\n   921→            self._export_controller.dispose()\n   922→        except Exception:\n   923→            pass\n   924→\n   925→        super().closeEvent(event)\n   926→    \n   927→    def keyPressEvent(self, event):\n   928→        \"\"\"键盘事件处理\"\"\"\n   929→        from PySide6.QtCore import Qt\n   930→        \n   931→        logger.debug(f\"[KEYBOARD] ImageDetailDialog键盘事件: {event.key()}\")\n   932→        \n   933→        if event.key() == Qt.Key_Left:\n   934→            # 左方向键：上一张图片\n   935→            if self.prev_btn.isEnabled():\n   936→                self.show_previous_image()\n   937→            event.accept()\n   938→        elif event.key() == Qt.Key_Right:\n   939→            # 右方向键：下一张图片\n   940→            if self.next_btn.isEnabled():\n   941→                self.show_next_image()\n   942→            event.accept()\n   943→        elif event.key() == Qt.Key_Escape:\n   944→            # ESC键：关闭对话框（保持原有功能）\n   945→            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n   946→            if self.is_fullscreen:\n   947→                self.exit_fullscreen()\n   948→            else:\n   949→                self.accept()\n   950→            event.accept()\n   951→        elif event.key() == Qt.Key_F11:\n   952→            # F11键：全屏切换（保持原有功能）\n   953→            self.toggle_fullscreen()\n   954→            event.accept()\n   955→        else:\n   956→            # 其他按键交给父类处理\n   957→            super().keyPressEvent(event)\n   958→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d137ee75-6d12-43ff-83f5-e11741ac40c2","timestamp":"2025-12-22T04:32:23.421Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/image_detail_dialog.py","content":"import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\n\nfrom PySide6.QtWidgets import (\n    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n    QTextEdit, QFileDialog, QMessageBox, QSplitter, QApplication,\n    QMenu, QSizePolicy\n)\nfrom PySide6.QtGui import QAction, QShortcut\nfrom PySide6.QtCore import Qt, QTimer, QSize, QEvent\nfrom PySide6.QtGui import QPixmap, QKeySequence\n\nfrom utils.logger import logger\nfrom utils.style_system import unified_style_system\nfrom components.widgets import ZoomableImageLabel, ClickableLabel\nfrom components.reference_assets import (\n    ReferenceGalleryWidget,\n    export_reference_asset,\n    open_reference_preview,\n    _find_reference_asset_index,\n)\nfrom components.controllers import ExportBundleController\nfrom utils.reference_display import ensure_reference_info, resolve_reference_assets\nfrom PySide6.QtCore import Signal\n\nclass ImageDetailDialog(QDialog):\n    \"\"\"图片详细信息对话框\"\"\"\n    \n    # 删除记录后发出信号，通知父视图刷新\n    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    \n    def __init__(self, image_data: Dict[str, Any], image_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n        super().__init__(parent)\n        self.image_data = image_data\n        self.image_list = image_list or [image_data]  # 图片列表\n        self.current_index = current_index  # 当前图片索引\n        self.zoom_factor = 1.0  # 缩放因子\n        self.is_fullscreen = False  # 全屏状态\n        self.original_geometry = None  # 原始窗口几何\n        self._reference_summary = ensure_reference_info(self.image_data)\n        self._reference_assets: List[Dict[str, Any]] = []\n        self._export_controller = ExportBundleController(self, \"image\")\n        \n        # Subscribe to theme changes\n        unified_style_system.styleChanged.connect(self._update_theme)\n        \n        self.setup_ui()\n        \n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        self.setWindowTitle(\"图片详细信息\")\n        self.resize(1100, 800)  # 改为可调整大小\n        self.setMinimumSize(800, 600)  # 设置最小尺寸\n        \n        # 设置焦点策略，确保能接收键盘事件\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n        self.setFocus()\n\n        # 确保窗口激活时获得焦点\n        self.activateWindow()\n        self.raise_()\n\n        try:\n            self.setObjectName(\"DetailDialog\")\n        except Exception:\n            pass\n\n        self._focus_timer = QTimer(self)\n        self._focus_timer.setSingleShot(True)\n        self._focus_timer.timeout.connect(self._ensure_focus)\n\n        layout = QHBoxLayout(self)\n        \n        # 左侧：大图显示（占70%宽度）\n        left_widget = QWidget()\n        left_layout = QVBoxLayout(left_widget)\n        left_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 图片显示区域（占据上方全部空间）\n        image_container = QWidget()\n        image_container.setObjectName(\"ImageContainer\")\n        image_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        # 在容器内创建布局\n        container_layout = QVBoxLayout(image_container)\n        container_layout.setContentsMargins(0, 0, 0, 0)\n        container_layout.setSpacing(0)\n\n        # 使用可缩放的图片标签，自适应容器大小\n        self.large_image_label = ZoomableImageLabel()\n        self.large_image_label.setAlignment(Qt.AlignCenter)\n        self.large_image_label.setStyleSheet(\"border: none; background-color: transparent;\")\n        \n        # 设置右键菜单\n        self.large_image_label.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.large_image_label.customContextMenuRequested.connect(self.show_context_menu)\n        \n        # 加载大图\n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if image_path and os.path.exists(image_path):\n            pixmap = QPixmap(image_path)\n            if not pixmap.isNull():\n                self.large_image_label.setPixmap(pixmap)\n        \n        container_layout.addWidget(self.large_image_label, 1)\n\n        reference_section = QWidget()\n        reference_section.setObjectName(\"ReferenceSection\")\n        reference_section.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        reference_section_layout = QVBoxLayout(reference_section)\n        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n        reference_section_layout.setSpacing(8)\n\n        self.reference_gallery = ReferenceGalleryWidget()\n        self.reference_gallery.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        try:\n            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n        except Exception:\n            pass\n        reference_section_layout.addWidget(self.reference_gallery, 1)\n\n        reference_button_layout = QHBoxLayout()\n        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n        reference_button_layout.setSpacing(6)\n        self.export_status_label = QLabel(\"\")\n        self.export_status_label.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(self.export_status_label)\n        reference_button_layout.addWidget(self.export_status_label)\n        reference_button_layout.addStretch(1)\n        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n        self.reference_export_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.reference_export_btn)\n        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n        reference_button_layout.addWidget(self.reference_export_btn)\n        self.export_bundle_btn = QPushButton(\"导出记录\")\n        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n        self.export_bundle_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.export_bundle_btn)\n        self._export_controller.configure(\n            self.export_bundle_btn,\n            self.export_status_label,\n            self._resolve_record_id,\n            context_widget=self,\n        )\n        reference_button_layout.addWidget(self.export_bundle_btn)\n        reference_section_layout.addLayout(reference_button_layout)\n\n        self._image_reference_splitter = QSplitter(Qt.Vertical)\n        self._image_reference_splitter.setObjectName(\"ImageReferenceSplitter\")\n        self._image_reference_splitter.setChildrenCollapsible(False)\n        self._image_reference_splitter.setHandleWidth(6)\n        self._image_reference_splitter.addWidget(image_container)\n        self._image_reference_splitter.addWidget(reference_section)\n        self._image_reference_splitter.setStretchFactor(0, 3)\n        self._image_reference_splitter.setStretchFactor(1, 2)\n        self._image_reference_splitter.setSizes([520, 280])\n\n        left_layout.addWidget(self._image_reference_splitter, 1)\n\n        # 底部区域：导航按钮 + 说明文本框（与右侧参数栏高度对齐）\n        bottom_layout = QHBoxLayout()\n        bottom_layout.setContentsMargins(0, 5, 0, 5)\n        bottom_layout.setSpacing(10)\n        \n        # 向左按钮\n        self.prev_btn = QPushButton(\"◀\")\n        self.prev_btn.setFixedSize(30, 30)  # 固定尺寸\n        self.prev_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.prev_btn)\n        self.prev_btn.clicked.connect(self.show_previous_image)\n        bottom_layout.addWidget(self.prev_btn)\n        \n        # 中间的说明文本框（完全透明设计）\n        zoom_info = QLabel(\"提示：鼠标位置缩放，点击拖拽，双击重置\")\n        zoom_info.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(zoom_info)\n        zoom_info.setAlignment(Qt.AlignCenter)\n        zoom_info.setMinimumHeight(30)  # 与按钮高度一致\n        zoom_info.setMaximumHeight(30)  # 固定高度，防止文字被压缩\n        bottom_layout.addWidget(zoom_info, 1)  # 占据中间所有空间\n        \n        # 向右按钮\n        self.next_btn = QPushButton(\"▶\")\n        self.next_btn.setFixedSize(30, 30)  # 固定尺寸\n        self.next_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.next_btn)\n        self.next_btn.clicked.connect(self.show_next_image)\n        bottom_layout.addWidget(self.next_btn)\n        \n        left_layout.addLayout(bottom_layout)\n\n        # 更新导航按钮状态\n        self.update_navigation_buttons()\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n\n        # 右侧：详细信息（固定30%宽度）\n        right_layout = QVBoxLayout()\n        \n        # 创建参数显示区域（不使用滚动条）\n        params_widget = QWidget()\n        params_widget.setFixedWidth(int(self.width() * 0.3))  # 固定30%宽度\n        params_widget.setObjectName(\"ParamsWidget\")\n        self.params_layout = QVBoxLayout(params_widget)  # 保存引用以便后续更新\n        self.params_layout.setSpacing(0)  # 设置间距为0\n        self.params_layout.setContentsMargins(5, 5, 5, 5)  # 设置紧凑的边距\n        \n        # 初始化参数显示区域\n        self.setup_params_area()\n        \n        \n        right_layout.addWidget(params_widget)\n        \n        # 全屏和复制图片按钮（与参数区底部对齐）\n        image_control_layout = QHBoxLayout()\n\n        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n        self.fullscreen_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.fullscreen_btn)\n        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n        image_control_layout.addWidget(self.fullscreen_btn)\n\n        self.copy_image_btn = QPushButton(\"复制图片\")\n        self.copy_image_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.copy_image_btn)\n        self.copy_image_btn.clicked.connect(self.copy_image)\n        image_control_layout.addWidget(self.copy_image_btn)\n\n        right_layout.addLayout(image_control_layout)\n\n        # 其他按钮\n        button_layout = QHBoxLayout()\n\n        self.delete_btn = QPushButton(\"删除记录\")\n        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        self.delete_btn.clicked.connect(self._delete_current_record)\n        button_layout.addWidget(self.delete_btn)\n\n        self.close_btn = QPushButton(\"关闭（ESC）\")\n        unified_style_system.apply_to_widget(self.close_btn)\n        self.close_btn.clicked.connect(self.accept)\n        button_layout.addWidget(self.close_btn)\n        \n        right_layout.addLayout(button_layout)\n        \n        # 设置布局比例：左侧70%，右侧30%\n        layout.addWidget(left_widget, 7)\n        layout.addLayout(right_layout, 3)\n        \n        # 添加键盘快捷键\n        self.setup_shortcuts()\n\n        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n        self._focus_timer.start(100)\n\n        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n        \n        # Apply initial theme\n        self._update_theme()\n    \n    def format_time(self, time_str: str) -> str:\n        \"\"\"格式化时间显示\"\"\"\n        if not time_str:\n            return '未知时间'\n        try:\n            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n            return dt.strftime('%Y-%m-%d %H:%M:%S')\n        except:\n            return time_str[:19] if len(time_str) > 19 else time_str\n    \n    def format_file_size(self, size) -> str:\n        \"\"\"格式化文件大小显示\"\"\"\n        # 处理字符串类型的size\n        try:\n            size = float(size) if size else 0\n        except (ValueError, TypeError):\n            return '未知大小'\n            \n        if size == 0:\n            return '未知大小'\n        \n        for unit in ['B', 'KB', 'MB', 'GB']:\n            if size < 1024.0:\n                return f\"{size:.1f} {unit}\"\n            size /= 1024.0\n        return f\"{size:.1f} TB\"\n    \n    def setup_shortcuts(self):\n        \"\"\"设置键盘快捷键\"\"\"\n        # 移除所有QShortcut，统一使用keyPressEvent处理\n        # 避免快捷键冲突问题\n        pass\n    \n    def _ensure_focus(self):\n        \"\"\"确保窗口获得焦点\"\"\"\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        logger.debug(f\"[FOCUS] ImageDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n        \n    def toggle_fullscreen(self):\n        \"\"\"切换全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.enter_fullscreen()\n            \n    def enter_fullscreen(self):\n        \"\"\"进入全屏模式\"\"\"\n        if not self.is_fullscreen:\n            self.original_geometry = self.geometry()\n            self.showFullScreen()\n            self.is_fullscreen = True\n            \n    def exit_fullscreen(self):\n        \"\"\"退出全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.showNormal()\n            if self.original_geometry:\n                self.setGeometry(self.original_geometry)\n            self.is_fullscreen = False\n            \n    def handle_escape_key(self):\n        \"\"\"处理ESC键：如果是全屏则退出全屏，否则关闭对话框\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.accept()  # 关闭对话框\n            \n    def copy_text_to_clipboard(self, text: str):\n        \"\"\"复制文本到剪贴板并显示提示\"\"\"\n        from PySide6.QtWidgets import QApplication\n        clipboard = QApplication.clipboard()\n        clipboard.setText(text)\n        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n        \n    def show_copy_toast(self, message: str):\n        \"\"\"显示复制成功的轻量提示\"\"\"\n        # 创建一个临时的提示标签\n        toast = QLabel(message, self)\n        toast.setObjectName(\"ToastLabel\")\n        toast.setAlignment(Qt.AlignCenter)\n        toast.adjustSize()\n        \n        # 定位到窗口中央偏上\n        x = (self.width() - toast.width()) // 2\n        y = self.height() // 4\n        toast.move(x, y)\n        toast.show()\n        \n        # 2秒后自动隐藏\n        QTimer.singleShot(2000, toast.deleteLater)\n        \n    def copy_prompt(self):\n        \"\"\"复制提示词到剪贴板\"\"\"\n        prompt_content = self.prompt_text_edit.toPlainText()\n        self.copy_text_to_clipboard(prompt_content)\n    \n    def copy_image(self):\n        \"\"\"复制图片到剪贴板\"\"\"\n        from PySide6.QtWidgets import QApplication\n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if image_path and os.path.exists(image_path):\n            pixmap = QPixmap(image_path)\n            if not pixmap.isNull():\n                clipboard = QApplication.clipboard()\n                clipboard.setPixmap(pixmap)\n                self.show_copy_toast(\"图片已复制到剪贴板\")\n            else:\n                self.show_copy_toast(\"无法复制图片\")\n        else:\n            self.show_copy_toast(\"图片文件不存在\")\n    \n    def copy_all_info(self):\n        \"\"\"复制所有信息到剪贴板\"\"\"\n        from PySide6.QtWidgets import QApplication\n        \n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        info_text = f\"\"\"图片详细信息\n===================\n提示词: {self.image_data.get('prompt', '无提示词')}\n尺寸: {params.get('size', '未知')}\n种子值: {params.get('seed', '未知')}\n引导强度: {params.get('guidance_scale', '未知')}\n生成模型: {params.get('model', '未知模型')}\n生成时间: {self.format_time(self.image_data.get('created_at', ''))}\n文件大小: {self.format_file_size(self.image_data.get('file_size', 0))}\n文件路径: {self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')}\n\"\"\"\n        \n        clipboard = QApplication.clipboard()\n        clipboard.setText(info_text)\n        self.show_copy_toast(\"所有信息已复制到剪贴板\")\n\n    def show_copy_message(self, message: str):\n        \"\"\"显示复制成功消息（已弃用，使用show_copy_toast代替）\"\"\"\n        # 直接使用轻量级Toast提示\n        self.show_copy_toast(message)\n\n    def _delete_current_record(self):\n        \"\"\"删除当前记录及相关文件\"\"\"\n        record_id = self._resolve_record_id()\n        if not record_id:\n            self.show_copy_toast(\"无法获取记录ID\")\n            return\n        \n        try:\n            # 获取 RepositoryManager\n            from config_api import get_storage_dir\n            from modules.repository.manager import RepositoryManager\n            \n            storage_dir = get_storage_dir()\n            repo = RepositoryManager(storage_dir)\n            \n            # 执行删除\n            if repo.delete_record_with_files(record_id):\n                self.show_copy_toast(\"记录已删除\")\n                \n                # 发出信号通知父视图刷新\n                self.recordDeleted.emit(record_id)\n                \n                # 从列表中移除当前记录\n                if len(self.image_list) > 1:\n                    del self.image_list[self.current_index]\n                    \n                    # 导航到后一条记录（保持索引，指向原来的下一条）\n                    # 只有当删除的是最后一条时，才需要调整索引\n                    if self.current_index >= len(self.image_list):\n                        self.current_index = len(self.image_list) - 1\n                    \n                    self.load_current_image()\n                    self.update_navigation_buttons()\n                else:\n                    # 只剩一条记录，关闭对话框\n                    self.accept()\n            else:\n                self.show_copy_toast(\"删除失败\")\n        except Exception as e:\n            from utils.logger import logger\n            logger.error(f\"删除记录异常: {e}\")\n            self.show_copy_toast(f\"删除失败: {str(e)}\")\n\n    def _on_reference_clicked(self, asset: Dict[str, Any]):\n        assets = list(self._reference_assets) if self._reference_assets else [asset]\n        start_idx = _find_reference_asset_index(assets, asset)\n        open_reference_preview(\n            self,\n            asset,\n            title_prefix=\"参考图\",\n            asset_list=assets,\n            start_index=start_idx,\n            on_asset_changed=self._sync_reference_selection,\n        )\n\n    def _on_reference_export(self, asset: Dict[str, Any]):\n        export_reference_asset(self, asset)\n\n    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n        asset_path = None\n        if isinstance(asset, dict):\n            asset_path = asset.get('absolute_path') or asset.get('path')\n        has_path = bool(asset_path and os.path.exists(asset_path))\n        if hasattr(self, 'reference_export_btn'):\n            self.reference_export_btn.setEnabled(has_path)\n\n    def _export_selected_reference(self):\n        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n        if not asset:\n            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n            return\n        export_reference_asset(self, asset)\n\n    def _refresh_reference_gallery(self):\n        if not hasattr(self, 'reference_gallery'):\n            return\n        self._reference_summary = ensure_reference_info(self.image_data)\n        if self._reference_summary.get('count', 0) <= 0:\n            self.reference_gallery.clear()\n            self.reference_gallery.setVisible(False)\n            if hasattr(self, 'reference_export_btn'):\n                self.reference_export_btn.setEnabled(False)\n            self._reference_assets = []\n            self._export_controller.refresh()\n            return\n        try:\n            self._reference_assets = resolve_reference_assets(self.image_data, absolute=True)\n        except Exception:\n            self._reference_assets = []\n        self.reference_gallery.setVisible(True)\n        self.reference_gallery.set_assets(self._reference_assets)\n        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n        self._export_controller.refresh()\n\n    def _sync_reference_selection(self, asset: Dict[str, Any]):\n        try:\n            self.reference_gallery.select_asset(asset)\n        except Exception:\n            pass\n\n    def _resolve_record_id(self) -> Optional[str]:\n        for key in (\"file_id\", \"id\", \"generation_id\"):\n            value = self.image_data.get(key)\n            if value not in (None, \"\"):\n                return str(value)\n        return None\n\n    def show_context_menu(self, position):\n        \"\"\"显示右键菜单\"\"\"\n        from PySide6.QtWidgets import QMenu\n        from PySide6.QtGui import QAction, QShortcut\n        \n        menu = QMenu(self)\n        \n        # 复制图片动作\n        copy_action = QAction(\"复制图片\", self)\n        copy_action.triggered.connect(self.copy_image)\n        menu.addAction(copy_action)\n        \n        # 下载图片动作\n        download_action = QAction(\"下载图片\", self)\n        download_action.triggered.connect(self.download_image)\n        menu.addAction(download_action)\n        \n        # 显示菜单\n        menu.exec(self.large_image_label.mapToGlobal(position))\n    \n    def download_image(self):\n        \"\"\"下载图片到指定位置\"\"\"\n        from PySide6.QtWidgets import QFileDialog, QMessageBox\n        import shutil\n        \n        image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')\n        if not image_path or not os.path.exists(image_path):\n            self.show_styled_message(\"错误\", \"图片文件不存在\", \"warning\")\n            return\n        \n        # 获取原始文件名\n        original_filename = os.path.basename(image_path)\n        \n        # 打开保存对话框\n        save_path, _ = QFileDialog.getSaveFileName(\n            self,\n            \"保存图片\",\n            original_filename,\n            \"图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)\"\n        )\n        \n        if save_path:\n            try:\n                shutil.copy2(image_path, save_path)\n                self.show_styled_message(\"成功\", f\"图片已保存到:\\n{save_path}\", \"information\")\n            except Exception as e:\n                self.show_styled_message(\"错误\", f\"保存图片失败:\\n{str(e)}\", \"critical\")\n    \n    def update_navigation_buttons(self):\n        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n        # 检查是否有图片列表\n        if len(self.image_list) <= 1:\n            self.prev_btn.setEnabled(False)\n            self.next_btn.setEnabled(False)\n            self.prev_btn.setToolTip(\"没有更多图片\")\n            self.next_btn.setToolTip(\"没有更多图片\")\n            return\n        \n        # 更新按钮状态（基于有效记录检查）\n        self.prev_btn.setEnabled(self._has_valid_previous_record())\n        self.next_btn.setEnabled(self._has_valid_next_record())\n        \n        # 更新工具提示显示当前位置和快捷键信息\n        current_pos = f\"({self.current_index + 1}/{len(self.image_list)})\"\n        self.prev_btn.setToolTip(f\"上一张 {current_pos} - 快捷键: ←\")\n        self.next_btn.setToolTip(f\"下一张 {current_pos} - 快捷键: →\")\n        \n        # 按钮文本保持简洁的箭头符号\n        self.prev_btn.setText(\"◀\")\n    \n    def _has_valid_previous_record(self):\n        \"\"\"检查是否有有效的上一个记录\"\"\"\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            if file_path and os.path.exists(file_path):\n                return True\n        return False\n    \n    def _has_valid_next_record(self):\n        \"\"\"检查是否有有效的下一个记录\"\"\"\n        for i in range(self.current_index + 1, len(self.image_list)):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            if file_path and os.path.exists(file_path):\n                return True\n        return False\n    \n    def show_previous_image(self):\n        \"\"\"显示上一张图片（带有效性验证）\"\"\"\n        # 寻找上一个有效记录\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            if file_path and os.path.exists(file_path):\n                # 找到有效记录\n                self.current_index = i\n                self.load_current_image()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的上一个记录，保持当前状态\n        self.update_navigation_buttons()\n    \n    def show_next_image(self):\n        \"\"\"显示下一张图片（带有效性验证）\"\"\"\n        # 寻找下一个有效记录\n        for i in range(self.current_index + 1, len(self.image_list)):\n            candidate_data = self.image_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            if file_path and os.path.exists(file_path):\n                # 找到有效记录\n                self.current_index = i\n                self.load_current_image()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的下一个记录，保持当前状态\n        self.update_navigation_buttons()\n    \n    def load_current_image(self):\n        \"\"\"加载当前索引的图片\"\"\"\n        if 0 <= self.current_index < len(self.image_list):\n            # 更新当前图片数据\n            self.image_data = self.image_list[self.current_index]\n            \n            # 重新加载图片\n            image_path = self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '') or self.image_data.get('file_path', '')\n            if image_path and os.path.exists(image_path):\n                pixmap = QPixmap(image_path)\n                if not pixmap.isNull():\n                    self.large_image_label.setPixmap(pixmap)\n                else:\n                    self.large_image_label.setText(\"图片加载失败\")\n            else:\n                self.large_image_label.setText(\"图片不存在\")\n            \n            # 更新窗口标题\n            self.setWindowTitle(f\"图片详细信息 ({self.current_index + 1}/{len(self.image_list)})\")\n            \n            # 更新提示词内容\n            prompt_content = self.image_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n            \n            # 更新参数信息\n            self.update_params_area()\n            self._refresh_reference_gallery()\n\n        self._export_controller.refresh()\n    \n    def setup_params_area(self):\n        \"\"\"初始化参数显示区域\"\"\"\n        # Ensure this area is deterministic (avoid stale/duplicated widgets across refresh/theme changes)\n        self._clear_params_layout()\n\n        # 解析生成参数\n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 提示词区域（可滚动查看全文）\n        prompt_label = QLabel(\"<b>提示词:</b>\")\n        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n        unified_style_system.apply_to_widget(prompt_label)\n        self.params_layout.addWidget(prompt_label)\n        \n        # 提示词文本框\n        prompt_content = self.image_data.get('prompt', '无提示词')\n        self.prompt_text_edit = QTextEdit()\n        self.prompt_text_edit.setPlainText(prompt_content)\n        self.prompt_text_edit.setReadOnly(True)  # 只读模式\n        # 约 4 行高度（按当前字体动态计算），避免信息区过高压缩其它内容\n        try:\n            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n            target_lines = 4\n            vertical_padding = 16  # 与全局 QTextEdit padding (8*2) 对齐\n            border = 2  # 1px*2\n            height = line_height * target_lines + vertical_padding + border\n            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n        except Exception:\n            self.prompt_text_edit.setMaximumHeight(96)\n            self.prompt_text_edit.setMinimumHeight(96)\n        self.prompt_text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n        self.prompt_text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        unified_style_system.apply_to_widget(self.prompt_text_edit)\n        # 应用与 _update_theme 一致的额外样式\n        colors = unified_style_system.get_colors()\n        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card')\n        text_color = colors.get('text') or colors.get('palette.text.primary')\n        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        brand = colors.get('palette.brand.main') or colors.get('primary')\n        self.prompt_text_edit.setStyleSheet(f\"\"\"\n            QTextEdit {{\n                background-color: {bg_input};\n                color: {text_color};\n                border: 1px solid {border_subtle};\n                border-radius: 8px;\n                padding: 8px;\n            }}\n            QTextEdit:focus {{\n                border-color: {brand};\n            }}\n        \"\"\")\n        self.params_layout.addWidget(self.prompt_text_edit)\n        \n        # 添加复制提示词按钮（使用统一的 SecondaryButton 样式）\n        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n        self.copy_prompt_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n        self.params_layout.addWidget(self.copy_prompt_btn)\n        \n        # 存储参数标签列表，用于后续清理\n        self.param_labels = []\n        self.create_param_labels()\n\n    def _clear_params_layout(self):\n        \"\"\"清空参数区布局中的所有控件（保留布局本身），避免重复/遮挡。\"\"\"\n        if not hasattr(self, \"params_layout\") or self.params_layout is None:\n            return\n        while self.params_layout.count() > 0:\n            item = self.params_layout.takeAt(0)\n            w = item.widget()\n            if w is not None:\n                w.hide()  # 立即隐藏，避免 deleteLater 异步导致残留显示\n                w.setParent(None)  # 断开父子关系\n                w.deleteLater()\n    \n    def _update_theme(self):\n        \"\"\"响应主题变化\"\"\"\n        colors = unified_style_system.get_colors()\n        logger.info(f\"[ImageDetailDialog] _update_theme called. Surface color: {colors.get('palette.neutral.bg_surface')}\")\n        \n        # Apply theme to self (Dialog)\n        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n        text_color = colors.get('text') or colors.get('palette.text.primary')\n        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n        bg_input = colors.get('palette.neutral.bg_input') or bg_card\n        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n        \n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {bg_color};\n                color: {text_color};\n            }}\n            QLabel {{\n                color: {text_color};\n            }}\n            QWidget#ParamsWidget {{\n                 background-color: {bg_card};\n                 border-left: 1px solid {border_subtle};\n            }}\n        \"\"\")\n\n        if hasattr(self, 'prompt_text_edit'):\n            self.prompt_text_edit.setStyleSheet(f\"\"\"\n                QTextEdit {{\n                    background-color: {bg_input};\n                    color: {text_color};\n                    border: 1px solid {border_subtle};\n                    border-radius: 8px;\n                    padding: 8px;\n                }}\n                QTextEdit:focus {{\n                    border-color: {brand};\n                }}\n            \"\"\")\n\n        # Reapply button styles\n        if hasattr(self, 'fullscreen_btn'):\n            unified_style_system.apply_to_widget(self.fullscreen_btn)\n        if hasattr(self, 'copy_image_btn'):\n            unified_style_system.apply_to_widget(self.copy_image_btn)\n        if hasattr(self, 'delete_btn'):\n            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        if hasattr(self, 'close_btn'):\n            unified_style_system.apply_to_widget(self.close_btn)\n        if hasattr(self, 'reference_export_btn'):\n            unified_style_system.apply_to_widget(self.reference_export_btn)\n        if hasattr(self, 'export_bundle_btn'):\n            unified_style_system.apply_to_widget(self.export_bundle_btn)\n        if hasattr(self, 'prev_btn'):\n            unified_style_system.apply_to_widget(self.prev_btn)\n        if hasattr(self, 'next_btn'):\n            unified_style_system.apply_to_widget(self.next_btn)\n\n        # Rebuild to ensure all param widgets pick up new palette and no stale widgets remain\n        self.setup_params_area()\n\n    def create_param_labels(self):\n        \"\"\"创建参数标签（初始化或更新时调用）\"\"\"\n        # 清除旧的参数标签 - Fix Race Condition\n        if hasattr(self, 'param_labels'):\n            for label_pair in self.param_labels:\n                # 必须先从布局中移除，防止 deleteLater 的异步销毁导致重影\n                self.params_layout.removeWidget(label_pair[0])\n                self.params_layout.removeWidget(label_pair[1])\n                label_pair[0].deleteLater()  # 删除标题标签\n                label_pair[1].deleteLater()  # 删除值标签\n            self.param_labels.clear()\n        else:\n            self.param_labels = []\n        \n        # 解析生成参数\n        params = self.image_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 详细信息\n        info_items = [\n            (\"尺寸\", f\"{params.get('size', '未知')}\"),\n            (\"种子值\", f\"{params.get('seed', '未知')}\"),\n            (\"引导强度\", f\"{params.get('guidance_scale', '未知')}\"),\n            (\"生成模型\", f\"{params.get('model', '未知模型')}\"),\n            (\"生成时间\", self.format_time(self.image_data.get('created_at', ''))),\n            (\"文件大小\", self.format_file_size(self.image_data.get('file_size', 0))),\n            (\"文件路径\", self.image_data.get('absolute_path', '') or self.image_data.get('file_path', '')),\n        ]\n        \n        # 如果是图生图，显示参考图信息\n        if params.get('model', '').find('i2i') != -1:\n            info_items.insert(-2, (\"生成类型\", \"图生图\"))\n            input_image = self.image_data.get('input_image', '')\n            if input_image:\n                info_items.insert(-2, (\"参考图片\", input_image))\n        else:\n            info_items.insert(-2, (\"生成类型\", \"文生图\"))\n        \n        colors = unified_style_system.get_colors()\n        bg_tag = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n        border_tag = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        text_tag = colors.get('text') or colors.get('palette.text.primary')\n        hover_bg = colors.get('palette.neutral.bg_hover') or bg_tag\n        hover_border = colors.get('palette.brand.main') or colors.get('primary') or border_tag\n\n        for label, value in info_items:\n            label_widget = QLabel(f\"<b>{label}:</b>\")\n            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n            unified_style_system.apply_to_widget(label_widget)\n            self.params_layout.addWidget(label_widget)\n            \n            # 使用可点击的标签\n            value_clickable = ClickableLabel(str(value))\n            value_clickable.set_text_with_ellipsis(str(value), int(self.width() * 0.25))\n            # File path is long and can otherwise expand to fill the panel, overlapping the prompt area.\n            # Keep it single-line with ellipsis and fixed height.\n            if label == \"文件路径\":\n                value_clickable.setWordWrap(False)\n                value_clickable.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n                value_clickable.setFixedHeight(32)\n                value_clickable.setToolTip(str(value))\n            else:\n                value_clickable.setWordWrap(True)\n            # 使用动态样式\n            value_clickable.setStyleSheet(f\"\"\"\n                QLabel {{\n                    margin: 0px; \n                    padding: 6px; \n                    background-color: {bg_tag}; \n                    color: {text_tag};\n                    border: 1px solid {border_tag};\n                    border-radius: 4px;\n                }}\n                QLabel:hover {{\n                    background-color: {hover_bg};\n                    border-color: {hover_border};\n                }}\n            \"\"\")\n            unified_style_system.apply_to_widget(value_clickable)\n            value_clickable.clicked.connect(self.copy_text_to_clipboard)\n            self.params_layout.addWidget(value_clickable)\n            \n            # 保存标签引用\n            self.param_labels.append((label_widget, value_clickable))\n\n        # Ensure remaining vertical space doesn't get assigned to the last label widget.\n        self.params_layout.addStretch(1)\n    \n    def update_params_area(self):\n        \"\"\"更新参数显示区域（切换图片时调用）\"\"\"\n        # Full rebuild avoids duplicated/stale widgets (e.g. file path blocks prompt area)\n        self.setup_params_area()\n\n    def closeEvent(self, event):\n        try:\n            if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n                self._focus_timer.stop()\n        except Exception:\n            pass\n\n        try:\n            self._export_controller.dispose()\n        except Exception:\n            pass\n\n        super().closeEvent(event)\n    \n    def keyPressEvent(self, event):\n        \"\"\"键盘事件处理\"\"\"\n        from PySide6.QtCore import Qt\n        \n        logger.debug(f\"[KEYBOARD] ImageDetailDialog键盘事件: {event.key()}\")\n        \n        if event.key() == Qt.Key_Left:\n            # 左方向键：上一张图片\n            if self.prev_btn.isEnabled():\n                self.show_previous_image()\n            event.accept()\n        elif event.key() == Qt.Key_Right:\n            # 右方向键：下一张图片\n            if self.next_btn.isEnabled():\n                self.show_next_image()\n            event.accept()\n        elif event.key() == Qt.Key_Escape:\n            # ESC键：关闭对话框（保持原有功能）\n            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n            if self.is_fullscreen:\n                self.exit_fullscreen()\n            else:\n                self.accept()\n            event.accept()\n        elif event.key() == Qt.Key_F11:\n            # F11键：全屏切换（保持原有功能）\n            self.toggle_fullscreen()\n            event.accept()\n        else:\n            # 其他按键交给父类处理\n            super().keyPressEvent(event)\n","numLines":958,"startLine":1,"totalLines":958}}}
{"parentUuid":"d137ee75-6d12-43ff-83f5-e11741ac40c2","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xervi1yDiVgEWyxLYRHEQS","type":"tool_result","content":"     1→import os\n     2→import json\n     3→from pathlib import Path\n     4→from datetime import datetime\n     5→from typing import Dict, Any, List, Optional\n     6→\n     7→from PySide6.QtWidgets import (\n     8→    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n     9→    QTextEdit, QFileDialog, QMessageBox, QStackedWidget, QSplitter,\n    10→    QApplication\n    11→)\n    12→from PySide6.QtGui import QShortcut\n    13→from PySide6.QtCore import Qt, QTimer, QUrl, QSize, QEvent\n    14→from PySide6.QtGui import QPixmap, QFont, QKeySequence, QPainter, QImage\n    15→from PySide6.QtMultimedia import QMediaPlayer\n    16→from PySide6.QtMultimediaWidgets import QVideoWidget\n    17→\n    18→# 使用全局视频管理器单例\n    19→from services.global_video_manager import get_global_video_manager\n    20→\n    21→from utils.logger import logger\n    22→from components.reference_assets import (\n    23→    ReferenceGalleryWidget,\n    24→    export_reference_asset,\n    25→    open_reference_preview,\n    26→    _find_reference_asset_index,\n    27→)\n    28→from utils.style_system import unified_style_system\n    29→from components.controllers import ExportBundleController\n    30→from utils.reference_display import (\n    31→    build_resolution_text,\n    32→    ensure_reference_info,\n    33→    get_model_display_name,\n    34→    pick_model_code,\n    35→    resolve_reference_assets,\n    36→)\n    37→from PySide6.QtCore import Signal\n    38→\n    39→class VideoDetailDialog(QDialog):\n    40→    \"\"\"视频详细信息对话框\"\"\"\n    41→    \n    42→    # 删除记录后发出信号，通知父视图刷新\n    43→    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    44→    \n    45→    def __init__(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n    46→        super().__init__(parent)\n    47→        self.video_data = video_data\n    48→        self.video_list = video_list or [video_data]  # 视频列表\n    49→        self.current_index = current_index  # 当前视频索引\n    50→        self.is_fullscreen = False  # 全屏状态\n    51→        self.original_geometry = None  # 原始窗口几何\n    52→        self.param_value_labels = {}  # 存储参数值标签的引用\n    53→        self._reference_summary = ensure_reference_info(self.video_data)\n    54→        self._reference_assets: List[Dict[str, Any]] = []\n    55→        self._export_controller = ExportBundleController(self, \"video\")\n    56→        \n    57→        # Subscribe to theme changes\n    58→        unified_style_system.styleChanged.connect(self._update_theme)\n    59→        \n    60→        self.setup_ui()\n    61→    \n    62→    def set_video_data(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0):\n    63→        \"\"\"更新视频数据（复用对话框时调用，避免重建 QVideoWidget）\"\"\"\n    64→        logger.debug(f\"[REUSE] 复用对话框，更新视频数据: index={current_index}\")\n    65→        \n    66→        # 1. 先停止当前播放\n    67→        if hasattr(self, '_video_manager') and self._video_manager is not None:\n    68→            self._video_manager.stop()\n    69→        \n    70→        # 2. 重置到缩略图模式\n    71→        if hasattr(self, 'video_stack'):\n    72→            self.video_stack.setCurrentIndex(0)\n    73→        self.is_playing = False\n    74→        \n    75→        # 3. 更新数据\n    76→        self.video_data = video_data\n    77→        self.video_list = video_list or [video_data]\n    78→        self.current_index = current_index\n    79→        self._reference_summary = ensure_reference_info(self.video_data)\n    80→        \n    81→        # 4. 刷新UI\n    82→        self.load_thumbnail()\n    83→        \n    84→        # 5. 更新右侧信息\n    85→        if hasattr(self, 'prompt_text_edit'):\n    86→            prompt_content = self.video_data.get('prompt', '无提示词')\n    87→            self.prompt_text_edit.setPlainText(prompt_content)\n    88→        \n    89→        # 6. 更新参数信息\n    90→        if hasattr(self, 'update_video_params'):\n    91→            self.update_video_params()\n    92→        \n    93→        # 7. 更新导航按钮\n    94→        if hasattr(self, 'update_navigation_buttons'):\n    95→            self.update_navigation_buttons()\n    96→        \n    97→        # 8. 刷新参考图画廊\n    98→        if hasattr(self, '_refresh_reference_gallery'):\n    99→            self._refresh_reference_gallery()\n   100→        \n   101→        # 9. 重新激活窗口\n   102→        self.setEnabled(True)\n   103→        self.activateWindow()\n   104→        self.raise_()\n   105→        self.setFocus()\n   106→        \n   107→        logger.debug(\"[REUSE] 视频数据更新完成\")\n   108→        \n   109→    def setup_ui(self):\n   110→        \"\"\"设置UI\"\"\"\n   111→        self.setWindowTitle(\"视频详细信息\")\n   112→        self.resize(1100, 800)  # 改为可调整大小\n   113→        self.setMinimumSize(800, 600)  # 设置最小尺寸\n   114→        \n   115→        # 设置焦点策略，确保能接收键盘事件\n   116→        self.setFocusPolicy(Qt.StrongFocus)\n   117→        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n   118→        self.setFocus()\n   119→\n   120→        # 确保窗口激活时获得焦点\n   121→        self.activateWindow()\n   122→        self.raise_()\n   123→\n   124→        try:\n   125→            self.setObjectName(\"DetailDialog\")\n   126→        except Exception:\n   127→            pass\n   128→\n   129→        self._focus_timer = QTimer(self)\n   130→        self._focus_timer.setSingleShot(True)\n   131→        self._focus_timer.timeout.connect(self._ensure_focus)\n   132→\n   133→        layout = QHBoxLayout(self)\n   134→        \n   135→        # 左侧：视频播放器（占70%宽度）\n   136→        left_widget = QWidget()\n   137→        left_layout = QVBoxLayout(left_widget)\n   138→        left_layout.setContentsMargins(0, 0, 0, 0)\n   139→        \n   140→        # 视频播放区域\n   141→        video_container = QWidget()\n   142→        video_container.setObjectName(\"VideoContainer\")\n   143→        \n   144→        container_layout = QVBoxLayout(video_container)\n   145→        container_layout.setContentsMargins(0, 0, 0, 0)\n   146→        \n   147→        # 创建堆叠布局，用于缩略图和视频播放器的切换\n   148→        from PySide6.QtWidgets import QStackedWidget\n   149→        self.video_stack = QStackedWidget()\n   150→        \n   151→        # 缩略图页面\n   152→        self.thumbnail_widget = QWidget()\n   153→        self.thumbnail_widget.setObjectName(\"ThumbnailWidget\")\n   154→        thumbnail_layout = QVBoxLayout(self.thumbnail_widget)\n   155→        thumbnail_layout.setContentsMargins(0, 0, 0, 0)\n   156→        thumbnail_layout.setAlignment(Qt.AlignCenter)\n   157→        \n   158→        # 缩略图标签\n   159→        self.thumbnail_label = QLabel()\n   160→        self.thumbnail_label.setAlignment(Qt.AlignCenter)\n   161→        colors = unified_style_system.get_colors()\n   162→        player_bg = colors.get('palette.component.player_bg')\n   163→        text_on_brand = (\n   164→            colors.get('palette.text.on_brand')\n   165→            or colors.get('palette.text.primary')\n   166→            or colors.get('text')\n   167→        )\n   168→        self.thumbnail_label.setStyleSheet(f\"\"\"\n   169→            QLabel {{\n   170→                border: none;\n   171→                background-color: {player_bg};\n   172→                color: {text_on_brand};\n   173→            }}\n   174→        \"\"\")\n   175→        self.thumbnail_label.setMinimumSize(400, 300)\n   176→        # 不使用setScaledContents，改为手动缩放\n   177→        # self.thumbnail_label.setScaledContents(True)\n   178→        \n   179→        # 播放按钮覆盖层\n   180→        self.play_overlay = QLabel(\"▶\")\n   181→        self.play_overlay.setAlignment(Qt.AlignCenter)\n   182→        self.play_overlay.setObjectName(\"PlayOverlay\")\n   183→        \n   184→        # 创建缩略图容器，使用相对定位\n   185→        thumbnail_container = QWidget()\n   186→        thumbnail_container.setStyleSheet(f\"border: none; background-color: {player_bg};\")\n   187→        # 设置固定尺寸确保容器有正确的大小\n   188→        thumbnail_container.setFixedSize(640, 480)\n   189→        \n   190→        # 使用绝对定位放置播放按钮\n   191→        def setup_thumbnail_layout():\n   192→            self.thumbnail_label.setParent(thumbnail_container)\n   193→            self.play_overlay.setParent(thumbnail_container)\n   194→            \n   195→            # 确保标签可见\n   196→            self.thumbnail_label.show()\n   197→            self.play_overlay.show()\n   198→            \n   199→            def resize_thumbnail_container():\n   200→                if hasattr(self, 'thumbnail_label') and hasattr(self, 'play_overlay'):\n   201→                    container_size = thumbnail_container.size()\n   202→                    logger.debug(f\"[UI] 详情缩略图容器尺寸: {container_size}\")\n   203→                    \n   204→                    # 设置缩略图标签尺寸和位置\n   205→                    self.thumbnail_label.setGeometry(0, 0, container_size.width(), container_size.height())\n   206→                    \n   207→                    # 播放按钮居中\n   208→                    overlay_x = max(0, (container_size.width() - 70) // 2)\n   209→                    overlay_y = max(0, (container_size.height() - 70) // 2)\n   210→                    self.play_overlay.setGeometry(overlay_x, overlay_y, 70, 70)\n   211→                    \n   212→                    logger.debug(f\"[UI] 缩略图标签位置: {self.thumbnail_label.geometry()}\")\n   213→                    logger.debug(f\"[UI] 播放按钮位置: {self.play_overlay.geometry()}\")\n   214→            \n   215→            def handle_resize_event(event):\n   216→                resize_thumbnail_container()\n   217→                QWidget.resizeEvent(thumbnail_container, event)\n   218→            \n   219→            thumbnail_container.resizeEvent = handle_resize_event\n   220→            \n   221→            # 立即调用布局函数\n   222→            resize_thumbnail_container()\n   223→        \n   224→        setup_thumbnail_layout()\n   225→        \n   226→        # 点击事件\n   227→        self.thumbnail_label.mousePressEvent = self.on_thumbnail_click\n   228→        self.play_overlay.mousePressEvent = self.on_thumbnail_click\n   229→        \n   230→        thumbnail_layout.addWidget(thumbnail_container)\n   231→        \n   232→        # 视频播放器页面\n   233→        self.video_widget = QVideoWidget()\n   234→        self.video_widget.setObjectName(\"VideoWidget\")\n   235→        \n   236→        # 使用全局视频管理器（单例模式）\n   237→        logger.debug(\"[UI] 连接全局视频管理器...\")\n   238→        self._video_manager = get_global_video_manager()\n   239→        \n   240→        # 绑定当前对话框（独占绑定，只有当前对话框接收信号）\n   241→        self._video_manager.bind_dialog(self)\n   242→        logger.debug(\"[UI] 全局视频管理器绑定完成\")\n   243→        \n   244→        # 播放状态标志\n   245→        self.is_playing = False\n   246→        \n   247→        # 添加到堆叠布局\n   248→        self.video_stack.addWidget(self.thumbnail_widget)  # 索引0：缩略图\n   249→        self.video_stack.addWidget(self.video_widget)      # 索引1：Qt视频播放器\n   250→        \n   251→        # 加载视频和缩略图\n   252→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   253→        if video_path and os.path.exists(video_path):\n   254→            # 不在初始化时加载媒体，延迟到用户点击播放时\n   255→            self.load_thumbnail()\n   256→        \n   257→        container_layout.addWidget(self.video_stack)\n   258→        \n   259→        # 视频区域占据所有可用空间\n   260→        left_splitter = QSplitter(Qt.Vertical)\n   261→        left_splitter.addWidget(video_container)\n   262→\n   263→        self.reference_gallery = ReferenceGalleryWidget()\n   264→        try:\n   265→            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n   266→            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n   267→            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n   268→        except Exception:\n   269→            pass\n   270→        # 参考图区域容器，包含画廊与操作按钮\n   271→        reference_section = QWidget()\n   272→        reference_section_layout = QVBoxLayout(reference_section)\n   273→        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n   274→        reference_section_layout.setSpacing(6)\n   275→        reference_section_layout.addWidget(self.reference_gallery)\n   276→        # 将左侧分割器先加入主布局（第二块稍后补充按钮区后再添加）\n   277→        # 注意：最终会把 reference_section 放入分割器\n   278→\n   279→        reference_button_layout = QHBoxLayout()\n   280→        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n   281→        reference_button_layout.setSpacing(6)\n   282→        self.export_status_label = QLabel(\"\")\n   283→        self.export_status_label.setObjectName(\"infoLabel\")\n   284→        unified_style_system.apply_to_widget(self.export_status_label)\n   285→        reference_button_layout.addWidget(self.export_status_label)\n   286→        reference_button_layout.addStretch(1)\n   287→        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n   288→        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n   289→        self.reference_export_btn.setEnabled(False)\n   290→        unified_style_system.apply_to_widget(self.reference_export_btn)\n   291→        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n   292→        reference_button_layout.addWidget(self.reference_export_btn)\n   293→        self.export_bundle_btn = QPushButton(\"导出记录\")\n   294→        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n   295→        self.export_bundle_btn.setEnabled(False)\n   296→        unified_style_system.apply_to_widget(self.export_bundle_btn)\n   297→        self._export_controller.configure(\n   298→            self.export_bundle_btn,\n   299→            self.export_status_label,\n   300→            self._resolve_video_record_id,\n   301→            context_widget=self,\n   302→        )\n   303→        reference_button_layout.addWidget(self.export_bundle_btn)\n   304→        reference_section_layout.addLayout(reference_button_layout)\n   305→        # 将参考图区域加入分割器，并把分割器加入左侧布局\n   306→        left_splitter.addWidget(reference_section)\n   307→        try:\n   308→            left_splitter.setStretchFactor(0, 3)\n   309→            left_splitter.setStretchFactor(1, 2)\n   310→            left_splitter.setSizes([520, 280])\n   311→        except Exception:\n   312→            pass\n   313→        left_layout.addWidget(left_splitter, 1)\n   314→\n   315→        # 底部控制区域\n   316→        controls_layout = QHBoxLayout()\n   317→        controls_layout.setContentsMargins(0, 5, 0, 5)\n   318→        controls_layout.setSpacing(10)\n   319→        \n   320→        # 播放/暂停按钮\n   321→        self.play_button = QPushButton(\"▶\")\n   322→        self.play_button.setFixedSize(40, 30)\n   323→        self.play_button.setObjectName(\"PlayButton\")\n   324→        unified_style_system.apply_to_widget(self.play_button)\n   325→        self.play_button.clicked.connect(self.toggle_play_pause)\n   326→        controls_layout.addWidget(self.play_button)\n   327→        \n   328→        # 进度条（简单的标签显示）\n   329→        self.progress_label = QLabel(\"00:00 / 00:00\")\n   330→        self.progress_label.setObjectName(\"ProgressLabel\")\n   331→        controls_layout.addWidget(self.progress_label, 1)\n   332→        \n   333→        # 音量控制\n   334→        volume_label = QLabel(\"🔊\")\n   335→        volume_label.setObjectName(\"infoLabel\")\n   336→        unified_style_system.apply_to_widget(volume_label)\n   337→        controls_layout.addWidget(volume_label)\n   338→        \n   339→        # 导航按钮\n   340→        self.prev_btn = QPushButton(\"◀\")\n   341→        self.prev_btn.setFixedSize(30, 30)\n   342→        self.prev_btn.setObjectName(\"NavButton\")\n   343→        unified_style_system.apply_to_widget(self.prev_btn)\n   344→        self.prev_btn.clicked.connect(self.show_previous_video)\n   345→        controls_layout.addWidget(self.prev_btn)\n   346→\n   347→        self.next_btn = QPushButton(\"▶\")\n   348→        self.next_btn.setFixedSize(30, 30)\n   349→        self.next_btn.setObjectName(\"NavButton\")\n   350→        unified_style_system.apply_to_widget(self.next_btn)\n   351→        self.next_btn.clicked.connect(self.show_next_video)\n   352→        controls_layout.addWidget(self.next_btn)\n   353→        \n   354→        left_layout.addLayout(controls_layout)\n   355→\n   356→        # 更新导航按钮状态\n   357→        self.update_navigation_buttons()\n   358→        self._refresh_reference_gallery()\n   359→        self._export_controller.refresh()\n   360→\n   361→        # 右侧：详细信息（固定30%宽度）\n   362→        right_layout = QVBoxLayout()\n   363→        \n   364→        # 创建参数显示区域\n   365→        params_widget = QWidget()\n   366→        params_widget.setFixedWidth(int(self.width() * 0.3))\n   367→        params_widget.setObjectName(\"ParamsWidget\")\n   368→        params_layout = QVBoxLayout(params_widget)\n   369→        params_layout.setSpacing(0)\n   370→        params_layout.setContentsMargins(5, 5, 5, 5)\n   371→        \n   372→        # 解析生成参数\n   373→        params = self.video_data.get('parameters', '{}')\n   374→        if isinstance(params, str):\n   375→            try:\n   376→                params = json.loads(params)\n   377→            except:\n   378→                params = {}\n   379→        \n   380→        # 提示词区域\n   381→        prompt_label = QLabel(\"<b>提示词:</b>\")\n   382→        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   383→        unified_style_system.apply_to_widget(prompt_label)\n   384→        params_layout.addWidget(prompt_label)\n   385→        \n   386→        # 提示词文本框\n   387→        prompt_content = self.video_data.get('prompt', '无提示词')\n   388→        self.prompt_text_edit = QTextEdit()\n   389→        self.prompt_text_edit.setPlainText(prompt_content)\n   390→        self.prompt_text_edit.setReadOnly(True)\n   391→        # 约 4 行高度（按当前字体动态计算），避免提示词区域过高挤压其它信息\n   392→        try:\n   393→            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n   394→            target_lines = 4\n   395→            vertical_padding = 16  # 与全局 QTextEdit padding (8*2) 对齐\n   396→            border = 2  # 1px*2\n   397→            height = line_height * target_lines + vertical_padding + border\n   398→            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n   399→        except Exception:\n   400→            self.prompt_text_edit.setMaximumHeight(96)\n   401→            self.prompt_text_edit.setMinimumHeight(96)\n   402→        unified_style_system.apply_to_widget(self.prompt_text_edit)\n   403→        # 应用与 _update_theme 一致的额外样式\n   404→        colors = unified_style_system.get_colors()\n   405→        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card')\n   406→        text_color = colors.get('text') or colors.get('palette.text.primary')\n   407→        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   408→        brand = colors.get('palette.brand.main') or colors.get('primary')\n   409→        self.prompt_text_edit.setStyleSheet(f\"\"\"\n   410→            QTextEdit {{\n   411→                background-color: {bg_input};\n   412→                color: {text_color};\n   413→                border: 1px solid {border_subtle};\n   414→                border-radius: 8px;\n   415→                padding: 8px;\n   416→            }}\n   417→            QTextEdit:focus {{\n   418→                border-color: {brand};\n   419→            }}\n   420→        \"\"\")\n   421→        params_layout.addWidget(self.prompt_text_edit)\n   422→        \n   423→        # 复制提示词按钮（使用统一的 SecondaryButton 样式）\n   424→        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n   425→        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n   426→        self.copy_prompt_btn.setMaximumHeight(30)\n   427→        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n   428→        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n   429→        params_layout.addWidget(self.copy_prompt_btn)\n   430→        \n   431→        # 详细信息 - 保存标签引用以便后续更新\n   432→        self.param_labels = {}  # 存储参数值标签的引用\n   433→\n   434→        # 从 parameters 中获取参数（兼容顶级字段）\n   435→        params = self.video_data.get('parameters', {}) or {}\n   436→        duration = params.get('duration') or self.video_data.get('duration', '未知')\n   437→        file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n   438→\n   439→        info_items = [\n   440→            (\"分辨率\", build_resolution_text(self.video_data)),\n   441→            (\"时长\", f\"{duration}秒\"),\n   442→            (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n   443→            (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n   444→            (\"文件大小\", self.format_file_size(file_size)),\n   445→            (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n   446→        ]\n   447→        \n   448→        for label, value in info_items:\n   449→            label_widget = QLabel(f\"<b>{label}:</b>\")\n   450→            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n   451→            unified_style_system.apply_to_widget(label_widget)\n   452→            params_layout.addWidget(label_widget)\n   453→            \n   454→            # Use QLineEdit for better copy interaction\n   455→            from PySide6.QtWidgets import QLineEdit\n   456→            value_label = QLineEdit(str(value))\n   457→            value_label.setReadOnly(True)\n   458→            value_label.setCursorPosition(0)\n   459→            value_label.setCursorPosition(0)\n   460→            # Style is now handled in _update_theme\n   461→            unified_style_system.apply_to_widget(value_label)\n   462→            params_layout.addWidget(value_label)\n   463→            \n   464→            # 保存参数值标签引用，用于后续更新\n   465→            self.param_value_labels[label] = value_label\n   466→        \n   467→        right_layout.addWidget(params_widget)\n   468→        \n   469→        # 控制按钮\n   470→        button_layout = QHBoxLayout()\n   471→\n   472→        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n   473→        self.fullscreen_btn.setMaximumHeight(30)\n   474→        unified_style_system.apply_to_widget(self.fullscreen_btn)\n   475→        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n   476→        button_layout.addWidget(self.fullscreen_btn)\n   477→\n   478→        self.download_btn = QPushButton(\"下载视频\")\n   479→        self.download_btn.setMaximumHeight(30)\n   480→        unified_style_system.apply_to_widget(self.download_btn)\n   481→        self.download_btn.clicked.connect(self.download_video)\n   482→        button_layout.addWidget(self.download_btn)\n   483→\n   484→        self.delete_btn = QPushButton(\"删除记录\")\n   485→        self.delete_btn.setMaximumHeight(30)\n   486→        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n   487→        self.delete_btn.clicked.connect(self._delete_current_record)\n   488→        button_layout.addWidget(self.delete_btn)\n   489→\n   490→        right_layout.addLayout(button_layout)\n   491→\n   492→        self.close_btn = QPushButton(\"关闭（ESC）\")\n   493→        unified_style_system.apply_to_widget(self.close_btn)\n   494→        self.close_btn.clicked.connect(self.accept)\n   495→        right_layout.addWidget(self.close_btn)\n   496→        \n   497→        # 设置布局比例：左侧70%，右侧30%\n   498→        layout.addWidget(left_widget, 7)\n   499→        layout.addLayout(right_layout, 3)\n   500→        \n   501→        # 添加键盘快捷键\n   502→        self.setup_shortcuts()\n   503→\n   504→        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n   505→        self._focus_timer.start(100)\n   506→        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n   507→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   508→        self._esc_shortcut.activated.connect(self.handle_escape_key)\n   509→        \n   510→        # Apply initial theme\n   511→        self._update_theme()\n   512→        \n   513→        # 信号已在setup_ui开头连接，不重复连接\n   514→    \n   515→    def closeEvent(self, event):\n   516→        \"\"\"窗口关闭事件，确保停止播放并释放资源\"\"\"\n   517→        # 0. 阻止对话框继续接收事件\n   518→        self.setEnabled(False)\n   519→        \n   520→        # 1. 停止焦点定时器\n   521→        if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n   522→            self._focus_timer.stop()\n   523→        \n   524→        # 2. 清理参考图画廊\n   525→        if hasattr(self, 'reference_gallery') and self.reference_gallery is not None:\n   526→            try:\n   527→                self.reference_gallery.clear()\n   528→            except Exception as e:\n   529→                logger.warning(f\"[CLEANUP] 清理参考图画廊时出错: {e}\")\n   530→        \n   531→        # 3. 解绑并停止全局视频管理器\n   532→        if hasattr(self, '_video_manager') and self._video_manager is not None:\n   533→            try:\n   534→                # 解绑对话框（取消独占绑定）\n   535→                self._video_manager.unbind_dialog(self)\n   536→                \n   537→                # 停止播放并断开视频输出\n   538→                self._video_manager.stop()\n   539→                \n   540→            except Exception as e:\n   541→                logger.warning(f\"[CLEANUP] 停止全局视频管理器时出错: {e}\")\n   542→\n   543→        # 4. 兼容旧字段：若存在本地 media_player 也停止\n   544→        if hasattr(self, 'media_player') and self.media_player:\n   545→            try:\n   546→                self.media_player.stop()\n   547→            except Exception:\n   548→                pass\n   549→\n   550→        # 5. 清理导出控制器\n   551→        try:\n   552→            self._export_controller.dispose()\n   553→        except Exception:\n   554→            pass\n   555→        \n   556→        self.is_playing = False\n   557→        super().closeEvent(event)\n   558→    \n   559→    def load_thumbnail(self):\n   560→        \"\"\"加载视频缩略图\"\"\"\n   561→        import os  # 将os导入移到函数开头\n   562→        try:\n   563→            logger.debug(\"开始加载缩略图...\")\n   564→            logger.debug(f\"视频数据: {self.video_data}\")\n   565→            \n   566→            # 获取缩略图路径\n   567→            thumbnail_path = self.video_data.get('thumbnail_local_path', '')\n   568→            logger.debug(f\"从video_data获取的thumbnail_local_path: {thumbnail_path}\")\n   569→            \n   570→            if thumbnail_path and os.path.exists(thumbnail_path):\n   571→                logger.debug(f\"找到现有缩略图文件: {thumbnail_path}\")\n   572→                # 使用现有缩略图\n   573→                pixmap = QPixmap(thumbnail_path)\n   574→                logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n   575→            else:\n   576→                logger.debug(\"缩略图文件不存在或路径为空，开始生成缩略图...\")\n   577→                # 生成缩略图\n   578→                video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   579→                logger.debug(f\"视频文件路径: {video_path}\")\n   580→                \n   581→                if video_path and os.path.exists(video_path):\n   582→                    logger.debug(\"视频文件存在，开始生成缩略图...\")\n   583→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   584→                    from config_api import get_storage_dir\n   585→                    storage_dir = get_storage_dir()\n   586→                    thumbnails_dir = os.path.join(storage_dir, 'thumbnails')\n   587→                    logger.debug(f\"缩略图目录: {thumbnails_dir}\")\n   588→                    \n   589→                    generator = VideoThumbnailGenerator(thumbnails_dir)\n   590→                    video_id = self.video_data.get('id', os.path.basename(video_path).split('.')[0])\n   591→                    logger.debug(f\"视频ID: {video_id}\")\n   592→                    \n   593→                    thumbnail_path = generator.generate_thumbnail_for_video(video_path, video_id)\n   594→                    logger.debug(f\"生成的缩略图路径: {thumbnail_path}\")\n   595→                    \n   596→                    if thumbnail_path and os.path.exists(thumbnail_path):\n   597→                        logger.debug(\"缩略图生成成功，加载到QPixmap...\")\n   598→                        pixmap = QPixmap(thumbnail_path)\n   599→                        logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n   600→                    else:\n   601→                        logger.debug(\"缩略图生成失败，使用默认图片\")\n   602→                        # 使用默认图片\n   603→                        pixmap = self.create_default_thumbnail()\n   604→                else:\n   605→                    logger.debug(\"视频文件不存在，使用默认图片\")\n   606→                    pixmap = self.create_default_thumbnail()\n   607→            \n   608→            if not pixmap.isNull():\n   609→                logger.debug(\"开始缩放图片...\")\n   610→                # 缩放图片以适应标签大小\n   611→                label_size = self.thumbnail_label.size()\n   612→                logger.debug(f\"标签大小: {label_size}\")\n   613→                \n   614→                scaled_pixmap = pixmap.scaled(\n   615→                    label_size,\n   616→                    Qt.KeepAspectRatio,\n   617→                    Qt.SmoothTransformation\n   618→                )\n   619→                logger.debug(f\"缩放后图片大小: {scaled_pixmap.size()}\")\n   620→                \n   621→                self.thumbnail_label.setPixmap(scaled_pixmap)\n   622→                logger.debug(\"缩略图设置成功\")\n   623→            else:\n   624→                logger.debug(\"QPixmap为空，显示错误文本\")\n   625→                self.thumbnail_label.setText(\"无法加载缩略图\")\n   626→                \n   627→        except Exception as e:\n   628→            logger.debug(f\"加载缩略图异常: {e}\")\n   629→            import traceback\n   630→            traceback.print_exc()\n   631→            self.thumbnail_label.setText(\"缩略图加载失败\")\n   632→    \n   633→    def create_default_thumbnail(self):\n   634→        \"\"\"创建默认缩略图\"\"\"\n   635→        pixmap = QPixmap(400, 300)\n   636→        pixmap.fill(Qt.black)\n   637→        \n   638→        from PySide6.QtGui import QPainter, QFont\n   639→        painter = QPainter(pixmap)\n   640→        painter.setPen(Qt.white)\n   641→        painter.setFont(QFont())  # Font configuration handled by unified style system\n   642→        painter.drawText(pixmap.rect(), Qt.AlignCenter, \"视频预览\")\n   643→        painter.end()\n   644→        \n   645→        return pixmap\n   646→    \n   647→    def on_thumbnail_click(self, event):\n   648→        \"\"\"缩略图点击事件\"\"\"\n   649→        self.start_video_playback()\n   650→    \n   651→    def start_video_playback(self):\n   652→        \"\"\"开始视频播放\"\"\"\n   653→        logger.debug(\"[UI] 开始视频播放…\")\n   654→        \n   655→        # 检查视频文件\n   656→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   657→        \n   658→        if not video_path or not os.path.exists(video_path):\n   659→            logger.warning(f\"[UI] 视频文件不存在: {video_path}\")\n   660→            from PySide6.QtWidgets import QMessageBox\n   661→            QMessageBox.critical(self, \"错误\", \"视频文件不存在\")\n   662→            return\n   663→        \n   664→        # 切换到视频播放器\n   665→        self.video_stack.setCurrentIndex(1)\n   666→        self.is_playing = True\n   667→        \n   668→        # 使用全局视频管理器播放\n   669→        self._video_manager.play(video_path, self.video_widget)\n   670→        logger.debug(\"[UI] 开始播放视频\")\n   671→    \n   672→    def toggle_play_pause(self):\n   673→        \"\"\"切换播放/暂停\"\"\"\n   674→        if not self.is_playing:\n   675→            self.start_video_playback()\n   676→        else:\n   677→            self._video_manager.toggle_play_pause()\n   678→    \n   679→    def on_state_changed(self, state):\n   680→        \"\"\"播放状态改变\"\"\"\n   681→        if state == QMediaPlayer.PlaybackState.PlayingState:\n   682→            self.play_button.setText(\"⏸\")\n   683→        else:\n   684→            self.play_button.setText(\"▶\")\n   685→    \n   686→    def on_position_changed(self, position):\n   687→        \"\"\"播放位置改变\"\"\"\n   688→        if hasattr(self, 'media_player'):\n   689→            duration = self.media_player.duration()\n   690→            if duration > 0:\n   691→                current_time = self.format_duration(position)\n   692→                total_time = self.format_duration(duration)\n   693→                self.progress_label.setText(f\"{current_time} / {total_time}\")\n   694→    \n   695→    def on_duration_changed(self, duration):\n   696→        \"\"\"视频时长改变\"\"\"\n   697→        if duration > 0:\n   698→            total_time = self.format_duration(duration)\n   699→            self.progress_label.setText(f\"00:00 / {total_time}\")\n   700→    \n   701→    def on_media_error(self, error, error_string):\n   702→        \"\"\"媒体播放错误处理\"\"\"\n   703→        logger.error(f\"[MEDIA] 播放错误: {error}, 信息: {error_string}\")\n   704→        \n   705→        from PySide6.QtWidgets import QMessageBox\n   706→        msg_box = QMessageBox(self)\n   707→        msg_box.setIcon(QMessageBox.Critical)\n   708→        msg_box.setText(\"视频播放错误\")\n   709→        msg_box.setInformativeText(f\"无法播放视频: {error_string}\")\n   710→        msg_box.exec()\n   711→        \n   712→        # 返回缩略图模式\n   713→        self.video_stack.setCurrentIndex(0)\n   714→        self.is_playing = False\n   715→    \n   716→    def on_media_status_changed(self, status):\n   717→        \"\"\"媒体状态改变\"\"\"\n   718→        from PySide6.QtMultimedia import QMediaPlayer\n   719→        \n   720→        logger.debug(f\"[MEDIA] 状态改变: {status}\")\n   721→        \n   722→        if status == QMediaPlayer.MediaStatus.EndOfMedia:\n   723→            # 视频播放结束，返回缩略图模式\n   724→            logger.debug(\"[MEDIA] 播放结束，切回缩略图模式\")\n   725→            self.video_stack.setCurrentIndex(0)\n   726→            self.is_playing = False\n   727→            if hasattr(self, 'media_player'):\n   728→                self.media_player.setPosition(0)  # 重置播放位置\n   729→            self.progress_label.setText(\"00:00 / 00:00\")\n   730→        elif status == QMediaPlayer.MediaStatus.InvalidMedia:\n   731→            logger.warning(\"[MEDIA] 媒体文件无效\")\n   732→        elif status == QMediaPlayer.MediaStatus.BufferedMedia:\n   733→            logger.debug(\"[MEDIA] 媒体缓冲完成\")\n   734→        elif status == QMediaPlayer.MediaStatus.LoadingMedia:\n   735→            logger.debug(\"[MEDIA] 正在加载媒体\")\n   736→        elif status == QMediaPlayer.MediaStatus.StalledMedia:\n   737→            logger.debug(\"[MEDIA] 播放卡顿\")\n   738→    \n   739→    def format_duration(self, ms):\n   740→        \"\"\"格式化时长显示\"\"\"\n   741→        seconds = ms // 1000\n   742→        minutes = seconds // 60\n   743→        seconds = seconds % 60\n   744→        return f\"{minutes:02d}:{seconds:02d}\"\n   745→    \n   746→    # OpenCV playback methods removed - using QtMultimedia exclusively\n   747→\n   748→    \n   749→    def format_time(self, time_str: str) -> str:\n   750→        \"\"\"格式化时间显示\"\"\"\n   751→        if not time_str:\n   752→            return '未知时间'\n   753→        try:\n   754→            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n   755→            return dt.strftime('%Y-%m-%d %H:%M:%S')\n   756→        except:\n   757→            return time_str[:19] if len(time_str) > 19 else time_str\n   758→    \n   759→    def format_file_size(self, size) -> str:\n   760→        \"\"\"格式化文件大小显示\"\"\"\n   761→        try:\n   762→            size = float(size) if size else 0\n   763→        except (ValueError, TypeError):\n   764→            return '未知大小'\n   765→            \n   766→        if size == 0:\n   767→            return '未知大小'\n   768→        \n   769→        for unit in ['B', 'KB', 'MB', 'GB']:\n   770→            if size < 1024.0:\n   771→                return f\"{size:.1f} {unit}\"\n   772→            size /= 1024.0\n   773→        return f\"{size:.1f} TB\"\n   774→    \n   775→    def setup_shortcuts(self):\n   776→        \"\"\"设置键盘快捷键\"\"\"\n   777→        # 移除所有QShortcut，统一使用keyPressEvent处理\n   778→        # 避免快捷键冲突问题\n   779→        pass\n   780→    \n   781→    def _ensure_focus(self):\n   782→        \"\"\"确保窗口获得焦点\"\"\"\n   783→        self.activateWindow()\n   784→        self.raise_()\n   785→        self.setFocus()\n   786→        logger.debug(f\"[FOCUS] VideoDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n   787→    \n   788→    def keyPressEvent(self, event):\n   789→        \"\"\"键盘事件处理\"\"\"\n   790→        from PySide6.QtCore import Qt\n   791→        \n   792→        logger.debug(f\"[KEYBOARD] VideoDetailDialog键盘事件: {event.key()}\")\n   793→        \n   794→        if event.key() == Qt.Key_Left:\n   795→            # 左方向键：上一个视频\n   796→            logger.debug(f\"[KEYBOARD] 左键pressed，prev_btn enabled: {self.prev_btn.isEnabled()}\")\n   797→            if self.prev_btn.isEnabled():\n   798→                self.show_previous_video()\n   799→            event.accept()\n   800→        elif event.key() == Qt.Key_Right:\n   801→            # 右方向键：下一个视频\n   802→            logger.debug(f\"[KEYBOARD] 右键pressed，next_btn enabled: {self.next_btn.isEnabled()}\")\n   803→            if self.next_btn.isEnabled():\n   804→                self.show_next_video()\n   805→            event.accept()\n   806→        elif event.key() == Qt.Key_Escape:\n   807→            # ESC键：关闭对话框（保持原有功能）\n   808→            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n   809→            if self.is_fullscreen:\n   810→                self.exit_fullscreen()\n   811→            else:\n   812→                self.accept()\n   813→            event.accept()\n   814→        elif event.key() == Qt.Key_F11:\n   815→            # F11键：全屏切换（保持原有功能）\n   816→            self.toggle_fullscreen()\n   817→            event.accept()\n   818→        elif event.key() == Qt.Key_Space:\n   819→            # 空格键：播放/暂停\n   820→            self.toggle_play_pause()\n   821→            event.accept()\n   822→        else:\n   823→            # 其他按键交给父类处理\n   824→            super().keyPressEvent(event)\n   825→    \n   826→    def toggle_fullscreen(self):\n   827→        \"\"\"切换全屏模式\"\"\"\n   828→        if self.is_fullscreen:\n   829→            self.exit_fullscreen()\n   830→        else:\n   831→            self.enter_fullscreen()\n   832→    \n   833→    def enter_fullscreen(self):\n   834→        \"\"\"进入全屏模式\"\"\"\n   835→        if not self.is_fullscreen:\n   836→            self.original_geometry = self.geometry()\n   837→            self.showFullScreen()\n   838→            self.is_fullscreen = True\n   839→    \n   840→    def exit_fullscreen(self):\n   841→        \"\"\"退出全屏模式\"\"\"\n   842→        if self.is_fullscreen:\n   843→            self.showNormal()\n   844→            if self.original_geometry:\n   845→                self.setGeometry(self.original_geometry)\n   846→            self.is_fullscreen = False\n   847→    \n   848→    def handle_escape_key(self):\n   849→        \"\"\"处理ESC键\"\"\"\n   850→        if self.is_fullscreen:\n   851→            self.exit_fullscreen()\n   852→        else:\n   853→            self.accept()\n   854→    \n   855→    def copy_prompt(self):\n   856→        \"\"\"复制提示词到剪贴板\"\"\"\n   857→        prompt_content = self.prompt_text_edit.toPlainText()\n   858→        clipboard = QApplication.clipboard()\n   859→        clipboard.setText(prompt_content)\n   860→        self.show_copy_toast(\"提示词已复制到剪贴板\")\n   861→    \n   862→    def show_copy_toast(self, message: str):\n   863→        \"\"\"显示复制成功的轻量提示\"\"\"\n   864→        toast = QLabel(message, self)\n   865→        toast.setObjectName(\"ToastLabel\")\n   866→        toast.setAlignment(Qt.AlignCenter)\n   867→        toast.adjustSize()\n   868→        \n   869→        x = (self.width() - toast.width()) // 2\n   870→        y = self.height() // 4\n   871→        toast.move(x, y)\n   872→        toast.show()\n   873→        \n   874→        QTimer.singleShot(2000, toast.deleteLater)\n   875→\n   876→    def _on_reference_clicked(self, asset: Dict[str, Any]):\n   877→        assets = list(self._reference_assets) if self._reference_assets else [asset]\n   878→        start_idx = _find_reference_asset_index(assets, asset)\n   879→        open_reference_preview(\n   880→            self,\n   881→            asset,\n   882→            title_prefix=\"参考图\",\n   883→            asset_list=assets,\n   884→            start_index=start_idx,\n   885→            on_asset_changed=self._sync_reference_selection,\n   886→        )\n   887→\n   888→    def _on_reference_export(self, asset: Dict[str, Any]):\n   889→        export_reference_asset(self, asset)\n   890→\n   891→    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n   892→        asset_path = None\n   893→        if isinstance(asset, dict):\n   894→            asset_path = asset.get('absolute_path') or asset.get('path')\n   895→        has_path = bool(asset_path and os.path.exists(asset_path))\n   896→        if hasattr(self, 'reference_export_btn'):\n   897→            self.reference_export_btn.setEnabled(has_path)\n   898→\n   899→    def _export_selected_reference(self):\n   900→        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n   901→        if not asset:\n   902→            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n   903→            return\n   904→        export_reference_asset(self, asset)\n   905→\n   906→    def _refresh_reference_gallery(self):\n   907→        if not hasattr(self, 'reference_gallery'):\n   908→            return\n   909→        self._reference_summary = ensure_reference_info(self.video_data)\n   910→        if self._reference_summary.get('count', 0) <= 0:\n   911→            self.reference_gallery.setVisible(False)\n   912→            self.reference_gallery.clear()\n   913→            if hasattr(self, 'reference_export_btn'):\n   914→                self.reference_export_btn.setEnabled(False)\n   915→            self._reference_assets = []\n   916→            self._export_controller.refresh()\n   917→            return\n   918→        try:\n   919→            self._reference_assets = resolve_reference_assets(self.video_data, absolute=True)\n   920→        except Exception:\n   921→            self._reference_assets = []\n   922→        self.reference_gallery.set_assets(self._reference_assets)\n   923→        self.reference_gallery.setVisible(True)\n   924→        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n   925→        self._export_controller.refresh()\n   926→\n   927→    def _sync_reference_selection(self, asset: Dict[str, Any]):\n   928→        try:\n   929→            self.reference_gallery.select_asset(asset)\n   930→        except Exception:\n   931→            pass\n   932→\n   933→    def _resolve_video_record_id(self) -> Optional[str]:\n   934→        for key in (\"file_id\", \"id\", \"generation_id\"):\n   935→            value = self.video_data.get(key)\n   936→            if value not in (None, \"\"):\n   937→                return str(value)\n   938→        return None\n   939→\n   940→    def _delete_current_record(self):\n   941→        \"\"\"删除当前视频记录及相关文件\"\"\"\n   942→        record_id = self._resolve_video_record_id()\n   943→        if not record_id:\n   944→            self.show_copy_toast(\"无法获取记录ID\")\n   945→            return\n   946→        \n   947→        try:\n   948→            # 停止当前播放\n   949→            if hasattr(self, 'media_player'):\n   950→                self.media_player.stop()\n   951→            \n   952→            # 获取 RepositoryManager\n   953→            from config_api import get_storage_dir\n   954→            from modules.repository.manager import RepositoryManager\n   955→            \n   956→            storage_dir = get_storage_dir()\n   957→            repo = RepositoryManager(storage_dir)\n   958→            \n   959→            # 执行删除\n   960→            if repo.delete_record_with_files(record_id):\n   961→                self.show_copy_toast(\"记录已删除\")\n   962→                \n   963→                # 发出信号通知父视图刷新\n   964→                self.recordDeleted.emit(record_id)\n   965→                \n   966→                # 从列表中移除当前记录\n   967→                if len(self.video_list) > 1:\n   968→                    del self.video_list[self.current_index]\n   969→                    \n   970→                    # 导航到后一条记录（保持索引，指向原来的下一条）\n   971→                    # 只有当删除的是最后一条时，才需要调整索引\n   972→                    if self.current_index >= len(self.video_list):\n   973→                        self.current_index = len(self.video_list) - 1\n   974→                    \n   975→                    # 更新 video_data 到新的当前记录\n   976→                    self.video_data = self.video_list[self.current_index]\n   977→                    self.load_video()\n   978→                    self.update_navigation_buttons()\n   979→                else:\n   980→                    # 只剩一条记录，关闭对话框\n   981→                    self.accept()\n   982→            else:\n   983→                self.show_copy_toast(\"删除失败\")\n   984→        except Exception as e:\n   985→            from utils.logger import logger\n   986→            logger.error(f\"删除视频记录异常: {e}\")\n   987→            self.show_copy_toast(f\"删除失败: {str(e)}\")\n   988→\n   989→    def download_video(self):\n   990→        \"\"\"下载视频到指定位置\"\"\"\n   991→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n   992→        if not video_path or not os.path.exists(video_path):\n   993→            self.show_styled_message(\"错误\", \"视频文件不存在\", \"warning\")\n   994→            return\n   995→        \n   996→        file_dialog = QFileDialog()\n   997→        save_path, _ = file_dialog.getSaveFileName(\n   998→            self,\n   999→            \"保存视频\",\n  1000→            f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4\",\n  1001→            \"视频文件 (*.mp4)\"\n  1002→        )\n  1003→        \n  1004→        if save_path:\n  1005→            try:\n  1006→                import shutil\n  1007→                shutil.copy2(video_path, save_path)\n  1008→                self.show_copy_toast(f\"视频已保存到: {os.path.basename(save_path)}\")\n  1009→            except Exception as e:\n  1010→                self.show_styled_message(\"错误\", f\"保存视频失败: {str(e)}\", \"critical\")\n  1011→    \n  1012→    def update_navigation_buttons(self):\n  1013→        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n  1014→        logger.debug(f\"[NAV] 更新导航按钮：当前索引{self.current_index}，总记录数{len(self.video_list)}\")\n  1015→        \n  1016→        has_prev = self._has_valid_previous_record()\n  1017→        has_next = self._has_valid_next_record()\n  1018→        \n  1019→        logger.debug(f\"[NAV] 有效记录检查：prev={has_prev}, next={has_next}\")\n  1020→        \n  1021→        self.prev_btn.setEnabled(has_prev)\n  1022→        self.next_btn.setEnabled(has_next)\n  1023→    \n  1024→    def _has_valid_previous_record(self):\n  1025→        \"\"\"检查是否有有效的上一个记录\"\"\"\n  1026→        logger.debug(f\"[NAV] 检查上一个记录：从索引{self.current_index - 1}到0\")\n  1027→        for i in range(self.current_index - 1, -1, -1):\n  1028→            candidate_data = self.video_list[i]\n  1029→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1030→            content_type = candidate_data.get('content_type', '')\n  1031→            \n  1032→            # 检查文件扩展名，确保是视频文件\n  1033→            is_video = False\n  1034→            if file_path:\n  1035→                from pathlib import Path\n  1036→                file_ext = Path(file_path).suffix.lower()\n  1037→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1038→            \n  1039→            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n  1040→            \n  1041→            if file_path and os.path.exists(file_path) and is_video:\n  1042→                logger.debug(f\"[NAV] 找到有效的上一个视频记录：索引{i}\")\n  1043→                return True\n  1044→        logger.debug(f\"[NAV] 没有找到有效的上一个视频记录\")\n  1045→        return False\n  1046→    \n  1047→    def _has_valid_next_record(self):\n  1048→        \"\"\"检查是否有有效的下一个记录\"\"\"\n  1049→        logger.debug(f\"[NAV] 检查下一个记录：从索引{self.current_index + 1}到{len(self.video_list) - 1}\")\n  1050→        for i in range(self.current_index + 1, len(self.video_list)):\n  1051→            candidate_data = self.video_list[i]\n  1052→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1053→            content_type = candidate_data.get('content_type', '')\n  1054→            \n  1055→            # 检查文件扩展名，确保是视频文件\n  1056→            is_video = False\n  1057→            if file_path:\n  1058→                from pathlib import Path\n  1059→                file_ext = Path(file_path).suffix.lower()\n  1060→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1061→            \n  1062→            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n  1063→            \n  1064→            if file_path and os.path.exists(file_path) and is_video:\n  1065→                logger.debug(f\"[NAV] 找到有效的下一个视频记录：索引{i}\")\n  1066→                return True\n  1067→        logger.debug(f\"[NAV] 没有找到有效的下一个视频记录\")\n  1068→        return False\n  1069→    \n  1070→    def show_previous_video(self):\n  1071→        \"\"\"显示上一个视频（带有效性验证）\"\"\"\n  1072→        # 寻找上一个有效视频记录\n  1073→        for i in range(self.current_index - 1, -1, -1):\n  1074→            candidate_data = self.video_list[i]\n  1075→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1076→            \n  1077→            # 检查是否为视频文件\n  1078→            is_video = False\n  1079→            if file_path:\n  1080→                from pathlib import Path\n  1081→                file_ext = Path(file_path).suffix.lower()\n  1082→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1083→            \n  1084→            if file_path and os.path.exists(file_path) and is_video:\n  1085→                # 找到有效视频记录\n  1086→                logger.debug(f\"[NAV] 切换到上一个视频：索引{i}\")\n  1087→                self.current_index = i\n  1088→                self.video_data = self.video_list[i]\n  1089→                self.load_video()\n  1090→                self.update_navigation_buttons()\n  1091→                return\n  1092→        \n  1093→        # 没有找到有效的上一个视频记录，保持当前状态\n  1094→        logger.debug(f\"[NAV] 没有上一个视频可切换\")\n  1095→        self.update_navigation_buttons()\n  1096→    \n  1097→    def show_next_video(self):\n  1098→        \"\"\"显示下一个视频（带有效性验证）\"\"\"\n  1099→        # 寻找下一个有效视频记录\n  1100→        for i in range(self.current_index + 1, len(self.video_list)):\n  1101→            candidate_data = self.video_list[i]\n  1102→            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n  1103→            \n  1104→            # 检查是否为视频文件\n  1105→            is_video = False\n  1106→            if file_path:\n  1107→                from pathlib import Path\n  1108→                file_ext = Path(file_path).suffix.lower()\n  1109→                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n  1110→            \n  1111→            if file_path and os.path.exists(file_path) and is_video:\n  1112→                # 找到有效视频记录\n  1113→                logger.debug(f\"[NAV] 切换到下一个视频：索引{i}\")\n  1114→                self.current_index = i\n  1115→                self.video_data = self.video_list[i]\n  1116→                self.load_video()\n  1117→                self.update_navigation_buttons()\n  1118→                return\n  1119→        \n  1120→        # 没有找到有效的下一个视频记录，保持当前状态\n  1121→        logger.debug(f\"[NAV] 没有下一个视频可切换\")\n  1122→        self.update_navigation_buttons()\n  1123→    \n  1124→    def load_video(self):\n  1125→        \"\"\"加载新视频\"\"\"\n  1126→        logger.debug(\"[UI] 加载新视频…\")\n  1127→        \n  1128→        # 停止当前播放器\n  1129→        if hasattr(self, 'media_player') and self.media_player:\n  1130→            self.media_player.stop()\n  1131→        \n  1132→        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n  1133→        if video_path and os.path.exists(video_path):\n  1134→            from PySide6.QtCore import QUrl\n  1135→            if hasattr(self, 'media_player') and self.media_player:\n  1136→                self.media_player.setSource(QUrl.fromLocalFile(video_path))\n  1137→            \n  1138→            # 重置到缩略图模式\n  1139→            self.video_stack.setCurrentIndex(0)\n  1140→            self.is_playing = False\n  1141→            \n  1142→            # 重新加载缩略图\n  1143→            self.load_thumbnail()\n  1144→            \n  1145→            # 更新右侧信息\n  1146→            prompt_content = self.video_data.get('prompt', '无提示词')\n  1147→            self.prompt_text_edit.setPlainText(prompt_content)\n  1148→            \n  1149→            # 更新参数信息\n  1150→            self.update_video_params()\n  1151→            \n  1152→            logger.debug(\"[UI] 新视频加载完成\")\n  1153→        else:\n  1154→            self.video_stack.setCurrentIndex(0)\n  1155→            self.is_playing = False\n  1156→\n  1157→        self._refresh_reference_gallery()\n  1158→        self._export_controller.refresh()\n  1159→    \n  1160→    def _update_theme(self):\n  1161→        \"\"\"响应主题变化\"\"\"\n  1162→        colors = unified_style_system.get_colors()\n  1163→        \n  1164→        # Apply theme to self (Dialog)\n  1165→        # Note: In some OS/Qt versions, QDialog styling needs explicit background\n  1166→        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n  1167→        text_color = colors.get('text') or colors.get('palette.text.primary')\n  1168→        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n  1169→        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or bg_card\n  1170→        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n  1171→        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n  1172→        \n  1173→        self.setStyleSheet(f\"\"\"\n  1174→            QDialog {{\n  1175→                background-color: {bg_color};\n  1176→                color: {text_color};\n  1177→            }}\n  1178→            QLabel {{\n  1179→                color: {text_color};\n  1180→            }}\n  1181→            QWidget#ParamsWidget {{\n  1182→                 background-color: {bg_card};\n  1183→                 border-left: 1px solid {border_subtle};\n  1184→            }}\n  1185→        \"\"\")\n  1186→        \n  1187→        # Update specific controls directly\n  1188→        if hasattr(self, 'prompt_text_edit'):\n  1189→             self.prompt_text_edit.setStyleSheet(f\"\"\"\n  1190→                QTextEdit {{\n  1191→                    background-color: {bg_input};\n  1192→                    color: {text_color};\n  1193→                    border: 1px solid {border_subtle};\n  1194→                    border-radius: 8px;\n  1195→                    padding: 8px;\n  1196→                }}\n  1197→                QTextEdit:focus {{\n  1198→                    border-color: {brand};\n  1199→                }}\n  1200→             \"\"\")\n  1201→\n  1202→        # Manually update param labels that were stored\n  1203→        if hasattr(self, 'param_value_labels'):\n  1204→            for label, value_label in self.param_value_labels.items():\n  1205→                value_label.setStyleSheet(f\"\"\"\n  1206→                    QLineEdit {{\n  1207→                        background-color: {bg_input};\n  1208→                        color: {text_color};\n  1209→                        border: 1px solid {border_subtle};\n  1210→                        padding: 4px;\n  1211→                        border-radius: 8px;\n  1212→                    }}\n  1213→                    QLineEdit:focus {{\n  1214→                        border-color: {brand};\n  1215→                    }}\n  1216→                \"\"\")\n  1217→\n  1218→        # Update thumbnail background if visible\n  1219→        if hasattr(self, 'thumbnail_label'):\n  1220→             player_bg = colors.get('palette.component.player_bg') or bg_color\n  1221→             self.thumbnail_label.setStyleSheet(f\"\"\"\n  1222→                QLabel {{\n  1223→                    border: none;\n  1224→                    background-color: {player_bg};\n  1225→                    color: {text_color};\n  1226→                }}\n  1227→             \"\"\")\n  1228→\n  1229→        # Reapply button styles\n  1230→        if hasattr(self, 'fullscreen_btn'):\n  1231→            unified_style_system.apply_to_widget(self.fullscreen_btn)\n  1232→        if hasattr(self, 'download_btn'):\n  1233→            unified_style_system.apply_to_widget(self.download_btn)\n  1234→        if hasattr(self, 'delete_btn'):\n  1235→            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n  1236→        if hasattr(self, 'close_btn'):\n  1237→            unified_style_system.apply_to_widget(self.close_btn)\n  1238→        if hasattr(self, 'reference_export_btn'):\n  1239→            unified_style_system.apply_to_widget(self.reference_export_btn)\n  1240→        if hasattr(self, 'export_bundle_btn'):\n  1241→            unified_style_system.apply_to_widget(self.export_bundle_btn)\n  1242→        if hasattr(self, 'play_button'):\n  1243→            unified_style_system.apply_to_widget(self.play_button)\n  1244→        if hasattr(self, 'prev_btn'):\n  1245→            unified_style_system.apply_to_widget(self.prev_btn)\n  1246→        if hasattr(self, 'next_btn'):\n  1247→            unified_style_system.apply_to_widget(self.next_btn)\n  1248→\n  1249→    def update_video_params(self):\n  1250→        \"\"\"更新视频参数显示（切换视频时调用）\"\"\"\n  1251→        try:\n  1252→            # 解析生成参数\n  1253→            params = self.video_data.get('parameters', '{}')\n  1254→            if isinstance(params, str):\n  1255→                try:\n  1256→                    params = json.loads(params)\n  1257→                except:\n  1258→                    params = {}\n  1259→\n  1260→            # 从 parameters 中获取参数（兼容顶级字段）\n  1261→            duration = params.get('duration') or self.video_data.get('duration', '未知')\n  1262→            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n  1263→\n  1264→            # 重新构建参数信息\n  1265→            info_items = [\n  1266→                (\"分辨率\", build_resolution_text(self.video_data)),\n  1267→                (\"时长\", f\"{duration}秒\"),\n  1268→                (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n  1269→                (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n  1270→                (\"文件大小\", self.format_file_size(file_size)),\n  1271→                (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n  1272→            ]\n  1273→            \n  1274→            # 更新已保存的标签\n  1275→            for label, new_value in info_items:\n  1276→                if label in self.param_value_labels:\n  1277→                    self.param_value_labels[label].setText(str(new_value))\n  1278→            \n  1279→            logger.debug(\"视频参数已更新\")\n  1280→            \n  1281→        except Exception as e:\n  1282→            logger.error(f\"更新视频参数失败: {e}\")\n  1283→    \n  1284→    def update_param_labels(self):\n  1285→        \"\"\"更新参数标签内容\"\"\"\n  1286→        try:\n  1287→            # 从 parameters 中获取参数（兼容顶级字段）\n  1288→            params = self.video_data.get('parameters', {}) or {}\n  1289→            duration = params.get('duration') or self.video_data.get('duration', '未知')\n  1290→            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n  1291→\n  1292→            # 更新各个参数标签\n  1293→            param_updates = {\n  1294→                \"分辨率\": build_resolution_text(self.video_data),\n  1295→                \"时长\": f\"{duration}秒\",\n  1296→                \"模型\": get_model_display_name(pick_model_code(self.video_data)),\n  1297→                \"生成时间\": self.format_time(self.video_data.get('created_at', '')),\n  1298→                \"文件大小\": self.format_file_size(file_size),\n  1299→                \"文件路径\": self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n  1300→            }\n  1301→            \n  1302→            for param_name, new_value in param_updates.items():\n  1303→                if param_name in self.param_labels:\n  1304→                    self.param_labels[param_name].setText(str(new_value))\n  1305→                    logger.debug(f\"已更新参数 {param_name}: {new_value}\")\n  1306→            \n  1307→            logger.debug(\"视频参数标签更新完成\")\n  1308→        except Exception as e:\n  1309→            logger.error(f\"更新视频参数标签失败: {e}\")\n  1310→    \n  1311→    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n  1312→        \"\"\"显示带有深色主题样式的消息框\"\"\"\n  1313→        from PySide6.QtWidgets import QMessageBox\n  1314→        \n  1315→        msg_box = QMessageBox(self)\n  1316→        msg_box.setWindowTitle(title)\n  1317→        msg_box.setText(message)\n  1318→        \n  1319→        # 设置图标\n  1320→        if icon_type == \"warning\":\n  1321→            msg_box.setIcon(QMessageBox.Warning)\n  1322→        elif icon_type == \"critical\":\n  1323→            msg_box.setIcon(QMessageBox.Critical)\n  1324→        elif icon_type == \"question\":\n  1325→            msg_box.setIcon(QMessageBox.Question)\n  1326→        else:\n  1327→            msg_box.setIcon(QMessageBox.Information)\n  1328→        \n  1329→        # 样式由全局QSS控制\n  1330→        \n  1331→        msg_box.exec()\n  1332→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a580bee7-b800-415e-8bee-56f8d8f50d7c","timestamp":"2025-12-22T04:32:24.205Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs/video_detail_dialog.py","content":"import os\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\n\nfrom PySide6.QtWidgets import (\n    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,\n    QTextEdit, QFileDialog, QMessageBox, QStackedWidget, QSplitter,\n    QApplication\n)\nfrom PySide6.QtGui import QShortcut\nfrom PySide6.QtCore import Qt, QTimer, QUrl, QSize, QEvent\nfrom PySide6.QtGui import QPixmap, QFont, QKeySequence, QPainter, QImage\nfrom PySide6.QtMultimedia import QMediaPlayer\nfrom PySide6.QtMultimediaWidgets import QVideoWidget\n\n# 使用全局视频管理器单例\nfrom services.global_video_manager import get_global_video_manager\n\nfrom utils.logger import logger\nfrom components.reference_assets import (\n    ReferenceGalleryWidget,\n    export_reference_asset,\n    open_reference_preview,\n    _find_reference_asset_index,\n)\nfrom utils.style_system import unified_style_system\nfrom components.controllers import ExportBundleController\nfrom utils.reference_display import (\n    build_resolution_text,\n    ensure_reference_info,\n    get_model_display_name,\n    pick_model_code,\n    resolve_reference_assets,\n)\nfrom PySide6.QtCore import Signal\n\nclass VideoDetailDialog(QDialog):\n    \"\"\"视频详细信息对话框\"\"\"\n    \n    # 删除记录后发出信号，通知父视图刷新\n    recordDeleted = Signal(str)  # 参数为被删除的记录ID\n    \n    def __init__(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0, parent=None):\n        super().__init__(parent)\n        self.video_data = video_data\n        self.video_list = video_list or [video_data]  # 视频列表\n        self.current_index = current_index  # 当前视频索引\n        self.is_fullscreen = False  # 全屏状态\n        self.original_geometry = None  # 原始窗口几何\n        self.param_value_labels = {}  # 存储参数值标签的引用\n        self._reference_summary = ensure_reference_info(self.video_data)\n        self._reference_assets: List[Dict[str, Any]] = []\n        self._export_controller = ExportBundleController(self, \"video\")\n        \n        # Subscribe to theme changes\n        unified_style_system.styleChanged.connect(self._update_theme)\n        \n        self.setup_ui()\n    \n    def set_video_data(self, video_data: Dict[str, Any], video_list: List[Dict[str, Any]] = None, current_index: int = 0):\n        \"\"\"更新视频数据（复用对话框时调用，避免重建 QVideoWidget）\"\"\"\n        logger.debug(f\"[REUSE] 复用对话框，更新视频数据: index={current_index}\")\n        \n        # 1. 先停止当前播放\n        if hasattr(self, '_video_manager') and self._video_manager is not None:\n            self._video_manager.stop()\n        \n        # 2. 重置到缩略图模式\n        if hasattr(self, 'video_stack'):\n            self.video_stack.setCurrentIndex(0)\n        self.is_playing = False\n        \n        # 3. 更新数据\n        self.video_data = video_data\n        self.video_list = video_list or [video_data]\n        self.current_index = current_index\n        self._reference_summary = ensure_reference_info(self.video_data)\n        \n        # 4. 刷新UI\n        self.load_thumbnail()\n        \n        # 5. 更新右侧信息\n        if hasattr(self, 'prompt_text_edit'):\n            prompt_content = self.video_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n        \n        # 6. 更新参数信息\n        if hasattr(self, 'update_video_params'):\n            self.update_video_params()\n        \n        # 7. 更新导航按钮\n        if hasattr(self, 'update_navigation_buttons'):\n            self.update_navigation_buttons()\n        \n        # 8. 刷新参考图画廊\n        if hasattr(self, '_refresh_reference_gallery'):\n            self._refresh_reference_gallery()\n        \n        # 9. 重新激活窗口\n        self.setEnabled(True)\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        \n        logger.debug(\"[REUSE] 视频数据更新完成\")\n        \n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        self.setWindowTitle(\"视频详细信息\")\n        self.resize(1100, 800)  # 改为可调整大小\n        self.setMinimumSize(800, 600)  # 设置最小尺寸\n        \n        # 设置焦点策略，确保能接收键盘事件\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.setAttribute(Qt.WA_KeyCompression, False)  # 禁用键盘事件压缩\n        self.setFocus()\n\n        # 确保窗口激活时获得焦点\n        self.activateWindow()\n        self.raise_()\n\n        try:\n            self.setObjectName(\"DetailDialog\")\n        except Exception:\n            pass\n\n        self._focus_timer = QTimer(self)\n        self._focus_timer.setSingleShot(True)\n        self._focus_timer.timeout.connect(self._ensure_focus)\n\n        layout = QHBoxLayout(self)\n        \n        # 左侧：视频播放器（占70%宽度）\n        left_widget = QWidget()\n        left_layout = QVBoxLayout(left_widget)\n        left_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 视频播放区域\n        video_container = QWidget()\n        video_container.setObjectName(\"VideoContainer\")\n        \n        container_layout = QVBoxLayout(video_container)\n        container_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 创建堆叠布局，用于缩略图和视频播放器的切换\n        from PySide6.QtWidgets import QStackedWidget\n        self.video_stack = QStackedWidget()\n        \n        # 缩略图页面\n        self.thumbnail_widget = QWidget()\n        self.thumbnail_widget.setObjectName(\"ThumbnailWidget\")\n        thumbnail_layout = QVBoxLayout(self.thumbnail_widget)\n        thumbnail_layout.setContentsMargins(0, 0, 0, 0)\n        thumbnail_layout.setAlignment(Qt.AlignCenter)\n        \n        # 缩略图标签\n        self.thumbnail_label = QLabel()\n        self.thumbnail_label.setAlignment(Qt.AlignCenter)\n        colors = unified_style_system.get_colors()\n        player_bg = colors.get('palette.component.player_bg')\n        text_on_brand = (\n            colors.get('palette.text.on_brand')\n            or colors.get('palette.text.primary')\n            or colors.get('text')\n        )\n        self.thumbnail_label.setStyleSheet(f\"\"\"\n            QLabel {{\n                border: none;\n                background-color: {player_bg};\n                color: {text_on_brand};\n            }}\n        \"\"\")\n        self.thumbnail_label.setMinimumSize(400, 300)\n        # 不使用setScaledContents，改为手动缩放\n        # self.thumbnail_label.setScaledContents(True)\n        \n        # 播放按钮覆盖层\n        self.play_overlay = QLabel(\"▶\")\n        self.play_overlay.setAlignment(Qt.AlignCenter)\n        self.play_overlay.setObjectName(\"PlayOverlay\")\n        \n        # 创建缩略图容器，使用相对定位\n        thumbnail_container = QWidget()\n        thumbnail_container.setStyleSheet(f\"border: none; background-color: {player_bg};\")\n        # 设置固定尺寸确保容器有正确的大小\n        thumbnail_container.setFixedSize(640, 480)\n        \n        # 使用绝对定位放置播放按钮\n        def setup_thumbnail_layout():\n            self.thumbnail_label.setParent(thumbnail_container)\n            self.play_overlay.setParent(thumbnail_container)\n            \n            # 确保标签可见\n            self.thumbnail_label.show()\n            self.play_overlay.show()\n            \n            def resize_thumbnail_container():\n                if hasattr(self, 'thumbnail_label') and hasattr(self, 'play_overlay'):\n                    container_size = thumbnail_container.size()\n                    logger.debug(f\"[UI] 详情缩略图容器尺寸: {container_size}\")\n                    \n                    # 设置缩略图标签尺寸和位置\n                    self.thumbnail_label.setGeometry(0, 0, container_size.width(), container_size.height())\n                    \n                    # 播放按钮居中\n                    overlay_x = max(0, (container_size.width() - 70) // 2)\n                    overlay_y = max(0, (container_size.height() - 70) // 2)\n                    self.play_overlay.setGeometry(overlay_x, overlay_y, 70, 70)\n                    \n                    logger.debug(f\"[UI] 缩略图标签位置: {self.thumbnail_label.geometry()}\")\n                    logger.debug(f\"[UI] 播放按钮位置: {self.play_overlay.geometry()}\")\n            \n            def handle_resize_event(event):\n                resize_thumbnail_container()\n                QWidget.resizeEvent(thumbnail_container, event)\n            \n            thumbnail_container.resizeEvent = handle_resize_event\n            \n            # 立即调用布局函数\n            resize_thumbnail_container()\n        \n        setup_thumbnail_layout()\n        \n        # 点击事件\n        self.thumbnail_label.mousePressEvent = self.on_thumbnail_click\n        self.play_overlay.mousePressEvent = self.on_thumbnail_click\n        \n        thumbnail_layout.addWidget(thumbnail_container)\n        \n        # 视频播放器页面\n        self.video_widget = QVideoWidget()\n        self.video_widget.setObjectName(\"VideoWidget\")\n        \n        # 使用全局视频管理器（单例模式）\n        logger.debug(\"[UI] 连接全局视频管理器...\")\n        self._video_manager = get_global_video_manager()\n        \n        # 绑定当前对话框（独占绑定，只有当前对话框接收信号）\n        self._video_manager.bind_dialog(self)\n        logger.debug(\"[UI] 全局视频管理器绑定完成\")\n        \n        # 播放状态标志\n        self.is_playing = False\n        \n        # 添加到堆叠布局\n        self.video_stack.addWidget(self.thumbnail_widget)  # 索引0：缩略图\n        self.video_stack.addWidget(self.video_widget)      # 索引1：Qt视频播放器\n        \n        # 加载视频和缩略图\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if video_path and os.path.exists(video_path):\n            # 不在初始化时加载媒体，延迟到用户点击播放时\n            self.load_thumbnail()\n        \n        container_layout.addWidget(self.video_stack)\n        \n        # 视频区域占据所有可用空间\n        left_splitter = QSplitter(Qt.Vertical)\n        left_splitter.addWidget(video_container)\n\n        self.reference_gallery = ReferenceGalleryWidget()\n        try:\n            self.reference_gallery.referenceClicked.connect(self._on_reference_clicked)\n            self.reference_gallery.exportRequested.connect(self._on_reference_export)\n            self.reference_gallery.selectionChanged.connect(self._on_reference_selection_changed)\n        except Exception:\n            pass\n        # 参考图区域容器，包含画廊与操作按钮\n        reference_section = QWidget()\n        reference_section_layout = QVBoxLayout(reference_section)\n        reference_section_layout.setContentsMargins(0, 0, 0, 0)\n        reference_section_layout.setSpacing(6)\n        reference_section_layout.addWidget(self.reference_gallery)\n        # 将左侧分割器先加入主布局（第二块稍后补充按钮区后再添加）\n        # 注意：最终会把 reference_section 放入分割器\n\n        reference_button_layout = QHBoxLayout()\n        reference_button_layout.setContentsMargins(0, 0, 0, 0)\n        reference_button_layout.setSpacing(6)\n        self.export_status_label = QLabel(\"\")\n        self.export_status_label.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(self.export_status_label)\n        reference_button_layout.addWidget(self.export_status_label)\n        reference_button_layout.addStretch(1)\n        self.reference_export_btn = QPushButton(\"导出选中参考图\")\n        self.reference_export_btn.setObjectName(\"SecondaryButton\")\n        self.reference_export_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.reference_export_btn)\n        self.reference_export_btn.clicked.connect(self._export_selected_reference)\n        reference_button_layout.addWidget(self.reference_export_btn)\n        self.export_bundle_btn = QPushButton(\"导出记录\")\n        self.export_bundle_btn.setObjectName(\"SecondaryButton\")\n        self.export_bundle_btn.setEnabled(False)\n        unified_style_system.apply_to_widget(self.export_bundle_btn)\n        self._export_controller.configure(\n            self.export_bundle_btn,\n            self.export_status_label,\n            self._resolve_video_record_id,\n            context_widget=self,\n        )\n        reference_button_layout.addWidget(self.export_bundle_btn)\n        reference_section_layout.addLayout(reference_button_layout)\n        # 将参考图区域加入分割器，并把分割器加入左侧布局\n        left_splitter.addWidget(reference_section)\n        try:\n            left_splitter.setStretchFactor(0, 3)\n            left_splitter.setStretchFactor(1, 2)\n            left_splitter.setSizes([520, 280])\n        except Exception:\n            pass\n        left_layout.addWidget(left_splitter, 1)\n\n        # 底部控制区域\n        controls_layout = QHBoxLayout()\n        controls_layout.setContentsMargins(0, 5, 0, 5)\n        controls_layout.setSpacing(10)\n        \n        # 播放/暂停按钮\n        self.play_button = QPushButton(\"▶\")\n        self.play_button.setFixedSize(40, 30)\n        self.play_button.setObjectName(\"PlayButton\")\n        unified_style_system.apply_to_widget(self.play_button)\n        self.play_button.clicked.connect(self.toggle_play_pause)\n        controls_layout.addWidget(self.play_button)\n        \n        # 进度条（简单的标签显示）\n        self.progress_label = QLabel(\"00:00 / 00:00\")\n        self.progress_label.setObjectName(\"ProgressLabel\")\n        controls_layout.addWidget(self.progress_label, 1)\n        \n        # 音量控制\n        volume_label = QLabel(\"🔊\")\n        volume_label.setObjectName(\"infoLabel\")\n        unified_style_system.apply_to_widget(volume_label)\n        controls_layout.addWidget(volume_label)\n        \n        # 导航按钮\n        self.prev_btn = QPushButton(\"◀\")\n        self.prev_btn.setFixedSize(30, 30)\n        self.prev_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.prev_btn)\n        self.prev_btn.clicked.connect(self.show_previous_video)\n        controls_layout.addWidget(self.prev_btn)\n\n        self.next_btn = QPushButton(\"▶\")\n        self.next_btn.setFixedSize(30, 30)\n        self.next_btn.setObjectName(\"NavButton\")\n        unified_style_system.apply_to_widget(self.next_btn)\n        self.next_btn.clicked.connect(self.show_next_video)\n        controls_layout.addWidget(self.next_btn)\n        \n        left_layout.addLayout(controls_layout)\n\n        # 更新导航按钮状态\n        self.update_navigation_buttons()\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n\n        # 右侧：详细信息（固定30%宽度）\n        right_layout = QVBoxLayout()\n        \n        # 创建参数显示区域\n        params_widget = QWidget()\n        params_widget.setFixedWidth(int(self.width() * 0.3))\n        params_widget.setObjectName(\"ParamsWidget\")\n        params_layout = QVBoxLayout(params_widget)\n        params_layout.setSpacing(0)\n        params_layout.setContentsMargins(5, 5, 5, 5)\n        \n        # 解析生成参数\n        params = self.video_data.get('parameters', '{}')\n        if isinstance(params, str):\n            try:\n                params = json.loads(params)\n            except:\n                params = {}\n        \n        # 提示词区域\n        prompt_label = QLabel(\"<b>提示词:</b>\")\n        prompt_label.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n        unified_style_system.apply_to_widget(prompt_label)\n        params_layout.addWidget(prompt_label)\n        \n        # 提示词文本框\n        prompt_content = self.video_data.get('prompt', '无提示词')\n        self.prompt_text_edit = QTextEdit()\n        self.prompt_text_edit.setPlainText(prompt_content)\n        self.prompt_text_edit.setReadOnly(True)\n        # 约 4 行高度（按当前字体动态计算），避免提示词区域过高挤压其它信息\n        try:\n            line_height = self.prompt_text_edit.fontMetrics().lineSpacing()\n            target_lines = 4\n            vertical_padding = 16  # 与全局 QTextEdit padding (8*2) 对齐\n            border = 2  # 1px*2\n            height = line_height * target_lines + vertical_padding + border\n            self.prompt_text_edit.setFixedHeight(max(72, int(height)))\n        except Exception:\n            self.prompt_text_edit.setMaximumHeight(96)\n            self.prompt_text_edit.setMinimumHeight(96)\n        unified_style_system.apply_to_widget(self.prompt_text_edit)\n        # 应用与 _update_theme 一致的额外样式\n        colors = unified_style_system.get_colors()\n        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card')\n        text_color = colors.get('text') or colors.get('palette.text.primary')\n        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        brand = colors.get('palette.brand.main') or colors.get('primary')\n        self.prompt_text_edit.setStyleSheet(f\"\"\"\n            QTextEdit {{\n                background-color: {bg_input};\n                color: {text_color};\n                border: 1px solid {border_subtle};\n                border-radius: 8px;\n                padding: 8px;\n            }}\n            QTextEdit:focus {{\n                border-color: {brand};\n            }}\n        \"\"\")\n        params_layout.addWidget(self.prompt_text_edit)\n        \n        # 复制提示词按钮（使用统一的 SecondaryButton 样式）\n        self.copy_prompt_btn = QPushButton(\"复制提示词\")\n        self.copy_prompt_btn.setObjectName(\"SecondaryButton\")\n        self.copy_prompt_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n        self.copy_prompt_btn.clicked.connect(self.copy_prompt)\n        params_layout.addWidget(self.copy_prompt_btn)\n        \n        # 详细信息 - 保存标签引用以便后续更新\n        self.param_labels = {}  # 存储参数值标签的引用\n\n        # 从 parameters 中获取参数（兼容顶级字段）\n        params = self.video_data.get('parameters', {}) or {}\n        duration = params.get('duration') or self.video_data.get('duration', '未知')\n        file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n\n        info_items = [\n            (\"分辨率\", build_resolution_text(self.video_data)),\n            (\"时长\", f\"{duration}秒\"),\n            (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n            (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n            (\"文件大小\", self.format_file_size(file_size)),\n            (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n        ]\n        \n        for label, value in info_items:\n            label_widget = QLabel(f\"<b>{label}:</b>\")\n            label_widget.setStyleSheet(\"margin: 0px; padding: 2px 0px;\")\n            unified_style_system.apply_to_widget(label_widget)\n            params_layout.addWidget(label_widget)\n            \n            # Use QLineEdit for better copy interaction\n            from PySide6.QtWidgets import QLineEdit\n            value_label = QLineEdit(str(value))\n            value_label.setReadOnly(True)\n            value_label.setCursorPosition(0)\n            value_label.setCursorPosition(0)\n            # Style is now handled in _update_theme\n            unified_style_system.apply_to_widget(value_label)\n            params_layout.addWidget(value_label)\n            \n            # 保存参数值标签引用，用于后续更新\n            self.param_value_labels[label] = value_label\n        \n        right_layout.addWidget(params_widget)\n        \n        # 控制按钮\n        button_layout = QHBoxLayout()\n\n        self.fullscreen_btn = QPushButton(\"全屏 (F11)\")\n        self.fullscreen_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.fullscreen_btn)\n        self.fullscreen_btn.clicked.connect(self.toggle_fullscreen)\n        button_layout.addWidget(self.fullscreen_btn)\n\n        self.download_btn = QPushButton(\"下载视频\")\n        self.download_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.download_btn)\n        self.download_btn.clicked.connect(self.download_video)\n        button_layout.addWidget(self.download_btn)\n\n        self.delete_btn = QPushButton(\"删除记录\")\n        self.delete_btn.setMaximumHeight(30)\n        unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        self.delete_btn.clicked.connect(self._delete_current_record)\n        button_layout.addWidget(self.delete_btn)\n\n        right_layout.addLayout(button_layout)\n\n        self.close_btn = QPushButton(\"关闭（ESC）\")\n        unified_style_system.apply_to_widget(self.close_btn)\n        self.close_btn.clicked.connect(self.accept)\n        right_layout.addWidget(self.close_btn)\n        \n        # 设置布局比例：左侧70%，右侧30%\n        layout.addWidget(left_widget, 7)\n        layout.addLayout(right_layout, 3)\n        \n        # 添加键盘快捷键\n        self.setup_shortcuts()\n\n        # 延迟设置焦点，确保窗口完全初始化后获得焦点\n        self._focus_timer.start(100)\n        self._esc_shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n        self._esc_shortcut.activated.connect(self.handle_escape_key)\n        \n        # Apply initial theme\n        self._update_theme()\n        \n        # 信号已在setup_ui开头连接，不重复连接\n    \n    def closeEvent(self, event):\n        \"\"\"窗口关闭事件，确保停止播放并释放资源\"\"\"\n        # 0. 阻止对话框继续接收事件\n        self.setEnabled(False)\n        \n        # 1. 停止焦点定时器\n        if hasattr(self, '_focus_timer') and self._focus_timer.isActive():\n            self._focus_timer.stop()\n        \n        # 2. 清理参考图画廊\n        if hasattr(self, 'reference_gallery') and self.reference_gallery is not None:\n            try:\n                self.reference_gallery.clear()\n            except Exception as e:\n                logger.warning(f\"[CLEANUP] 清理参考图画廊时出错: {e}\")\n        \n        # 3. 解绑并停止全局视频管理器\n        if hasattr(self, '_video_manager') and self._video_manager is not None:\n            try:\n                # 解绑对话框（取消独占绑定）\n                self._video_manager.unbind_dialog(self)\n                \n                # 停止播放并断开视频输出\n                self._video_manager.stop()\n                \n            except Exception as e:\n                logger.warning(f\"[CLEANUP] 停止全局视频管理器时出错: {e}\")\n\n        # 4. 兼容旧字段：若存在本地 media_player 也停止\n        if hasattr(self, 'media_player') and self.media_player:\n            try:\n                self.media_player.stop()\n            except Exception:\n                pass\n\n        # 5. 清理导出控制器\n        try:\n            self._export_controller.dispose()\n        except Exception:\n            pass\n        \n        self.is_playing = False\n        super().closeEvent(event)\n    \n    def load_thumbnail(self):\n        \"\"\"加载视频缩略图\"\"\"\n        import os  # 将os导入移到函数开头\n        try:\n            logger.debug(\"开始加载缩略图...\")\n            logger.debug(f\"视频数据: {self.video_data}\")\n            \n            # 获取缩略图路径\n            thumbnail_path = self.video_data.get('thumbnail_local_path', '')\n            logger.debug(f\"从video_data获取的thumbnail_local_path: {thumbnail_path}\")\n            \n            if thumbnail_path and os.path.exists(thumbnail_path):\n                logger.debug(f\"找到现有缩略图文件: {thumbnail_path}\")\n                # 使用现有缩略图\n                pixmap = QPixmap(thumbnail_path)\n                logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n            else:\n                logger.debug(\"缩略图文件不存在或路径为空，开始生成缩略图...\")\n                # 生成缩略图\n                video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n                logger.debug(f\"视频文件路径: {video_path}\")\n                \n                if video_path and os.path.exists(video_path):\n                    logger.debug(\"视频文件存在，开始生成缩略图...\")\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    from config_api import get_storage_dir\n                    storage_dir = get_storage_dir()\n                    thumbnails_dir = os.path.join(storage_dir, 'thumbnails')\n                    logger.debug(f\"缩略图目录: {thumbnails_dir}\")\n                    \n                    generator = VideoThumbnailGenerator(thumbnails_dir)\n                    video_id = self.video_data.get('id', os.path.basename(video_path).split('.')[0])\n                    logger.debug(f\"视频ID: {video_id}\")\n                    \n                    thumbnail_path = generator.generate_thumbnail_for_video(video_path, video_id)\n                    logger.debug(f\"生成的缩略图路径: {thumbnail_path}\")\n                    \n                    if thumbnail_path and os.path.exists(thumbnail_path):\n                        logger.debug(\"缩略图生成成功，加载到QPixmap...\")\n                        pixmap = QPixmap(thumbnail_path)\n                        logger.debug(f\"QPixmap加载结果: isNull={pixmap.isNull()}, size={pixmap.size()}\")\n                    else:\n                        logger.debug(\"缩略图生成失败，使用默认图片\")\n                        # 使用默认图片\n                        pixmap = self.create_default_thumbnail()\n                else:\n                    logger.debug(\"视频文件不存在，使用默认图片\")\n                    pixmap = self.create_default_thumbnail()\n            \n            if not pixmap.isNull():\n                logger.debug(\"开始缩放图片...\")\n                # 缩放图片以适应标签大小\n                label_size = self.thumbnail_label.size()\n                logger.debug(f\"标签大小: {label_size}\")\n                \n                scaled_pixmap = pixmap.scaled(\n                    label_size,\n                    Qt.KeepAspectRatio,\n                    Qt.SmoothTransformation\n                )\n                logger.debug(f\"缩放后图片大小: {scaled_pixmap.size()}\")\n                \n                self.thumbnail_label.setPixmap(scaled_pixmap)\n                logger.debug(\"缩略图设置成功\")\n            else:\n                logger.debug(\"QPixmap为空，显示错误文本\")\n                self.thumbnail_label.setText(\"无法加载缩略图\")\n                \n        except Exception as e:\n            logger.debug(f\"加载缩略图异常: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.thumbnail_label.setText(\"缩略图加载失败\")\n    \n    def create_default_thumbnail(self):\n        \"\"\"创建默认缩略图\"\"\"\n        pixmap = QPixmap(400, 300)\n        pixmap.fill(Qt.black)\n        \n        from PySide6.QtGui import QPainter, QFont\n        painter = QPainter(pixmap)\n        painter.setPen(Qt.white)\n        painter.setFont(QFont())  # Font configuration handled by unified style system\n        painter.drawText(pixmap.rect(), Qt.AlignCenter, \"视频预览\")\n        painter.end()\n        \n        return pixmap\n    \n    def on_thumbnail_click(self, event):\n        \"\"\"缩略图点击事件\"\"\"\n        self.start_video_playback()\n    \n    def start_video_playback(self):\n        \"\"\"开始视频播放\"\"\"\n        logger.debug(\"[UI] 开始视频播放…\")\n        \n        # 检查视频文件\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        \n        if not video_path or not os.path.exists(video_path):\n            logger.warning(f\"[UI] 视频文件不存在: {video_path}\")\n            from PySide6.QtWidgets import QMessageBox\n            QMessageBox.critical(self, \"错误\", \"视频文件不存在\")\n            return\n        \n        # 切换到视频播放器\n        self.video_stack.setCurrentIndex(1)\n        self.is_playing = True\n        \n        # 使用全局视频管理器播放\n        self._video_manager.play(video_path, self.video_widget)\n        logger.debug(\"[UI] 开始播放视频\")\n    \n    def toggle_play_pause(self):\n        \"\"\"切换播放/暂停\"\"\"\n        if not self.is_playing:\n            self.start_video_playback()\n        else:\n            self._video_manager.toggle_play_pause()\n    \n    def on_state_changed(self, state):\n        \"\"\"播放状态改变\"\"\"\n        if state == QMediaPlayer.PlaybackState.PlayingState:\n            self.play_button.setText(\"⏸\")\n        else:\n            self.play_button.setText(\"▶\")\n    \n    def on_position_changed(self, position):\n        \"\"\"播放位置改变\"\"\"\n        if hasattr(self, 'media_player'):\n            duration = self.media_player.duration()\n            if duration > 0:\n                current_time = self.format_duration(position)\n                total_time = self.format_duration(duration)\n                self.progress_label.setText(f\"{current_time} / {total_time}\")\n    \n    def on_duration_changed(self, duration):\n        \"\"\"视频时长改变\"\"\"\n        if duration > 0:\n            total_time = self.format_duration(duration)\n            self.progress_label.setText(f\"00:00 / {total_time}\")\n    \n    def on_media_error(self, error, error_string):\n        \"\"\"媒体播放错误处理\"\"\"\n        logger.error(f\"[MEDIA] 播放错误: {error}, 信息: {error_string}\")\n        \n        from PySide6.QtWidgets import QMessageBox\n        msg_box = QMessageBox(self)\n        msg_box.setIcon(QMessageBox.Critical)\n        msg_box.setText(\"视频播放错误\")\n        msg_box.setInformativeText(f\"无法播放视频: {error_string}\")\n        msg_box.exec()\n        \n        # 返回缩略图模式\n        self.video_stack.setCurrentIndex(0)\n        self.is_playing = False\n    \n    def on_media_status_changed(self, status):\n        \"\"\"媒体状态改变\"\"\"\n        from PySide6.QtMultimedia import QMediaPlayer\n        \n        logger.debug(f\"[MEDIA] 状态改变: {status}\")\n        \n        if status == QMediaPlayer.MediaStatus.EndOfMedia:\n            # 视频播放结束，返回缩略图模式\n            logger.debug(\"[MEDIA] 播放结束，切回缩略图模式\")\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n            if hasattr(self, 'media_player'):\n                self.media_player.setPosition(0)  # 重置播放位置\n            self.progress_label.setText(\"00:00 / 00:00\")\n        elif status == QMediaPlayer.MediaStatus.InvalidMedia:\n            logger.warning(\"[MEDIA] 媒体文件无效\")\n        elif status == QMediaPlayer.MediaStatus.BufferedMedia:\n            logger.debug(\"[MEDIA] 媒体缓冲完成\")\n        elif status == QMediaPlayer.MediaStatus.LoadingMedia:\n            logger.debug(\"[MEDIA] 正在加载媒体\")\n        elif status == QMediaPlayer.MediaStatus.StalledMedia:\n            logger.debug(\"[MEDIA] 播放卡顿\")\n    \n    def format_duration(self, ms):\n        \"\"\"格式化时长显示\"\"\"\n        seconds = ms // 1000\n        minutes = seconds // 60\n        seconds = seconds % 60\n        return f\"{minutes:02d}:{seconds:02d}\"\n    \n    # OpenCV playback methods removed - using QtMultimedia exclusively\n\n    \n    def format_time(self, time_str: str) -> str:\n        \"\"\"格式化时间显示\"\"\"\n        if not time_str:\n            return '未知时间'\n        try:\n            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n            return dt.strftime('%Y-%m-%d %H:%M:%S')\n        except:\n            return time_str[:19] if len(time_str) > 19 else time_str\n    \n    def format_file_size(self, size) -> str:\n        \"\"\"格式化文件大小显示\"\"\"\n        try:\n            size = float(size) if size else 0\n        except (ValueError, TypeError):\n            return '未知大小'\n            \n        if size == 0:\n            return '未知大小'\n        \n        for unit in ['B', 'KB', 'MB', 'GB']:\n            if size < 1024.0:\n                return f\"{size:.1f} {unit}\"\n            size /= 1024.0\n        return f\"{size:.1f} TB\"\n    \n    def setup_shortcuts(self):\n        \"\"\"设置键盘快捷键\"\"\"\n        # 移除所有QShortcut，统一使用keyPressEvent处理\n        # 避免快捷键冲突问题\n        pass\n    \n    def _ensure_focus(self):\n        \"\"\"确保窗口获得焦点\"\"\"\n        self.activateWindow()\n        self.raise_()\n        self.setFocus()\n        logger.debug(f\"[FOCUS] VideoDialog窗口焦点设置完成，hasFocus: {self.hasFocus()}\")\n    \n    def keyPressEvent(self, event):\n        \"\"\"键盘事件处理\"\"\"\n        from PySide6.QtCore import Qt\n        \n        logger.debug(f\"[KEYBOARD] VideoDetailDialog键盘事件: {event.key()}\")\n        \n        if event.key() == Qt.Key_Left:\n            # 左方向键：上一个视频\n            logger.debug(f\"[KEYBOARD] 左键pressed，prev_btn enabled: {self.prev_btn.isEnabled()}\")\n            if self.prev_btn.isEnabled():\n                self.show_previous_video()\n            event.accept()\n        elif event.key() == Qt.Key_Right:\n            # 右方向键：下一个视频\n            logger.debug(f\"[KEYBOARD] 右键pressed，next_btn enabled: {self.next_btn.isEnabled()}\")\n            if self.next_btn.isEnabled():\n                self.show_next_video()\n            event.accept()\n        elif event.key() == Qt.Key_Escape:\n            # ESC键：关闭对话框（保持原有功能）\n            logger.debug(f\"[KEYBOARD] ESC键pressed，fullscreen: {self.is_fullscreen}\")\n            if self.is_fullscreen:\n                self.exit_fullscreen()\n            else:\n                self.accept()\n            event.accept()\n        elif event.key() == Qt.Key_F11:\n            # F11键：全屏切换（保持原有功能）\n            self.toggle_fullscreen()\n            event.accept()\n        elif event.key() == Qt.Key_Space:\n            # 空格键：播放/暂停\n            self.toggle_play_pause()\n            event.accept()\n        else:\n            # 其他按键交给父类处理\n            super().keyPressEvent(event)\n    \n    def toggle_fullscreen(self):\n        \"\"\"切换全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.enter_fullscreen()\n    \n    def enter_fullscreen(self):\n        \"\"\"进入全屏模式\"\"\"\n        if not self.is_fullscreen:\n            self.original_geometry = self.geometry()\n            self.showFullScreen()\n            self.is_fullscreen = True\n    \n    def exit_fullscreen(self):\n        \"\"\"退出全屏模式\"\"\"\n        if self.is_fullscreen:\n            self.showNormal()\n            if self.original_geometry:\n                self.setGeometry(self.original_geometry)\n            self.is_fullscreen = False\n    \n    def handle_escape_key(self):\n        \"\"\"处理ESC键\"\"\"\n        if self.is_fullscreen:\n            self.exit_fullscreen()\n        else:\n            self.accept()\n    \n    def copy_prompt(self):\n        \"\"\"复制提示词到剪贴板\"\"\"\n        prompt_content = self.prompt_text_edit.toPlainText()\n        clipboard = QApplication.clipboard()\n        clipboard.setText(prompt_content)\n        self.show_copy_toast(\"提示词已复制到剪贴板\")\n    \n    def show_copy_toast(self, message: str):\n        \"\"\"显示复制成功的轻量提示\"\"\"\n        toast = QLabel(message, self)\n        toast.setObjectName(\"ToastLabel\")\n        toast.setAlignment(Qt.AlignCenter)\n        toast.adjustSize()\n        \n        x = (self.width() - toast.width()) // 2\n        y = self.height() // 4\n        toast.move(x, y)\n        toast.show()\n        \n        QTimer.singleShot(2000, toast.deleteLater)\n\n    def _on_reference_clicked(self, asset: Dict[str, Any]):\n        assets = list(self._reference_assets) if self._reference_assets else [asset]\n        start_idx = _find_reference_asset_index(assets, asset)\n        open_reference_preview(\n            self,\n            asset,\n            title_prefix=\"参考图\",\n            asset_list=assets,\n            start_index=start_idx,\n            on_asset_changed=self._sync_reference_selection,\n        )\n\n    def _on_reference_export(self, asset: Dict[str, Any]):\n        export_reference_asset(self, asset)\n\n    def _on_reference_selection_changed(self, asset: Dict[str, Any]):\n        asset_path = None\n        if isinstance(asset, dict):\n            asset_path = asset.get('absolute_path') or asset.get('path')\n        has_path = bool(asset_path and os.path.exists(asset_path))\n        if hasattr(self, 'reference_export_btn'):\n            self.reference_export_btn.setEnabled(has_path)\n\n    def _export_selected_reference(self):\n        asset = self.reference_gallery.current_asset() if hasattr(self, 'reference_gallery') else None\n        if not asset:\n            QMessageBox.information(self, \"导出参考图\", \"请先选择参考图\")\n            return\n        export_reference_asset(self, asset)\n\n    def _refresh_reference_gallery(self):\n        if not hasattr(self, 'reference_gallery'):\n            return\n        self._reference_summary = ensure_reference_info(self.video_data)\n        if self._reference_summary.get('count', 0) <= 0:\n            self.reference_gallery.setVisible(False)\n            self.reference_gallery.clear()\n            if hasattr(self, 'reference_export_btn'):\n                self.reference_export_btn.setEnabled(False)\n            self._reference_assets = []\n            self._export_controller.refresh()\n            return\n        try:\n            self._reference_assets = resolve_reference_assets(self.video_data, absolute=True)\n        except Exception:\n            self._reference_assets = []\n        self.reference_gallery.set_assets(self._reference_assets)\n        self.reference_gallery.setVisible(True)\n        self._on_reference_selection_changed(self.reference_gallery.current_asset())\n        self._export_controller.refresh()\n\n    def _sync_reference_selection(self, asset: Dict[str, Any]):\n        try:\n            self.reference_gallery.select_asset(asset)\n        except Exception:\n            pass\n\n    def _resolve_video_record_id(self) -> Optional[str]:\n        for key in (\"file_id\", \"id\", \"generation_id\"):\n            value = self.video_data.get(key)\n            if value not in (None, \"\"):\n                return str(value)\n        return None\n\n    def _delete_current_record(self):\n        \"\"\"删除当前视频记录及相关文件\"\"\"\n        record_id = self._resolve_video_record_id()\n        if not record_id:\n            self.show_copy_toast(\"无法获取记录ID\")\n            return\n        \n        try:\n            # 停止当前播放\n            if hasattr(self, 'media_player'):\n                self.media_player.stop()\n            \n            # 获取 RepositoryManager\n            from config_api import get_storage_dir\n            from modules.repository.manager import RepositoryManager\n            \n            storage_dir = get_storage_dir()\n            repo = RepositoryManager(storage_dir)\n            \n            # 执行删除\n            if repo.delete_record_with_files(record_id):\n                self.show_copy_toast(\"记录已删除\")\n                \n                # 发出信号通知父视图刷新\n                self.recordDeleted.emit(record_id)\n                \n                # 从列表中移除当前记录\n                if len(self.video_list) > 1:\n                    del self.video_list[self.current_index]\n                    \n                    # 导航到后一条记录（保持索引，指向原来的下一条）\n                    # 只有当删除的是最后一条时，才需要调整索引\n                    if self.current_index >= len(self.video_list):\n                        self.current_index = len(self.video_list) - 1\n                    \n                    # 更新 video_data 到新的当前记录\n                    self.video_data = self.video_list[self.current_index]\n                    self.load_video()\n                    self.update_navigation_buttons()\n                else:\n                    # 只剩一条记录，关闭对话框\n                    self.accept()\n            else:\n                self.show_copy_toast(\"删除失败\")\n        except Exception as e:\n            from utils.logger import logger\n            logger.error(f\"删除视频记录异常: {e}\")\n            self.show_copy_toast(f\"删除失败: {str(e)}\")\n\n    def download_video(self):\n        \"\"\"下载视频到指定位置\"\"\"\n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if not video_path or not os.path.exists(video_path):\n            self.show_styled_message(\"错误\", \"视频文件不存在\", \"warning\")\n            return\n        \n        file_dialog = QFileDialog()\n        save_path, _ = file_dialog.getSaveFileName(\n            self,\n            \"保存视频\",\n            f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4\",\n            \"视频文件 (*.mp4)\"\n        )\n        \n        if save_path:\n            try:\n                import shutil\n                shutil.copy2(video_path, save_path)\n                self.show_copy_toast(f\"视频已保存到: {os.path.basename(save_path)}\")\n            except Exception as e:\n                self.show_styled_message(\"错误\", f\"保存视频失败: {str(e)}\", \"critical\")\n    \n    def update_navigation_buttons(self):\n        \"\"\"更新导航按钮状态（基于有效记录检查）\"\"\"\n        logger.debug(f\"[NAV] 更新导航按钮：当前索引{self.current_index}，总记录数{len(self.video_list)}\")\n        \n        has_prev = self._has_valid_previous_record()\n        has_next = self._has_valid_next_record()\n        \n        logger.debug(f\"[NAV] 有效记录检查：prev={has_prev}, next={has_next}\")\n        \n        self.prev_btn.setEnabled(has_prev)\n        self.next_btn.setEnabled(has_next)\n    \n    def _has_valid_previous_record(self):\n        \"\"\"检查是否有有效的上一个记录\"\"\"\n        logger.debug(f\"[NAV] 检查上一个记录：从索引{self.current_index - 1}到0\")\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            content_type = candidate_data.get('content_type', '')\n            \n            # 检查文件扩展名，确保是视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                logger.debug(f\"[NAV] 找到有效的上一个视频记录：索引{i}\")\n                return True\n        logger.debug(f\"[NAV] 没有找到有效的上一个视频记录\")\n        return False\n    \n    def _has_valid_next_record(self):\n        \"\"\"检查是否有有效的下一个记录\"\"\"\n        logger.debug(f\"[NAV] 检查下一个记录：从索引{self.current_index + 1}到{len(self.video_list) - 1}\")\n        for i in range(self.current_index + 1, len(self.video_list)):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            content_type = candidate_data.get('content_type', '')\n            \n            # 检查文件扩展名，确保是视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            logger.debug(f\"[NAV] 检查索引{i}: file_path={file_path}, content_type={content_type}, is_video={is_video}, exists={os.path.exists(file_path) if file_path else False}\")\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                logger.debug(f\"[NAV] 找到有效的下一个视频记录：索引{i}\")\n                return True\n        logger.debug(f\"[NAV] 没有找到有效的下一个视频记录\")\n        return False\n    \n    def show_previous_video(self):\n        \"\"\"显示上一个视频（带有效性验证）\"\"\"\n        # 寻找上一个有效视频记录\n        for i in range(self.current_index - 1, -1, -1):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            # 检查是否为视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                # 找到有效视频记录\n                logger.debug(f\"[NAV] 切换到上一个视频：索引{i}\")\n                self.current_index = i\n                self.video_data = self.video_list[i]\n                self.load_video()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的上一个视频记录，保持当前状态\n        logger.debug(f\"[NAV] 没有上一个视频可切换\")\n        self.update_navigation_buttons()\n    \n    def show_next_video(self):\n        \"\"\"显示下一个视频（带有效性验证）\"\"\"\n        # 寻找下一个有效视频记录\n        for i in range(self.current_index + 1, len(self.video_list)):\n            candidate_data = self.video_list[i]\n            file_path = candidate_data.get('absolute_path', '') or candidate_data.get('file_path', '')\n            \n            # 检查是否为视频文件\n            is_video = False\n            if file_path:\n                from pathlib import Path\n                file_ext = Path(file_path).suffix.lower()\n                is_video = file_ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']\n            \n            if file_path and os.path.exists(file_path) and is_video:\n                # 找到有效视频记录\n                logger.debug(f\"[NAV] 切换到下一个视频：索引{i}\")\n                self.current_index = i\n                self.video_data = self.video_list[i]\n                self.load_video()\n                self.update_navigation_buttons()\n                return\n        \n        # 没有找到有效的下一个视频记录，保持当前状态\n        logger.debug(f\"[NAV] 没有下一个视频可切换\")\n        self.update_navigation_buttons()\n    \n    def load_video(self):\n        \"\"\"加载新视频\"\"\"\n        logger.debug(\"[UI] 加载新视频…\")\n        \n        # 停止当前播放器\n        if hasattr(self, 'media_player') and self.media_player:\n            self.media_player.stop()\n        \n        video_path = self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n        if video_path and os.path.exists(video_path):\n            from PySide6.QtCore import QUrl\n            if hasattr(self, 'media_player') and self.media_player:\n                self.media_player.setSource(QUrl.fromLocalFile(video_path))\n            \n            # 重置到缩略图模式\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n            \n            # 重新加载缩略图\n            self.load_thumbnail()\n            \n            # 更新右侧信息\n            prompt_content = self.video_data.get('prompt', '无提示词')\n            self.prompt_text_edit.setPlainText(prompt_content)\n            \n            # 更新参数信息\n            self.update_video_params()\n            \n            logger.debug(\"[UI] 新视频加载完成\")\n        else:\n            self.video_stack.setCurrentIndex(0)\n            self.is_playing = False\n\n        self._refresh_reference_gallery()\n        self._export_controller.refresh()\n    \n    def _update_theme(self):\n        \"\"\"响应主题变化\"\"\"\n        colors = unified_style_system.get_colors()\n        \n        # Apply theme to self (Dialog)\n        # Note: In some OS/Qt versions, QDialog styling needs explicit background\n        bg_color = colors.get('palette.neutral.bg_surface') or colors.get('palette.neutral.bg_app') or colors.get('background')\n        text_color = colors.get('text') or colors.get('palette.text.primary')\n        bg_card = colors.get('palette.neutral.bg_card') or colors.get('surface') or bg_color\n        bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or bg_card\n        border_subtle = colors.get('palette.neutral.border_subtle') or colors.get('border')\n        brand = colors.get('palette.brand.main') or colors.get('primary') or text_color\n        \n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {bg_color};\n                color: {text_color};\n            }}\n            QLabel {{\n                color: {text_color};\n            }}\n            QWidget#ParamsWidget {{\n                 background-color: {bg_card};\n                 border-left: 1px solid {border_subtle};\n            }}\n        \"\"\")\n        \n        # Update specific controls directly\n        if hasattr(self, 'prompt_text_edit'):\n             self.prompt_text_edit.setStyleSheet(f\"\"\"\n                QTextEdit {{\n                    background-color: {bg_input};\n                    color: {text_color};\n                    border: 1px solid {border_subtle};\n                    border-radius: 8px;\n                    padding: 8px;\n                }}\n                QTextEdit:focus {{\n                    border-color: {brand};\n                }}\n             \"\"\")\n\n        # Manually update param labels that were stored\n        if hasattr(self, 'param_value_labels'):\n            for label, value_label in self.param_value_labels.items():\n                value_label.setStyleSheet(f\"\"\"\n                    QLineEdit {{\n                        background-color: {bg_input};\n                        color: {text_color};\n                        border: 1px solid {border_subtle};\n                        padding: 4px;\n                        border-radius: 8px;\n                    }}\n                    QLineEdit:focus {{\n                        border-color: {brand};\n                    }}\n                \"\"\")\n\n        # Update thumbnail background if visible\n        if hasattr(self, 'thumbnail_label'):\n             player_bg = colors.get('palette.component.player_bg') or bg_color\n             self.thumbnail_label.setStyleSheet(f\"\"\"\n                QLabel {{\n                    border: none;\n                    background-color: {player_bg};\n                    color: {text_color};\n                }}\n             \"\"\")\n\n        # Reapply button styles\n        if hasattr(self, 'fullscreen_btn'):\n            unified_style_system.apply_to_widget(self.fullscreen_btn)\n        if hasattr(self, 'download_btn'):\n            unified_style_system.apply_to_widget(self.download_btn)\n        if hasattr(self, 'delete_btn'):\n            unified_style_system.apply_to_widget(self.delete_btn, extra={'variant': 'danger'})\n        if hasattr(self, 'close_btn'):\n            unified_style_system.apply_to_widget(self.close_btn)\n        if hasattr(self, 'reference_export_btn'):\n            unified_style_system.apply_to_widget(self.reference_export_btn)\n        if hasattr(self, 'export_bundle_btn'):\n            unified_style_system.apply_to_widget(self.export_bundle_btn)\n        if hasattr(self, 'play_button'):\n            unified_style_system.apply_to_widget(self.play_button)\n        if hasattr(self, 'prev_btn'):\n            unified_style_system.apply_to_widget(self.prev_btn)\n        if hasattr(self, 'next_btn'):\n            unified_style_system.apply_to_widget(self.next_btn)\n\n    def update_video_params(self):\n        \"\"\"更新视频参数显示（切换视频时调用）\"\"\"\n        try:\n            # 解析生成参数\n            params = self.video_data.get('parameters', '{}')\n            if isinstance(params, str):\n                try:\n                    params = json.loads(params)\n                except:\n                    params = {}\n\n            # 从 parameters 中获取参数（兼容顶级字段）\n            duration = params.get('duration') or self.video_data.get('duration', '未知')\n            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n\n            # 重新构建参数信息\n            info_items = [\n                (\"分辨率\", build_resolution_text(self.video_data)),\n                (\"时长\", f\"{duration}秒\"),\n                (\"模型\", get_model_display_name(pick_model_code(self.video_data))),\n                (\"生成时间\", self.format_time(self.video_data.get('created_at', ''))),\n                (\"文件大小\", self.format_file_size(file_size)),\n                (\"文件路径\", self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')),\n            ]\n            \n            # 更新已保存的标签\n            for label, new_value in info_items:\n                if label in self.param_value_labels:\n                    self.param_value_labels[label].setText(str(new_value))\n            \n            logger.debug(\"视频参数已更新\")\n            \n        except Exception as e:\n            logger.error(f\"更新视频参数失败: {e}\")\n    \n    def update_param_labels(self):\n        \"\"\"更新参数标签内容\"\"\"\n        try:\n            # 从 parameters 中获取参数（兼容顶级字段）\n            params = self.video_data.get('parameters', {}) or {}\n            duration = params.get('duration') or self.video_data.get('duration', '未知')\n            file_size = params.get('file_size') or self.video_data.get('file_size', 0)\n\n            # 更新各个参数标签\n            param_updates = {\n                \"分辨率\": build_resolution_text(self.video_data),\n                \"时长\": f\"{duration}秒\",\n                \"模型\": get_model_display_name(pick_model_code(self.video_data)),\n                \"生成时间\": self.format_time(self.video_data.get('created_at', '')),\n                \"文件大小\": self.format_file_size(file_size),\n                \"文件路径\": self.video_data.get('absolute_path', '') or self.video_data.get('file_path', '')\n            }\n            \n            for param_name, new_value in param_updates.items():\n                if param_name in self.param_labels:\n                    self.param_labels[param_name].setText(str(new_value))\n                    logger.debug(f\"已更新参数 {param_name}: {new_value}\")\n            \n            logger.debug(\"视频参数标签更新完成\")\n        except Exception as e:\n            logger.error(f\"更新视频参数标签失败: {e}\")\n    \n    def show_styled_message(self, title: str, message: str, icon_type: str = \"information\"):\n        \"\"\"显示带有深色主题样式的消息框\"\"\"\n        from PySide6.QtWidgets import QMessageBox\n        \n        msg_box = QMessageBox(self)\n        msg_box.setWindowTitle(title)\n        msg_box.setText(message)\n        \n        # 设置图标\n        if icon_type == \"warning\":\n            msg_box.setIcon(QMessageBox.Warning)\n        elif icon_type == \"critical\":\n            msg_box.setIcon(QMessageBox.Critical)\n        elif icon_type == \"question\":\n            msg_box.setIcon(QMessageBox.Question)\n        else:\n            msg_box.setIcon(QMessageBox.Information)\n        \n        # 样式由全局QSS控制\n        \n        msg_box.exec()\n","numLines":1332,"startLine":1,"totalLines":1332}}}
{"parentUuid":"a580bee7-b800-415e-8bee-56f8d8f50d7c","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Te7yYF69ARJ6Fjzd9Ej5Jx","type":"message","role":"assistant","content":[{"type":"text","text":"现在我来详细对比这两个文件的参数区域实现。让我先分析关键差异点："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":37152,"cache_read_input_tokens":20837,"cache_creation":{"ephemeral_5m_input_tokens":37152,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"bae29f18-c1f4-4fb0-a947-2c37fb588da1","timestamp":"2025-12-22T04:32:28.652Z"}
{"parentUuid":"bae29f18-c1f4-4fb0-a947-2c37fb588da1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Te7yYF69ARJ6Fjzd9Ej5Jx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0179TfD5DbHk2MVsxAdXkVyP","name":"Grep","input":{"pattern":"def setup_params_area|def _clear_params_layout|def _update_theme|def update_params_area|def update_video_params","path":"/Users/yunchang/Documents/GitHub/gemeng2/components/dialogs","output_mode":"content","type":"py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":37152,"cache_read_input_tokens":20837,"cache_creation":{"ephemeral_5m_input_tokens":37152,"ephemeral_1h_input_tokens":0},"output_tokens":189,"service_tier":"standard"}},"type":"assistant","uuid":"ce4bb090-1215-4c78-b7af-dac0433e1c1f","timestamp":"2025-12-22T04:32:29.709Z"}
{"parentUuid":"ce4bb090-1215-4c78-b7af-dac0433e1c1f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0179TfD5DbHk2MVsxAdXkVyP","type":"tool_result","content":"components/dialogs/video_detail_dialog.py:1160:    def _update_theme(self):\ncomponents/dialogs/video_detail_dialog.py:1249:    def update_video_params(self):\ncomponents/dialogs/image_detail_dialog.py:672:    def setup_params_area(self):\ncomponents/dialogs/image_detail_dialog.py:742:    def _clear_params_layout(self):\ncomponents/dialogs/image_detail_dialog.py:754:    def _update_theme(self):\ncomponents/dialogs/image_detail_dialog.py:908:    def update_params_area(self):"}]},"uuid":"94607e53-c73d-4de8-aed5-e24f00e2998f","timestamp":"2025-12-22T04:32:30.053Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"components/dialogs/video_detail_dialog.py:1160:    def _update_theme(self):\ncomponents/dialogs/video_detail_dialog.py:1249:    def update_video_params(self):\ncomponents/dialogs/image_detail_dialog.py:672:    def setup_params_area(self):\ncomponents/dialogs/image_detail_dialog.py:742:    def _clear_params_layout(self):\ncomponents/dialogs/image_detail_dialog.py:754:    def _update_theme(self):\ncomponents/dialogs/image_detail_dialog.py:908:    def update_params_area(self):","numLines":6}}
{"parentUuid":"94607e53-c73d-4de8-aed5-e24f00e2998f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"831827d4-8f64-40eb-a2ca-946ae836d86c","version":"2.0.75","gitBranch":"refactor/ui-v2-linear","agentId":"ad34c7c","slug":"smooth-dazzling-bear","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01G5iw5N8zs7ySTX9dyahgxo","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看一下这两个文件的完整比较，我来创建一份详细的分析报告（虽然是READ-ONLY任务，但我可以分析并直接输出）。\n\n根据我的详细对比分析，这两个文件在参数区域实现上有以下关键差异：\n\n## 详细对比分析\n\n### 1. setup_params_area() vs 初始化策略\n\n**ImageDetailDialog (image_detail_dialog.py)**\n- **第672行**: 有完整的 `setup_params_area()` 方法\n- **特点**:\n  - 调用 `_clear_params_layout()` 清空旧的layout\n  - 创建提示词区域（QTextEdit）\n  - 创建复制按钮（`copy_prompt_btn`）\n  - 调用 `create_param_labels()` 生成参数标签\n  - 包含 `addStretch(1)` 保留垂直空间\n\n**VideoDetailDialog (video_detail_dialog.py)**\n- **第364-465行**: 直接在 `setup_ui()` 中初始化参数区\n- **特点**:\n  - 没有 `setup_params_area()` 方法\n  - 参数区直接内联创建\n  - 使用 `QLineEdit` 而非 `ClickableLabel`\n  - 保存引用在 `self.param_value_labels` 字典中\n  - 没有任何清空机制\n\n---\n\n### 2. _clear_params_layout() 清空策略\n\n**ImageDetailDialog**\n```python\ndef _clear_params_layout(self):\n    \"\"\"清空参数区布局中的所有控件\"\"\"\n    if not hasattr(self, \"params_layout\") or self.params_layout is None:\n        return\n    while self.params_layout.count() > 0:\n        item = self.params_layout.takeAt(0)\n        w = item.widget()\n        if w is not None:\n            w.hide()  # 立即隐藏\n            w.setParent(None)  # 断开父子关系\n            w.deleteLater()\n```\n- 完整的清理流程：hide() → setParent(None) → deleteLater()\n- 解决了\"残留widget遮挡\"问题\n\n**VideoDetailDialog**\n- 完全没有这个方法\n- 这是导致样式可能丢失的根本原因\n\n---\n\n### 3. copy_prompt_btn 的生命周期管理\n\n**ImageDetailDialog**\n- **第731-736行**: 在 `setup_params_area()` 中创建并配置\n- 每次 `_update_theme()` 调用时，通过 `setup_params_area()` 重建整个参数区\n- 确保按钮始终拥有最新的样式\n\n**VideoDetailDialog**\n- **第424-429行**: 仅在 `setup_ui()` 中创建一次\n- `_update_theme()` 中没有重新创建或重新应用样式到按钮\n- 按钮样式可能在主题切换后不更新\n\n---\n\n### 4. 记录切换时的更新逻辑\n\n**ImageDetailDialog (load_current_image)**\n```python\n# 第667行：完整重建参数区\nself.update_params_area()  # 调用 setup_params_area()\n```\n\n**VideoDetailDialog (load_video 和 set_video_data)**\n```python\n# 第1150行：仅更新参数值\nself.update_video_params()  # 仅更新标签文本，不重建\n\n# 第90-91行：\nif hasattr(self, 'update_video_params'):\n    self.update_video_params()\n```\n\n**差异影响**:\n- Image: 每次切换记录时完整重建参数UI，保证样式一致性\n- Video: 仅更新文本值，保留旧的样式对象（可能导致主题不适配）\n\n---\n\n### 5. _update_theme() 中的参数区处理\n\n**ImageDetailDialog (第754-814行)**\n```python\ndef _update_theme(self):\n    # ... 设置Dialog和Label样式 ...\n    \n    # 最后：完整重建参数区\n    self.setup_params_area()  # 关键！\n```\n- 主题切换时**完全重建参数UI**\n- 确保所有新创建的widget都继承最新的主题颜色\n\n**VideoDetailDialog (第1160-1247行)**\n```python\ndef _update_theme(self):\n    # ... 设置Dialog样式 ...\n    \n    # 手动更新已存储的标签样式\n    if hasattr(self, 'param_value_labels'):\n        for label, value_label in self.param_value_labels.items():\n            value_label.setStyleSheet(...)  # 直接修改样式字符串\n    \n    # 没有重建参数区\n    # 没有重建 copy_prompt_btn\n```\n- 仅尝试**更新**已存在的widget样式\n- `copy_prompt_btn` 完全没有处理！\n- QLineEdit的样式更新可能不完全（依赖已有的widget引用）\n\n---\n\n### 6. 参数标签的引用管理\n\n**ImageDetailDialog**\n```python\nself.param_labels = []  # 列表\n\n# 保存为元组对：\nself.param_labels.append((label_widget, value_clickable))\n\n# 清理时逐个移除和删除\n```\n\n**VideoDetailDialog**\n```python\nself.param_value_labels = {}  # 字典\n\n# 保存为 dict：\nself.param_value_labels[label] = value_label\n\n# 清理时仅更新文本，没有删除旧widget\n```\n\n---\n\n### 7. 参数值widget类型\n\n**ImageDetailDialog**\n- 使用自定义 `ClickableLabel` 类\n- 包含点击事件、动态样式、ellipsis等高级功能\n- 每次重建时生成新实例\n\n**VideoDetailDialog**\n- 使用 `QLineEdit`（只读模式）\n- 功能更简单\n- 初始化后基本不变\n\n---\n\n## 核心问题分析\n\n### 为什么Image有样式丢失问题，而Video没有？\n\n**看起来矛盾，但实际上**：\n\n1. **Image的问题根源**：\n   - `_update_theme()` 中调用 `setup_params_area()` 每次都完整重建\n   - `create_param_labels()` 创建很多ClickableLabel widget\n   - 旧widget的清理（`_clear_params_layout()`）可能不彻底\n   - 导致**残留widget遮挡新widget**（特别是文件路径块压住提示词区）\n\n2. **Video没有问题的原因**：\n   - 参数区在 `setup_ui()` 中初始化后**基本不重建**\n   - `update_video_params()` 仅更新文本，不创建新widget\n   - 没有残留widget的问题（因为根本没有重建）\n   - 但缺点是：**主题切换时，某些widget样式可能不完全更新**\n\n---\n\n## 统一设计建议\n\n一个更优雅的设计应该：\n\n### 方案A：采用Image的策略（推荐）\n- 统一使用 `setup_params_area()` 方法\n- 完整的 `_clear_params_layout()` 清理\n- `_update_theme()` 中调用完整重建\n- 优点：样式一致，主题切换完美\n- 缺点：需要确保清理逻辑无遗漏\n\n### 方案B：改进Video的策略（另一选择）\n- 保留初始化后不重建的思路\n- 但在 `_update_theme()` 中**逐个widget手动apply样式**\n- 而不是依赖字符串setStyleSheet()\n- 优点：性能更好，避免重建\n- 缺点：需要追踪所有widget，容易遗漏\n\n### 方案C：混合策略（最实用）\n- 提示词区 + 复制按钮：在 `setup_ui()` 初始化\n- 参数标签：保留不重建，仅更新值\n- `_update_theme()` 中：\n  - `apply_to_widget(prompt_text_edit, copy_prompt_btn)` \n  - 逐个更新 `param_value_labels` 的样式\n\n---\n\n## 关键发现\n\n| 维度 | ImageDetailDialog | VideoDetailDialog |\n|------|------------------|------------------|\n| **参数区初始化方式** | `setup_params_area()` | 内联在 `setup_ui()` |\n| **是否有清空方法** | ✅ `_clear_params_layout()` | ❌ |\n| **主题切换策略** | 完整重建整个参数区 | 仅更新已有widget样式 |\n| **记录切换时** | 完整重建（`setup_params_area()`） | 仅更新文本（`update_video_params()`） |\n| **copy_prompt_btn处理** | 每次重建时重新创建并apply样式 | 仅在setup_ui()创建，_update_theme()中**无处理** |\n| **参数标签类型** | ClickableLabel（自定义） | QLineEdit（原生） |\n| **是否有样式丢失问题** | 有（残留widget遮挡） | 无（因为不重建） |\n| **是否有主题切换遗漏** | 无（完整重建） | 可能（copy_prompt_btn未处理） |\n\n---\n\n## 建议的统一方案\n\n```python\n# 统一的参数区管理模式：\n\nclass DetailDialog:\n    def setup_ui(self):\n        # 1. 创建参数布局\n        self.params_layout = QVBoxLayout(params_widget)\n        \n        # 2. 仅初始化提示词区和复制按钮（不变内容）\n        self._setup_prompt_area()\n        \n        # 3. 延迟初始化参数标签\n        self.param_labels = None\n        \n    def _setup_prompt_area(self):\n        # 提示词区独立初始化\n        # 此部分不变\n        pass\n    \n    def setup_params_area(self):\n        # 清空旧的参数标签\n        if self.param_labels:\n            self._clear_param_labels()\n        \n        # 重建参数标签\n        self._build_param_labels()\n    \n    def _clear_param_labels(self):\n        # 仅清理参数标签，保留提示词区\n        pass\n    \n    def _update_theme(self):\n        # 1. 更新Dialog样式\n        # 2. 更新提示词区样式\n        unified_style_system.apply_to_widget(self.prompt_text_edit)\n        unified_style_system.apply_to_widget(self.copy_prompt_btn)\n        \n        # 3. 重建参数标签（确保新颜色）\n        self.setup_params_area()\n```\n\n这样可以同时获得：\n- Image的**样式一致性**\n- Video的**性能和稳定性**（只重建参数标签，不重建提示词区）"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":394,"cache_read_input_tokens":57989,"cache_creation":{"ephemeral_5m_input_tokens":394,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"type":"assistant","uuid":"d39464d5-0b09-4963-a237-761fed2ba66c","timestamp":"2025-12-22T04:32:58.795Z"}
