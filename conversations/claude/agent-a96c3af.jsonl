{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":"用户报告了视频相关的两个问题：\n\n**问题1：视频水印**\n- 视频模式下水印显示 \"AI 生成\"，而不是本地端 \"pigeon\" 水印\n- 可能是服务端水印没关，或者本地水印没加上\n\n**问题2：视频下载不稳定**\n- 生成了两个视频，有一个任务一直是\"加载中\"状态\n- 重启应用也没下载成功\n- 需要检查下载链路是否正确\n\n请调研：\n1. 视频水印的添加逻辑在哪里？搜索 watermark 相关代码\n2. 视频生成请求时是否有关闭服务端水印的参数？\n3. 视频下载的完整链路：从任务状态检查到下载完成\n4. pending 状态的视频任务恢复机制是什么？\n5. 下载失败时的重试逻辑\n\n重点文件：\n- modules/seedance/ 目录\n- threads/ 目录下的视频相关线程\n- components/modes/video_mode_widget.py 中的下载处理\n\n只做代码调研，不要修改任何代码。"},"uuid":"dc17af7f-f391-45f0-86c0-db3f8e9bb7dc","timestamp":"2025-12-30T09:55:36.912Z"}
{"parentUuid":"dc17af7f-f391-45f0-86c0-db3f8e9bb7dc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XFFsQNB4yFDcTKremH8D5V","type":"message","role":"assistant","content":[{"type":"text","text":"我来为你调研视频相关的两个问题。让我从系统地搜索 watermark 相关代码开始。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21471,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21471,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"05bd0352-8615-4e45-8bd7-660849c428a8","timestamp":"2025-12-30T09:55:40.690Z"}
{"parentUuid":"05bd0352-8615-4e45-8bd7-660849c428a8","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XFFsQNB4yFDcTKremH8D5V","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M2B35GNwYNfABAzUXaq62Q","name":"Grep","input":{"pattern":"watermark|water_mark","path":"/Users/yunchang/Documents/GitHub/gemeng2"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21471,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21471,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"835e6e7f-c3ed-4717-9fd3-e0ecc4c11b8b","timestamp":"2025-12-30T09:55:41.498Z"}
{"parentUuid":"835e6e7f-c3ed-4717-9fd3-e0ecc4c11b8b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XFFsQNB4yFDcTKremH8D5V","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BxdRMVB2M3oqvDdLrJSiKw","name":"Glob","input":{"pattern":"modules/seedance/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21471,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21471,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"1dd5cba4-bad5-4061-9ac4-1743a5cad02f","timestamp":"2025-12-30T09:55:41.538Z"}
{"parentUuid":"1dd5cba4-bad5-4061-9ac4-1743a5cad02f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XFFsQNB4yFDcTKremH8D5V","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018rn9vSkVj6zgki2gxPH2Mq","name":"Glob","input":{"pattern":"threads/**/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21471,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21471,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"956a88af-a6ae-4f35-8ab5-cb9cb710abfb","timestamp":"2025-12-30T09:55:41.551Z"}
{"parentUuid":"956a88af-a6ae-4f35-8ab5-cb9cb710abfb","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XFFsQNB4yFDcTKremH8D5V","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019cN8kN3erGqb6ks2DQZH3e","name":"Glob","input":{"pattern":"components/modes/*video*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21471,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21471,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"type":"assistant","uuid":"3aded711-3d2e-4554-b82d-b78f8741fccd","timestamp":"2025-12-30T09:55:41.757Z"}
{"parentUuid":"3aded711-3d2e-4554-b82d-b78f8741fccd","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M2B35GNwYNfABAzUXaq62Q","type":"tool_result","content":"Found 61 files\ncomponents/widgets/integrated_reference_panel.py\ncomponents/modes/video_mode_widget.py\n.claude/commands/pack.md\npackaging/windows/gemeng_windows_trial.spec\ndocs/design/问题排查与修复方案_20251113.md\ndocs/design/体验版测试指南_20251113.md\ndocs/design/macOS_体验版打包_执行方案_待审批.md\ndocs/api/图片生成API-火山方舟大模型服务平台-火山引擎.md\nservices/video_service.py\nmodules/seedance/manager.py\nmodules/seedance/client.py\nmodules/provider/volc.py\nmodules/provider/schema.py\nconfig_api_example.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/creation_components.py\npackaging/windows/gemeng_windows.spec\nedition/watermark_service.py\nGoDream_macOS_Trial.spec\nGoDream_macOS_Official.spec\n.claude/docs/WINDOWS_PACKAGING_NOTES.md\n.claude/commands/pack-win.md\npackaging/zero_config_launcher.py\npackaging/windows/gemeng_windows_onefile.spec\npackaging/windows/gemeng_fixed_v2.9.spec\ncomponents/creation_components.py\npackaging/legacy/GoDream_Official.spec\n.claude/PACKAGING_NOTES.md\nmodules/seedream/client.py\nmodules/seedream/manager.py\nmodules/provider/volc_v4_5.py\n.kim-orchestrator/phase2_code.md\nmodules/provider/volc_v4.py\nsnapshot1.json\ntools/diagnose_watermark.py\nscripts/run_seedance_watermark_test2.py\nscripts/run_seedance_watermark_test.py\nscripts/run_seedance_watermark_direct.py\nmodules/seedream/__init__.py\nedition/constants.py\nedition/__init__.py\ndocs/界面优化总结.md\ndocs/reference_manuals/API_Documentation.md\ndocs/refactor/PLAN_C_CONFIG_DEEP_REFACTOR.md\ndocs/refactor/PLAN_C_COMPLETION_REPORT.md\ndocs/refactor/PHASE1_COMPLETE_REPORT.md\ndocs/codex 对话记录导出.md\ndocs/WATERMARK_ENABLED_FIX_PLAN.md\ndocs/TRIAL_VERSION_IMPLEMENTATION_PLAN.md\ndocs/Seedream_API参数完整清单.md\ndocs/PROJECT_AUDIT_AND_CHANGE_PLAN_2025-09-12.md\ndocs/CONFIG_GUIDE.md\nconfig/unified_config.py\nconfig/sources/watermark_config.py\nconfig/sources/generation_config.py\nconfig/sources/__init__.py\nconfig/legacy/README.md\nconfig/app_config.py\nconfig/__init__.py\n.style_backup/qt_app.py\n.style_backup/components/creation_components.py"}]},"uuid":"b8a6a12f-3d0c-4c5b-90f3-dfd92c5a5dfc","timestamp":"2025-12-30T09:55:41.876Z","toolUseResult":{"mode":"files_with_matches","filenames":["components/widgets/integrated_reference_panel.py","components/modes/video_mode_widget.py",".claude/commands/pack.md","packaging/windows/gemeng_windows_trial.spec","docs/design/问题排查与修复方案_20251113.md","docs/design/体验版测试指南_20251113.md","docs/design/macOS_体验版打包_执行方案_待审批.md","docs/api/图片生成API-火山方舟大模型服务平台-火山引擎.md","services/video_service.py","modules/seedance/manager.py","modules/seedance/client.py","modules/provider/volc.py","modules/provider/schema.py","config_api_example.py",".style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py",".style_backup/备份（界面正确版）/鸽梦 9.24/components/creation_components.py","packaging/windows/gemeng_windows.spec","edition/watermark_service.py","GoDream_macOS_Trial.spec","GoDream_macOS_Official.spec",".claude/docs/WINDOWS_PACKAGING_NOTES.md",".claude/commands/pack-win.md","packaging/zero_config_launcher.py","packaging/windows/gemeng_windows_onefile.spec","packaging/windows/gemeng_fixed_v2.9.spec","components/creation_components.py","packaging/legacy/GoDream_Official.spec",".claude/PACKAGING_NOTES.md","modules/seedream/client.py","modules/seedream/manager.py","modules/provider/volc_v4_5.py",".kim-orchestrator/phase2_code.md","modules/provider/volc_v4.py","snapshot1.json","tools/diagnose_watermark.py","scripts/run_seedance_watermark_test2.py","scripts/run_seedance_watermark_test.py","scripts/run_seedance_watermark_direct.py","modules/seedream/__init__.py","edition/constants.py","edition/__init__.py","docs/界面优化总结.md","docs/reference_manuals/API_Documentation.md","docs/refactor/PLAN_C_CONFIG_DEEP_REFACTOR.md","docs/refactor/PLAN_C_COMPLETION_REPORT.md","docs/refactor/PHASE1_COMPLETE_REPORT.md","docs/codex 对话记录导出.md","docs/WATERMARK_ENABLED_FIX_PLAN.md","docs/TRIAL_VERSION_IMPLEMENTATION_PLAN.md","docs/Seedream_API参数完整清单.md","docs/PROJECT_AUDIT_AND_CHANGE_PLAN_2025-09-12.md","docs/CONFIG_GUIDE.md","config/unified_config.py","config/sources/watermark_config.py","config/sources/generation_config.py","config/sources/__init__.py","config/legacy/README.md","config/app_config.py","config/__init__.py",".style_backup/qt_app.py",".style_backup/components/creation_components.py"],"numFiles":61}}
{"parentUuid":"b8a6a12f-3d0c-4c5b-90f3-dfd92c5a5dfc","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BxdRMVB2M3oqvDdLrJSiKw","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py\n/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}]},"uuid":"9f0d9d40-ca9c-498d-96e9-9645c345ce63","timestamp":"2025-12-30T09:55:41.974Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/__init__.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/config.py","/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"],"durationMs":144,"numFiles":4,"truncated":false}}
{"parentUuid":"9f0d9d40-ca9c-498d-96e9-9645c345ce63","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018rn9vSkVj6zgki2gxPH2Mq","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/threads/image_generation_thread.py"}]},"uuid":"223cdc2d-e33d-4e68-a9d5-4107c00a54d1","timestamp":"2025-12-30T09:55:41.975Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/threads/image_generation_thread.py"],"durationMs":146,"numFiles":1,"truncated":false}}
{"parentUuid":"223cdc2d-e33d-4e68-a9d5-4107c00a54d1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019cN8kN3erGqb6ks2DQZH3e","type":"tool_result","content":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py"}]},"uuid":"7e53a2b5-fa03-450b-a2bf-b0c22ae81abf","timestamp":"2025-12-30T09:55:41.976Z","toolUseResult":{"filenames":["/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py"],"durationMs":147,"numFiles":1,"truncated":false}}
{"parentUuid":"7e53a2b5-fa03-450b-a2bf-b0c22ae81abf","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AwSJfmWNbkZAPjVLGFgvNu","type":"message","role":"assistant","content":[{"type":"text","text":"很好，我找到了水印相关的代码。让我深入调查这些关键文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1567,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":1567,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"85104a24-1ef8-47d7-a4e2-00e3f42200f1","timestamp":"2025-12-30T09:55:46.046Z"}
{"parentUuid":"85104a24-1ef8-47d7-a4e2-00e3f42200f1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AwSJfmWNbkZAPjVLGFgvNu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TR9FQ89wp1eF1FiX3awCB7","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1567,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":1567,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"218dd72a-7cc3-4c63-9f93-52d40e765af3","timestamp":"2025-12-30T09:55:46.370Z"}
{"parentUuid":"218dd72a-7cc3-4c63-9f93-52d40e765af3","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AwSJfmWNbkZAPjVLGFgvNu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UEcHBnwhK4wsHMFUXHmv7y","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1567,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":1567,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"d422e11d-b518-4c1d-af3f-b23bd73a1a3d","timestamp":"2025-12-30T09:55:46.596Z"}
{"parentUuid":"d422e11d-b518-4c1d-af3f-b23bd73a1a3d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AwSJfmWNbkZAPjVLGFgvNu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kpmv2xVbFRNQtmWeu2g1jj","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/services/video_service.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1567,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":1567,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"3cc7ffb3-bf01-4986-8788-70b3866b1bde","timestamp":"2025-12-30T09:55:46.756Z"}
{"parentUuid":"3cc7ffb3-bf01-4986-8788-70b3866b1bde","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AwSJfmWNbkZAPjVLGFgvNu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ReP66ppBwmaHfrDELbzXBy","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/config/sources/watermark_config.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1567,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":1567,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"4b40b6e8-64d4-4047-b84d-6d427295806e","timestamp":"2025-12-30T09:55:46.980Z"}
{"parentUuid":"4b40b6e8-64d4-4047-b84d-6d427295806e","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kpmv2xVbFRNQtmWeu2g1jj","type":"tool_result","content":"     1→\"\"\"Seedance 视频生成服务层，实现与 UI 解耦并统一水印逻辑。\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import time\n     6→from datetime import datetime\n     7→from typing import Any, Callable, Dict, Optional\n     8→\n     9→from config.unified_config import get_unified_config\n    10→from modules.repository.manager import RepositoryManager\n    11→from modules.seedance.manager import SeedanceManager\n    12→from utils.logger import logger\n    13→\n    14→ProgressCallback = Optional[Callable[[Optional[float], str], None]]\n    15→CancelCallback = Optional[Callable[[], bool]]\n    16→\n    17→\n    18→class VideoService:\n    19→    \"\"\"封装 Seedance 视频生成的业务逻辑与水印处理。\"\"\"\n    20→\n    21→    def __init__(\n    22→        self,\n    23→        repository_manager: Optional[RepositoryManager] = None,\n    24→        seedance_manager_factory: Optional[Callable[[Optional[str]], SeedanceManager]] = None,\n    25→    ) -> None:\n    26→        \"\"\"\n    27→        初始化服务层并注入依赖。\n    28→\n    29→        Args:\n    30→            repository_manager: 历史记录仓库管理器。\n    31→            seedance_manager_factory: SeedanceManager 工厂，便于测试替身。\n    32→        \"\"\"\n    33→        # 使用统一配置\n    34→        self.unified_config = get_unified_config()\n    35→\n    36→        self.repository_manager = repository_manager\n    37→        self._seedance_manager_factory = seedance_manager_factory or (lambda api_key=None: SeedanceManager(api_key))\n    38→\n    39→    def _ensure_repository_manager(self) -> Optional[RepositoryManager]:\n    40→        if self.repository_manager:\n    41→            return self.repository_manager\n    42→        try:\n    43→            storage_dir = self.unified_config.get_storage_dir()\n    44→            self.repository_manager = RepositoryManager(storage_dir)\n    45→            return self.repository_manager\n    46→        except Exception as exc:\n    47→            logger.debug(f\"初始化 RepositoryManager 失败（将跳过 params 落盘）: {exc}\")\n    48→            return None\n    49→\n    50→    @staticmethod\n    51→    def _ensure_dict(value: Any) -> Dict[str, Any]:\n    52→        if isinstance(value, dict):\n    53→            return value\n    54→        if isinstance(value, str) and value:\n    55→            try:\n    56→                import json\n    57→\n    58→                loaded = json.loads(value)\n    59→                return loaded if isinstance(loaded, dict) else {}\n    60→            except Exception:\n    61→                return {}\n    62→        return {}\n    63→\n    64→    @staticmethod\n    65→    def _build_params_requested(params: Dict[str, Any]) -> Dict[str, Any]:\n    66→        requested = dict(params or {})\n    67→        requested.pop(\"generation_id\", None)\n    68→        requested.pop(\"task_id\", None)\n    69→        return requested\n    70→\n    71→    @staticmethod\n    72→    def _build_params_actual(status_result: Dict[str, Any]) -> Dict[str, Any]:\n    73→        if not isinstance(status_result, dict):\n    74→            return {}\n    75→        fps_value = status_result.get(\"framespersecond\")\n    76→        if fps_value is None:\n    77→            fps_value = status_result.get(\"fps\")\n    78→        return {\n    79→            \"api_task_id\": status_result.get(\"task_id\"),\n    80→            \"model\": status_result.get(\"model\"),\n    81→            \"status\": status_result.get(\"status\"),\n    82→            \"video_url\": status_result.get(\"video_url\"),\n    83→            \"thumbnail_url\": status_result.get(\"thumbnail_url\"),\n    84→            \"preview_url\": status_result.get(\"preview_url\"),\n    85→            \"seed\": status_result.get(\"seed\"),\n    86→            \"resolution\": status_result.get(\"resolution\"),\n    87→            \"ratio\": status_result.get(\"ratio\"),\n    88→            \"duration\": status_result.get(\"duration\"),\n    89→            \"framespersecond\": fps_value,\n    90→            \"service_tier\": status_result.get(\"service_tier\"),\n    91→            \"execution_expires_after\": status_result.get(\"execution_expires_after\"),\n    92→            \"generate_audio\": status_result.get(\"generate_audio\"),\n    93→            \"usage\": status_result.get(\"usage\"),\n    94→            \"created_at\": status_result.get(\"created_at\"),\n    95→            \"updated_at\": status_result.get(\"updated_at\"),\n    96→        }\n    97→\n    98→    @classmethod\n    99→    def _merge_params_bundle(\n   100→        cls,\n   101→        *,\n   102→        existing: Optional[Dict[str, Any]] = None,\n   103→        params_requested: Optional[Dict[str, Any]] = None,\n   104→        params_sent: Optional[Dict[str, Any]] = None,\n   105→        params_actual: Optional[Dict[str, Any]] = None,\n   106→    ) -> Dict[str, Any]:\n   107→        bundle: Dict[str, Any] = {}\n   108→        if isinstance(existing, dict):\n   109→            bundle.update(existing)\n   110→\n   111→        requested = cls._ensure_dict(params_requested) if params_requested is not None else cls._ensure_dict(bundle.get(\"params_requested\"))\n   112→        sent = cls._ensure_dict(params_sent) if params_sent is not None else cls._ensure_dict(bundle.get(\"params_sent\"))\n   113→        actual = cls._ensure_dict(params_actual) if params_actual is not None else cls._ensure_dict(bundle.get(\"params_actual\"))\n   114→\n   115→        # 同步 requested 到顶层，保持旧逻辑（pending/详情页）可用\n   116→        if requested:\n   117→            for key, value in requested.items():\n   118→                bundle.setdefault(key, value)\n   119→\n   120→        # 三层结构\n   121→        if requested:\n   122→            bundle[\"params_requested\"] = requested\n   123→        if sent:\n   124→            bundle[\"params_sent\"] = sent\n   125→        if actual:\n   126→            bundle[\"params_actual\"] = actual\n   127→\n   128→        # 回填关键展示字段：sent -> actual（展示用；复用仍以 params_requested / params_actual 为准）\n   129→        if sent:\n   130→            if sent.get(\"resolution\"):\n   131→                bundle[\"resolution_grade\"] = sent.get(\"resolution\")\n   132→            if sent.get(\"ratio\"):\n   133→                bundle[\"ratio\"] = sent.get(\"ratio\")\n   134→            if sent.get(\"duration\") is not None:\n   135→                bundle[\"duration\"] = sent.get(\"duration\")\n   136→            fps_sent = sent.get(\"framespersecond\")\n   137→            if fps_sent is None:\n   138→                fps_sent = sent.get(\"fps\")\n   139→            if fps_sent is not None:\n   140→                bundle[\"fps\"] = fps_sent\n   141→            if sent.get(\"generate_audio\") is not None:\n   142→                bundle[\"generate_audio\"] = sent.get(\"generate_audio\")\n   143→\n   144→        # 回填关键展示字段：优先 actual\n   145→        if actual:\n   146→            if actual.get(\"seed\") is not None:\n   147→                bundle[\"seed\"] = actual.get(\"seed\")\n   148→            if actual.get(\"resolution\"):\n   149→                bundle[\"resolution_grade\"] = actual.get(\"resolution\")\n   150→            if actual.get(\"ratio\"):\n   151→                bundle[\"ratio\"] = actual.get(\"ratio\")\n   152→            if actual.get(\"duration\") is not None:\n   153→                bundle[\"duration\"] = actual.get(\"duration\")\n   154→            if actual.get(\"framespersecond\") is not None:\n   155→                bundle[\"fps\"] = actual.get(\"framespersecond\")\n   156→            if actual.get(\"generate_audio\") is not None:\n   157→                bundle[\"generate_audio\"] = actual.get(\"generate_audio\")\n   158→\n   159→        return bundle\n   160→\n   161→    # ------------------------------------------------------------------\n   162→    # 公共接口\n   163→    # ------------------------------------------------------------------\n   164→    def generate_video(\n   165→        self,\n   166→        params: Dict[str, Any],\n   167→        progress_callback: ProgressCallback = None,\n   168→        should_cancel: CancelCallback = None,\n   169→    ) -> Dict[str, Any]:\n   170→        \"\"\"\n   171→        统一的视频生成入口。\n   172→\n   173→        Args:\n   174→            params: 视频生成参数，兼容 VideoModeWidget 的字段集合。\n   175→            progress_callback: 进度回调函数，形如 callback(percentage, message)。\n   176→\n   177→        Returns:\n   178→            生成结果字典，包含 success / error / local_path 等信息。\n   179→        \"\"\"\n   180→        task_id: Optional[str] = params.get(\"generation_id\")\n   181→        api_task_id: Optional[str] = None\n   182→\n   183→        prompt = (params.get(\"prompt\") or \"\").strip()\n   184→        if not prompt:\n   185→            return self._failure(\"提示词不能为空\")\n   186→\n   187→        if self._is_cancelled(should_cancel):\n   188→            logger.info(\"用户取消了视频生成: 初始化前\")\n   189→            return self._cancelled()\n   190→\n   191→        self._emit_progress(progress_callback, \"正在初始化视频生成...\")\n   192→\n   193→        try:\n   194→            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n   195→            if not is_valid:\n   196→                missing = f\"缺失: {', '.join(missing_keys)}\" if missing_keys else \"\"\n   197→                detail = message or \"API密钥未配置\"\n   198→                return self._failure(detail if not missing else f\"{detail}（{missing}）\")\n   199→        except Exception as cfg_err:\n   200→            return self._failure(f\"配置检查失败: {cfg_err}\")\n   201→\n   202→        if self._is_cancelled(should_cancel):\n   203→            logger.info(\"用户取消了视频生成: 配置检查后\")\n   204→            return self._cancelled()\n   205→\n   206→        watermark_settings = self._apply_watermark_config(params)\n   207→        watermark_enabled = watermark_settings[\"watermark_enabled\"]\n   208→\n   209→        try:\n   210→            api_key = self.unified_config.get_api_key(\"volcengine\")\n   211→            manager = self._seedance_manager_factory(api_key)\n   212→            self._emit_progress(progress_callback, \"Seedance 管理器初始化成功\", percentage=5.0)\n   213→        except Exception as init_err:\n   214→            logger.error(f\"Seedance 管理器初始化失败: {init_err}\")\n   215→            return self._failure(f\"Seedance管理器初始化失败: {init_err}\")\n   216→\n   217→        if self._is_cancelled(should_cancel):\n   218→            logger.info(\"用户取消了视频生成: 管理器初始化后\")\n   219→            return self._cancelled()\n   220→\n   221→        model_variant = params.get(\"model_variant\") or \"seedance_pro\"\n   222→        is_seedance_1_5 = str(model_variant).strip().lower() == \"seedance_1_5_pro\"\n   223→\n   224→        raw_duration = params.get(\"duration\", 5)\n   225→        if is_seedance_1_5:\n   226→            # 1.5 Pro 支持 duration=-1（自适应）；其余情况交由后端/Provider 进一步校验\n   227→            try:\n   228→                duration = int(raw_duration)\n   229→            except Exception:\n   230→                duration = 5\n   231→        else:\n   232→            duration = self._safe_int(raw_duration, default=5, minimum=1)\n   233→        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n   234→        fps = self._safe_int(params.get(\"fps\", 24), default=24, minimum=1)\n   235→        ratio = params.get(\"ratio\", \"16:9\")\n   236→        resolution_grade = params.get(\"resolution_grade\", \"1080p\")\n   237→        camera_fixed = bool(params.get(\"camera_fixed\", True))\n   238→        model_type = params.get(\"model_type\", \"pro\")\n   239→        generate_audio = params.get(\"generate_audio\")\n   240→\n   241→        first_frame = params.get(\"first_frame\")\n   242→        last_frame = params.get(\"last_frame\")\n   243→        input_image = params.get(\"image_path\") or params.get(\"input_image\")\n   244→        reference_images = params.get(\"reference_images\") or params.get(\"reference_assets\") or []\n   245→        schema_values = params.get(\"schema_values\") or {}\n   246→\n   247→        self._emit_progress(progress_callback, \"正在创建视频生成任务...\", percentage=10.0)\n   248→        try:\n   249→            create_result = manager.generate_video(\n   250→                prompt=prompt,\n   251→                first_frame_path=first_frame if first_frame and last_frame else None,\n   252→                last_frame_path=last_frame if first_frame and last_frame else None,\n   253→                image_path=None if (first_frame and last_frame) else (first_frame or input_image),\n   254→                duration=duration,\n   255→                seed=seed if seed >= 0 else -1,\n   256→                resolution_grade=resolution_grade,\n   257→                ratio=ratio,\n   258→                fps=fps,\n   259→                watermark=watermark_enabled,\n   260→                camera_fixed=camera_fixed,\n   261→                use_pro_model=(model_type in (\"pro\", \"pro_fast\")),\n   262→                model_type=model_type,\n   263→                model_variant=model_variant,\n   264→                generate_audio=generate_audio,\n   265→                save_local=False,\n   266→                wait_for_completion=False,\n   267→                reference_images=reference_images,\n   268→                generation_id=task_id,\n   269→            )\n   270→        except Exception as api_err:\n   271→            logger.error(f\"调用 Seedance API 创建任务失败: {api_err}\")\n   272→            return self._failure(f\"创建任务失败: {api_err}\")\n   273→\n   274→        api_task_id = create_result.get(\"api_task_id\") or create_result.get(\"task_id\") or api_task_id\n   275→        task_id = task_id or create_result.get(\"task_id\")\n   276→\n   277→        if self._is_cancelled(should_cancel):\n   278→            self._request_remote_cancel(manager, api_task_id)\n   279→            logger.info(\"用户取消了视频生成: 任务创建后\")\n   280→            return self._cancelled()\n   281→\n   282→        if not create_result.get(\"success\"):\n   283→            return self._failure(create_result.get(\"error\", \"创建任务失败\"))\n   284→\n   285→        if not api_task_id:\n   286→            return self._failure(\"未获取到服务端任务ID\")\n   287→\n   288→        if not task_id:\n   289→            return self._failure(\"未获取到任务ID\")\n   290→\n   291→        params_requested = self._build_params_requested(params)\n   292→        params_sent = self._ensure_dict(create_result.get(\"params_sent\")) if isinstance(create_result, dict) else {}\n   293→        if api_task_id and isinstance(params_sent, dict):\n   294→            params_sent.setdefault(\"api_task_id\", api_task_id)\n   295→\n   296→        # P1：创建成功后立即写回 api_task_id/params_sent，便于重启恢复与参数一致性\n   297→        params_bundle = self._merge_params_bundle(params_requested=params_requested, params_sent=params_sent)\n   298→        create_params = self._ensure_dict(create_result.get(\"parameters\")) if isinstance(create_result, dict) else {}\n   299→        if create_params:\n   300→            for key in (\"first_frame\", \"last_frame\", \"image_path\", \"reference_assets\", \"resolution_grade\", \"ratio\"):\n   301→                if key in create_params and create_params.get(key) is not None:\n   302→                    params_bundle[key] = create_params.get(key)\n   303→        repo_manager = self._ensure_repository_manager()\n   304→        if repo_manager and task_id:\n   305→            model_for_record = (\n   306→                params_sent.get(\"model\")\n   307→                or create_result.get(\"model\")\n   308→                or params.get(\"model_variant\")\n   309→                or params.get(\"model_type\")\n   310→            )\n   311→            try:\n   312→                updated = repo_manager.update_record(\n   313→                    str(task_id),\n   314→                    {\n   315→                        \"status\": \"pending\",\n   316→                        \"model\": model_for_record,\n   317→                        \"parameters\": params_bundle,\n   318→                    },\n   319→                )\n   320→                if not updated:\n   321→                    repo_manager.add_content(\n   322→                        str(task_id),\n   323→                        \"videos\",\n   324→                        {\n   325→                            \"prompt\": prompt,\n   326→                            \"model\": model_for_record,\n   327→                            \"status\": \"pending\",\n   328→                            \"created_at\": datetime.now().isoformat(),\n   329→                            \"parameters\": params_bundle,\n   330→                        },\n   331→                    )\n   332→            except Exception as exc:\n   333→                logger.debug(f\"创建后写回 api_task_id 失败（将继续主流程）: {exc}\")\n   334→\n   335→        if create_result.get(\"fallback_applied\"):\n   336→            logger.warning(f\"视频生成参数已自动回退: {create_result.get('fallback_reason', '')}\")\n   337→\n   338→        status_result = self._poll_task(manager, api_task_id, progress_callback, should_cancel)\n   339→        if not status_result.get(\"success\"):\n   340→            return status_result\n   341→\n   342→        params_actual = self._build_params_actual(status_result)\n   343→        params_bundle = self._merge_params_bundle(\n   344→            existing=params_bundle,\n   345→            params_requested=params_requested,\n   346→            params_sent=params_sent,\n   347→            params_actual=params_actual,\n   348→        )\n   349→\n   350→        if task_id:\n   351→            status_result[\"task_id\"] = task_id\n   352→        if api_task_id:\n   353→            status_result[\"api_task_id\"] = api_task_id\n   354→\n   355→        complete_result = self._build_complete_result(\n   356→            create_result=create_result,\n   357→            status_result=status_result,\n   358→            params=params,\n   359→            watermark_settings=watermark_settings,\n   360→            schema_values=schema_values,\n   361→            reference_images=reference_images,\n   362→            model_variant=model_variant,\n   363→            model_type=model_type,\n   364→            params_bundle=params_bundle,\n   365→        )\n   366→\n   367→        if self._is_cancelled(should_cancel):\n   368→            logger.info(\"用户取消了视频生成: 保存结果前\")\n   369→            return self._cancelled()\n   370→\n   371→        return self._save_result(manager, complete_result)\n   372→\n   373→    # ------------------------------------------------------------------\n   374→    # 内部工具方法\n   375→    # ------------------------------------------------------------------\n   376→    def _poll_task(\n   377→        self,\n   378→        manager: SeedanceManager,\n   379→        task_id: str,\n   380→        progress_callback: ProgressCallback,\n   381→        should_cancel: CancelCallback,\n   382→        max_wait_seconds: int = 600,\n   383→    ) -> Dict[str, Any]:\n   384→        start_time = time.time()\n   385→        intervals = [2, 3, 5, 8, 10]\n   386→        attempt = 0\n   387→\n   388→        while time.time() - start_time < max_wait_seconds:\n   389→            if self._is_cancelled(should_cancel):\n   390→                self._request_remote_cancel(manager, task_id)\n   391→                logger.info(\"用户取消了视频生成任务\")\n   392→                return self._cancelled()\n   393→\n   394→            status_result = manager.client.query_video_task(task_id)\n   395→\n   396→            if not status_result.get(\"success\"):\n   397→                return self._failure(f\"查询任务状态失败: {status_result.get('error', '未知错误')}\")\n   398→\n   399→            status = status_result.get(\"status\")\n   400→            elapsed = time.time() - start_time\n   401→            progress = min(int((elapsed / max_wait_seconds) * 100), 95)\n   402→            self._emit_progress(progress_callback, f\"任务状态: {status}\", percentage=progress)\n   403→\n   404→            if status == \"succeeded\":\n   405→                self._emit_progress(progress_callback, \"视频生成完成\", percentage=100.0)\n   406→                status_result[\"success\"] = True\n   407→                status_result[\"task_id\"] = status_result.get(\"task_id\") or task_id\n   408→                return status_result\n   409→            if status == \"failed\":\n   410→                return self._failure(\"视频生成失败\")\n   411→            if status == \"cancelled\":\n   412→                return self._failure(\"任务被取消\")\n   413→            if status == \"expired\":\n   414→                return self._failure(\"任务已过期（expired）\")\n   415→\n   416→            interval = intervals[min(attempt, len(intervals) - 1)]\n   417→            time.sleep(interval)\n   418→            attempt += 1\n   419→\n   420→        return self._failure(\"视频生成超时\")\n   421→\n   422→    def _build_complete_result(\n   423→        self,\n   424→        create_result: Dict[str, Any],\n   425→        status_result: Dict[str, Any],\n   426→        params: Dict[str, Any],\n   427→        watermark_settings: Dict[str, Any],\n   428→        schema_values: Dict[str, Any],\n   429→        reference_images: Any,\n   430→        model_variant: str,\n   431→        model_type: str,\n   432→        params_bundle: Dict[str, Any],\n   433→    ) -> Dict[str, Any]:\n   434→        task_id = status_result.get(\"task_id\") or create_result.get(\"task_id\")\n   435→        model_code = (\n   436→            status_result.get(\"model\")\n   437→            or create_result.get(\"model\")\n   438→            or (self._ensure_dict(create_result.get(\"params_sent\")) if isinstance(create_result, dict) else {}).get(\"model\")\n   439→        )\n   440→        video_url = status_result.get(\"video_url\")\n   441→        thumbnail_url = status_result.get(\"thumbnail_url\", \"\")\n   442→        preview_url = status_result.get(\"preview_url\", \"\")\n   443→        ref_assets = (\n   444→            status_result.get(\"reference_assets\")\n   445→            or create_result.get(\"reference_assets\")\n   446→            or status_result.get(\"parameters\", {}).get(\"reference_assets\")\n   447→            or reference_images\n   448→            or []\n   449→        )\n   450→\n   451→        now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n   452→\n   453→        parameters: Dict[str, Any] = dict(params_bundle or {})\n   454→        parameters.setdefault(\"prompt\", params.get(\"prompt\", \"\"))\n   455→        parameters.setdefault(\"model_type\", model_type)\n   456→        parameters.setdefault(\"model_variant\", model_variant)\n   457→        parameters[\"reference_assets\"] = ref_assets\n   458→        parameters[\"watermark\"] = watermark_settings.get(\"watermark_enabled\", False)\n   459→        parameters[\"watermark_text\"] = watermark_settings.get(\"watermark_text\", \"\")\n   460→        parameters[\"watermark_opacity\"] = watermark_settings.get(\"watermark_opacity\", 0.0)\n   461→        parameters[\"watermark_position\"] = watermark_settings.get(\"watermark_position\", \"bottom_right\")\n   462→        parameters[\"watermark_font_size\"] = watermark_settings.get(\"watermark_font_size\", 0)\n   463→        if schema_values:\n   464→            parameters[\"schema_values\"] = dict(schema_values)\n   465→\n   466→        complete_result: Dict[str, Any] = {\n   467→            \"success\": True,\n   468→            \"task_id\": task_id,\n   469→            \"api_task_id\": status_result.get(\"api_task_id\") or create_result.get(\"api_task_id\"),\n   470→            # 顶层写入真实模型代码（用于落库与 UI 显示推断）\n   471→            \"model\": model_code,\n   472→            \"video_url\": video_url,\n   473→            \"thumbnail_url\": thumbnail_url,\n   474→            \"preview_url\": preview_url,\n   475→            \"status\": status_result.get(\"status\", \"success\"),\n   476→            \"type\": \"video\",\n   477→            \"input_image\": params.get(\"first_frame\", \"\") or params.get(\"image_path\") or \"\",\n   478→            \"parameters\": parameters,\n   479→            \"created_at\": now,\n   480→            \"completed_at\": now,\n   481→        }\n   482→\n   483→        complete_result[\"reference_assets\"] = ref_assets\n   484→\n   485→        if create_result.get(\"fallback_applied\"):\n   486→            complete_result[\"fallback_applied\"] = True\n   487→            complete_result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n   488→\n   489→        return complete_result\n   490→\n   491→    def _save_result(self, manager: SeedanceManager, complete_result: Dict[str, Any]) -> Dict[str, Any]:\n   492→        try:\n   493→            local_result = manager._save_video_locally(complete_result)\n   494→        except Exception as save_err:  # pylint: disable=broad-except\n   495→            logger.error(f\"保存视频失败: {save_err}\")\n   496→            return self._failure(f\"保存视频失败: {save_err}\")\n   497→\n   498→        if not isinstance(local_result, dict):\n   499→            return self._failure(\"视频保存返回无效结果\")\n   500→\n   501→        if local_result.get(\"local_save_error\"):\n   502→            return self._failure(f\"视频保存失败: {local_result['local_save_error']}\")\n   503→\n   504→        merged = {**complete_result, **local_result}\n   505→        merged[\"success\"] = True\n   506→        return merged\n   507→\n   508→    def _apply_watermark_config(self, params: Dict[str, Any]) -> Dict[str, Any]:\n   509→        \"\"\"\n   510→        统一应用水印配置，优先使用传入配置，其次使用 config_api.LOCAL_WATERMARK_CONFIG。\n   511→        \"\"\"\n   512→        watermark_config = params.get(\"watermark_config\", self.unified_config.get_watermark_config())\n   513→        normalized = {\n   514→            \"watermark_enabled\": watermark_config.get(\"enabled\", False),\n   515→            \"watermark_text\": watermark_config.get(\"text\", \"\"),\n   516→            \"watermark_opacity\": watermark_config.get(\"opacity\", 0.0),\n   517→            \"watermark_position\": watermark_config.get(\"position\", \"bottom_right\"),\n   518→            \"watermark_font_size\": watermark_config.get(\"font_size\", 0),\n   519→        }\n   520→        logger.info(\n   521→            \"视频水印配置应用: enabled=%s text=%s opacity=%s position=%s font_size=%s\",\n   522→            normalized[\"watermark_enabled\"],\n   523→            normalized[\"watermark_text\"],\n   524→            normalized[\"watermark_opacity\"],\n   525→            normalized[\"watermark_position\"],\n   526→            normalized[\"watermark_font_size\"],\n   527→        )\n   528→        return normalized\n   529→\n   530→    @staticmethod\n   531→    def _emit_progress(callback: ProgressCallback, message: str, percentage: Optional[float] = None) -> None:\n   532→        if callback:\n   533→            try:\n   534→                callback(percentage, message)\n   535→            except Exception:\n   536→                logger.debug(\"进度回调执行失败，已忽略。\")\n   537→\n   538→    @staticmethod\n   539→    def _failure(message: str) -> Dict[str, Any]:\n   540→        return {\"success\": False, \"error\": message}\n   541→\n   542→    @staticmethod\n   543→    def _is_cancelled(should_cancel: CancelCallback) -> bool:\n   544→        return bool(should_cancel and callable(should_cancel) and should_cancel())\n   545→\n   546→    @staticmethod\n   547→    def _cancelled() -> Dict[str, Any]:\n   548→        return {\"success\": False, \"error\": \"用户已取消操作\"}\n   549→\n   550→    def _request_remote_cancel(self, manager: Optional[SeedanceManager], task_id: Optional[str]) -> None:\n   551→        \"\"\"尝试向服务端发送取消任务请求，失败时仅记录日志。\"\"\"\n   552→        if not manager or not task_id:\n   553→            return\n   554→\n   555→        try:\n   556→            cancel_result = manager.client.cancel_task(task_id)\n   557→            if cancel_result.get(\"success\"):\n   558→                logger.info(f\"已向服务端成功发送取消请求: {task_id}\")\n   559→            else:\n   560→                logger.warning(\n   561→                    f\"服务端取消请求失败（任务可能已在running状态）: {cancel_result.get('error', '未知错误')}\"\n   562→                )\n   563→        except Exception as exc:  # pylint: disable=broad-except\n   564→            logger.warning(f\"服务端取消请求异常: {exc}\")\n   565→\n   566→    @staticmethod\n   567→    def _safe_int(value: Any, default: int = 0, minimum: Optional[int] = None) -> int:\n   568→        try:\n   569→            parsed = int(value)\n   570→            if minimum is not None:\n   571→                parsed = max(parsed, minimum)\n   572→            return parsed\n   573→        except Exception:\n   574→            return default\n   575→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"87d6c62d-cb72-44ec-9ac3-1410bbf339ff","timestamp":"2025-12-30T09:55:47.014Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/services/video_service.py","content":"\"\"\"Seedance 视频生成服务层，实现与 UI 解耦并统一水印逻辑。\"\"\"\n\nfrom __future__ import annotations\n\nimport time\nfrom datetime import datetime\nfrom typing import Any, Callable, Dict, Optional\n\nfrom config.unified_config import get_unified_config\nfrom modules.repository.manager import RepositoryManager\nfrom modules.seedance.manager import SeedanceManager\nfrom utils.logger import logger\n\nProgressCallback = Optional[Callable[[Optional[float], str], None]]\nCancelCallback = Optional[Callable[[], bool]]\n\n\nclass VideoService:\n    \"\"\"封装 Seedance 视频生成的业务逻辑与水印处理。\"\"\"\n\n    def __init__(\n        self,\n        repository_manager: Optional[RepositoryManager] = None,\n        seedance_manager_factory: Optional[Callable[[Optional[str]], SeedanceManager]] = None,\n    ) -> None:\n        \"\"\"\n        初始化服务层并注入依赖。\n\n        Args:\n            repository_manager: 历史记录仓库管理器。\n            seedance_manager_factory: SeedanceManager 工厂，便于测试替身。\n        \"\"\"\n        # 使用统一配置\n        self.unified_config = get_unified_config()\n\n        self.repository_manager = repository_manager\n        self._seedance_manager_factory = seedance_manager_factory or (lambda api_key=None: SeedanceManager(api_key))\n\n    def _ensure_repository_manager(self) -> Optional[RepositoryManager]:\n        if self.repository_manager:\n            return self.repository_manager\n        try:\n            storage_dir = self.unified_config.get_storage_dir()\n            self.repository_manager = RepositoryManager(storage_dir)\n            return self.repository_manager\n        except Exception as exc:\n            logger.debug(f\"初始化 RepositoryManager 失败（将跳过 params 落盘）: {exc}\")\n            return None\n\n    @staticmethod\n    def _ensure_dict(value: Any) -> Dict[str, Any]:\n        if isinstance(value, dict):\n            return value\n        if isinstance(value, str) and value:\n            try:\n                import json\n\n                loaded = json.loads(value)\n                return loaded if isinstance(loaded, dict) else {}\n            except Exception:\n                return {}\n        return {}\n\n    @staticmethod\n    def _build_params_requested(params: Dict[str, Any]) -> Dict[str, Any]:\n        requested = dict(params or {})\n        requested.pop(\"generation_id\", None)\n        requested.pop(\"task_id\", None)\n        return requested\n\n    @staticmethod\n    def _build_params_actual(status_result: Dict[str, Any]) -> Dict[str, Any]:\n        if not isinstance(status_result, dict):\n            return {}\n        fps_value = status_result.get(\"framespersecond\")\n        if fps_value is None:\n            fps_value = status_result.get(\"fps\")\n        return {\n            \"api_task_id\": status_result.get(\"task_id\"),\n            \"model\": status_result.get(\"model\"),\n            \"status\": status_result.get(\"status\"),\n            \"video_url\": status_result.get(\"video_url\"),\n            \"thumbnail_url\": status_result.get(\"thumbnail_url\"),\n            \"preview_url\": status_result.get(\"preview_url\"),\n            \"seed\": status_result.get(\"seed\"),\n            \"resolution\": status_result.get(\"resolution\"),\n            \"ratio\": status_result.get(\"ratio\"),\n            \"duration\": status_result.get(\"duration\"),\n            \"framespersecond\": fps_value,\n            \"service_tier\": status_result.get(\"service_tier\"),\n            \"execution_expires_after\": status_result.get(\"execution_expires_after\"),\n            \"generate_audio\": status_result.get(\"generate_audio\"),\n            \"usage\": status_result.get(\"usage\"),\n            \"created_at\": status_result.get(\"created_at\"),\n            \"updated_at\": status_result.get(\"updated_at\"),\n        }\n\n    @classmethod\n    def _merge_params_bundle(\n        cls,\n        *,\n        existing: Optional[Dict[str, Any]] = None,\n        params_requested: Optional[Dict[str, Any]] = None,\n        params_sent: Optional[Dict[str, Any]] = None,\n        params_actual: Optional[Dict[str, Any]] = None,\n    ) -> Dict[str, Any]:\n        bundle: Dict[str, Any] = {}\n        if isinstance(existing, dict):\n            bundle.update(existing)\n\n        requested = cls._ensure_dict(params_requested) if params_requested is not None else cls._ensure_dict(bundle.get(\"params_requested\"))\n        sent = cls._ensure_dict(params_sent) if params_sent is not None else cls._ensure_dict(bundle.get(\"params_sent\"))\n        actual = cls._ensure_dict(params_actual) if params_actual is not None else cls._ensure_dict(bundle.get(\"params_actual\"))\n\n        # 同步 requested 到顶层，保持旧逻辑（pending/详情页）可用\n        if requested:\n            for key, value in requested.items():\n                bundle.setdefault(key, value)\n\n        # 三层结构\n        if requested:\n            bundle[\"params_requested\"] = requested\n        if sent:\n            bundle[\"params_sent\"] = sent\n        if actual:\n            bundle[\"params_actual\"] = actual\n\n        # 回填关键展示字段：sent -> actual（展示用；复用仍以 params_requested / params_actual 为准）\n        if sent:\n            if sent.get(\"resolution\"):\n                bundle[\"resolution_grade\"] = sent.get(\"resolution\")\n            if sent.get(\"ratio\"):\n                bundle[\"ratio\"] = sent.get(\"ratio\")\n            if sent.get(\"duration\") is not None:\n                bundle[\"duration\"] = sent.get(\"duration\")\n            fps_sent = sent.get(\"framespersecond\")\n            if fps_sent is None:\n                fps_sent = sent.get(\"fps\")\n            if fps_sent is not None:\n                bundle[\"fps\"] = fps_sent\n            if sent.get(\"generate_audio\") is not None:\n                bundle[\"generate_audio\"] = sent.get(\"generate_audio\")\n\n        # 回填关键展示字段：优先 actual\n        if actual:\n            if actual.get(\"seed\") is not None:\n                bundle[\"seed\"] = actual.get(\"seed\")\n            if actual.get(\"resolution\"):\n                bundle[\"resolution_grade\"] = actual.get(\"resolution\")\n            if actual.get(\"ratio\"):\n                bundle[\"ratio\"] = actual.get(\"ratio\")\n            if actual.get(\"duration\") is not None:\n                bundle[\"duration\"] = actual.get(\"duration\")\n            if actual.get(\"framespersecond\") is not None:\n                bundle[\"fps\"] = actual.get(\"framespersecond\")\n            if actual.get(\"generate_audio\") is not None:\n                bundle[\"generate_audio\"] = actual.get(\"generate_audio\")\n\n        return bundle\n\n    # ------------------------------------------------------------------\n    # 公共接口\n    # ------------------------------------------------------------------\n    def generate_video(\n        self,\n        params: Dict[str, Any],\n        progress_callback: ProgressCallback = None,\n        should_cancel: CancelCallback = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        统一的视频生成入口。\n\n        Args:\n            params: 视频生成参数，兼容 VideoModeWidget 的字段集合。\n            progress_callback: 进度回调函数，形如 callback(percentage, message)。\n\n        Returns:\n            生成结果字典，包含 success / error / local_path 等信息。\n        \"\"\"\n        task_id: Optional[str] = params.get(\"generation_id\")\n        api_task_id: Optional[str] = None\n\n        prompt = (params.get(\"prompt\") or \"\").strip()\n        if not prompt:\n            return self._failure(\"提示词不能为空\")\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 初始化前\")\n            return self._cancelled()\n\n        self._emit_progress(progress_callback, \"正在初始化视频生成...\")\n\n        try:\n            is_valid, missing_keys, message = self.unified_config.validate_api_keys()\n            if not is_valid:\n                missing = f\"缺失: {', '.join(missing_keys)}\" if missing_keys else \"\"\n                detail = message or \"API密钥未配置\"\n                return self._failure(detail if not missing else f\"{detail}（{missing}）\")\n        except Exception as cfg_err:\n            return self._failure(f\"配置检查失败: {cfg_err}\")\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 配置检查后\")\n            return self._cancelled()\n\n        watermark_settings = self._apply_watermark_config(params)\n        watermark_enabled = watermark_settings[\"watermark_enabled\"]\n\n        try:\n            api_key = self.unified_config.get_api_key(\"volcengine\")\n            manager = self._seedance_manager_factory(api_key)\n            self._emit_progress(progress_callback, \"Seedance 管理器初始化成功\", percentage=5.0)\n        except Exception as init_err:\n            logger.error(f\"Seedance 管理器初始化失败: {init_err}\")\n            return self._failure(f\"Seedance管理器初始化失败: {init_err}\")\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 管理器初始化后\")\n            return self._cancelled()\n\n        model_variant = params.get(\"model_variant\") or \"seedance_pro\"\n        is_seedance_1_5 = str(model_variant).strip().lower() == \"seedance_1_5_pro\"\n\n        raw_duration = params.get(\"duration\", 5)\n        if is_seedance_1_5:\n            # 1.5 Pro 支持 duration=-1（自适应）；其余情况交由后端/Provider 进一步校验\n            try:\n                duration = int(raw_duration)\n            except Exception:\n                duration = 5\n        else:\n            duration = self._safe_int(raw_duration, default=5, minimum=1)\n        seed = self._safe_int(params.get(\"seed\", -1), default=-1)\n        fps = self._safe_int(params.get(\"fps\", 24), default=24, minimum=1)\n        ratio = params.get(\"ratio\", \"16:9\")\n        resolution_grade = params.get(\"resolution_grade\", \"1080p\")\n        camera_fixed = bool(params.get(\"camera_fixed\", True))\n        model_type = params.get(\"model_type\", \"pro\")\n        generate_audio = params.get(\"generate_audio\")\n\n        first_frame = params.get(\"first_frame\")\n        last_frame = params.get(\"last_frame\")\n        input_image = params.get(\"image_path\") or params.get(\"input_image\")\n        reference_images = params.get(\"reference_images\") or params.get(\"reference_assets\") or []\n        schema_values = params.get(\"schema_values\") or {}\n\n        self._emit_progress(progress_callback, \"正在创建视频生成任务...\", percentage=10.0)\n        try:\n            create_result = manager.generate_video(\n                prompt=prompt,\n                first_frame_path=first_frame if first_frame and last_frame else None,\n                last_frame_path=last_frame if first_frame and last_frame else None,\n                image_path=None if (first_frame and last_frame) else (first_frame or input_image),\n                duration=duration,\n                seed=seed if seed >= 0 else -1,\n                resolution_grade=resolution_grade,\n                ratio=ratio,\n                fps=fps,\n                watermark=watermark_enabled,\n                camera_fixed=camera_fixed,\n                use_pro_model=(model_type in (\"pro\", \"pro_fast\")),\n                model_type=model_type,\n                model_variant=model_variant,\n                generate_audio=generate_audio,\n                save_local=False,\n                wait_for_completion=False,\n                reference_images=reference_images,\n                generation_id=task_id,\n            )\n        except Exception as api_err:\n            logger.error(f\"调用 Seedance API 创建任务失败: {api_err}\")\n            return self._failure(f\"创建任务失败: {api_err}\")\n\n        api_task_id = create_result.get(\"api_task_id\") or create_result.get(\"task_id\") or api_task_id\n        task_id = task_id or create_result.get(\"task_id\")\n\n        if self._is_cancelled(should_cancel):\n            self._request_remote_cancel(manager, api_task_id)\n            logger.info(\"用户取消了视频生成: 任务创建后\")\n            return self._cancelled()\n\n        if not create_result.get(\"success\"):\n            return self._failure(create_result.get(\"error\", \"创建任务失败\"))\n\n        if not api_task_id:\n            return self._failure(\"未获取到服务端任务ID\")\n\n        if not task_id:\n            return self._failure(\"未获取到任务ID\")\n\n        params_requested = self._build_params_requested(params)\n        params_sent = self._ensure_dict(create_result.get(\"params_sent\")) if isinstance(create_result, dict) else {}\n        if api_task_id and isinstance(params_sent, dict):\n            params_sent.setdefault(\"api_task_id\", api_task_id)\n\n        # P1：创建成功后立即写回 api_task_id/params_sent，便于重启恢复与参数一致性\n        params_bundle = self._merge_params_bundle(params_requested=params_requested, params_sent=params_sent)\n        create_params = self._ensure_dict(create_result.get(\"parameters\")) if isinstance(create_result, dict) else {}\n        if create_params:\n            for key in (\"first_frame\", \"last_frame\", \"image_path\", \"reference_assets\", \"resolution_grade\", \"ratio\"):\n                if key in create_params and create_params.get(key) is not None:\n                    params_bundle[key] = create_params.get(key)\n        repo_manager = self._ensure_repository_manager()\n        if repo_manager and task_id:\n            model_for_record = (\n                params_sent.get(\"model\")\n                or create_result.get(\"model\")\n                or params.get(\"model_variant\")\n                or params.get(\"model_type\")\n            )\n            try:\n                updated = repo_manager.update_record(\n                    str(task_id),\n                    {\n                        \"status\": \"pending\",\n                        \"model\": model_for_record,\n                        \"parameters\": params_bundle,\n                    },\n                )\n                if not updated:\n                    repo_manager.add_content(\n                        str(task_id),\n                        \"videos\",\n                        {\n                            \"prompt\": prompt,\n                            \"model\": model_for_record,\n                            \"status\": \"pending\",\n                            \"created_at\": datetime.now().isoformat(),\n                            \"parameters\": params_bundle,\n                        },\n                    )\n            except Exception as exc:\n                logger.debug(f\"创建后写回 api_task_id 失败（将继续主流程）: {exc}\")\n\n        if create_result.get(\"fallback_applied\"):\n            logger.warning(f\"视频生成参数已自动回退: {create_result.get('fallback_reason', '')}\")\n\n        status_result = self._poll_task(manager, api_task_id, progress_callback, should_cancel)\n        if not status_result.get(\"success\"):\n            return status_result\n\n        params_actual = self._build_params_actual(status_result)\n        params_bundle = self._merge_params_bundle(\n            existing=params_bundle,\n            params_requested=params_requested,\n            params_sent=params_sent,\n            params_actual=params_actual,\n        )\n\n        if task_id:\n            status_result[\"task_id\"] = task_id\n        if api_task_id:\n            status_result[\"api_task_id\"] = api_task_id\n\n        complete_result = self._build_complete_result(\n            create_result=create_result,\n            status_result=status_result,\n            params=params,\n            watermark_settings=watermark_settings,\n            schema_values=schema_values,\n            reference_images=reference_images,\n            model_variant=model_variant,\n            model_type=model_type,\n            params_bundle=params_bundle,\n        )\n\n        if self._is_cancelled(should_cancel):\n            logger.info(\"用户取消了视频生成: 保存结果前\")\n            return self._cancelled()\n\n        return self._save_result(manager, complete_result)\n\n    # ------------------------------------------------------------------\n    # 内部工具方法\n    # ------------------------------------------------------------------\n    def _poll_task(\n        self,\n        manager: SeedanceManager,\n        task_id: str,\n        progress_callback: ProgressCallback,\n        should_cancel: CancelCallback,\n        max_wait_seconds: int = 600,\n    ) -> Dict[str, Any]:\n        start_time = time.time()\n        intervals = [2, 3, 5, 8, 10]\n        attempt = 0\n\n        while time.time() - start_time < max_wait_seconds:\n            if self._is_cancelled(should_cancel):\n                self._request_remote_cancel(manager, task_id)\n                logger.info(\"用户取消了视频生成任务\")\n                return self._cancelled()\n\n            status_result = manager.client.query_video_task(task_id)\n\n            if not status_result.get(\"success\"):\n                return self._failure(f\"查询任务状态失败: {status_result.get('error', '未知错误')}\")\n\n            status = status_result.get(\"status\")\n            elapsed = time.time() - start_time\n            progress = min(int((elapsed / max_wait_seconds) * 100), 95)\n            self._emit_progress(progress_callback, f\"任务状态: {status}\", percentage=progress)\n\n            if status == \"succeeded\":\n                self._emit_progress(progress_callback, \"视频生成完成\", percentage=100.0)\n                status_result[\"success\"] = True\n                status_result[\"task_id\"] = status_result.get(\"task_id\") or task_id\n                return status_result\n            if status == \"failed\":\n                return self._failure(\"视频生成失败\")\n            if status == \"cancelled\":\n                return self._failure(\"任务被取消\")\n            if status == \"expired\":\n                return self._failure(\"任务已过期（expired）\")\n\n            interval = intervals[min(attempt, len(intervals) - 1)]\n            time.sleep(interval)\n            attempt += 1\n\n        return self._failure(\"视频生成超时\")\n\n    def _build_complete_result(\n        self,\n        create_result: Dict[str, Any],\n        status_result: Dict[str, Any],\n        params: Dict[str, Any],\n        watermark_settings: Dict[str, Any],\n        schema_values: Dict[str, Any],\n        reference_images: Any,\n        model_variant: str,\n        model_type: str,\n        params_bundle: Dict[str, Any],\n    ) -> Dict[str, Any]:\n        task_id = status_result.get(\"task_id\") or create_result.get(\"task_id\")\n        model_code = (\n            status_result.get(\"model\")\n            or create_result.get(\"model\")\n            or (self._ensure_dict(create_result.get(\"params_sent\")) if isinstance(create_result, dict) else {}).get(\"model\")\n        )\n        video_url = status_result.get(\"video_url\")\n        thumbnail_url = status_result.get(\"thumbnail_url\", \"\")\n        preview_url = status_result.get(\"preview_url\", \"\")\n        ref_assets = (\n            status_result.get(\"reference_assets\")\n            or create_result.get(\"reference_assets\")\n            or status_result.get(\"parameters\", {}).get(\"reference_assets\")\n            or reference_images\n            or []\n        )\n\n        now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        parameters: Dict[str, Any] = dict(params_bundle or {})\n        parameters.setdefault(\"prompt\", params.get(\"prompt\", \"\"))\n        parameters.setdefault(\"model_type\", model_type)\n        parameters.setdefault(\"model_variant\", model_variant)\n        parameters[\"reference_assets\"] = ref_assets\n        parameters[\"watermark\"] = watermark_settings.get(\"watermark_enabled\", False)\n        parameters[\"watermark_text\"] = watermark_settings.get(\"watermark_text\", \"\")\n        parameters[\"watermark_opacity\"] = watermark_settings.get(\"watermark_opacity\", 0.0)\n        parameters[\"watermark_position\"] = watermark_settings.get(\"watermark_position\", \"bottom_right\")\n        parameters[\"watermark_font_size\"] = watermark_settings.get(\"watermark_font_size\", 0)\n        if schema_values:\n            parameters[\"schema_values\"] = dict(schema_values)\n\n        complete_result: Dict[str, Any] = {\n            \"success\": True,\n            \"task_id\": task_id,\n            \"api_task_id\": status_result.get(\"api_task_id\") or create_result.get(\"api_task_id\"),\n            # 顶层写入真实模型代码（用于落库与 UI 显示推断）\n            \"model\": model_code,\n            \"video_url\": video_url,\n            \"thumbnail_url\": thumbnail_url,\n            \"preview_url\": preview_url,\n            \"status\": status_result.get(\"status\", \"success\"),\n            \"type\": \"video\",\n            \"input_image\": params.get(\"first_frame\", \"\") or params.get(\"image_path\") or \"\",\n            \"parameters\": parameters,\n            \"created_at\": now,\n            \"completed_at\": now,\n        }\n\n        complete_result[\"reference_assets\"] = ref_assets\n\n        if create_result.get(\"fallback_applied\"):\n            complete_result[\"fallback_applied\"] = True\n            complete_result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n\n        return complete_result\n\n    def _save_result(self, manager: SeedanceManager, complete_result: Dict[str, Any]) -> Dict[str, Any]:\n        try:\n            local_result = manager._save_video_locally(complete_result)\n        except Exception as save_err:  # pylint: disable=broad-except\n            logger.error(f\"保存视频失败: {save_err}\")\n            return self._failure(f\"保存视频失败: {save_err}\")\n\n        if not isinstance(local_result, dict):\n            return self._failure(\"视频保存返回无效结果\")\n\n        if local_result.get(\"local_save_error\"):\n            return self._failure(f\"视频保存失败: {local_result['local_save_error']}\")\n\n        merged = {**complete_result, **local_result}\n        merged[\"success\"] = True\n        return merged\n\n    def _apply_watermark_config(self, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        统一应用水印配置，优先使用传入配置，其次使用 config_api.LOCAL_WATERMARK_CONFIG。\n        \"\"\"\n        watermark_config = params.get(\"watermark_config\", self.unified_config.get_watermark_config())\n        normalized = {\n            \"watermark_enabled\": watermark_config.get(\"enabled\", False),\n            \"watermark_text\": watermark_config.get(\"text\", \"\"),\n            \"watermark_opacity\": watermark_config.get(\"opacity\", 0.0),\n            \"watermark_position\": watermark_config.get(\"position\", \"bottom_right\"),\n            \"watermark_font_size\": watermark_config.get(\"font_size\", 0),\n        }\n        logger.info(\n            \"视频水印配置应用: enabled=%s text=%s opacity=%s position=%s font_size=%s\",\n            normalized[\"watermark_enabled\"],\n            normalized[\"watermark_text\"],\n            normalized[\"watermark_opacity\"],\n            normalized[\"watermark_position\"],\n            normalized[\"watermark_font_size\"],\n        )\n        return normalized\n\n    @staticmethod\n    def _emit_progress(callback: ProgressCallback, message: str, percentage: Optional[float] = None) -> None:\n        if callback:\n            try:\n                callback(percentage, message)\n            except Exception:\n                logger.debug(\"进度回调执行失败，已忽略。\")\n\n    @staticmethod\n    def _failure(message: str) -> Dict[str, Any]:\n        return {\"success\": False, \"error\": message}\n\n    @staticmethod\n    def _is_cancelled(should_cancel: CancelCallback) -> bool:\n        return bool(should_cancel and callable(should_cancel) and should_cancel())\n\n    @staticmethod\n    def _cancelled() -> Dict[str, Any]:\n        return {\"success\": False, \"error\": \"用户已取消操作\"}\n\n    def _request_remote_cancel(self, manager: Optional[SeedanceManager], task_id: Optional[str]) -> None:\n        \"\"\"尝试向服务端发送取消任务请求，失败时仅记录日志。\"\"\"\n        if not manager or not task_id:\n            return\n\n        try:\n            cancel_result = manager.client.cancel_task(task_id)\n            if cancel_result.get(\"success\"):\n                logger.info(f\"已向服务端成功发送取消请求: {task_id}\")\n            else:\n                logger.warning(\n                    f\"服务端取消请求失败（任务可能已在running状态）: {cancel_result.get('error', '未知错误')}\"\n                )\n        except Exception as exc:  # pylint: disable=broad-except\n            logger.warning(f\"服务端取消请求异常: {exc}\")\n\n    @staticmethod\n    def _safe_int(value: Any, default: int = 0, minimum: Optional[int] = None) -> int:\n        try:\n            parsed = int(value)\n            if minimum is not None:\n                parsed = max(parsed, minimum)\n            return parsed\n        except Exception:\n            return default\n","numLines":575,"startLine":1,"totalLines":575}}}
{"parentUuid":"87d6c62d-cb72-44ec-9ac3-1410bbf339ff","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ReP66ppBwmaHfrDELbzXBy","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→# -*- coding: utf-8 -*-\n     3→\"\"\"\n     4→水印配置管理 - 单一真源\n     5→\n     6→职责：\n     7→- 提供本地水印配置\n     8→- 提供API水印配置\n     9→\n    10→迁移自：\n    11→- config_api.py 的 LOCAL_WATERMARK_CONFIG\n    12→- config_api.py 的 API_WATERMARK_CONFIG\n    13→\"\"\"\n    14→\n    15→from typing import Dict, Any\n    16→\n    17→\n    18→# =============================================================================\n    19→# 水印配置定义\n    20→# =============================================================================\n    21→\n    22→# 本地水印配置（正式版禁用）\n    23→LOCAL_WATERMARK_CONFIG = {\n    24→    \"enabled\": False,\n    25→    \"text\": \"\",\n    26→    \"opacity\": 0.0,\n    27→    \"position\": \"bottom_right\",\n    28→    \"font_size\": 0,\n    29→}\n    30→\n    31→# API水印配置（正式版禁用）\n    32→API_WATERMARK_CONFIG = {\n    33→    \"image_watermark\": False,\n    34→    \"video_watermark\": False,\n    35→}\n    36→\n    37→\n    38→# =============================================================================\n    39→# 访问接口\n    40→# =============================================================================\n    41→\n    42→def get_watermark_config() -> Dict[str, Any]:\n    43→    \"\"\"获取水印配置\n    44→\n    45→    Returns:\n    46→        水印配置字典，包含以下字段：\n    47→        - enabled: bool - 是否启用水印\n    48→        - text: str - 水印文字\n    49→        - opacity: float - 透明度（0.0-1.0）\n    50→        - position: str - 位置（如 'bottom_right'）\n    51→        - font_size: int - 字体大小\n    52→    \"\"\"\n    53→    return LOCAL_WATERMARK_CONFIG.copy()\n    54→\n    55→\n    56→def is_watermark_enabled() -> bool:\n    57→    \"\"\"快捷方法：检查水印是否启用\n    58→\n    59→    Returns:\n    60→        是否启用水印\n    61→    \"\"\"\n    62→    return LOCAL_WATERMARK_CONFIG.get(\"enabled\", False)\n    63→\n    64→\n    65→def get_api_watermark_config() -> Dict[str, Any]:\n    66→    \"\"\"获取API水印配置\n    67→\n    68→    Returns:\n    69→        API水印配置字典\n    70→    \"\"\"\n    71→    return API_WATERMARK_CONFIG.copy()\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"fe22fada-358a-4541-899a-15a1e0370dff","timestamp":"2025-12-30T09:55:47.014Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/config/sources/watermark_config.py","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n水印配置管理 - 单一真源\n\n职责：\n- 提供本地水印配置\n- 提供API水印配置\n\n迁移自：\n- config_api.py 的 LOCAL_WATERMARK_CONFIG\n- config_api.py 的 API_WATERMARK_CONFIG\n\"\"\"\n\nfrom typing import Dict, Any\n\n\n# =============================================================================\n# 水印配置定义\n# =============================================================================\n\n# 本地水印配置（正式版禁用）\nLOCAL_WATERMARK_CONFIG = {\n    \"enabled\": False,\n    \"text\": \"\",\n    \"opacity\": 0.0,\n    \"position\": \"bottom_right\",\n    \"font_size\": 0,\n}\n\n# API水印配置（正式版禁用）\nAPI_WATERMARK_CONFIG = {\n    \"image_watermark\": False,\n    \"video_watermark\": False,\n}\n\n\n# =============================================================================\n# 访问接口\n# =============================================================================\n\ndef get_watermark_config() -> Dict[str, Any]:\n    \"\"\"获取水印配置\n\n    Returns:\n        水印配置字典，包含以下字段：\n        - enabled: bool - 是否启用水印\n        - text: str - 水印文字\n        - opacity: float - 透明度（0.0-1.0）\n        - position: str - 位置（如 'bottom_right'）\n        - font_size: int - 字体大小\n    \"\"\"\n    return LOCAL_WATERMARK_CONFIG.copy()\n\n\ndef is_watermark_enabled() -> bool:\n    \"\"\"快捷方法：检查水印是否启用\n\n    Returns:\n        是否启用水印\n    \"\"\"\n    return LOCAL_WATERMARK_CONFIG.get(\"enabled\", False)\n\n\ndef get_api_watermark_config() -> Dict[str, Any]:\n    \"\"\"获取API水印配置\n\n    Returns:\n        API水印配置字典\n    \"\"\"\n    return API_WATERMARK_CONFIG.copy()","numLines":71,"startLine":1,"totalLines":71}}}
{"parentUuid":"fe22fada-358a-4541-899a-15a1e0370dff","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UEcHBnwhK4wsHMFUXHmv7y","type":"tool_result","content":"     1→# Seedance视频生成管理器\n     2→# 负责视频生成的业务逻辑和本地存储管理\n     3→# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n     4→# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n     5→\n     6→import os\n     7→import uuid\n     8→import requests\n     9→from ..utils.safe_requests import safe_requests_get\n    10→import hashlib\n    11→import mimetypes\n    12→import base64\n    13→import pandas as pd\n    14→from datetime import datetime\n    15→from pathlib import Path\n    16→from typing import Dict, Any, List, Optional, Tuple\n    17→from urllib.parse import urlparse\n    18→from loguru import logger\n    19→from PIL import Image\n    20→\n    21→from ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n    22→\n    23→from .client import SeedanceClient\n    24→from ..storage import get_v2_storage_manager\n    25→from ..provider.schema import (\n    26→    VideoParams,\n    27→    validate_and_normalize_video,\n    28→)\n    29→from config.unified_config import get_unified_config\n    30→from config_api import get_storage_dir\n    31→# 使用统一水印服务（edition/watermark_service.py）\n    32→from edition.watermark_service import (\n    33→    should_add_watermark,\n    34→    get_watermark_text,\n    35→    get_watermark_opacity,\n    36→)\n    37→\n    38→# API水印配置保持不变（用于服务端水印）\n    39→try:  # pragma: no cover\n    40→    from config_api import API_WATERMARK_CONFIG  # type: ignore\n    41→except Exception:  # pragma: no cover\n    42→    API_WATERMARK_CONFIG = {\n    43→        \"image_watermark\": False,\n    44→        \"video_watermark\": False,\n    45→    }\n    46→try:  # pragma: no cover\n    47→    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\n    48→except Exception:  # pragma: no cover\n    49→    LOCAL_WATERMARK_CONFIG = {\n    50→        \"enabled\": False,\n    51→        \"text\": \"\",\n    52→        \"opacity\": 0.0,\n    53→        \"position\": \"bottom_right\",\n    54→        \"font_size\": 0,\n    55→    }\n    56→\n    57→\n    58→class SeedanceManager:\n    59→    \"\"\"Seedance视频生成管理器\"\"\"\n    60→\n    61→    def __init__(self, api_key: str = None):\n    62→        \"\"\"\n    63→        初始化Seedance管理器\n    64→\n    65→        Args:\n    66→            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n    67→        \"\"\"\n    68→        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n    69→        if api_key is None:\n    70→            try:\n    71→                api_key = get_unified_config().get_api_key(\"volcengine\")\n    72→            except Exception as exc:\n    73→                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n    74→        \n    75→        self.client = SeedanceClient(api_key)\n    76→\n    77→        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n    78→        storage_path = get_storage_dir()\n    79→        Path(storage_path).mkdir(parents=True, exist_ok=True)\n    80→\n    81→        # 使用V2统一存储管理器（与单一真源对齐）\n    82→        self.storage_manager = get_v2_storage_manager(storage_path)\n    83→        \n    84→        # 保持兼容性别名\n    85→        self.file_manager = self.storage_manager\n    86→        self.metadata_manager = self.storage_manager\n    87→        self.video_storage_manager = self.storage_manager\n    88→        \n    89→        # 保留原有的目录属性以保持兼容性\n    90→        self.data_dir = Path(self.storage_manager.root_path)\n    91→        self.videos_dir = self.data_dir / \"videos\"\n    92→        self.metadata_dir = self.data_dir / \"metadata\"\n    93→\n    94→        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n    95→\n    96→    def generate_video(\n    97→        self,\n    98→        prompt: str,\n    99→        image_path: Optional[str] = None,\n   100→        first_frame_path: Optional[str] = None,\n   101→        last_frame_path: Optional[str] = None,\n   102→        duration: float = 4.0,\n   103→        seed: int = -1,\n   104→        watermark: bool = False,\n   105→        save_local: bool = True,\n   106→        wait_for_completion: bool = True,\n   107→        # 新增参数（P0b）\n   108→        resolution_grade: Optional[str] = None,\n   109→        ratio: Optional[str] = None,\n   110→        fps: int = 24,\n   111→        camera_fixed: bool = True,\n   112→        use_pro_model: bool = True,\n   113→        model_type: Optional[str] = None,\n   114→        model_variant: Optional[str] = None,\n   115→        generate_audio: Optional[bool] = None,\n   116→        reference_images: Optional[List[Any]] = None,\n   117→        generation_id: Optional[str] = None,\n   118→    ) -> Dict[str, Any]:\n   119→        \"\"\"\n   120→        生成视频并保存到本地\n   121→\n   122→        Args:\n   123→            image_path: 输入图像路径\n   124→            duration: 视频时长（秒）\n   125→            motion_strength: 运动强度 (0.1-1.0)\n   126→            seed: 随机种子\n   127→            watermark: 保留参数（服务端水印由配置决定）\n   128→            save_local: 是否保存到本地\n   129→            wait_for_completion: 是否等待任务完成\n   130→\n   131→        Returns:\n   132→            Dict: 生成结果\n   133→        \"\"\"\n   134→        logger.info(\"开始视频生成任务(Manager)\")\n   135→\n   136→        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n   137→        task_id = generation_id or str(uuid.uuid4())\n   138→\n   139→        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n   140→        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n   141→            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n   142→\n   143→        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n   144→        # 构建待处理的图片列表\n   145→        all_input_images = []\n   146→\n   147→        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n   148→        frame_inputs = []\n   149→        if first_frame_path:\n   150→            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n   151→        if last_frame_path:\n   152→            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n   153→        elif image_path and not first_frame_path:\n   154→            frame_inputs.append({'path': image_path, 'type': 'image'})\n   155→\n   156→        all_input_images.extend(frame_inputs)\n   157→\n   158→        # 2. 添加参考图\n   159→        if reference_images:\n   160→            for ref in reference_images:\n   161→                if isinstance(ref, dict):\n   162→                    ref_copy = dict(ref)\n   163→                    ref_copy['type'] = ref_copy.get('type', 'reference')\n   164→                    all_input_images.append(ref_copy)\n   165→                else:\n   166→                    all_input_images.append({'path': ref, 'type': 'reference'})\n   167→\n   168→        # 3. 统一处理（复制到 references 目录）\n   169→        ref_summary = self._process_reference_assets(\n   170→            all_input_images if all_input_images else None,\n   171→            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n   172→            expected_outputs=1,\n   173→        )\n   174→        ref_assets = ref_summary.get('assets', [])\n   175→        ref_paths: List[str] = list(ref_summary.get('paths', []))\n   176→\n   177→        # 4. 分离帧图片和参考图\n   178→        frame_assets = {}\n   179→        pure_ref_assets = []\n   180→        for asset in ref_assets:\n   181→            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n   182→            if asset_type in ('first_frame', 'last_frame', 'image'):\n   183→                frame_assets[asset_type] = asset\n   184→            else:\n   185→                pure_ref_assets.append(asset)\n   186→\n   187→        # 5. 提取帧图片的相对路径（用于存储）\n   188→        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n   189→        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n   190→        stored_image_path = frame_assets.get('image', {}).get('path')\n   191→\n   192→        # 6. 提取参考图的 payload（用于 API 调用）\n   193→        ref_payloads: List[str] = []\n   194→        for asset in pure_ref_assets:\n   195→            payload = asset.get('_payload_b64')\n   196→            if payload:\n   197→                ref_payloads.append(payload)\n   198→\n   199→        if ref_summary.get('errors'):\n   200→            logger.warning(\n   201→                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n   202→            )\n   203→        if ref_summary.get('warnings'):\n   204→            for warn in ref_summary['warnings']:\n   205→                logger.warning(f\"图片处理提示: {warn}\")\n   206→\n   207→        watermark_enabled = bool(\n   208→            LOCAL_WATERMARK_CONFIG.get(\"enabled\", API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n   209→        )\n   210→\n   211→        create_kwargs = dict(\n   212→            prompt=prompt,\n   213→            duration=int(duration),\n   214→            seed=None if seed == -1 else seed,\n   215→            fps=fps,\n   216→            resolution_grade=resolution_grade,\n   217→            ratio=ratio,\n   218→            watermark=watermark_enabled,\n   219→            camera_fixed=bool(camera_fixed),\n   220→            use_pro_model=use_pro_model,\n   221→            model_type=model_type,\n   222→            model_variant=model_variant,\n   223→            generate_audio=generate_audio,\n   224→        )\n   225→        if ref_payloads:\n   226→            create_kwargs['reference_images'] = ref_payloads\n   227→        if first_frame_path and last_frame_path:\n   228→            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n   229→        elif image_path:\n   230→            create_kwargs.update(dict(image_path=image_path))\n   231→        # 文生视频：不追加图片参数\n   232→\n   233→        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n   234→        precheck_fb = False\n   235→        precheck_reason = \"\"\n   236→        try:\n   237→            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n   238→                VideoParams(\n   239→                    prompt=prompt,\n   240→                    image_path=None,  # 校验不依赖图像数据\n   241→                    first_frame_path=None,\n   242→                    last_frame_path=None,\n   243→                    duration=int(duration),\n   244→                    fps=int(fps),\n   245→                    seed=(None if seed == -1 else seed),\n   246→                    camera_fixed=bool(camera_fixed),\n   247→                    watermark=bool(watermark),\n   248→                    resolution_grade=resolution_grade,\n   249→                    ratio=ratio,\n   250→                    use_pro_model=bool(use_pro_model),\n   251→                    model_variant=model_variant,\n   252→                    generate_audio=generate_audio,\n   253→                )\n   254→            )\n   255→            logger.info(\n   256→                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n   257→            )\n   258→            if fb:\n   259→                logger.warning(f\"前置参数回退建议: {reason}\")\n   260→            precheck_fb = fb\n   261→            precheck_reason = reason\n   262→        except Exception as _e:\n   263→            logger.debug(f\"前置参数校验跳过: {_e}\")\n   264→\n   265→        create_result = self.client.create_video_task(**create_kwargs)\n   266→        params_sent = create_result.get(\"params_sent\") if isinstance(create_result, dict) else None\n   267→\n   268→        # 用实际执行参数覆盖用户输入（如 Lite 参考图模式 1080p→720p 降级）\n   269→        if create_result.get(\"success\"):\n   270→            actual_rs = create_result.get('used_rs')\n   271→            actual_rt = create_result.get('used_rt')\n   272→            if actual_rs:\n   273→                logger.debug(f\"参数覆盖|resolution_grade: 用户输入={resolution_grade} -> 实际执行={actual_rs}\")\n   274→                resolution_grade = actual_rs\n   275→            if actual_rt:\n   276→                logger.debug(f\"参数覆盖|ratio: 用户输入={ratio} -> 实际执行={actual_rt}\")\n   277→                ratio = actual_rt\n   278→\n   279→        if not create_result[\"success\"]:\n   280→            self._cleanup_reference_paths(ref_paths)\n   281→            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n   282→            return create_result\n   283→\n   284→        api_task_id = create_result[\"task_id\"]\n   285→\n   286→        result = {\n   287→            \"task_id\": task_id,\n   288→            \"api_task_id\": api_task_id,\n   289→            \"params_sent\": params_sent,\n   290→            \"success\": True,\n   291→            \"type\": \"image_to_video\",\n   292→            \"input_image\": image_path,\n   293→            \"status\": \"pending\",\n   294→            \"parameters\": {\n   295→                \"prompt\": prompt,\n   296→                \"duration\": duration,\n   297→                \"seed\": (None if seed == -1 else seed),\n   298→                \"watermark\": watermark_enabled,\n   299→                \"resolution_grade\": resolution_grade,\n   300→                \"ratio\": ratio,\n   301→                \"fps\": fps,\n   302→                \"camera_fixed\": bool(camera_fixed),\n   303→                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n   304→                \"first_frame\": stored_first_frame,\n   305→                \"last_frame\": stored_last_frame,\n   306→                \"image_path\": stored_image_path,\n   307→            },\n   308→            \"created_at\": datetime.now().isoformat(),\n   309→        }\n   310→\n   311→        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n   312→        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n   313→        result['reference_assets'] = sanitized_refs\n   314→        if ref_summary.get('errors'):\n   315→            result['reference_asset_errors'] = ref_summary['errors']\n   316→        if ref_summary.get('warnings'):\n   317→            result['reference_asset_warnings'] = ref_summary['warnings']\n   318→        if precheck_fb and precheck_reason:\n   319→            result.setdefault('fallback_applied', True)\n   320→            if result.get('fallback_reason'):\n   321→                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n   322→            else:\n   323→                result['fallback_reason'] = precheck_reason\n   324→\n   325→        masked_ids = self._summarize_reference_ids(sanitized_refs)\n   326→        logger.info(\n   327→            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n   328→            len(sanitized_refs),\n   329→            masked_ids or \"-\",\n   330→            self._provider_hint(),\n   331→        )\n   332→\n   333→        # 透传回退信息\n   334→        if create_result.get(\"fallback_applied\"):\n   335→            result[\"fallback_applied\"] = True\n   336→            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n   337→\n   338→        # 如果等待完成，轮询任务状态\n   339→        if wait_for_completion:\n   340→            completion_result = self.client.wait_for_completion(api_task_id)\n   341→\n   342→            if completion_result[\"success\"]:\n   343→                if completion_result[\"status\"] == \"success\":\n   344→                    result[\"status\"] = \"success\"\n   345→                    result[\"video_url\"] = completion_result[\"video_url\"]\n   346→                    result[\"duration\"] = completion_result.get(\"duration\")\n   347→                    result[\"file_size\"] = completion_result.get(\"file_size\")\n   348→                    result[\"completed_at\"] = datetime.now().isoformat()\n   349→\n   350→                    # 保存到本地\n   351→                    if save_local:\n   352→                        local_result = self._save_video_locally(result)\n   353→                        result.update(local_result)\n   354→                        # 注：file_size 已在 _save_video_locally 内部设置到 metadata['parameters'] 中\n   355→                        if local_result.get('local_save_error'):\n   356→                            self._cleanup_reference_paths(ref_paths)\n   357→                            result['parameters'][\"reference_assets\"] = []\n   358→                            result['reference_assets'] = []\n   359→                            warnings = result.setdefault('reference_asset_warnings', [])\n   360→                            warnings.append(\"视频保存失败，参考图已回滚\")\n   361→                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n   362→\n   363→                    logger.success(f\"视频生成任务完成: {task_id}\")\n   364→                else:\n   365→                    result[\"status\"] = completion_result[\"status\"]\n   366→                    result[\"error\"] = completion_result.get(\"error\")\n   367→                    result[\"error_code\"] = completion_result.get(\"error_code\")\n   368→                    logger.error(f\"视频生成任务失败: {result['error']}\")\n   369→            else:\n   370→                result[\"status\"] = \"failed\"\n   371→                result[\"error\"] = completion_result[\"error\"]\n   372→                result[\"error_code\"] = completion_result[\"error_code\"]\n   373→                logger.error(f\"等待任务完成失败: {result['error']}\")\n   374→\n   375→        # 注：元数据已通过 save_content_file() 保存，无需重复调用\n   376→\n   377→        return result\n   378→\n   379→    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n   380→        \"\"\"\n   381→        检查任务状态\n   382→\n   383→        Args:\n   384→            task_id: 本地任务ID\n   385→\n   386→        Returns:\n   387→            Dict: 任务状态信息\n   388→        \"\"\"\n   389→        logger.info(f\"检查任务状态: {task_id}\")\n   390→\n   391→        # 从元数据中获取任务信息\n   392→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   393→\n   394→        if not task_record:\n   395→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   396→\n   397→        api_task_id = task_record.get(\"api_task_id\")\n   398→        if not api_task_id:\n   399→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   400→\n   401→        # 查询API任务状态\n   402→        status_result = self.client.get_task_status(api_task_id)\n   403→\n   404→        if status_result[\"success\"]:\n   405→            # 更新本地记录\n   406→            updates = {\n   407→                \"status\": status_result[\"status\"],\n   408→                \"progress\": status_result.get(\"progress\", 0),\n   409→                \"updated_at\": datetime.now().isoformat(),\n   410→            }\n   411→\n   412→            # 如果任务完成，添加结果信息\n   413→            if status_result[\"status\"] == \"success\":\n   414→                updates[\"video_url\"] = status_result[\"video_url\"]\n   415→                updates[\"duration\"] = status_result.get(\"duration\")\n   416→                updates[\"file_size\"] = status_result.get(\"file_size\")\n   417→                updates[\"completed_at\"] = datetime.now().isoformat()\n   418→\n   419→            # 如果任务失败，添加错误信息\n   420→            elif status_result[\"status\"] == \"failed\":\n   421→                updates[\"error\"] = status_result.get(\"error\")\n   422→                updates[\"error_code\"] = status_result.get(\"error_code\")\n   423→\n   424→            # 更新元数据\n   425→            self.metadata_manager.update_record(task_id, updates)\n   426→\n   427→            # 合并任务信息\n   428→            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n   429→\n   430→            return result\n   431→        else:\n   432→            return status_result\n   433→\n   434→    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n   435→        \"\"\"\n   436→        下载已完成的视频\n   437→\n   438→        Args:\n   439→            task_id: 本地任务ID\n   440→\n   441→        Returns:\n   442→            Dict: 下载结果\n   443→        \"\"\"\n   444→        logger.info(f\"下载视频: {task_id}\")\n   445→\n   446→        # 获取任务信息\n   447→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   448→\n   449→        if not task_record:\n   450→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   451→\n   452→        # 检查任务状态\n   453→        if task_record.get(\"status\") != \"success\":\n   454→            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n   455→\n   456→        video_url = task_record.get(\"video_url\")\n   457→        if not video_url:\n   458→            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n   459→\n   460→        # 检查是否已下载\n   461→        local_path = task_record.get(\"local_path\")\n   462→        if local_path and Path(local_path).exists():\n   463→            logger.info(\n   464→                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n   465→            )\n   466→            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n   467→\n   468→        # 下载视频\n   469→        try:\n   470→            response = safe_requests_get(video_url, timeout=300)\n   471→\n   472→            # 生成本地文件名\n   473→            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n   474→            task_id_short = task_id[:8]\n   475→            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n   476→\n   477→            # 保存文件\n   478→            local_path = self.file_manager.save_file(filename, response.content)\n   479→\n   480→            # 获取视频信息\n   481→            video_info = self._get_video_info(local_path)\n   482→\n   483→            # 更新元数据\n   484→            updates = {\n   485→                \"filename\": filename,\n   486→                \"local_path\": str(local_path),\n   487→                \"local_file_size\": local_path.stat().st_size,\n   488→                \"downloaded_at\": datetime.now().isoformat(),\n   489→            }\n   490→\n   491→            if video_info:\n   492→                updates.update(video_info)\n   493→\n   494→            self.metadata_manager.update_record(task_id, updates)\n   495→\n   496→            logger.success(f\"视频下载成功: {filename}\")\n   497→\n   498→            summary = {\n   499→                \"success\": True,\n   500→                \"local_path\": str(local_path),\n   501→                \"filename\": filename,\n   502→                \"file_size\": local_path.stat().st_size,\n   503→                \"video_info\": video_info,\n   504→            }\n   505→            try:\n   506→                logger.info(\n   507→                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n   508→                )\n   509→            except Exception:\n   510→                pass\n   511→            return summary\n   512→\n   513→        except Exception as e:\n   514→            logger.error(f\"下载视频失败: {e}\")\n   515→            try:\n   516→                logger.info(\n   517→                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n   518→                )\n   519→            except Exception:\n   520→                pass\n   521→            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n   522→\n   523→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n   524→        \"\"\"\n   525→        取消任务\n   526→\n   527→        Args:\n   528→            task_id: 本地任务ID\n   529→\n   530→        Returns:\n   531→            Dict: 取消结果\n   532→        \"\"\"\n   533→        logger.info(f\"取消任务: {task_id}\")\n   534→\n   535→        # 获取任务信息\n   536→        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n   537→\n   538→        if not task_record:\n   539→            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n   540→\n   541→        api_task_id = task_record.get(\"api_task_id\")\n   542→        if not api_task_id:\n   543→            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n   544→\n   545→        # 调用API取消任务\n   546→        cancel_result = self.client.cancel_task(api_task_id)\n   547→\n   548→        if cancel_result[\"success\"]:\n   549→            # 更新本地记录\n   550→            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n   551→\n   552→            self.metadata_manager.update_record(task_id, updates)\n   553→\n   554→            logger.success(f\"任务取消成功: {task_id}\")\n   555→\n   556→        return cancel_result\n   557→\n   558→    def batch_generate_videos(\n   559→        self,\n   560→        image_paths: List[str],\n   561→        duration: float = 4.0,\n   562→        motion_strength: float = 0.8,\n   563→        watermark: bool = True,\n   564→        save_local: bool = True,\n   565→        wait_for_completion: bool = False,\n   566→    ) -> List[Dict[str, Any]]:\n   567→        \"\"\"\n   568→        批量生成视频\n   569→\n   570→        Args:\n   571→            image_paths: 图像路径列表\n   572→            duration: 视频时长\n   573→            motion_strength: 运动强度\n   574→            watermark: 保留参数（服务端水印由配置决定）\n   575→            save_local: 是否保存到本地\n   576→            wait_for_completion: 是否等待任务完成\n   577→\n   578→        Returns:\n   579→            List[Dict]: 生成结果列表\n   580→        \"\"\"\n   581→        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n   582→\n   583→        results = []\n   584→        for i, image_path in enumerate(image_paths, 1):\n   585→            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n   586→\n   587→            result = self.generate_video(\n   588→                image_path=image_path,\n   589→                duration=duration,\n   590→                motion_strength=motion_strength,\n   591→                watermark=watermark,\n   592→                save_local=save_local,\n   593→                wait_for_completion=wait_for_completion,\n   594→            )\n   595→\n   596→            results.append(result)\n   597→\n   598→        success_count = sum(1 for r in results if r[\"success\"])\n   599→        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n   600→\n   601→        return results\n   602→\n   603→    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n   604→        \"\"\"\n   605→        保存视频到本地\n   606→\n   607→        Args:\n   608→            result: API生成结果\n   609→\n   610→        Returns:\n   611→            Dict: 包含本地文件信息的字典\n   612→        \"\"\"\n   613→        try:\n   614→            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n   615→\n   616→            # Validate inputs\n   617→            task_id = result.get(\"task_id\")\n   618→            video_url = result.get(\"video_url\")\n   619→            if not task_id:\n   620→                raise ValueError(\"Task ID is required\")\n   621→            if not video_url:\n   622→                raise ValueError(\"Video URL is required\")\n   623→            \n   624→            # 下载视频\n   625→            logger.info(f\"Downloading video from {video_url}\")\n   626→            try:\n   627→                response = safe_requests_get(video_url, stream=True, timeout=300)\n   628→                \n   629→                # Check content type\n   630→                content_type = response.headers.get('content-type', '')\n   631→                if 'video' not in content_type:\n   632→                    logger.warning(f\"Unexpected content type: {content_type}\")\n   633→                \n   634→                # Get file size for progress tracking\n   635→                total_size = int(response.headers.get('content-length', 0))\n   636→                video_data = response.content\n   637→                \n   638→                logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n   639→                \n   640→            except requests.exceptions.RequestException as e:\n   641→                logger.error(f\"Network error downloading video: {e}\")\n   642→                raise Exception(f\"Failed to download video: {str(e)}\")\n   643→            \n   644→            # 在保存前获取真实视频信息（写临时文件以便读取）\n   645→            actual_width = None\n   646→            actual_height = None\n   647→            actual_fps = None\n   648→            actual_duration = None\n   649→            try:\n   650→                import tempfile\n   651→                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   652→                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n   653→                    tf.write(video_data)\n   654→                    temp_path = Path(tf.name)\n   655→                # 使用缩略图工具的get_video_info\n   656→                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   657→                gen = VideoThumbnailGenerator(str(thumbs_dir))\n   658→                info = gen.get_video_info(str(temp_path))\n   659→                try:\n   660→                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n   661→                except Exception:\n   662→                    pass\n   663→                if info:\n   664→                    actual_width = info.get('width')\n   665→                    actual_height = info.get('height')\n   666→                    actual_fps = info.get('fps')\n   667→                    actual_duration = info.get('duration')\n   668→            except Exception as e:\n   669→                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n   670→\n   671→            # 准备元数据（适配UnifiedStorageManager的格式）\n   672→            metadata = {\n   673→                'generation_id': task_id,\n   674→                'task_id': task_id,\n   675→                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n   676→                'parameters': {\n   677→                    **result.get('parameters', {}),\n   678→                    # 设置文件大小（在保存前就设置，确保写入数据库）\n   679→                    'file_size': len(video_data),\n   680→                    # 回填真实视频信息\n   681→                    **({} if actual_width is None else {'width': actual_width}),\n   682→                    **({} if actual_height is None else {'height': actual_height}),\n   683→                    **({} if actual_fps is None else {'fps': actual_fps}),\n   684→                    **({} if actual_duration is None else {'duration': actual_duration}),\n   685→                    # 透传fallback信息\n   686→                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n   687→                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n   688→                },\n   689→                'model': self._get_display_model_name(result),\n   690→                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n   691→                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n   692→                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n   693→                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n   694→                'generation_time': result.get('generation_time', 0),\n   695→                'status': result.get('status', 'completed'),\n   696→                'batch_id': result.get('batch_id', '')\n   697→            }\n   698→\n   699→            # 使用统一存储管理器保存文件\n   700→            save_result = self.storage_manager.save_content_file(\n   701→                content_type='videos',\n   702→                file_data=video_data,\n   703→                url=video_url,\n   704→                metadata=metadata\n   705→            )\n   706→\n   707→            # 缩略图生成（已由UnifiedStorageManager处理）\n   708→            thumbnail_local_path = save_result.get('thumbnail_path')\n   709→            thumbnail_filename = None\n   710→            if thumbnail_local_path:\n   711→                thumbnail_filename = Path(thumbnail_local_path).name\n   712→                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n   713→            else:\n   714→                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n   715→\n   716→            # 下载并保存API返回的缩略图（如果有）作为备用\n   717→            api_thumbnail_local_path = None\n   718→            api_thumbnail_filename = None\n   719→            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n   720→                try:\n   721→                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n   722→                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n   723→                    \n   724→                    # 使用统一存储管理器保存备用缩略图\n   725→                    backup_metadata = {\n   726→                        'generation_id': task_id,\n   727→                        'prompt': 'API backup thumbnail for video',\n   728→                        'model': 'seedance',\n   729→                        'width': 320,\n   730→                        'height': 180,\n   731→                        'status': 'completed'\n   732→                    }\n   733→                    \n   734→                    backup_result = self.storage_manager.save_content_file(\n   735→                        content_type='images',  # 缩略图保存为图片\n   736→                        file_data=thumbnail_response.content,\n   737→                        url=result[\"thumbnail_url\"],\n   738→                        metadata=backup_metadata\n   739→                    )\n   740→                    \n   741→                    api_thumbnail_local_path = backup_result['local_path']\n   742→                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n   743→                    \n   744→                    # 如果本地缩略图生成失败，使用API缩略图\n   745→                    if not thumbnail_local_path:\n   746→                        thumbnail_local_path = api_thumbnail_local_path\n   747→                        thumbnail_filename = api_thumbnail_filename\n   748→                    \n   749→                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n   750→                        \n   751→                except Exception as e:\n   752→                    logger.warning(f\"下载API缩略图失败: {e}\")\n   753→                    api_thumbnail_local_path = None\n   754→                    api_thumbnail_filename = None\n   755→\n   756→            # 获取视频信息\n   757→            local_path = Path(save_result['local_path'])\n   758→            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n   759→            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n   760→                try:\n   761→                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n   762→                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n   763→                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n   764→                    video_info = gen.get_video_info(str(local_path))\n   765→                except Exception:\n   766→                    video_info = {}\n   767→            else:\n   768→                video_info = {\n   769→                    'width': actual_width,\n   770→                    'height': actual_height,\n   771→                    'fps': actual_fps,\n   772→                    'duration': actual_duration,\n   773→                }\n   774→            file_size = local_path.stat().st_size if local_path.exists() else 0\n   775→            \n   776→            logger.success(f\"视频已保存到本地: {local_path.name}\")\n   777→            \n   778→            # 本地视频水印（使用统一水印服务控制）\n   779→            if should_add_watermark():\n   780→                try:\n   781→                    from edition.watermark_service import WatermarkService\n   782→\n   783→                    watermark_text = get_watermark_text() or \"PIGEON\"\n   784→                    try:\n   785→                        opacity = get_watermark_opacity()\n   786→                    except Exception:\n   787→                        opacity = 0.3\n   788→                    opacity = max(0.0, min(opacity, 1.0))\n   789→\n   790→                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n   791→                    watermark_applied = watermark_service.apply_to_video(local_path)\n   792→                    if watermark_applied:\n   793→                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n   794→                    else:\n   795→                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n   796→                except Exception as e:\n   797→                    logger.warning(f\"添加视频水印时出错: {e}\")\n   798→\n   799→            result_obj = {\n   800→                \"local_path\": save_result['local_path'],\n   801→                \"filename\": local_path.name,\n   802→                \"file_path\": save_result['local_path'],  # 保持兼容性\n   803→                \"local_file_size\": file_size,\n   804→                \"video_info\": video_info,\n   805→                # 同步回填至顶层，便于上游使用\n   806→                **({} if not video_info else {\n   807→                    'width': video_info.get('width'),\n   808→                    'height': video_info.get('height'),\n   809→                    'fps': video_info.get('fps'),\n   810→                    'duration': video_info.get('duration'),\n   811→                }),\n   812→                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n   813→                \"thumbnail_filename\": thumbnail_filename,\n   814→                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n   815→                \"api_thumbnail_filename\": api_thumbnail_filename,\n   816→                \"task_id\": task_id,  # 添加task_id以供后续使用\n   817→                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n   818→                \"file_id\": save_result.get('file_id'),\n   819→                \"relative_path\": save_result.get('relative_path'),\n   820→            }\n   821→            try:\n   822→                logger.info(\n   823→                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n   824→                )\n   825→            except Exception:\n   826→                pass\n   827→            return result_obj\n   828→\n   829→        except Exception as e:\n   830→            logger.error(f\"保存视频到本地失败: {e}\")\n   831→            logger.exception(\"Full traceback for video save error:\")\n   832→            try:\n   833→                logger.info(\n   834→                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n   835→                )\n   836→            except Exception:\n   837→                pass\n   838→            return {\"local_save_error\": str(e)}\n   839→\n   840→    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n   841→        checksum = hashlib.sha1(file_data).hexdigest()\n   842→        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n   843→        return f\"ref_{ts}_{checksum[:8]}\"\n   844→\n   845→    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n   846→        source_meta: Dict[str, Any] = {}\n   847→        raw = ref\n   848→        if isinstance(ref, dict):\n   849→            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n   850→                if ref.get(key) is not None:\n   851→                    source_meta[key] = ref.get(key)\n   852→            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n   853→        if raw is None:\n   854→            return None\n   855→\n   856→        extension = source_meta.get('extension')\n   857→        data = None\n   858→        source_repr = source_meta.get('source')\n   859→\n   860→        try:\n   861→            if isinstance(raw, bytes):\n   862→                data = raw\n   863→            elif isinstance(raw, str):\n   864→                stripped = raw.strip()\n   865→                if stripped.startswith('data:') and ';base64,' in stripped:\n   866→                    header, payload = stripped.split(';base64,', 1)\n   867→                    mime_part = header[5:]\n   868→                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n   869→                    data = base64.b64decode(payload)\n   870→                    source_repr = source_repr or mime_part\n   871→                    source_meta.setdefault('type', 'image')\n   872→                elif stripped.startswith(('http://', 'https://')):\n   873→                    resp = safe_requests_get(stripped, timeout=15)\n   874→                    data = resp.content\n   875→                    parsed = urlparse(stripped)\n   876→                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n   877→                    source_repr = source_repr or stripped\n   878→                    source_meta.setdefault('source_url', stripped)\n   879→                else:\n   880→                    path = Path(stripped)\n   881→                    if not path.exists():\n   882→                        logger.warning(f\"参考图像不存在: {stripped}\")\n   883→                        return None\n   884→                    data = path.read_bytes()\n   885→                    extension = extension or path.suffix or '.png'\n   886→                    source_repr = source_repr or path.name\n   887→                    source_meta.setdefault('source_path', str(path))\n   888→            else:\n   889→                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n   890→                return None\n   891→        except Exception as exc:\n   892→            logger.warning(f\"加载参考图失败: {exc}\")\n   893→            return None\n   894→\n   895→        if data is None:\n   896→            return None\n   897→\n   898→        width = source_meta.get('width')\n   899→        height = source_meta.get('height')\n   900→        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n   901→            try:\n   902→                from io import BytesIO\n   903→\n   904→                with Image.open(BytesIO(data)) as img:\n   905→                    width = img.width\n   906→                    height = img.height\n   907→            except Exception:\n   908→                pass\n   909→\n   910→        source_meta['width'] = width\n   911→        source_meta['height'] = height\n   912→        source_meta.setdefault('type', 'image')\n   913→        source_meta['source'] = source_repr or source_meta.get('source')\n   914→\n   915→        return data, extension, source_meta\n   916→\n   917→    def _process_reference_assets(\n   918→        self,\n   919→        references: Optional[List[Any]],\n   920→        *,\n   921→        max_refs: int = MAX_REFERENCE_IMAGES,\n   922→        expected_outputs: int = 1,\n   923→    ) -> Dict[str, Any]:\n   924→        stored: List[Dict[str, Any]] = []\n   925→        absolute_paths: List[str] = []\n   926→        errors: List[str] = []\n   927→        warnings: List[str] = []\n   928→\n   929→        if not references:\n   930→            return {\n   931→                'assets': stored,\n   932→                'paths': absolute_paths,\n   933→                'errors': errors,\n   934→                'warnings': warnings,\n   935→            }\n   936→\n   937→        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n   938→            warnings.append(\n   939→                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n   940→            )\n   941→            references = references[:max_refs]\n   942→\n   943→        for order, item in enumerate(references):\n   944→            load_result = self._load_reference_source(item)\n   945→            if not load_result:\n   946→                errors.append(f\"ref[{order}] 加载失败\")\n   947→                continue\n   948→\n   949→            file_data, extension, meta = load_result\n   950→            meta.setdefault('order', order)\n   951→            meta.setdefault('kind', meta.get('type', 'image'))\n   952→\n   953→            try:\n   954→                asset_id = self._generate_reference_asset_id(file_data)\n   955→                record = self.storage_manager.save_reference_asset(\n   956→                    'images',\n   957→                    file_data,\n   958→                    asset_id=asset_id,\n   959→                    extension=extension,\n   960→                    metadata=meta,\n   961→                )\n   962→                try:\n   963→                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n   964→                except Exception:\n   965→                    record['_payload_b64'] = None\n   966→                record['_source_meta'] = meta\n   967→                stored.append(record)\n   968→                if record.get('absolute_path'):\n   969→                    absolute_paths.append(record['absolute_path'])\n   970→            except Exception as exc:\n   971→                logger.warning(f\"保存参考图失败: {exc}\")\n   972→                errors.append(f\"ref[{order}] 保存失败\")\n   973→\n   974→        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n   975→            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n   976→            if len(stored) > allowed:\n   977→                warnings.append(\n   978→                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n   979→                )\n   980→                stored = stored[:allowed]\n   981→                absolute_paths = absolute_paths[:allowed]\n   982→\n   983→        return {\n   984→            'assets': stored,\n   985→            'paths': absolute_paths,\n   986→            'errors': errors,\n   987→            'warnings': warnings,\n   988→        }\n   989→\n   990→    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n   991→        cleaned: List[Dict[str, Any]] = []\n   992→        for rec in assets or []:\n   993→            rec.pop('_payload_b64', None)\n   994→            rec.pop('_source_meta', None)\n   995→            rec.pop('absolute_path', None)\n   996→            cleaned.append({\n   997→                'id': rec.get('id') or rec.get('reference_id'),\n   998→                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n   999→                'type': rec.get('type'),\n  1000→                'kind': rec.get('kind'),\n  1001→                'source': rec.get('source'),\n  1002→                'order': rec.get('order'),\n  1003→                'checksum': rec.get('checksum'),\n  1004→                'size': rec.get('size'),\n  1005→                'width': rec.get('width'),\n  1006→                'height': rec.get('height'),\n  1007→                'created_at': rec.get('created_at'),\n  1008→            })\n  1009→        return cleaned\n  1010→\n  1011→    @staticmethod\n  1012→    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n  1013→        masked: List[str] = []\n  1014→        for rec in assets or []:\n  1015→            rid = rec.get('id') or ''\n  1016→            if not rid:\n  1017→                continue\n  1018→            masked.append(f\"{rid[:6]}***\")\n  1019→        return \",\".join(masked)\n  1020→\n  1021→    @staticmethod\n  1022→    def _provider_hint() -> str:\n  1023→        try:\n  1024→            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n  1025→        except Exception:\n  1026→            return \"seedance\"\n  1027→\n  1028→    @staticmethod\n  1029→    def _cleanup_reference_paths(paths: List[str]):\n  1030→        for path in paths or []:\n  1031→            try:\n  1032→                if path and Path(path).exists():\n  1033→                    Path(path).unlink(missing_ok=True)\n  1034→            except Exception as exc:\n  1035→                logger.debug(f\"参考图清理失败: {exc}\")\n  1036→\n  1037→    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n  1038→        \"\"\"\n  1039→        将绝对路径转换为相对路径（相对于存储根目录）\n  1040→\n  1041→        如果路径已经是相对路径或无法转换，返回原路径。\n  1042→        这确保数据库中存储的是相对路径，支持跨平台迁移。\n  1043→\n  1044→        Args:\n  1045→            abs_path: 绝对路径或相对路径\n  1046→\n  1047→        Returns:\n  1048→            相对路径字符串，如 \"images/xxx.png\"\n  1049→        \"\"\"\n  1050→        if not abs_path:\n  1051→            return None\n  1052→\n  1053→        try:\n  1054→            path = Path(abs_path)\n  1055→\n  1056→            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n  1057→            if not path.is_absolute():\n  1058→                return str(path).replace('\\\\', '/')\n  1059→\n  1060→            # 尝试转换为相对于存储根目录的路径\n  1061→            storage_root = Path(self.storage_manager.root_path)\n  1062→            try:\n  1063→                relative = path.relative_to(storage_root)\n  1064→                return str(relative).replace('\\\\', '/')\n  1065→            except ValueError:\n  1066→                # 路径不在存储根目录下，尝试提取文件名部分\n  1067→                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n  1068→                parts = path.parts\n  1069→                for i, part in enumerate(parts):\n  1070→                    if part in ('images', 'videos', 'thumbnails', 'references'):\n  1071→                        relative = Path(*parts[i:])\n  1072→                        return str(relative).replace('\\\\', '/')\n  1073→\n  1074→                # 无法提取，返回原路径（记录警告）\n  1075→                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n  1076→                return str(path).replace('\\\\', '/')\n  1077→\n  1078→        except Exception as e:\n  1079→            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n  1080→            return abs_path\n  1081→\n  1082→    def _extract_width_from_resolution(self, resolution: str) -> int:\n  1083→        \"\"\"\n  1084→        从分辨率字符串中提取宽度\n  1085→        \n  1086→        Args:\n  1087→            resolution: 分辨率字符串，如 \"1280x720\"\n  1088→            \n  1089→        Returns:\n  1090→            int: 宽度值\n  1091→        \"\"\"\n  1092→        try:\n  1093→            return int(resolution.split('x')[0])\n  1094→        except (ValueError, IndexError):\n  1095→            return 1280  # 默认值\n  1096→    \n  1097→    def _extract_height_from_resolution(self, resolution: str) -> int:\n  1098→        \"\"\"\n  1099→        从分辨率字符串中提取高度\n  1100→        \n  1101→        Args:\n  1102→            resolution: 分辨率字符串，如 \"1280x720\"\n  1103→            \n  1104→        Returns:\n  1105→            int: 高度值\n  1106→        \"\"\"\n  1107→        try:\n  1108→            return int(resolution.split('x')[1])\n  1109→        except (ValueError, IndexError):\n  1110→            return 720  # 默认值\n  1111→\n  1112→    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n  1113→        \"\"\"\n  1114→        获取视频信息\n  1115→\n  1116→        Args:\n  1117→            video_path: 视频文件路径\n  1118→\n  1119→        Returns:\n  1120→            Dict: 视频信息\n  1121→        \"\"\"\n  1122→        try:\n  1123→            # 这里可以使用ffprobe或其他工具获取视频信息\n  1124→            # 暂时返回基本信息\n  1125→            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n  1126→        except Exception as e:\n  1127→            logger.error(f\"获取视频信息失败: {e}\")\n  1128→            return {}\n  1129→\n  1130→    def _save_task_metadata(self, result: Dict[str, Any]):\n  1131→        \"\"\"\n  1132→        保存任务元数据\n  1133→\n  1134→        Args:\n  1135→            result: 任务结果\n  1136→        \"\"\"\n  1137→        try:\n  1138→            # 构建视频元数据\n  1139→            metadata = {\n  1140→                \"generation_id\": result[\"task_id\"],\n  1141→                \"file_id\": result[\"task_id\"],\n  1142→                \"filename\": result.get(\"filename\", \"\"),\n  1143→                \"file_path\": result.get(\"local_path\", \"\"),\n  1144→                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n  1145→                \"parameters\": result.get(\"parameters\", {}),\n  1146→                \"created_at\": result[\"created_at\"],\n  1147→                \"file_size\": result.get(\"local_file_size\", 0),\n  1148→                \"source_url\": result.get(\"video_url\", \"\"),\n  1149→                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n  1150→                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n  1151→            }\n  1152→\n  1153→            # 调用视频元数据保存方法\n  1154→            self.metadata_manager.save_video_metadata(metadata)\n  1155→            \n  1156→            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n  1157→\n  1158→        except Exception as e:\n  1159→            logger.error(f\"保存任务元数据失败: {e}\")\n  1160→\n  1161→    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n  1162→        \"\"\"\n  1163→        获取视频生成历史记录\n  1164→\n  1165→        Args:\n  1166→            limit: 返回记录数量限制\n  1167→\n  1168→        Returns:\n  1169→            List[Dict]: 历史记录列表\n  1170→        \"\"\"\n  1171→        return self.storage_manager.load_history('videos', limit=limit)\n  1172→\n  1173→    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n  1174→        \"\"\"\n  1175→        根据输入图像路径搜索历史记录\n  1176→\n  1177→        Args:\n  1178→            keyword: 搜索关键字\n  1179→\n  1180→        Returns:\n  1181→            List[Dict]: 匹配的记录列表\n  1182→        \"\"\"\n  1183→        return self.metadata_manager.search_records(\"input_image\", keyword)\n  1184→\n  1185→    def get_statistics(self) -> Dict[str, Any]:\n  1186→        \"\"\"\n  1187→        获取生成统计信息\n  1188→\n  1189→        Returns:\n  1190→            Dict: 统计信息\n  1191→        \"\"\"\n  1192→        try:\n  1193→            df = self.metadata_manager.get_dataframe()\n  1194→\n  1195→            if df.empty:\n  1196→                return {\n  1197→                    \"total_videos\": 0,\n  1198→                    \"success_count\": 0,\n  1199→                    \"failed_count\": 0,\n  1200→                    \"pending_count\": 0,\n  1201→                    \"total_file_size\": 0,\n  1202→                    \"average_file_size\": 0,\n  1203→                    \"total_duration\": 0,\n  1204→                    \"average_duration\": 0,\n  1205→                }\n  1206→\n  1207→            stats = {\n  1208→                \"total_videos\": len(df),\n  1209→                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n  1210→                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n  1211→                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n  1212→                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n  1213→                \"total_file_size\": df[\"local_file_size\"].sum(),\n  1214→                \"average_file_size\": df[\"local_file_size\"].mean(),\n  1215→                \"total_duration\": df[\"duration\"].sum(),\n  1216→                \"average_duration\": df[\"duration\"].mean(),\n  1217→                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n  1218→            }\n  1219→\n  1220→            return stats\n  1221→\n  1222→        except Exception as e:\n  1223→            logger.error(f\"获取统计信息失败: {e}\")\n  1224→            return {}\n  1225→\n  1226→    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n  1227→        \"\"\"\n  1228→        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n  1229→\n  1230→        注意：\n  1231→        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n  1232→          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n  1233→        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n  1234→        \"\"\"\n  1235→        params = result.get(\"parameters\", {}) or {}\n  1236→\n  1237→        # 新三层参数结构优先：actual > sent > requested\n  1238→        if isinstance(params, dict):\n  1239→            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n  1240→                layer_obj = params.get(layer)\n  1241→                if isinstance(layer_obj, dict):\n  1242→                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n  1243→                    if cand:\n  1244→                        return str(cand)\n  1245→                    if layer == \"params_requested\":\n  1246→                        mv = layer_obj.get(\"model_variant\")\n  1247→                        if mv:\n  1248→                            return str(mv)\n  1249→\n  1250→        # 顶层 model（VideoService 会尽量补齐）\n  1251→        top = result.get(\"model\")\n  1252→        if top:\n  1253→            return str(top)\n  1254→\n  1255→        # 旧结构兼容：从 parameters 推断\n  1256→        if isinstance(params, dict):\n  1257→            mv = params.get(\"model_variant\") or \"\"\n  1258→            mt = params.get(\"model_type\") or \"\"\n  1259→            use_pro_model = params.get(\"use_pro_model\", True)\n  1260→\n  1261→            if mv:\n  1262→                return str(mv)\n  1263→            if isinstance(mt, str) and mt.strip():\n  1264→                return mt.strip()\n  1265→            if bool(use_pro_model):\n  1266→                return \"pro\"\n  1267→            return \"lite\"\n  1268→\n  1269→        return \"seedance\"\n  1270→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ea64930b-9f28-49f9-8bb9-30bf982fed51","timestamp":"2025-12-30T09:55:49.584Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/manager.py","content":"# Seedance视频生成管理器\n# 负责视频生成的业务逻辑和本地存储管理\n# 路径真源说明：存储路径仅允许通过 config_api.get_storage_dir() + V2 工厂注入；\n# 禁止通过构造参数传入路径，杜绝多根与兼容分支。\n\nimport os\nimport uuid\nimport requests\nfrom ..utils.safe_requests import safe_requests_get\nimport hashlib\nimport mimetypes\nimport base64\nimport pandas as pd\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom urllib.parse import urlparse\nfrom loguru import logger\nfrom PIL import Image\n\nfrom ..provider.schema import MAX_REFERENCE_IMAGES, MAX_REFERENCE_BUNDLE\n\nfrom .client import SeedanceClient\nfrom ..storage import get_v2_storage_manager\nfrom ..provider.schema import (\n    VideoParams,\n    validate_and_normalize_video,\n)\nfrom config.unified_config import get_unified_config\nfrom config_api import get_storage_dir\n# 使用统一水印服务（edition/watermark_service.py）\nfrom edition.watermark_service import (\n    should_add_watermark,\n    get_watermark_text,\n    get_watermark_opacity,\n)\n\n# API水印配置保持不变（用于服务端水印）\ntry:  # pragma: no cover\n    from config_api import API_WATERMARK_CONFIG  # type: ignore\nexcept Exception:  # pragma: no cover\n    API_WATERMARK_CONFIG = {\n        \"image_watermark\": False,\n        \"video_watermark\": False,\n    }\ntry:  # pragma: no cover\n    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\nexcept Exception:  # pragma: no cover\n    LOCAL_WATERMARK_CONFIG = {\n        \"enabled\": False,\n        \"text\": \"\",\n        \"opacity\": 0.0,\n        \"position\": \"bottom_right\",\n        \"font_size\": 0,\n    }\n\n\nclass SeedanceManager:\n    \"\"\"Seedance视频生成管理器\"\"\"\n\n    def __init__(self, api_key: str = None):\n        \"\"\"\n        初始化Seedance管理器\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从共享管理器获取\n        \"\"\"\n        # 从配置管理器获取API密钥（支持credentials.json和环境变量）\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise ValueError(f\"获取API密钥失败: {exc}\") from exc\n        \n        self.client = SeedanceClient(api_key)\n\n        # 获取存储路径并确保目录存在（防止路径切换后目录不存在）\n        storage_path = get_storage_dir()\n        Path(storage_path).mkdir(parents=True, exist_ok=True)\n\n        # 使用V2统一存储管理器（与单一真源对齐）\n        self.storage_manager = get_v2_storage_manager(storage_path)\n        \n        # 保持兼容性别名\n        self.file_manager = self.storage_manager\n        self.metadata_manager = self.storage_manager\n        self.video_storage_manager = self.storage_manager\n        \n        # 保留原有的目录属性以保持兼容性\n        self.data_dir = Path(self.storage_manager.root_path)\n        self.videos_dir = self.data_dir / \"videos\"\n        self.metadata_dir = self.data_dir / \"metadata\"\n\n        logger.info(f\"Seedance管理器初始化完成，使用统一存储管理器，根目录: {self.storage_manager.root_path}\")\n\n    def generate_video(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: float = 4.0,\n        seed: int = -1,\n        watermark: bool = False,\n        save_local: bool = True,\n        wait_for_completion: bool = True,\n        # 新增参数（P0b）\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        fps: int = 24,\n        camera_fixed: bool = True,\n        use_pro_model: bool = True,\n        model_type: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        generate_audio: Optional[bool] = None,\n        reference_images: Optional[List[Any]] = None,\n        generation_id: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        生成视频并保存到本地\n\n        Args:\n            image_path: 输入图像路径\n            duration: 视频时长（秒）\n            motion_strength: 运动强度 (0.1-1.0)\n            seed: 随机种子\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            Dict: 生成结果\n        \"\"\"\n        logger.info(\"开始视频生成任务(Manager)\")\n\n        # 生成唯一ID（本地任务ID），优先使用外部传入的 generation_id\n        task_id = generation_id or str(uuid.uuid4())\n\n        # Seedance 1.5 Pro：不支持参考图模式（reference_image）\n        if str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\" and reference_images:\n            raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n        # 统一处理所有外部图片（参考图 + 首帧/尾帧/单图）\n        # 构建待处理的图片列表\n        all_input_images = []\n\n        # 1. 添加首帧/尾帧/单图（标记类型以便后续提取）\n        frame_inputs = []\n        if first_frame_path:\n            frame_inputs.append({'path': first_frame_path, 'type': 'first_frame'})\n        if last_frame_path:\n            frame_inputs.append({'path': last_frame_path, 'type': 'last_frame'})\n        elif image_path and not first_frame_path:\n            frame_inputs.append({'path': image_path, 'type': 'image'})\n\n        all_input_images.extend(frame_inputs)\n\n        # 2. 添加参考图\n        if reference_images:\n            for ref in reference_images:\n                if isinstance(ref, dict):\n                    ref_copy = dict(ref)\n                    ref_copy['type'] = ref_copy.get('type', 'reference')\n                    all_input_images.append(ref_copy)\n                else:\n                    all_input_images.append({'path': ref, 'type': 'reference'})\n\n        # 3. 统一处理（复制到 references 目录）\n        ref_summary = self._process_reference_assets(\n            all_input_images if all_input_images else None,\n            max_refs=MAX_REFERENCE_IMAGES + len(frame_inputs),  # 帧图片不占用参考图配额\n            expected_outputs=1,\n        )\n        ref_assets = ref_summary.get('assets', [])\n        ref_paths: List[str] = list(ref_summary.get('paths', []))\n\n        # 4. 分离帧图片和参考图\n        frame_assets = {}\n        pure_ref_assets = []\n        for asset in ref_assets:\n            asset_type = asset.get('_source_meta', {}).get('type', 'reference')\n            if asset_type in ('first_frame', 'last_frame', 'image'):\n                frame_assets[asset_type] = asset\n            else:\n                pure_ref_assets.append(asset)\n\n        # 5. 提取帧图片的相对路径（用于存储）\n        stored_first_frame = frame_assets.get('first_frame', {}).get('path')\n        stored_last_frame = frame_assets.get('last_frame', {}).get('path')\n        stored_image_path = frame_assets.get('image', {}).get('path')\n\n        # 6. 提取参考图的 payload（用于 API 调用）\n        ref_payloads: List[str] = []\n        for asset in pure_ref_assets:\n            payload = asset.get('_payload_b64')\n            if payload:\n                ref_payloads.append(payload)\n\n        if ref_summary.get('errors'):\n            logger.warning(\n                f\"图片处理不完整: count={len(ref_assets)} errors={len(ref_summary['errors'])}\"\n            )\n        if ref_summary.get('warnings'):\n            for warn in ref_summary['warnings']:\n                logger.warning(f\"图片处理提示: {warn}\")\n\n        watermark_enabled = bool(\n            LOCAL_WATERMARK_CONFIG.get(\"enabled\", API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n        )\n\n        create_kwargs = dict(\n            prompt=prompt,\n            duration=int(duration),\n            seed=None if seed == -1 else seed,\n            fps=fps,\n            resolution_grade=resolution_grade,\n            ratio=ratio,\n            watermark=watermark_enabled,\n            camera_fixed=bool(camera_fixed),\n            use_pro_model=use_pro_model,\n            model_type=model_type,\n            model_variant=model_variant,\n            generate_audio=generate_audio,\n        )\n        if ref_payloads:\n            create_kwargs['reference_images'] = ref_payloads\n        if first_frame_path and last_frame_path:\n            create_kwargs.update(dict(first_frame_path=first_frame_path, last_frame_path=last_frame_path))\n        elif image_path:\n            create_kwargs.update(dict(image_path=image_path))\n        # 文生视频：不追加图片参数\n\n        # 前置参数校验（不改变业务参数，仅记录摘要与回退建议）\n        precheck_fb = False\n        precheck_reason = \"\"\n        try:\n            norm, fb, reason, used_rs, used_rt = validate_and_normalize_video(\n                VideoParams(\n                    prompt=prompt,\n                    image_path=None,  # 校验不依赖图像数据\n                    first_frame_path=None,\n                    last_frame_path=None,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if seed == -1 else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=bool(watermark),\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                    model_variant=model_variant,\n                    generate_audio=generate_audio,\n                )\n            )\n            logger.info(\n                f\"摘要|operation=precheck_video rs={used_rs} rt={used_rt} dur={norm.duration}s fps={norm.fps} seed={norm.seed} fallback={'yes' if fb else 'no'}\"\n            )\n            if fb:\n                logger.warning(f\"前置参数回退建议: {reason}\")\n            precheck_fb = fb\n            precheck_reason = reason\n        except Exception as _e:\n            logger.debug(f\"前置参数校验跳过: {_e}\")\n\n        create_result = self.client.create_video_task(**create_kwargs)\n        params_sent = create_result.get(\"params_sent\") if isinstance(create_result, dict) else None\n\n        # 用实际执行参数覆盖用户输入（如 Lite 参考图模式 1080p→720p 降级）\n        if create_result.get(\"success\"):\n            actual_rs = create_result.get('used_rs')\n            actual_rt = create_result.get('used_rt')\n            if actual_rs:\n                logger.debug(f\"参数覆盖|resolution_grade: 用户输入={resolution_grade} -> 实际执行={actual_rs}\")\n                resolution_grade = actual_rs\n            if actual_rt:\n                logger.debug(f\"参数覆盖|ratio: 用户输入={ratio} -> 实际执行={actual_rt}\")\n                ratio = actual_rt\n\n        if not create_result[\"success\"]:\n            self._cleanup_reference_paths(ref_paths)\n            logger.error(f\"视频任务创建失败: {create_result['error']}\")\n            return create_result\n\n        api_task_id = create_result[\"task_id\"]\n\n        result = {\n            \"task_id\": task_id,\n            \"api_task_id\": api_task_id,\n            \"params_sent\": params_sent,\n            \"success\": True,\n            \"type\": \"image_to_video\",\n            \"input_image\": image_path,\n            \"status\": \"pending\",\n            \"parameters\": {\n                \"prompt\": prompt,\n                \"duration\": duration,\n                \"seed\": (None if seed == -1 else seed),\n                \"watermark\": watermark_enabled,\n                \"resolution_grade\": resolution_grade,\n                \"ratio\": ratio,\n                \"fps\": fps,\n                \"camera_fixed\": bool(camera_fixed),\n                # 使用处理后的相对路径（已复制到 references，跨平台兼容）\n                \"first_frame\": stored_first_frame,\n                \"last_frame\": stored_last_frame,\n                \"image_path\": stored_image_path,\n            },\n            \"created_at\": datetime.now().isoformat(),\n        }\n\n        sanitized_refs = self._sanitize_reference_assets(ref_assets)\n        result['parameters'][\"reference_assets\"] = sanitized_refs if sanitized_refs else []\n        result['reference_assets'] = sanitized_refs\n        if ref_summary.get('errors'):\n            result['reference_asset_errors'] = ref_summary['errors']\n        if ref_summary.get('warnings'):\n            result['reference_asset_warnings'] = ref_summary['warnings']\n        if precheck_fb and precheck_reason:\n            result.setdefault('fallback_applied', True)\n            if result.get('fallback_reason'):\n                result['fallback_reason'] = f\"{result['fallback_reason']}; {precheck_reason}\"\n            else:\n                result['fallback_reason'] = precheck_reason\n\n        masked_ids = self._summarize_reference_ids(sanitized_refs)\n        logger.info(\n            \"摘要|operation=video_reference reference_count={} ref_ids={} provider={}\",\n            len(sanitized_refs),\n            masked_ids or \"-\",\n            self._provider_hint(),\n        )\n\n        # 透传回退信息\n        if create_result.get(\"fallback_applied\"):\n            result[\"fallback_applied\"] = True\n            result[\"fallback_reason\"] = create_result.get(\"fallback_reason\", \"\")\n\n        # 如果等待完成，轮询任务状态\n        if wait_for_completion:\n            completion_result = self.client.wait_for_completion(api_task_id)\n\n            if completion_result[\"success\"]:\n                if completion_result[\"status\"] == \"success\":\n                    result[\"status\"] = \"success\"\n                    result[\"video_url\"] = completion_result[\"video_url\"]\n                    result[\"duration\"] = completion_result.get(\"duration\")\n                    result[\"file_size\"] = completion_result.get(\"file_size\")\n                    result[\"completed_at\"] = datetime.now().isoformat()\n\n                    # 保存到本地\n                    if save_local:\n                        local_result = self._save_video_locally(result)\n                        result.update(local_result)\n                        # 注：file_size 已在 _save_video_locally 内部设置到 metadata['parameters'] 中\n                        if local_result.get('local_save_error'):\n                            self._cleanup_reference_paths(ref_paths)\n                            result['parameters'][\"reference_assets\"] = []\n                            result['reference_assets'] = []\n                            warnings = result.setdefault('reference_asset_warnings', [])\n                            warnings.append(\"视频保存失败，参考图已回滚\")\n                            logger.warning(f\"参考图已回滚: task_id={task_id}\")\n\n                    logger.success(f\"视频生成任务完成: {task_id}\")\n                else:\n                    result[\"status\"] = completion_result[\"status\"]\n                    result[\"error\"] = completion_result.get(\"error\")\n                    result[\"error_code\"] = completion_result.get(\"error_code\")\n                    logger.error(f\"视频生成任务失败: {result['error']}\")\n            else:\n                result[\"status\"] = \"failed\"\n                result[\"error\"] = completion_result[\"error\"]\n                result[\"error_code\"] = completion_result[\"error_code\"]\n                logger.error(f\"等待任务完成失败: {result['error']}\")\n\n        # 注：元数据已通过 save_content_file() 保存，无需重复调用\n\n        return result\n\n    def check_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        检查任务状态\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        logger.info(f\"检查任务状态: {task_id}\")\n\n        # 从元数据中获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 查询API任务状态\n        status_result = self.client.get_task_status(api_task_id)\n\n        if status_result[\"success\"]:\n            # 更新本地记录\n            updates = {\n                \"status\": status_result[\"status\"],\n                \"progress\": status_result.get(\"progress\", 0),\n                \"updated_at\": datetime.now().isoformat(),\n            }\n\n            # 如果任务完成，添加结果信息\n            if status_result[\"status\"] == \"success\":\n                updates[\"video_url\"] = status_result[\"video_url\"]\n                updates[\"duration\"] = status_result.get(\"duration\")\n                updates[\"file_size\"] = status_result.get(\"file_size\")\n                updates[\"completed_at\"] = datetime.now().isoformat()\n\n            # 如果任务失败，添加错误信息\n            elif status_result[\"status\"] == \"failed\":\n                updates[\"error\"] = status_result.get(\"error\")\n                updates[\"error_code\"] = status_result.get(\"error_code\")\n\n            # 更新元数据\n            self.metadata_manager.update_record(task_id, updates)\n\n            # 合并任务信息\n            result = {\"task_id\": task_id, \"api_task_id\": api_task_id, **status_result}\n\n            return result\n        else:\n            return status_result\n\n    def download_completed_video(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        下载已完成的视频\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 下载结果\n        \"\"\"\n        logger.info(f\"下载视频: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        # 检查任务状态\n        if task_record.get(\"status\") != \"success\":\n            return {\"success\": False, \"error\": \"任务未完成\", \"error_code\": \"TASK_NOT_COMPLETED\"}\n\n        video_url = task_record.get(\"video_url\")\n        if not video_url:\n            return {\"success\": False, \"error\": \"视频URL不存在\", \"error_code\": \"NO_VIDEO_URL\"}\n\n        # 检查是否已下载\n        local_path = task_record.get(\"local_path\")\n        if local_path and Path(local_path).exists():\n            logger.info(\n                f\"摘要|operation=download_video status=skipped(already_downloaded) task_id={task_id} path={Path(local_path).name}\"\n            )\n            return {\"success\": True, \"local_path\": local_path, \"already_downloaded\": True}\n\n        # 下载视频\n        try:\n            response = safe_requests_get(video_url, timeout=300)\n\n            # 生成本地文件名\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            task_id_short = task_id[:8]\n            filename = f\"video_{timestamp}_{task_id_short}.mp4\"\n\n            # 保存文件\n            local_path = self.file_manager.save_file(filename, response.content)\n\n            # 获取视频信息\n            video_info = self._get_video_info(local_path)\n\n            # 更新元数据\n            updates = {\n                \"filename\": filename,\n                \"local_path\": str(local_path),\n                \"local_file_size\": local_path.stat().st_size,\n                \"downloaded_at\": datetime.now().isoformat(),\n            }\n\n            if video_info:\n                updates.update(video_info)\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"视频下载成功: {filename}\")\n\n            summary = {\n                \"success\": True,\n                \"local_path\": str(local_path),\n                \"filename\": filename,\n                \"file_size\": local_path.stat().st_size,\n                \"video_info\": video_info,\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=success task_id={task_id} file={filename} size={summary['file_size']}B\"\n                )\n            except Exception:\n                pass\n            return summary\n\n        except Exception as e:\n            logger.error(f\"下载视频失败: {e}\")\n            try:\n                logger.info(\n                    f\"摘要|operation=download_video status=failed task_id={task_id} error=DOWNLOAD_ERROR\"\n                )\n            except Exception:\n                pass\n            return {\"success\": False, \"error\": str(e), \"error_code\": \"DOWNLOAD_ERROR\"}\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消任务\n\n        Args:\n            task_id: 本地任务ID\n\n        Returns:\n            Dict: 取消结果\n        \"\"\"\n        logger.info(f\"取消任务: {task_id}\")\n\n        # 获取任务信息\n        task_record = self.metadata_manager.get_record_by_task_id(task_id)\n\n        if not task_record:\n            return {\"success\": False, \"error\": \"任务不存在\", \"error_code\": \"TASK_NOT_FOUND\"}\n\n        api_task_id = task_record.get(\"api_task_id\")\n        if not api_task_id:\n            return {\"success\": False, \"error\": \"API任务ID不存在\", \"error_code\": \"INVALID_TASK\"}\n\n        # 调用API取消任务\n        cancel_result = self.client.cancel_task(api_task_id)\n\n        if cancel_result[\"success\"]:\n            # 更新本地记录\n            updates = {\"status\": \"cancelled\", \"cancelled_at\": datetime.now().isoformat()}\n\n            self.metadata_manager.update_record(task_id, updates)\n\n            logger.success(f\"任务取消成功: {task_id}\")\n\n        return cancel_result\n\n    def batch_generate_videos(\n        self,\n        image_paths: List[str],\n        duration: float = 4.0,\n        motion_strength: float = 0.8,\n        watermark: bool = True,\n        save_local: bool = True,\n        wait_for_completion: bool = False,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        批量生成视频\n\n        Args:\n            image_paths: 图像路径列表\n            duration: 视频时长\n            motion_strength: 运动强度\n            watermark: 保留参数（服务端水印由配置决定）\n            save_local: 是否保存到本地\n            wait_for_completion: 是否等待任务完成\n\n        Returns:\n            List[Dict]: 生成结果列表\n        \"\"\"\n        logger.info(f\"开始批量视频生成，共{len(image_paths)}个任务\")\n\n        results = []\n        for i, image_path in enumerate(image_paths, 1):\n            logger.info(f\"处理第{i}/{len(image_paths)}个任务\")\n\n            result = self.generate_video(\n                image_path=image_path,\n                duration=duration,\n                motion_strength=motion_strength,\n                watermark=watermark,\n                save_local=save_local,\n                wait_for_completion=wait_for_completion,\n            )\n\n            results.append(result)\n\n        success_count = sum(1 for r in results if r[\"success\"])\n        logger.info(f\"批量视频生成完成，成功{success_count}/{len(image_paths)}个\")\n\n        return results\n\n    def _save_video_locally(self, result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        保存视频到本地\n\n        Args:\n            result: API生成结果\n\n        Returns:\n            Dict: 包含本地文件信息的字典\n        \"\"\"\n        try:\n            logger.info(f\"Starting to save video locally for task_id: {result.get('task_id')}\")\n\n            # Validate inputs\n            task_id = result.get(\"task_id\")\n            video_url = result.get(\"video_url\")\n            if not task_id:\n                raise ValueError(\"Task ID is required\")\n            if not video_url:\n                raise ValueError(\"Video URL is required\")\n            \n            # 下载视频\n            logger.info(f\"Downloading video from {video_url}\")\n            try:\n                response = safe_requests_get(video_url, stream=True, timeout=300)\n                \n                # Check content type\n                content_type = response.headers.get('content-type', '')\n                if 'video' not in content_type:\n                    logger.warning(f\"Unexpected content type: {content_type}\")\n                \n                # Get file size for progress tracking\n                total_size = int(response.headers.get('content-length', 0))\n                video_data = response.content\n                \n                logger.info(f\"Video downloaded successfully. Size: {len(video_data)} bytes\")\n                \n            except requests.exceptions.RequestException as e:\n                logger.error(f\"Network error downloading video: {e}\")\n                raise Exception(f\"Failed to download video: {str(e)}\")\n            \n            # 在保存前获取真实视频信息（写临时文件以便读取）\n            actual_width = None\n            actual_height = None\n            actual_fps = None\n            actual_duration = None\n            try:\n                import tempfile\n                from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as tf:\n                    tf.write(video_data)\n                    temp_path = Path(tf.name)\n                # 使用缩略图工具的get_video_info\n                thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                gen = VideoThumbnailGenerator(str(thumbs_dir))\n                info = gen.get_video_info(str(temp_path))\n                try:\n                    temp_path.unlink(missing_ok=True)  # 清理临时文件\n                except Exception:\n                    pass\n                if info:\n                    actual_width = info.get('width')\n                    actual_height = info.get('height')\n                    actual_fps = info.get('fps')\n                    actual_duration = info.get('duration')\n            except Exception as e:\n                logger.warning(f\"获取视频信息失败（使用回退元数据）: {e}\")\n\n            # 准备元数据（适配UnifiedStorageManager的格式）\n            metadata = {\n                'generation_id': task_id,\n                'task_id': task_id,\n                'prompt': result.get('parameters', {}).get('prompt', 'Generated from image'),\n                'parameters': {\n                    **result.get('parameters', {}),\n                    # 设置文件大小（在保存前就设置，确保写入数据库）\n                    'file_size': len(video_data),\n                    # 回填真实视频信息\n                    **({} if actual_width is None else {'width': actual_width}),\n                    **({} if actual_height is None else {'height': actual_height}),\n                    **({} if actual_fps is None else {'fps': actual_fps}),\n                    **({} if actual_duration is None else {'duration': actual_duration}),\n                    # 透传fallback信息\n                    **({'fallback_applied': result.get('fallback_applied')} if 'fallback_applied' in result else {}),\n                    **({'fallback_reason': result.get('fallback_reason')} if 'fallback_reason' in result else {}),\n                },\n                'model': self._get_display_model_name(result),\n                'duration': (actual_duration if actual_duration is not None else result.get('parameters', {}).get('duration', 4.0)),\n                'fps': (actual_fps if actual_fps is not None else result.get('parameters', {}).get('fps', 24)),\n                'width': (actual_width if actual_width is not None else self._extract_width_from_resolution(result.get('resolution', '1280x720'))),\n                'height': (actual_height if actual_height is not None else self._extract_height_from_resolution(result.get('resolution', '1280x720'))),\n                'generation_time': result.get('generation_time', 0),\n                'status': result.get('status', 'completed'),\n                'batch_id': result.get('batch_id', '')\n            }\n\n            # 使用统一存储管理器保存文件\n            save_result = self.storage_manager.save_content_file(\n                content_type='videos',\n                file_data=video_data,\n                url=video_url,\n                metadata=metadata\n            )\n\n            # 缩略图生成（已由UnifiedStorageManager处理）\n            thumbnail_local_path = save_result.get('thumbnail_path')\n            thumbnail_filename = None\n            if thumbnail_local_path:\n                thumbnail_filename = Path(thumbnail_local_path).name\n                logger.success(f\"视频缩略图生成成功: {thumbnail_local_path}\")\n            else:\n                logger.warning(f\"视频缩略图生成失败: {task_id}\")\n\n            # 下载并保存API返回的缩略图（如果有）作为备用\n            api_thumbnail_local_path = None\n            api_thumbnail_filename = None\n            if not thumbnail_local_path and result.get(\"thumbnail_url\"):\n                try:\n                    logger.info(f\"Downloading API thumbnail from {result['thumbnail_url']} as backup\")\n                    thumbnail_response = safe_requests_get(result[\"thumbnail_url\"], stream=True, timeout=60)\n                    \n                    # 使用统一存储管理器保存备用缩略图\n                    backup_metadata = {\n                        'generation_id': task_id,\n                        'prompt': 'API backup thumbnail for video',\n                        'model': 'seedance',\n                        'width': 320,\n                        'height': 180,\n                        'status': 'completed'\n                    }\n                    \n                    backup_result = self.storage_manager.save_content_file(\n                        content_type='images',  # 缩略图保存为图片\n                        file_data=thumbnail_response.content,\n                        url=result[\"thumbnail_url\"],\n                        metadata=backup_metadata\n                    )\n                    \n                    api_thumbnail_local_path = backup_result['local_path']\n                    api_thumbnail_filename = Path(api_thumbnail_local_path).name\n                    \n                    # 如果本地缩略图生成失败，使用API缩略图\n                    if not thumbnail_local_path:\n                        thumbnail_local_path = api_thumbnail_local_path\n                        thumbnail_filename = api_thumbnail_filename\n                    \n                    logger.success(f\"API缩略图已保存作为备用: {api_thumbnail_filename}\")\n                        \n                except Exception as e:\n                    logger.warning(f\"下载API缩略图失败: {e}\")\n                    api_thumbnail_local_path = None\n                    api_thumbnail_filename = None\n\n            # 获取视频信息\n            local_path = Path(save_result['local_path'])\n            # 再次保障：若前面未取到信息，这里用已保存文件兜底\n            if actual_width is None or actual_height is None or actual_fps is None or actual_duration is None:\n                try:\n                    from utils.video_thumbnail_generator import VideoThumbnailGenerator\n                    thumbs_dir = Path(self.storage_manager.root_path) / 'thumbnails' / 'videos'\n                    gen = VideoThumbnailGenerator(str(thumbs_dir))\n                    video_info = gen.get_video_info(str(local_path))\n                except Exception:\n                    video_info = {}\n            else:\n                video_info = {\n                    'width': actual_width,\n                    'height': actual_height,\n                    'fps': actual_fps,\n                    'duration': actual_duration,\n                }\n            file_size = local_path.stat().st_size if local_path.exists() else 0\n            \n            logger.success(f\"视频已保存到本地: {local_path.name}\")\n            \n            # 本地视频水印（使用统一水印服务控制）\n            if should_add_watermark():\n                try:\n                    from edition.watermark_service import WatermarkService\n\n                    watermark_text = get_watermark_text() or \"PIGEON\"\n                    try:\n                        opacity = get_watermark_opacity()\n                    except Exception:\n                        opacity = 0.3\n                    opacity = max(0.0, min(opacity, 1.0))\n\n                    watermark_service = WatermarkService(watermark_text, opacity=opacity)\n                    watermark_applied = watermark_service.apply_to_video(local_path)\n                    if watermark_applied:\n                        logger.success(f\"视频水印添加成功: {local_path.name}\")\n                    else:\n                        logger.warning(f\"视频水印添加失败: {local_path.name}\")\n                except Exception as e:\n                    logger.warning(f\"添加视频水印时出错: {e}\")\n\n            result_obj = {\n                \"local_path\": save_result['local_path'],\n                \"filename\": local_path.name,\n                \"file_path\": save_result['local_path'],  # 保持兼容性\n                \"local_file_size\": file_size,\n                \"video_info\": video_info,\n                # 同步回填至顶层，便于上游使用\n                **({} if not video_info else {\n                    'width': video_info.get('width'),\n                    'height': video_info.get('height'),\n                    'fps': video_info.get('fps'),\n                    'duration': video_info.get('duration'),\n                }),\n                \"thumbnail_local_path\": str(thumbnail_local_path) if thumbnail_local_path else None,\n                \"thumbnail_filename\": thumbnail_filename,\n                \"api_thumbnail_local_path\": str(api_thumbnail_local_path) if api_thumbnail_local_path else None,\n                \"api_thumbnail_filename\": api_thumbnail_filename,\n                \"task_id\": task_id,  # 添加task_id以供后续使用\n                # 修复：确保 file_id 和 relative_path 被返回，用于占位符替换\n                \"file_id\": save_result.get('file_id'),\n                \"relative_path\": save_result.get('relative_path'),\n            }\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=success task_id={task_id} file={local_path.name} size={file_size}B width={result_obj.get('width')} height={result_obj.get('height')} fps={result_obj.get('fps')} duration={result_obj.get('duration')}\"\n                )\n            except Exception:\n                pass\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"保存视频到本地失败: {e}\")\n            logger.exception(\"Full traceback for video save error:\")\n            try:\n                logger.info(\n                    f\"摘要|operation=save_video status=failed task_id={task_id}\"\n                )\n            except Exception:\n                pass\n            return {\"local_save_error\": str(e)}\n\n    def _generate_reference_asset_id(self, file_data: bytes) -> str:\n        checksum = hashlib.sha1(file_data).hexdigest()\n        ts = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")\n        return f\"ref_{ts}_{checksum[:8]}\"\n\n    def _load_reference_source(self, ref: Any) -> Optional[Tuple[bytes, str, Dict[str, Any]]]:\n        source_meta: Dict[str, Any] = {}\n        raw = ref\n        if isinstance(ref, dict):\n            for key in ('source', 'order', 'type', 'extension', 'width', 'height'):\n                if ref.get(key) is not None:\n                    source_meta[key] = ref.get(key)\n            raw = ref.get('data') or ref.get('path') or ref.get('url') or ref.get('value')\n        if raw is None:\n            return None\n\n        extension = source_meta.get('extension')\n        data = None\n        source_repr = source_meta.get('source')\n\n        try:\n            if isinstance(raw, bytes):\n                data = raw\n            elif isinstance(raw, str):\n                stripped = raw.strip()\n                if stripped.startswith('data:') and ';base64,' in stripped:\n                    header, payload = stripped.split(';base64,', 1)\n                    mime_part = header[5:]\n                    extension = extension or mimetypes.guess_extension(mime_part) or '.png'\n                    data = base64.b64decode(payload)\n                    source_repr = source_repr or mime_part\n                    source_meta.setdefault('type', 'image')\n                elif stripped.startswith(('http://', 'https://')):\n                    resp = safe_requests_get(stripped, timeout=15)\n                    data = resp.content\n                    parsed = urlparse(stripped)\n                    extension = extension or Path(parsed.path).suffix or mimetypes.guess_extension(resp.headers.get('Content-Type', '')) or '.png'\n                    source_repr = source_repr or stripped\n                    source_meta.setdefault('source_url', stripped)\n                else:\n                    path = Path(stripped)\n                    if not path.exists():\n                        logger.warning(f\"参考图像不存在: {stripped}\")\n                        return None\n                    data = path.read_bytes()\n                    extension = extension or path.suffix or '.png'\n                    source_repr = source_repr or path.name\n                    source_meta.setdefault('source_path', str(path))\n            else:\n                logger.warning(f\"不支持的参考图类型: {type(raw)}\")\n                return None\n        except Exception as exc:\n            logger.warning(f\"加载参考图失败: {exc}\")\n            return None\n\n        if data is None:\n            return None\n\n        width = source_meta.get('width')\n        height = source_meta.get('height')\n        if source_meta.get('type', 'image') == 'image' and (width is None or height is None):\n            try:\n                from io import BytesIO\n\n                with Image.open(BytesIO(data)) as img:\n                    width = img.width\n                    height = img.height\n            except Exception:\n                pass\n\n        source_meta['width'] = width\n        source_meta['height'] = height\n        source_meta.setdefault('type', 'image')\n        source_meta['source'] = source_repr or source_meta.get('source')\n\n        return data, extension, source_meta\n\n    def _process_reference_assets(\n        self,\n        references: Optional[List[Any]],\n        *,\n        max_refs: int = MAX_REFERENCE_IMAGES,\n        expected_outputs: int = 1,\n    ) -> Dict[str, Any]:\n        stored: List[Dict[str, Any]] = []\n        absolute_paths: List[str] = []\n        errors: List[str] = []\n        warnings: List[str] = []\n\n        if not references:\n            return {\n                'assets': stored,\n                'paths': absolute_paths,\n                'errors': errors,\n                'warnings': warnings,\n            }\n\n        if max_refs is not None and max_refs > 0 and len(references) > max_refs:\n            warnings.append(\n                f\"参考图数量超过 {max_refs}（官方文档行203-204），已按顺序截取前 {max_refs} 张\"\n            )\n            references = references[:max_refs]\n\n        for order, item in enumerate(references):\n            load_result = self._load_reference_source(item)\n            if not load_result:\n                errors.append(f\"ref[{order}] 加载失败\")\n                continue\n\n            file_data, extension, meta = load_result\n            meta.setdefault('order', order)\n            meta.setdefault('kind', meta.get('type', 'image'))\n\n            try:\n                asset_id = self._generate_reference_asset_id(file_data)\n                record = self.storage_manager.save_reference_asset(\n                    'images',\n                    file_data,\n                    asset_id=asset_id,\n                    extension=extension,\n                    metadata=meta,\n                )\n                try:\n                    record['_payload_b64'] = base64.b64encode(file_data).decode('utf-8')\n                except Exception:\n                    record['_payload_b64'] = None\n                record['_source_meta'] = meta\n                stored.append(record)\n                if record.get('absolute_path'):\n                    absolute_paths.append(record['absolute_path'])\n            except Exception as exc:\n                logger.warning(f\"保存参考图失败: {exc}\")\n                errors.append(f\"ref[{order}] 保存失败\")\n\n        if expected_outputs >= 0 and len(stored) + expected_outputs > MAX_REFERENCE_BUNDLE:\n            allowed = max(0, MAX_REFERENCE_BUNDLE - expected_outputs)\n            if len(stored) > allowed:\n                warnings.append(\n                    f\"参考图与生成量合计超过 {MAX_REFERENCE_BUNDLE}（官方文档行203-204），已截取前 {allowed} 张\"\n                )\n                stored = stored[:allowed]\n                absolute_paths = absolute_paths[:allowed]\n\n        return {\n            'assets': stored,\n            'paths': absolute_paths,\n            'errors': errors,\n            'warnings': warnings,\n        }\n\n    def _sanitize_reference_assets(self, assets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        cleaned: List[Dict[str, Any]] = []\n        for rec in assets or []:\n            rec.pop('_payload_b64', None)\n            rec.pop('_source_meta', None)\n            rec.pop('absolute_path', None)\n            cleaned.append({\n                'id': rec.get('id') or rec.get('reference_id'),\n                'path': rec.get('path') or rec.get('relative_path') or rec.get('asset_path'),\n                'type': rec.get('type'),\n                'kind': rec.get('kind'),\n                'source': rec.get('source'),\n                'order': rec.get('order'),\n                'checksum': rec.get('checksum'),\n                'size': rec.get('size'),\n                'width': rec.get('width'),\n                'height': rec.get('height'),\n                'created_at': rec.get('created_at'),\n            })\n        return cleaned\n\n    @staticmethod\n    def _summarize_reference_ids(assets: List[Dict[str, Any]]) -> str:\n        masked: List[str] = []\n        for rec in assets or []:\n            rid = rec.get('id') or ''\n            if not rid:\n                continue\n            masked.append(f\"{rid[:6]}***\")\n        return \",\".join(masked)\n\n    @staticmethod\n    def _provider_hint() -> str:\n        try:\n            return os.environ.get(\"GEMENG_SEEDANCE_PROVIDER\", \"seedance\")\n        except Exception:\n            return \"seedance\"\n\n    @staticmethod\n    def _cleanup_reference_paths(paths: List[str]):\n        for path in paths or []:\n            try:\n                if path and Path(path).exists():\n                    Path(path).unlink(missing_ok=True)\n            except Exception as exc:\n                logger.debug(f\"参考图清理失败: {exc}\")\n\n    def _to_relative_path(self, abs_path: Optional[str]) -> Optional[str]:\n        \"\"\"\n        将绝对路径转换为相对路径（相对于存储根目录）\n\n        如果路径已经是相对路径或无法转换，返回原路径。\n        这确保数据库中存储的是相对路径，支持跨平台迁移。\n\n        Args:\n            abs_path: 绝对路径或相对路径\n\n        Returns:\n            相对路径字符串，如 \"images/xxx.png\"\n        \"\"\"\n        if not abs_path:\n            return None\n\n        try:\n            path = Path(abs_path)\n\n            # 如果已经是相对路径，直接返回（统一使用正斜杠）\n            if not path.is_absolute():\n                return str(path).replace('\\\\', '/')\n\n            # 尝试转换为相对于存储根目录的路径\n            storage_root = Path(self.storage_manager.root_path)\n            try:\n                relative = path.relative_to(storage_root)\n                return str(relative).replace('\\\\', '/')\n            except ValueError:\n                # 路径不在存储根目录下，尝试提取文件名部分\n                # 例如: C:/Users/.../SQL8/images/xxx.png -> images/xxx.png\n                parts = path.parts\n                for i, part in enumerate(parts):\n                    if part in ('images', 'videos', 'thumbnails', 'references'):\n                        relative = Path(*parts[i:])\n                        return str(relative).replace('\\\\', '/')\n\n                # 无法提取，返回原路径（记录警告）\n                logger.warning(f\"无法转换路径为相对路径: {abs_path}\")\n                return str(path).replace('\\\\', '/')\n\n        except Exception as e:\n            logger.debug(f\"路径转换失败: {abs_path}, 错误: {e}\")\n            return abs_path\n\n    def _extract_width_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取宽度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 宽度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[0])\n        except (ValueError, IndexError):\n            return 1280  # 默认值\n    \n    def _extract_height_from_resolution(self, resolution: str) -> int:\n        \"\"\"\n        从分辨率字符串中提取高度\n        \n        Args:\n            resolution: 分辨率字符串，如 \"1280x720\"\n            \n        Returns:\n            int: 高度值\n        \"\"\"\n        try:\n            return int(resolution.split('x')[1])\n        except (ValueError, IndexError):\n            return 720  # 默认值\n\n    def _get_video_info(self, video_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        获取视频信息\n\n        Args:\n            video_path: 视频文件路径\n\n        Returns:\n            Dict: 视频信息\n        \"\"\"\n        try:\n            # 这里可以使用ffprobe或其他工具获取视频信息\n            # 暂时返回基本信息\n            return {\"format\": \"mp4\", \"codec\": \"h264\", \"container\": \"mp4\"}\n        except Exception as e:\n            logger.error(f\"获取视频信息失败: {e}\")\n            return {}\n\n    def _save_task_metadata(self, result: Dict[str, Any]):\n        \"\"\"\n        保存任务元数据\n\n        Args:\n            result: 任务结果\n        \"\"\"\n        try:\n            # 构建视频元数据\n            metadata = {\n                \"generation_id\": result[\"task_id\"],\n                \"file_id\": result[\"task_id\"],\n                \"filename\": result.get(\"filename\", \"\"),\n                \"file_path\": result.get(\"local_path\", \"\"),\n                \"prompt\": result.get(\"parameters\", {}).get(\"prompt\", \"\"),\n                \"parameters\": result.get(\"parameters\", {}),\n                \"created_at\": result[\"created_at\"],\n                \"file_size\": result.get(\"local_file_size\", 0),\n                \"source_url\": result.get(\"video_url\", \"\"),\n                \"thumbnail_local_path\": result.get(\"thumbnail_local_path\", \"\"),\n                \"thumbnail_filename\": result.get(\"thumbnail_filename\", \"\")\n            }\n\n            # 调用视频元数据保存方法\n            self.metadata_manager.save_video_metadata(metadata)\n            \n            logger.success(f\"视频元数据保存成功: {result['task_id']}\")\n\n        except Exception as e:\n            logger.error(f\"保存任务元数据失败: {e}\")\n\n    def get_generation_history(self, limit: int = 50) -> List[Dict[str, Any]]:\n        \"\"\"\n        获取视频生成历史记录\n\n        Args:\n            limit: 返回记录数量限制\n\n        Returns:\n            List[Dict]: 历史记录列表\n        \"\"\"\n        return self.storage_manager.load_history('videos', limit=limit)\n\n    def search_by_input_image(self, keyword: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据输入图像路径搜索历史记录\n\n        Args:\n            keyword: 搜索关键字\n\n        Returns:\n            List[Dict]: 匹配的记录列表\n        \"\"\"\n        return self.metadata_manager.search_records(\"input_image\", keyword)\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取生成统计信息\n\n        Returns:\n            Dict: 统计信息\n        \"\"\"\n        try:\n            df = self.metadata_manager.get_dataframe()\n\n            if df.empty:\n                return {\n                    \"total_videos\": 0,\n                    \"success_count\": 0,\n                    \"failed_count\": 0,\n                    \"pending_count\": 0,\n                    \"total_file_size\": 0,\n                    \"average_file_size\": 0,\n                    \"total_duration\": 0,\n                    \"average_duration\": 0,\n                }\n\n            stats = {\n                \"total_videos\": len(df),\n                \"success_count\": len(df[df[\"status\"] == \"success\"]),\n                \"failed_count\": len(df[df[\"status\"] == \"failed\"]),\n                \"pending_count\": len(df[df[\"status\"].isin([\"pending\", \"running\"])]),\n                \"cancelled_count\": len(df[df[\"status\"] == \"cancelled\"]),\n                \"total_file_size\": df[\"local_file_size\"].sum(),\n                \"average_file_size\": df[\"local_file_size\"].mean(),\n                \"total_duration\": df[\"duration\"].sum(),\n                \"average_duration\": df[\"duration\"].mean(),\n                \"creation_dates\": df[\"created_at\"].tolist()[-10:],  # 最近10次创建时间\n            }\n\n            return stats\n\n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {}\n\n    def _get_display_model_name(self, result: Dict[str, Any]) -> str:\n        \"\"\"\n        获取用于落库的模型代码（真实 model id / UI variant / 旧 model_type）。\n\n        注意：\n        - 数据库存储应尽量保存“真实模型代码”（如 doubao-seedance-1-5-pro-251215），\n          UI 侧再通过 get_model_display_name(...) 做友好显示与去日期后缀。\n        - 为兼容旧记录，本方法允许回退到 model_variant / model_type。\n        \"\"\"\n        params = result.get(\"parameters\", {}) or {}\n\n        # 新三层参数结构优先：actual > sent > requested\n        if isinstance(params, dict):\n            for layer in (\"params_actual\", \"params_sent\", \"params_requested\"):\n                layer_obj = params.get(layer)\n                if isinstance(layer_obj, dict):\n                    cand = layer_obj.get(\"model\") or layer_obj.get(\"model_id\")\n                    if cand:\n                        return str(cand)\n                    if layer == \"params_requested\":\n                        mv = layer_obj.get(\"model_variant\")\n                        if mv:\n                            return str(mv)\n\n        # 顶层 model（VideoService 会尽量补齐）\n        top = result.get(\"model\")\n        if top:\n            return str(top)\n\n        # 旧结构兼容：从 parameters 推断\n        if isinstance(params, dict):\n            mv = params.get(\"model_variant\") or \"\"\n            mt = params.get(\"model_type\") or \"\"\n            use_pro_model = params.get(\"use_pro_model\", True)\n\n            if mv:\n                return str(mv)\n            if isinstance(mt, str) and mt.strip():\n                return mt.strip()\n            if bool(use_pro_model):\n                return \"pro\"\n            return \"lite\"\n\n        return \"seedance\"\n","numLines":1270,"startLine":1,"totalLines":1270}}}
{"parentUuid":"ea64930b-9f28-49f9-8bb9-30bf982fed51","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TR9FQ89wp1eF1FiX3awCB7","type":"tool_result","content":"     1→# Seedance视频生成客户端\n     2→# 封装火山引擎Seedance1.0pro的API调用\n     3→\n     4→import os\n     5→import time\n     6→import json\n     7→import base64\n     8→import requests\n     9→import logging\n    10→import asyncio\n    11→from typing import Dict, Any, Optional, List, Tuple\n    12→from pathlib import Path\n    13→from loguru import logger\n    14→# volcenginesdkarkruntime import removed - not used in current implementation\n    15→from requests.adapters import HTTPAdapter\n    16→from urllib3.util.retry import Retry\n    17→\n    18→# 导入配置管理器和错误处理\n    19→from config.unified_config import get_unified_config\n    20→from modules.utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler\n    21→from .config import SeedanceModels, TaskStatus, SeedanceConfig\n    22→\n    23→\"\"\"\n    24→常量与辅助方法（视频参数 P0b）\n    25→- 仅保留“分辨率档位 + 比例”的新路径；不再支持旧 width/height → --rs 映射\n    26→\"\"\"\n    27→\n    28→# 白名单常量\n    29→RES_GRADES = {\"480p\", \"720p\", \"1080p\"}\n    30→RATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n    31→\n    32→def _summarize_payload_for_storage(\n    33→    data: Dict[str, Any],\n    34→    *,\n    35→    resolution_grade: Optional[str],\n    36→    ratio: Optional[str],\n    37→    duration: int,\n    38→    fps: int,\n    39→    seed: Optional[int],\n    40→    camera_fixed: bool,\n    41→    used_rs: str,\n    42→    used_rt: str,\n    43→    mode: str,\n    44→) -> Dict[str, Any]:\n    45→    \"\"\"\n    46→    生成可落盘的 params_sent（避免保存 base64 / 大字段）。\n    47→\n    48→    注意：\n    49→    - 仅存储与“参数一致性/复用/恢复”相关信息，不落 content.image_url.url 等内容。\n    50→    \"\"\"\n    51→    try:\n    52→        content = data.get(\"content\") or []\n    53→        image_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"image_url\"]\n    54→        text_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"text\"]\n    55→        text_len = 0\n    56→        if text_items:\n    57→            try:\n    58→                text_len = len(str(text_items[0].get(\"text\") or \"\"))\n    59→            except Exception:\n    60→                text_len = 0\n    61→\n    62→        roles = []\n    63→        for item in image_items:\n    64→            role = item.get(\"role\")\n    65→            if role:\n    66→                roles.append(str(role))\n    67→\n    68→        resolved_rs = used_rs or (resolution_grade or \"\")\n    69→        resolved_rt = used_rt or (ratio or \"\")\n    70→        return {\n    71→            \"model\": data.get(\"model\"),\n    72→            \"mode\": mode,\n    73→            \"service_tier\": data.get(\"service_tier\"),\n    74→            \"execution_expires_after\": data.get(\"execution_expires_after\"),\n    75→            \"generate_audio\": data.get(\"generate_audio\"),\n    76→            \"resolution\": resolved_rs,\n    77→            \"ratio\": resolved_rt,\n    78→            \"duration\": int(duration),\n    79→            \"framespersecond\": int(fps),\n    80→            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n    81→            \"camera_fixed\": bool(camera_fixed),\n    82→            # 服务端 watermark 已强制关闭（仅本地水印）\n    83→            \"watermark\": bool(data.get(\"watermark\", False)) if isinstance(data, dict) else False,\n    84→            \"content_summary\": {\n    85→                \"image_count\": len(image_items),\n    86→                \"image_roles\": roles,\n    87→                \"text_prompt_length\": text_len,\n    88→            },\n    89→        }\n    90→    except Exception:\n    91→        # 兜底：永远不让 params_sent 影响主流程\n    92→        return {\n    93→            \"model\": data.get(\"model\") if isinstance(data, dict) else None,\n    94→            \"mode\": mode,\n    95→            \"resolution\": used_rs or resolution_grade,\n    96→            \"ratio\": used_rt or ratio,\n    97→            \"duration\": int(duration),\n    98→            \"framespersecond\": int(fps),\n    99→            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n   100→        }\n   101→\n   102→def _validate_and_build_flags(\n   103→    resolution_grade: Optional[str],\n   104→    ratio: Optional[str],\n   105→    duration: int,\n   106→    fps: int,\n   107→    watermark: bool,\n   108→    camera_fixed: bool,\n   109→    seed: Optional[int],\n   110→) -> Tuple[str, bool, str, str, str]:\n   111→    \"\"\"生成安全版文本命令片段；返回 (flags_text, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n   112→    used_rs = resolution_grade or \"\"\n   113→    used_rt = ratio or \"\"\n   114→    fallback_applied = False\n   115→    fallback_reasons: List[str] = []\n   116→\n   117→    # 校验白名单\n   118→    if not used_rs or used_rs not in RES_GRADES:\n   119→        fallback_applied = True\n   120→        fallback_reasons.append(f\"无效分辨率: {used_rs or '缺失'}\")\n   121→        used_rs = \"1080p\"\n   122→    if not used_rt or used_rt not in RATIOS:\n   123→        fallback_applied = True\n   124→        fallback_reasons.append(f\"无效比例: {used_rt or '缺失'}\")\n   125→        used_rt = \"16:9\"\n   126→\n   127→    # 组装顺序: --rs --rt --dur --fps --wm --seed --cf\n   128→    parts: List[str] = []\n   129→    parts += [\"--rs\", used_rs, \"--rt\", used_rt, \"--dur\", str(int(duration)), \"--fps\", str(int(fps))]\n   130→    parts += [\"--wm\", str(bool(watermark)).lower()]\n   131→    if seed is not None and seed != -1:\n   132→        try:\n   133→            parts += [\"--seed\", str(int(seed))]\n   134→        except Exception:\n   135→            # 种子解析异常时忽略，不触发全局fallback\n   136→            logger.warning(\"种子参数无效，已忽略 --seed\")\n   137→    parts += [\"--cf\", str(bool(camera_fixed)).lower()]\n   138→\n   139→    flags_text = \" \".join(parts)\n   140→    fallback_reason = \", \".join(fallback_reasons) if fallback_applied else \"\"\n   141→    return flags_text, fallback_applied, fallback_reason, used_rs, used_rt\n   142→\n   143→\n   144→class SeedanceClient:\n   145→    \"\"\"火山引擎Seedance视频生成客户端\n   146→\n   147→    提供文生视频、图生视频和首尾帧视频生成功能\n   148→    \"\"\"\n   149→\n   150→    def __init__(\n   151→        self,\n   152→        api_key: Optional[str] = None,\n   153→        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n   154→        timeout: int = 60,\n   155→        max_retries: int = 3,\n   156→    ):\n   157→        \"\"\"初始化Seedance客户端\n   158→\n   159→        Args:\n   160→            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n   161→            base_url: API基础URL\n   162→            timeout: 请求超时时间（秒）\n   163→            max_retries: 最大重试次数\n   164→        \"\"\"\n   165→        # 获取API密钥\n   166→        if api_key is None:\n   167→            try:\n   168→                api_key = get_unified_config().get_api_key(\"volcengine\")\n   169→            except Exception as exc:\n   170→                raise AppError(str(exc), ErrorHandler.ErrorType.AUTH_ERROR) from exc\n   171→\n   172→        self.api_key = api_key\n   173→        self.base_url = base_url.rstrip(\"/\")\n   174→        self.timeout = timeout\n   175→        self.max_retries = max_retries\n   176→        self.retry_delay = 2\n   177→        self.config = SeedanceConfig()\n   178→        self._active_tasks = set()  # 跟踪活跃任务\n   179→\n   180→        # 配置会话\n   181→        self.session = requests.Session()\n   182→        \n   183→        # 配置SSL和连接参数\n   184→        import ssl\n   185→        from requests.adapters import HTTPAdapter\n   186→        from urllib3.util.retry import Retry\n   187→        from urllib3.util.ssl_ import create_urllib3_context\n   188→        \n   189→        # 创建自定义SSL上下文\n   190→        ssl_context = create_urllib3_context()\n   191→        ssl_context.check_hostname = False\n   192→        ssl_context.verify_mode = ssl.CERT_NONE\n   193→        ssl_context.set_ciphers('DEFAULT@SECLEVEL=1')\n   194→        \n   195→        # 配置更强的重试策略\n   196→        retry_strategy = Retry(\n   197→            total=max_retries * 2,  # 增加重试次数\n   198→            status_forcelist=[429, 500, 502, 503, 504],\n   199→            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n   200→            backoff_factor=2,  # 增加退避因子\n   201→            raise_on_status=False\n   202→        )\n   203→        \n   204→        # 创建自定义适配器\n   205→        class SSLAdapter(HTTPAdapter):\n   206→            def init_poolmanager(self, *args, **kwargs):\n   207→                kwargs['ssl_context'] = ssl_context\n   208→                kwargs['socket_options'] = [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]\n   209→                return super().init_poolmanager(*args, **kwargs)\n   210→        \n   211→        import socket\n   212→        adapter = SSLAdapter(\n   213→            max_retries=retry_strategy,\n   214→            pool_connections=10,\n   215→            pool_maxsize=20,\n   216→            pool_block=False\n   217→        )\n   218→        \n   219→        self.session.mount(\"http://\", adapter)\n   220→        self.session.mount(\"https://\", adapter)\n   221→\n   222→        # 设置会话级别的超时和连接参数\n   223→        self.session.timeout = (30, 120)  # (连接超时, 读取超时)\n   224→        self.session.verify = False  # 直接禁用SSL验证，避免证书问题\n   225→\n   226→        # 禁用SSL警告\n   227→        import urllib3\n   228→        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   229→\n   230→        self.session.headers.update({\n   231→            'Connection': 'keep-alive',\n   232→            'Keep-Alive': 'timeout=30, max=100'\n   233→        })\n   234→\n   235→        # 初始化性能监控\n   236→        self._performance_stats = {\n   237→            \"total_requests\": 0,\n   238→            \"successful_requests\": 0,\n   239→            \"failed_requests\": 0,\n   240→            \"total_response_time\": 0,\n   241→            \"last_request_time\": None\n   242→        }\n   243→        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n   244→        \n   245→        logger.info(\"Seedance客户端初始化完成\")\n   246→        logger.info(f\"使用配置: 基础URL={self.base_url}, 超时={timeout}秒, 最大重试={max_retries}次\")\n   247→\n   248→    def _provider_enabled(self) -> bool:\n   249→        try:\n   250→            import os\n   251→            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n   252→            return v not in {\"0\", \"false\", \"no\"}\n   253→        except Exception:\n   254→            return True\n   255→\n   256→    def _get_headers(self) -> Dict[str, str]:\n   257→        \"\"\"获取请求头\"\"\"\n   258→        api_key = str(self.api_key).strip()\n   259→\n   260→        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n   261→        try:\n   262→            api_key.encode('ascii')\n   263→        except UnicodeEncodeError:\n   264→            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n   265→\n   266→        return {\n   267→            \"Authorization\": f\"Bearer {api_key}\",\n   268→            \"Content-Type\": \"application/json; charset=utf-8\",\n   269→            \"User-Agent\": \"Seedance-Client/1.0.0\",\n   270→        }\n   271→\n   272→    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout=60):\n   273→        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n   274→        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   275→        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n   276→\n   277→    def _handle_response(self, response: requests.Response, operation: str = \"API调用\") -> Dict[str, Any]:\n   278→        \"\"\"处理API响应\n   279→\n   280→        Args:\n   281→            response: HTTP响应对象\n   282→            operation: 操作描述，用于日志记录\n   283→\n   284→        Returns:\n   285→            解析后的响应数据\n   286→\n   287→        Raises:\n   288→            Exception: 当API返回错误时\n   289→        \"\"\"\n   290→        try:\n   291→            # 记录响应基本信息\n   292→            logger.info(f\"{operation} - 响应状态码: {response.status_code}\")\n   293→            \n   294→            # 处理HTTP错误状态码\n   295→            if not response.ok:\n   296→                error_details = {\n   297→                    \"status_code\": response.status_code,\n   298→                    \"url\": response.url,\n   299→                    \"headers\": dict(response.headers),\n   300→                    \"operation\": operation\n   301→                }\n   302→                \n   303→                try:\n   304→                    error_body = response.json()\n   305→                    error_details[\"response_body\"] = error_body\n   306→                except Exception:\n   307→                    try:\n   308→                        error_details[\"response_text\"] = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   309→                    except Exception:\n   310→                        error_details[\"response_text\"] = str(response.content[:500])\n   311→                \n   312→                # 根据状态码分类错误\n   313→                if response.status_code == 400:\n   314→                    logger.error(f\"{operation} - 请求参数错误: {error_details}\")\n   315→                    try:\n   316→                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   317→                    except Exception:\n   318→                        preview = str(response.content[:500])\n   319→                    raise Exception(f\"请求参数错误: {preview}\")\n   320→                elif response.status_code == 401:\n   321→                    logger.error(f\"{operation} - 认证失败: API密钥无效\")\n   322→                    raise Exception(\"认证失败: 请检查API密钥是否正确\")\n   323→                elif response.status_code == 403:\n   324→                    logger.error(f\"{operation} - 权限不足: {error_details}\")\n   325→                    raise Exception(\"权限不足: 请检查API密钥权限\")\n   326→                elif response.status_code == 404:\n   327→                    logger.error(f\"{operation} - 资源不存在: {error_details}\")\n   328→                    raise Exception(\"资源不存在: 请检查API端点或任务ID\")\n   329→                elif response.status_code == 429:\n   330→                    logger.error(f\"{operation} - 请求频率限制: {error_details}\")\n   331→                    raise Exception(\"请求频率过高: 请稍后重试\")\n   332→                elif response.status_code >= 500:\n   333→                    logger.error(f\"{operation} - 服务器错误: {error_details}\")\n   334→                    raise Exception(f\"服务器错误: {response.status_code}\")\n   335→                else:\n   336→                    logger.error(f\"{operation} - HTTP错误: {error_details}\")\n   337→                    try:\n   338→                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n   339→                    except Exception:\n   340→                        preview = str(response.content[:500])\n   341→                    raise Exception(f\"HTTP错误: {response.status_code} - {preview}\")\n   342→\n   343→            # 解析JSON响应（增强容错：包括编码问题回退）\n   344→            try:\n   345→                result = response.json()\n   346→            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n   347→                raw = response.content or b\"\"\n   348→                tried = set()\n   349→                result = None\n   350→                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n   351→                    if not enc or enc in tried:\n   352→                        continue\n   353→                    tried.add(enc)\n   354→                    try:\n   355→                        text = raw.decode(enc, errors=\"strict\")\n   356→                        result = json.loads(text)\n   357→                        logger.debug(f\"{operation} - 通过备用编码解析成功: {enc}\")\n   358→                        break\n   359→                    except Exception:\n   360→                        continue\n   361→                if result is None:\n   362→                    # 最后尝试宽松日志预览，抛出统一错误\n   363→                    try:\n   364→                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n   365→                    except Exception:\n   366→                        preview = str(raw[:200])\n   367→                    logger.error(f\"{operation} - JSON解析失败(编码问题): {preview}\")\n   368→                    raise Exception(f\"响���格式错误: 无法解析JSON - {str(e)}\")\n   369→\n   370→            # 检查业务错误\n   371→            if \"error\" in result:\n   372→                error_info = result[\"error\"]\n   373→                error_msg = error_info.get(\"message\", \"未知错误\")\n   374→                error_code = error_info.get(\"code\", \"UNKNOWN_ERROR\")\n   375→                \n   376→                logger.error(f\"{operation} - API业务错误: {error_msg} (代码: {error_code})\")\n   377→                logger.error(f\"完整错误信息: {result}\")\n   378→                \n   379→                # 根据错误代码提供更友好的错误信息\n   380→                friendly_msg = self._get_friendly_error_message(error_code, error_msg)\n   381→                raise Exception(f\"API业务错误: {friendly_msg}\")\n   382→\n   383→            # 记录成功响应的关键信息\n   384→            if \"id\" in result:\n   385→                logger.info(f\"{operation} - 成功，任务ID: {result['id']}\")\n   386→            elif \"status\" in result:\n   387→                logger.info(f\"{operation} - 成功，状态: {result['status']}\")\n   388→            else:\n   389→                logger.info(f\"{operation} - 成功\")\n   390→\n   391→            return result\n   392→\n   393→        except requests.exceptions.Timeout as e:\n   394→            logger.error(f\"{operation} - 请求超时: {str(e)}\")\n   395→            raise Exception(f\"请求超时: 请检查网络连接或稍后重试\")\n   396→        except requests.exceptions.ConnectionError as e:\n   397→            logger.error(f\"{operation} - 连接错误: {str(e)}\")\n   398→            raise Exception(f\"网络连接错误: 请检查网络连接\")\n   399→        except requests.exceptions.RequestException as e:\n   400→            logger.error(f\"{operation} - 网络请求错误: {str(e)}\")\n   401→            raise Exception(f\"网络请求失败: {str(e)}\")\n   402→        except Exception as e:\n   403→            if \"API业务错误\" in str(e) or \"请求参数错误\" in str(e) or \"认证失败\" in str(e):\n   404→                # 重新抛出已处理的业务错误\n   405→                raise\n   406→            else:\n   407→                logger.error(f\"{operation} - 未知错误: {str(e)}\")\n   408→                raise Exception(f\"处理响应时发生未知错误: {str(e)}\")\n   409→    \n   410→    def _get_friendly_error_message(self, error_code: str, error_msg: str) -> str:\n   411→        \"\"\"获取友好的错误信息\n   412→        \n   413→        Args:\n   414→            error_code: 错误代码\n   415→            error_msg: 原始错误信息\n   416→            \n   417→        Returns:\n   418→            友好的错误信息\n   419→        \"\"\"\n   420→        error_mapping = {\n   421→            \"INVALID_PARAMETER\": \"参数无效，请检查输入参数\",\n   422→            \"INSUFFICIENT_QUOTA\": \"配额不足，请检查账户余额\",\n   423→            \"MODEL_NOT_FOUND\": \"模型不存在，请检查模型名称\",\n   424→            \"TASK_NOT_FOUND\": \"任务不存在，请检查任务ID\",\n   425→            \"TASK_ALREADY_CANCELLED\": \"任务已被取消\",\n   426→            \"TASK_ALREADY_COMPLETED\": \"任务已完成，无法取消\",\n   427→            \"RATE_LIMIT_EXCEEDED\": \"请求频率过高，请稍后重试\",\n   428→            \"INTERNAL_ERROR\": \"服务内部错误，请稍后重试\",\n   429→            \"UNAUTHORIZED\": \"未授权访问，请检查API密钥\",\n   430→            \"FORBIDDEN\": \"禁止访问，请检查权限设置\"\n   431→        }\n   432→        \n   433→        return error_mapping.get(error_code, f\"{error_msg} (错误代码: {error_code})\")\n   434→    \n   435→    def _record_request_stats(\n   436→        self,\n   437→        operation: str,\n   438→        success: bool,\n   439→        response_time: float,\n   440→        error_code: Optional[str] = None,\n   441→        error_message: Optional[str] = None,\n   442→    ):\n   443→        \"\"\"记录请求统计信息（统一结构 + 最近错误）。\"\"\"\n   444→        try:\n   445→            self._performance_stats[\"total_requests\"] += 1\n   446→            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n   447→            self._performance_stats[\"last_request_time\"] = time.time()\n   448→            \n   449→            if success:\n   450→                self._performance_stats[\"successful_requests\"] += 1\n   451→            else:\n   452→                self._performance_stats[\"failed_requests\"] += 1\n   453→                if error_code or error_message:\n   454→                    self._last_error = {\"code\": error_code, \"message\": (str(error_message)[:200] if error_message else None)}\n   455→            \n   456→            # 记录性能日志（安全摘要）\n   457→            total = max(1, self._performance_stats[\"total_requests\"])\n   458→            avg = self._performance_stats[\"total_response_time\"] / total\n   459→            success_rate = (self._performance_stats[\"successful_requests\"] / total) * 100\n   460→            logger.debug(f\"{operation} - 响应时间: {response_time:.2f}s, 平均: {avg:.2f}s, 成功率: {success_rate:.1f}%\")\n   461→        except Exception:\n   462→            pass\n   463→    \n   464→    def get_performance_stats(self) -> Dict[str, Any]:\n   465→        \"\"\"获取性能统计信息（统一字段命名）。\"\"\"\n   466→        stats = dict(self._performance_stats)\n   467→        total = stats.get(\"total_requests\", 0) or 0\n   468→        if total > 0:\n   469→            avg = stats.get(\"total_response_time\", 0.0) / total\n   470→            suc_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n   471→        else:\n   472→            avg = 0.0\n   473→            suc_rate = 0.0\n   474→        return {\n   475→            \"total_requests\": total,\n   476→            \"successful_requests\": stats.get(\"successful_requests\", 0),\n   477→            \"failed_requests\": stats.get(\"failed_requests\", 0),\n   478→            \"avg_response_time\": avg,\n   479→            \"success_rate\": suc_rate,\n   480→            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n   481→        }\n   482→\n   483→    def dump_metrics(self) -> Dict[str, Any]:\n   484→        \"\"\"导出统一指标，便于诊断脚本读取。\"\"\"\n   485→        m = self.get_performance_stats()\n   486→        m.update({\n   487→            \"client\": \"Seedance\",\n   488→            \"base_url\": self.base_url,\n   489→        })\n   490→        return m\n   491→\n   492→    def create_video_task(\n   493→        self,\n   494→        prompt: str,\n   495→        image_path: Optional[str] = None,\n   496→        first_frame_path: Optional[str] = None,\n   497→        last_frame_path: Optional[str] = None,\n   498→        duration: int = 8,\n   499→        fps: int = 24,\n   500→        width: Optional[int] = None,\n   501→        height: Optional[int] = None,\n   502→        seed: Optional[int] = None,\n   503→        use_pro_model: bool = True,\n   504→        model_type: Optional[str] = None,\n   505→        model_variant: Optional[str] = None,\n   506→        camera_fixed: bool = True,\n   507→        resolution_grade: Optional[str] = None,\n   508→        ratio: Optional[str] = None,\n   509→        watermark: bool = False,\n   510→        reference_images: Optional[List[str]] = None,\n   511→        generate_audio: Optional[bool] = None,\n   512→    ) -> Dict[str, Any]:\n   513→        \"\"\"\n   514→        创建视频生成任务（新路径：分辨率档位 + 比例）\n   515→\n   516→        Args:\n   517→            prompt: 视频描述提示词\n   518→            image_path: 输入图片路径（图生视频）\n   519→            first_frame_path: 首帧图片路径（首尾帧模式）\n   520→            last_frame_path: 尾帧图片路径（首尾帧模式）\n   521→            duration: 视频时长（秒），默认8秒\n   522→            fps: 帧率，默认24fps\n   523→            width/height: 旧路径兼容（关闭灰度时使用）\n   524→            seed: 随机种子\n   525→            use_pro_model: 是否使用Pro模型（兼容旧调用）\n   526→            model_type: 模型类型 \"pro\"/\"pro_fast\"/\"lite\"（优先级高于 use_pro_model）\n   527→            model_variant: UI 侧模型变体（如 seedance_1_5_pro）\n   528→            camera_fixed: 是否固定摄像头视角\n   529→            resolution_grade: 分辨率档位\n   530→            ratio: 画面比例\n   531→            watermark: 是否添加水印\n   532→            reference_images: 额外参考图（base64/url），Seedream 4.0 视频扩展预留\n   533→            generate_audio: 是否生成同步音频（仅 Seedance 1.5 Pro 生效）\n   534→\n   535→        Returns:\n   536→            包含任务ID的响应结果\n   537→        \"\"\"\n   538→        url = f\"{self.base_url}/contents/generations/tasks\"\n   539→        is_seedance_1_5_variant = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n   540→\n   541→        # 通过 Provider Schema 映射（默认启用；关闭时回退旧逻辑）\n   542→        data = None\n   543→        mode = \"\"\n   544→        fallback_applied = False\n   545→        fallback_reason = \"\"\n   546→        used_rs = \"\"\n   547→        used_rt = \"\"\n   548→        if self._provider_enabled():\n   549→            try:\n   550→                # 预编码图片为 data URL（与旧实现一致），再交由 Provider 组装 content\n   551→                enc_first = self._encode_image(first_frame_path) if first_frame_path else None\n   552→                enc_last = self._encode_image(last_frame_path) if last_frame_path else None\n   553→                enc_img = self._encode_image(image_path) if image_path else None\n   554→\n   555→                from modules.provider.factory import get_default_provider\n   556→                from modules.provider.schema import VideoParams\n   557→                provider = get_default_provider()\n   558→                mapped, fb, reason, used_rs, used_rt = provider.map_video(VideoParams(\n   559→                    prompt=prompt,\n   560→                    image_path=enc_img,\n   561→                    first_frame_path=enc_first,\n   562→                    last_frame_path=enc_last,\n   563→                    duration=int(duration),\n   564→                    fps=int(fps),\n   565→                    seed=(None if (seed is None or seed == -1) else seed),\n   566→                    camera_fixed=bool(camera_fixed),\n   567→                    watermark=False,\n   568→                    resolution_grade=resolution_grade,\n   569→                    ratio=ratio,\n   570→                    use_pro_model=bool(use_pro_model),\n   571→                    model_variant=model_variant,\n   572→                    generate_audio=generate_audio,\n   573→                    reference_images=(reference_images or []),\n   574→                ))\n   575→                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\n   576→                mode = mapped.get(\"mode\", \"视频\")\n   577→                model = data[\"model\"]\n   578→                fallback_applied, fallback_reason = fb, reason\n   579→                if fb:\n   580→                    logger.warning(f\"参数回退: {reason}\")\n   581→                logger.info(f\"安全版参数: {mapped.get('flags_text', '')}\")\n   582→            except Exception as _e:\n   583→                logger.warning(f\"Provider 映射失败，回退旧路径: {_e}\")\n   584→\n   585→        if data is None:\n   586→            # 旧内容组装路径\n   587→            content: List[Dict[str, Any]] = []\n   588→\n   589→            # 解析 model_type（优先级高于 use_pro_model）\n   590→            effective_model_type = model_type\n   591→            if not effective_model_type:\n   592→                effective_model_type = \"pro\" if use_pro_model else \"lite\"\n   593→\n   594→            # Seedance 1.5 Pro：独立模型（有声），不支持参考图模式\n   595→            is_seedance_1_5 = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n   596→            if is_seedance_1_5 and reference_images:\n   597→                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n   598→\n   599→            # 1.5 Pro 暂不支持 1080p，提前降级避免走到 flags fallback\n   600→            if is_seedance_1_5 and (not resolution_grade or resolution_grade == \"1080p\"):\n   601→                resolution_grade = \"720p\"\n   602→            if is_seedance_1_5 and not ratio:\n   603→                ratio = \"adaptive\"\n   604→\n   605→            # Pro-fast 不支持首尾帧模式，如果用户选了 pro_fast 但又传了首尾帧，回退到 Pro\n   606→            has_first_last_frame = bool(first_frame_path and last_frame_path)\n   607→            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n   608→                logger.warning(\"Pro-fast 不支持首尾帧模式，自动切换到 Pro 模型\")\n   609→                effective_model_type = \"pro\"\n   610→\n   611→            if is_seedance_1_5:\n   612→                model = SeedanceModels.PRO_1_5.value\n   613→                mode = (\n   614→                    \"首尾帧视频(1.5 Pro)\"\n   615→                    if has_first_last_frame\n   616→                    else (\"图生视频(1.5 Pro)\" if image_path else \"文生视频(1.5 Pro)\")\n   617→                )\n   618→            else:\n   619→                # 模型选择逻辑\n   620→                if has_first_last_frame:\n   621→                    # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面被回退）\n   622→                    if effective_model_type in (\"pro\", \"pro_fast\"):\n   623→                        model = SeedanceModels.PRO.value\n   624→                        mode = \"首尾帧视频(Pro)\"\n   625→                    else:\n   626→                        model = SeedanceModels.LITE_I2V.value\n   627→                        mode = \"首尾帧视频(Lite)\"\n   628→                elif effective_model_type == \"pro_fast\":\n   629→                    # Pro-fast 模式（文生视频或首帧图生视频）\n   630→                    model = SeedanceModels.PRO_FAST.value\n   631→                    mode = \"图生视频(Pro-fast)\" if image_path else \"文生视频(Pro-fast)\"\n   632→                elif effective_model_type == \"pro\":\n   633→                    model = SeedanceModels.PRO.value\n   634→                    mode = \"图生视频(Pro)\" if image_path else \"文生视频(Pro)\"\n   635→                else:\n   636→                    # Lite 模式\n   637→                    if image_path or reference_images:\n   638→                        model = SeedanceModels.LITE_I2V.value\n   639→                        if reference_images and not image_path:\n   640→                            mode = f\"参考图视频(Lite, {len(reference_images)}张)\"\n   641→                        else:\n   642→                            mode = \"图生视频(Lite)\"\n   643→                    else:\n   644→                        model = SeedanceModels.LITE_T2V.value\n   645→                        mode = \"文生视频(Lite)\"\n   646→\n   647→            if first_frame_path and last_frame_path:\n   648→                content.append({\n   649→                    \"type\": \"image_url\",\n   650→                    \"image_url\": {\"url\": self._encode_image(first_frame_path)},\n   651→                    \"role\": \"first_frame\"\n   652→                })\n   653→                content.append({\n   654→                    \"type\": \"image_url\",\n   655→                    \"image_url\": {\"url\": self._encode_image(last_frame_path)},\n   656→                    \"role\": \"last_frame\"\n   657→                })\n   658→            elif image_path:\n   659→                content.append({\n   660→                    \"type\": \"image_url\",\n   661→                    \"image_url\": {\"url\": self._encode_image(image_path)},\n   662→                    \"role\": \"first_frame\"\n   663→                })\n   664→            if reference_images:\n   665→                for ref_img in reference_images:\n   666→                    ref_path = ref_img.get('path') if isinstance(ref_img, dict) else ref_img\n   667→                    if ref_path:\n   668→                        content.append({\n   669→                            \"type\": \"image_url\",\n   670→                            \"image_url\": {\"url\": self._encode_image(ref_path)},\n   671→                            \"role\": \"reference_image\"\n   672→                        })\n   673→                logger.info(f\"添加 {len(reference_images)} 张参考图到请求\")\n   674→\n   675→            # Lite 参考图模式（r2v）不支持 1080p，强制降级到 720p\n   676→            if reference_images and not image_path and effective_model_type == \"lite\":\n   677→                if resolution_grade == \"1080p\" or not resolution_grade:\n   678→                    resolution_grade = \"720p\"\n   679→                    logger.info(\"Lite 参考图模式不支持 1080p，已自动降级到 720p\")\n   680→\n   681→            # 文本命令\n   682→            # Force server-side watermark off for Plan B (local watermark only)\n   683→            flags_text, fallback_applied, fallback_reason, used_rs, used_rt = _validate_and_build_flags(\n   684→                resolution_grade=resolution_grade,\n   685→                ratio=ratio,\n   686→                duration=duration,\n   687→                fps=fps,\n   688→                watermark=False,\n   689→                camera_fixed=camera_fixed,\n   690→                seed=seed,\n   691→            )\n   692→            text_prompt = f\"{prompt} {flags_text}\".strip()\n   693→            if fallback_applied:\n   694→                logger.warning(f\"参数回退: {fallback_reason}\")\n   695→            logger.info(f\"安全版参数: {flags_text}\")\n   696→            content.append({\"type\": \"text\", \"text\": text_prompt})\n   697→            data = {\"model\": model, \"content\": content}\n   698→\n   699→        # 固定后端参数：service_tier=default, execution_expires_after=6h（21600s）\n   700→        # 不暴露 UI；用于服务端任务超时治理\n   701→        try:\n   702→            data.setdefault(\"service_tier\", \"default\")\n   703→            data.setdefault(\"execution_expires_after\", 21600)\n   704→        except Exception:\n   705→            pass\n   706→\n   707→        # Seedance 1.5 Pro：生成音频开关（默认 true）\n   708→        try:\n   709→            if is_seedance_1_5_variant or data.get(\"model\") == SeedanceModels.PRO_1_5.value:\n   710→                data[\"generate_audio\"] = bool(True if generate_audio is None else generate_audio)\n   711→        except Exception:\n   712→            pass\n   713→\n   714→        headers = self._get_headers()\n   715→        logger.info(f\"创建{mode}任务: {prompt[:50]}...\")\n   716→        logger.info(f\"使用模型: {model}\")\n   717→        logger.info(f\"参数: {used_rs or resolution_grade}+{used_rt or ratio}, dur={duration}s, fps={fps}\")\n   718→\n   719→        params_sent_summary = _summarize_payload_for_storage(\n   720→            data,\n   721→            resolution_grade=resolution_grade,\n   722→            ratio=ratio,\n   723→            duration=duration,\n   724→            fps=fps,\n   725→            seed=seed,\n   726→            camera_fixed=camera_fixed,\n   727→            used_rs=used_rs,\n   728→            used_rt=used_rt,\n   729→            mode=mode,\n   730→        )\n   731→\n   732→        start_time = time.time()\n   733→        success = False\n   734→        err_code: Optional[str] = None\n   735→        err_msg: Optional[str] = None\n   736→        try:\n   737→            logger.info(f\"发送请求到: {url}\")\n   738→            # 安全日志对象，避免 content 结构异常导致索引错误\n   739→            text_items = [item for item in data.get(\"content\", []) if item.get(\"type\") == \"text\"]\n   740→            text_len = 0\n   741→            if text_items:\n   742→                try:\n   743→                    text_len = len(text_items[0].get(\"text\", \"\"))\n   744→                except Exception:\n   745→                    text_len = 0\n   746→            safe_data = {\n   747→                \"model\": data.get(\"model\"),\n   748→                \"content_types\": [item.get(\"type\") for item in data.get(\"content\", [])],\n   749→                \"text_prompt_length\": text_len,\n   750→                \"image_count\": len([item for item in data.get(\"content\", []) if item.get(\"type\") == \"image_url\"]) \n   751→            }\n   752→            logger.info(f\"请求参数: {json.dumps(safe_data, indent=2, ensure_ascii=False)}\")\n   753→\n   754→            response = self._safe_json_post(url, headers, data, timeout=60)\n   755→            response_time = time.time() - start_time\n   756→            logger.info(f\"响应状态码: {response.status_code}, 响应时间: {response_time:.2f}s\")\n   757→\n   758→            result = self._handle_response(response, \"创建视频任务\")\n   759→            success = True\n   760→            task_id = result.get(\"id\")\n   761→            if task_id:\n   762→                self._active_tasks.add(task_id)\n   763→                logger.info(f\"{mode}任务创建成功，任务ID: {task_id}\")\n   764→                try:\n   765→                    params_sent_summary[\"api_task_id\"] = task_id\n   766→                except Exception:\n   767→                    pass\n   768→                result_obj = {\n   769→                    \"success\": True,\n   770→                    \"task_id\": task_id,\n   771→                    \"status\": result.get(\"status\", \"processing\"),\n   772→                    \"model\": model,\n   773→                    \"mode\": mode,\n   774→                    \"estimated_cost\": self._calculate_cost(model, duration),\n   775→                    \"created_at\": time.time(),\n   776→                    \"fallback_applied\": fallback_applied,\n   777→                    \"fallback_reason\": fallback_reason,\n   778→                    \"used_rs\": used_rs,\n   779→                    \"used_rt\": used_rt,\n   780→                    \"params_sent\": params_sent_summary,\n   781→                }\n   782→                # 安全摘要日志\n   783→                logger.info(\n   784→                    f\"摘要|operation=create_task status=success elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id}\"\n   785→                )\n   786→                return result_obj\n   787→            else:\n   788→                logger.error(f\"{mode}任务创建失败，未获取到任务ID\")\n   789→                return {\"success\": False, \"error\": \"未获取到任务ID\", \"response\": result}\n   790→\n   791→        except requests.exceptions.SSLError as e:\n   792→            logger.error(f\"{mode}任务创建失败 - SSL错误: {str(e)}\")\n   793→            logger.info(\"尝试使用备用SSL配置重新连接...\")\n   794→            try:\n   795→                backup_session = requests.Session()\n   796→                backup_session.verify = False\n   797→                import urllib3\n   798→                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   799→                # 手动编码避免 PyInstaller latin-1 问题\n   800→                body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n   801→                response = backup_session.post(url, headers=headers, data=body, timeout=(30, 120))\n   802→                result = self._handle_response(response, \"创建视频任务(备用连接)\")\n   803→                success = True\n   804→                task_id = result.get(\"id\")\n   805→                if task_id:\n   806→                    self._active_tasks.add(task_id)\n   807→                    logger.info(f\"{mode}任务创建成功(备用连接)，任务ID: {task_id}\")\n   808→                    try:\n   809→                        params_sent_summary[\"api_task_id\"] = task_id\n   810→                    except Exception:\n   811→                        pass\n   812→                    result_obj = {\n   813→                        \"success\": True,\n   814→                        \"task_id\": task_id,\n   815→                        \"status\": result.get(\"status\", \"processing\"),\n   816→                        \"model\": model,\n   817→                        \"mode\": mode,\n   818→                        \"estimated_cost\": self._calculate_cost(model, duration),\n   819→                        \"created_at\": time.time(),\n   820→                        \"fallback_applied\": fallback_applied,\n   821→                        \"fallback_reason\": fallback_reason,\n   822→                        \"used_rs\": used_rs,\n   823→                        \"used_rt\": used_rt,\n   824→                        \"params_sent\": params_sent_summary,\n   825→                    }\n   826→                    logger.info(\n   827→                        f\"摘要|operation=create_task status=success elapsed={time.time() - start_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id} (backup)\"\n   828→                    )\n   829→                    return result_obj\n   830→                else:\n   831→                    raise Exception(\"备用连接也未获取到任务ID\")\n   832→            except Exception as backup_e:\n   833→                logger.error(f\"备用连接也失败: {str(backup_e)}\")\n   834→                err_code, err_msg = \"SSL_ERROR\", f\"SSL连接失败: {str(e)}; 备用: {str(backup_e)}\"\n   835→                raise Exception(f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}\")\n   836→        except requests.exceptions.ConnectionError as e:\n   837→            logger.error(f\"{mode}任务创建失败 - 连接错误: {str(e)}\")\n   838→            err_code, err_msg = \"NETWORK_ERROR\", str(e)\n   839→            raise Exception(f\"网络连接失败，请检查网络连接: {str(e)}\")\n   840→        except requests.exceptions.Timeout as e:\n   841→            logger.error(f\"{mode}任务创建失败 - 超时: {str(e)}\")\n   842→            err_code, err_msg = \"TIMEOUT_ERROR\", str(e)\n   843→            raise Exception(f\"请求超时，请稍后重试: {str(e)}\")\n   844→        except Exception as e:\n   845→            logger.error(f\"{mode}任务创建失败: {str(e)}\")\n   846→            err_code, err_msg = \"UNKNOWN_ERROR\", str(e)\n   847→            raise Exception(f\"视频生成任务创建失败: {str(e)}\")\n   848→        finally:\n   849→            response_time = time.time() - start_time\n   850→            # 失败时记录摘要\n   851→            if not success:\n   852→                logger.info(\n   853→                    f\"摘要|operation=create_task status=failed elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s error={err_code}\"\n   854→                )\n   855→            self._record_request_stats(\"创建视频任务\", success, response_time, err_code, err_msg)\n   856→\n   857→    \n   858→    def _calculate_cost(self, model: str, duration: int) -> float:\n   859→        \"\"\"计算预估成本\"\"\"\n   860→        base_cost = self.config.MODEL_PRICING.get(model, 15)\n   861→        # 简单的成本估算：基础价格 * 时长系数\n   862→        return base_cost * (duration / 5.0)  # 以5秒为基准\n   863→\n   864→    def query_video_task(self, task_id: str) -> Dict[str, Any]:\n   865→        \"\"\"查询视频生成任务状态\n   866→\n   867→        Args:\n   868→            task_id: 任务ID\n   869→\n   870→        Returns:\n   871→            任务状态信息\n   872→\n   873→        Raises:\n   874→            AppError: 当API调用失败时\n   875→        \"\"\"\n   876→        # 使用正确的查询API端点\n   877→        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n   878→        headers = self._get_headers()\n   879→\n   880→        logger.info(f\"查询视频任务状态: {task_id}\")\n   881→\n   882→        try:\n   883→            try:\n   884→                response = self.session.get(url, headers=headers, timeout=30)\n   885→            except requests.exceptions.SSLError as e:\n   886→                logger.error(f\"查询视频任务状态失败 - SSL错误: {str(e)}\")\n   887→                logger.info(\"尝试使用备用SSL配置重新查询任务状态...\")\n   888→                try:\n   889→                    backup_session = requests.Session()\n   890→                    backup_session.verify = False\n   891→                    import urllib3\n   892→                    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n   893→                    response = backup_session.get(url, headers=headers, timeout=30)\n   894→                except Exception as backup_e:\n   895→                    logger.error(f\"备用SSL配置查询失败: {str(backup_e)}\")\n   896→                    raise Exception(\n   897→                        f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}; 备用: {str(backup_e)}\"\n   898→                    ) from e\n   899→\n   900→            result = self._handle_response(response, \"查询视频任务\")\n   901→\n   902→            # 根据官方API返回格式解析状态\n   903→            status = result.get(\"status\", \"unknown\")\n   904→            video_url = result.get(\"content\", {}).get(\"video_url\")\n   905→            \n   906→            logger.info(f\"任务 {task_id} 状态: {status}\")\n   907→            \n   908→            if status == \"succeeded\" and video_url:\n   909→                logger.info(f\"视频生成完成: {video_url}\")\n   910→\n   911→            # 获取缩略图URL\n   912→            thumbnail_url = result.get(\"content\", {}).get(\"thumbnail_url\") or result.get(\"thumbnail_url\")\n   913→            preview_url = result.get(\"content\", {}).get(\"preview_url\") or result.get(\"preview_url\")\n   914→\n   915→            # 解析关键“实际参数”（用于 params_actual 落盘）\n   916→            seed_value = result.get(\"seed\")\n   917→            ratio_value = result.get(\"ratio\")\n   918→            fps_value = result.get(\"framespersecond\")\n   919→            service_tier = result.get(\"service_tier\")\n   920→            execution_expires_after = result.get(\"execution_expires_after\")\n   921→            generate_audio = result.get(\"generate_audio\")\n   922→            \n   923→            result_obj = {\n   924→                \"success\": True,\n   925→                \"task_id\": task_id,\n   926→                \"status\": status,\n   927→                \"video_url\": video_url,\n   928→                \"thumbnail_url\": thumbnail_url,\n   929→                \"preview_url\": preview_url,\n   930→                \"model\": result.get(\"model\"),\n   931→                \"resolution\": result.get(\"resolution\"),\n   932→                \"ratio\": ratio_value,\n   933→                \"duration\": result.get(\"duration\"),\n   934→                \"fps\": fps_value,\n   935→                \"framespersecond\": fps_value,\n   936→                \"seed\": seed_value,\n   937→                \"service_tier\": service_tier,\n   938→                \"execution_expires_after\": execution_expires_after,\n   939→                \"generate_audio\": generate_audio,\n   940→                \"usage\": result.get(\"usage\"),\n   941→                \"created_at\": result.get(\"created_at\"),\n   942→                \"updated_at\": result.get(\"updated_at\")\n   943→            }\n   944→            # 安全摘要日志\n   945→            logger.info(\n   946→                f\"摘要|operation=query_task status={status} task_id={task_id} video_ready={'yes' if bool(video_url) else 'no'}\"\n   947→            )\n   948→            return result_obj\n   949→\n   950→        except Exception as e:\n   951→            logger.error(f\"查询视频任务状态失败: {str(e)}\")\n   952→            raise Exception(f\"查询任务状态失败: {str(e)}\")\n   953→\n   954→    def get_task_status(self, task_id: str) -> Dict[str, Any]:\n   955→        \"\"\"\n   956→        查询任务状态（兼容旧接口）\n   957→\n   958→        Args:\n   959→            task_id: 任务ID\n   960→\n   961→        Returns:\n   962→            Dict: 任务状态信息\n   963→        \"\"\"\n   964→        return self.query_video_task(task_id)\n   965→\n   966→    def wait_for_completion(self, task_id: str, max_wait_time: Optional[int] = None) -> Dict[str, Any]:\n   967→        \"\"\"\n   968→        等待任务完成（智能轮询）\n   969→\n   970→        Args:\n   971→            task_id: 任务ID\n   972→            max_wait_time: 最大等待时间（秒），默认使用配置值\n   973→\n   974→        Returns:\n   975→            Dict: 最终任务结果\n   976→        \"\"\"\n   977→        max_wait_time = max_wait_time or self.config.POLLING[\"max_wait_time\"]\n   978→        intervals = self.config.POLLING[\"intervals\"]\n   979→        \n   980→        logger.info(f\"开始智能轮询任务: {task_id}\")\n   981→        \n   982→        start_time = time.time()\n   983→        attempt = 0\n   984→\n   985→        while time.time() - start_time < max_wait_time:\n   986→            try:\n   987→                # 查询任务状态\n   988→                status_result = self.get_task_status(task_id)\n   989→\n   990→                if not status_result[\"success\"]:\n   991→                    return status_result\n   992→\n   993→                status = status_result[\"status\"]\n   994→                progress = status_result.get(\"progress\", 0)\n   995→\n   996→                logger.info(f\"任务 {task_id} 状态: {status}, 进度: {progress}%\")\n   997→\n   998→                # 检查是否为终态\n   999→                if TaskStatus.is_terminal(status):\n  1000→                    if status == TaskStatus.SUCCEEDED.value:\n  1001→                        logger.success(f\"任务完成: {task_id}\")\n  1002→                    elif status == TaskStatus.FAILED.value:\n  1003→                        logger.error(f\"任务失败: {task_id}\")\n  1004→                    elif status == TaskStatus.CANCELLED.value:\n  1005→                        logger.warning(f\"任务被取消: {task_id}\")\n  1006→                    \n  1007→                    # 从活跃任务中移除\n  1008→                    self._active_tasks.discard(task_id)\n  1009→                    return status_result\n  1010→\n  1011→                # 动态调整轮询间隔\n  1012→                interval = intervals[min(attempt, len(intervals) - 1)]\n  1013→                logger.debug(f\"等待 {interval} 秒后继续轮询\")\n  1014→                time.sleep(interval)\n  1015→                attempt += 1\n  1016→                \n  1017→            except Exception as e:\n  1018→                logger.error(f\"轮询异常: {e}\")\n  1019→                time.sleep(5)  # 异常时等待5秒\n  1020→\n  1021→        # 超时处理\n  1022→        logger.error(f\"轮询超时: {task_id}\")\n  1023→        self._active_tasks.discard(task_id)\n  1024→        return {\n  1025→            \"success\": False, \n  1026→            \"error\": \"等待任务完成超时\", \n  1027→            \"error_code\": \"TIMEOUT_ERROR\", \n  1028→            \"task_id\": task_id,\n  1029→            \"elapsed_time\": time.time() - start_time\n  1030→        }\n  1031→\n  1032→    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n  1033→        \"\"\"\n  1034→        取消视频生成任务（仅在queued状态有效）\n  1035→\n  1036→        Args:\n  1037→            task_id: 任务ID\n  1038→\n  1039→        Returns:\n  1040→            成功: {\"success\": True, \"status\": \"cancelled\"}\n  1041→            失败: {\"success\": False, \"error\": \"错误信息\"}\n  1042→        \"\"\"\n  1043→        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n  1044→        headers = {\n  1045→            \"Content-Type\": \"application/json\",\n  1046→            \"Authorization\": f\"Bearer {self.api_key}\"\n  1047→        }\n  1048→\n  1049→        try:\n  1050→            response = requests.delete(url, headers=headers, timeout=10)\n  1051→\n  1052→            if response.status_code == 200:\n  1053→                # DELETE请求成功，等待0.5秒后查询实际状态\n  1054→                time.sleep(0.5)\n  1055→\n  1056→                # 查询任务状态以确认是否真的变成cancelled\n  1057→                try:\n  1058→                    status_result = self.query_video_task(task_id)\n  1059→                    current_status = status_result.get(\"status\", \"unknown\")\n  1060→\n  1061→                    if current_status == \"cancelled\":\n  1062→                        # 真正成功取消\n  1063→                        self._active_tasks.discard(task_id)\n  1064→                        logger.info(f\"任务已成功取消: {task_id}，状态已变更为 cancelled\")\n  1065→                        return {\"success\": True, \"status\": \"cancelled\"}\n  1066→                    else:\n  1067→                        # DELETE成功但状态不是cancelled（任务可能已在执行中）\n  1068→                        logger.warning(f\"DELETE请求成功，但任务状态为 {current_status}（任务可能已在执行中，无法取消）\")\n  1069→                        return {\"success\": False, \"status\": current_status, \"error\": f\"任务状态为 {current_status}，无法取消\"}\n  1070→                except Exception as query_e:\n  1071→                    # 状态查询失败，但DELETE请求成功\n  1072→                    logger.warning(f\"DELETE请求成功，但状态查询失败: {query_e}\")\n  1073→                    self._active_tasks.discard(task_id)\n  1074→                    return {\"success\": True, \"status\": \"cancelled\", \"warning\": \"状态确认失败\"}\n  1075→\n  1076→            if response.status_code == 400:\n  1077→                error_msg = response.json().get(\"error\", {}).get(\"message\", \"任务无法取消（可能已在执行中）\")\n  1078→                logger.warning(f\"取消任务失败: {task_id} - {error_msg}\")\n  1079→                return {\"success\": False, \"error\": error_msg}\n  1080→\n  1081→            error_msg = f\"HTTP {response.status_code}: {response.text}\"\n  1082→            logger.error(f\"取消任务请求失败: {error_msg}\")\n  1083→            return {\"success\": False, \"error\": error_msg}\n  1084→\n  1085→        except Exception as e:  # pylint: disable=broad-except\n  1086→            logger.error(f\"取消任务异常: {task_id} - {e}\")\n  1087→            return {\"success\": False, \"error\": str(e)}\n  1088→\n  1089→    def list_tasks(self, limit: int = 20, offset: int = 0, status_filter: Optional[str] = None) -> Dict[str, Any]:\n  1090→        \"\"\"\n  1091→        获取任务列表（改进版）\n  1092→\n  1093→        Args:\n  1094→            limit: 返回数量限制\n  1095→            offset: 偏移量\n  1096→            status_filter: 状态过滤器\n  1097→\n  1098→        Returns:\n  1099→            Dict: 任务列表\n  1100→        \"\"\"\n  1101→        url = f\"{self.base_url}{self.config.ENDPOINTS['list_tasks']}\"\n  1102→        headers = self._get_headers()\n  1103→        \n  1104→        params = {\n  1105→            \"limit\": limit,\n  1106→            \"offset\": offset\n  1107→        }\n  1108→        \n  1109→        if status_filter:\n  1110→            params[\"status\"] = status_filter\n  1111→        \n  1112→        logger.info(f\"获取任务列表: limit={limit}, offset={offset}, status_filter={status_filter}\")\n  1113→        \n  1114→        # 记录开始时间\n  1115→        start_time = time.time()\n  1116→        success = False\n  1117→\n  1118→        try:\n  1119→            response = self.session.get(url, headers=headers, params=params, timeout=30)\n  1120→            result = self._handle_response(response, \"获取任务列表\")\n  1121→            \n  1122→            tasks = result.get(\"data\", [])\n  1123→            total = result.get(\"total\", len(tasks))\n  1124→            \n  1125→            logger.success(f\"获取任务列表成功，共{len(tasks)}个任务\")\n  1126→            success = True\n  1127→            \n  1128→            return {\n  1129→                \"success\": True,\n  1130→                \"tasks\": tasks,\n  1131→                \"total\": total,\n  1132→                \"limit\": limit,\n  1133→                \"offset\": offset,\n  1134→                \"has_more\": offset + len(tasks) < total\n  1135→            }\n  1136→            \n  1137→        except Exception as e:\n  1138→            logger.error(f\"获取任务列表失败: {e}\")\n  1139→            return {\n  1140→                 \"success\": False,\n  1141→                 \"error\": str(e)\n  1142→             }\n  1143→        finally:\n  1144→            # 记录性能统计\n  1145→            response_time = time.time() - start_time\n  1146→            self._record_request_stats(\"获取任务列表\", success, response_time)\n  1147→    \n  1148→    def batch_query_tasks(self, task_ids: List[str]) -> Dict[str, Any]:\n  1149→        \"\"\"\n  1150→        批量查询任务状态\n  1151→        \n  1152→        Args:\n  1153→            task_ids: 任务ID列表\n  1154→        \n  1155→        Returns:\n  1156→            批量查询结果\n  1157→        \"\"\"\n  1158→        results = {}\n  1159→        success_count = 0\n  1160→        \n  1161→        logger.info(f\"批量查询{len(task_ids)}个任务\")\n  1162→        \n  1163→        for task_id in task_ids:\n  1164→            try:\n  1165→                result = self.query_video_task(task_id)\n  1166→                if result.get(\"success\", True):  # 兼容不同的返回格式\n  1167→                    success_count += 1\n  1168→                results[task_id] = result\n  1169→            except Exception as e:\n  1170→                results[task_id] = {\n  1171→                    \"success\": False,\n  1172→                    \"error\": str(e)\n  1173→                }\n  1174→        \n  1175→        return {\n  1176→            \"success\": True,\n  1177→            \"results\": results,\n  1178→            \"total\": len(task_ids),\n  1179→            \"success_count\": success_count,\n  1180→            \"failed_count\": len(task_ids) - success_count\n  1181→        }\n  1182→    \n  1183→    def cancel_all_active_tasks(self) -> Dict[str, Any]:\n  1184→        \"\"\"\n  1185→        取消所有活跃任务\n  1186→        \n  1187→        Returns:\n  1188→            取消结果统计\n  1189→        \"\"\"\n  1190→        active_tasks = list(self._active_tasks)\n  1191→        \n  1192→        if not active_tasks:\n  1193→            return {\n  1194→                \"success\": True,\n  1195→                \"message\": \"没有活跃任务需要取消\",\n  1196→                \"cancelled\": 0\n  1197→            }\n  1198→        \n  1199→        cancelled_count = 0\n  1200→        failed_count = 0\n  1201→        \n  1202→        logger.info(f\"取消{len(active_tasks)}个活跃任务\")\n  1203→        \n  1204→        for task_id in active_tasks:\n  1205→            result = self.cancel_task(task_id)\n  1206→            if result.get(\"success\"):\n  1207→                cancelled_count += 1\n  1208→            else:\n  1209→                failed_count += 1\n  1210→        \n  1211→        return {\n  1212→            \"success\": True,\n  1213→            \"cancelled\": cancelled_count,\n  1214→            \"failed\": failed_count,\n  1215→            \"total_active\": len(active_tasks)\n  1216→        }\n  1217→    \n  1218→    def get_task_statistics(self) -> Dict[str, Any]:\n  1219→        \"\"\"\n  1220→        获取任务统计信息\n  1221→        \n  1222→        Returns:\n  1223→            统计信息\n  1224→        \"\"\"\n  1225→        try:\n  1226→            # 获取最近的任务列表\n  1227→            tasks_result = self.list_tasks(limit=100)\n  1228→            \n  1229→            if not tasks_result.get(\"success\"):\n  1230→                return tasks_result\n  1231→            \n  1232→            tasks = tasks_result.get(\"tasks\", [])\n  1233→            \n  1234→            # 统计各状态任务数量\n  1235→            status_counts = {}\n  1236→            total_cost = 0\n  1237→            \n  1238→            for task in tasks:\n  1239→                status = task.get(\"status\", \"unknown\")\n  1240→                status_counts[status] = status_counts.get(status, 0) + 1\n  1241→                \n  1242→                # 估算成本\n  1243→                model = task.get(\"model\", \"\")\n  1244→                if model in self.config.MODEL_PRICING:\n  1245→                    total_cost += self.config.MODEL_PRICING[model]\n  1246→            \n  1247→            return {\n  1248→                \"success\": True,\n  1249→                \"total_tasks\": len(tasks),\n  1250→                \"active_tasks\": len(self._active_tasks),\n  1251→                \"status_counts\": status_counts,\n  1252→                \"estimated_total_cost\": total_cost,\n  1253→                \"timestamp\": time.time()\n  1254→            }\n  1255→            \n  1256→        except Exception as e:\n  1257→            logger.error(f\"获取统计信息失败: {e}\")\n  1258→            return {\n  1259→                \"success\": False,\n  1260→                \"error\": str(e)\n  1261→            }\n  1262→\n  1263→    def _prepare_image(self, image_path: str) -> str:\n  1264→        \"\"\"准备图片数据，返回data URL格式\"\"\"\n  1265→        try:\n  1266→            # 使用新的图片格式验证器\n  1267→            from utils.image_format_validator import validate_and_prepare_image\n  1268→            \n  1269→            result = validate_and_prepare_image(image_path, auto_convert=True)\n  1270→            \n  1271→            if result['success']:\n  1272→                if result['is_converted']:\n  1273→                    logger.info(f\"图片已自动转换: {result['original_format']} -> {result['final_format']}\")\n  1274→                return result['data_url']\n  1275→            else:\n  1276→                raise Exception(result['error'])\n  1277→                \n  1278→        except Exception as e:\n  1279→            logger.error(f\"图片处理失败: {str(e)}\")\n  1280→            raise Exception(f\"图片处理失败: {str(e)}\")\n  1281→\n  1282→    def _encode_image(self, image_path: str) -> str:\n  1283→        \"\"\"将图像文件编码为data URL格式\n  1284→        集成图片格式验证和自动转换功能\n  1285→        \n  1286→        Args:\n  1287→            image_path: 图像文件路径\n  1288→            \n  1289→        Returns:\n  1290→            data URL格式的图像字符串\n  1291→            \n  1292→        Raises:\n  1293→            AppError: 当图像文件不存在或编码失败时\n  1294→        \"\"\"\n  1295→        try:\n  1296→            image_path = Path(image_path)\n  1297→            if not image_path.exists():\n  1298→                raise AppError(f\"图像文件不存在: {image_path}\", ErrorHandler.ErrorType.FILE_ERROR)\n  1299→            \n  1300→            # 使用图片格式验证器处理\n  1301→            from utils.image_format_validator import validate_and_prepare_image\n  1302→            \n  1303→            result = validate_and_prepare_image(str(image_path), auto_convert=True)\n  1304→            \n  1305→            if result['success']:\n  1306→                if result['is_converted']:\n  1307→                    logger.info(f\"图片格式已自动转换: {result['original_format']} -> {result['final_format']}\")\n  1308→                return result['data_url']\n  1309→            else:\n  1310→                logger.error(f\"图片处理失败: {result['error']}\")\n  1311→                raise AppError(f\"图片处理失败: {result['error']}\", ErrorHandler.ErrorType.FILE_ERROR)\n  1312→                \n  1313→        except AppError:\n  1314→            raise\n  1315→        except Exception as e:\n  1316→            # 避免在日志中显示可能包含base64数据的异常信息\n  1317→            error_msg = str(e)\n  1318→            if len(error_msg) > 200:\n  1319→                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n  1320→            logger.error(f\"图像编码失败: {error_msg}\")\n  1321→            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorHandler.ErrorType.FILE_ERROR)\n  1322→\n  1323→    def _get_mime_type(self, extension: str) -> str:\n  1324→        \"\"\"\n  1325→        根据文件扩展名获取MIME类型\n  1326→\n  1327→        Args:\n  1328→            extension: 文件扩展名\n  1329→\n  1330→        Returns:\n  1331→            str: MIME类型\n  1332→        \"\"\"\n  1333→        mime_types = {\".jpg\": \"image/jpeg\", \".jpeg\": \"image/jpeg\", \".png\": \"image/png\", \".webp\": \"image/webp\"}\n  1334→        return mime_types.get(extension, \"image/jpeg\")\n  1335→\n  1336→    def _make_request(\n  1337→        self,\n  1338→        endpoint: str,\n  1339→        data: Optional[Dict[str, Any]] = None,\n  1340→        params: Optional[Dict[str, Any]] = None,\n  1341→        method: str = \"POST\",\n  1342→    ) -> Dict[str, Any]:\n  1343→        \"\"\"\n  1344→        发送HTTP请求\n  1345→\n  1346→        Args:\n  1347→            endpoint: API端点\n  1348→            data: 请求数据\n  1349→            params: 查询参数\n  1350→            method: HTTP方法\n  1351→\n  1352→        Returns:\n  1353→            Dict: 响应结果\n  1354→        \"\"\"\n  1355→        url = f\"{self.base_url}{endpoint}\"\n  1356→\n  1357→        headers = {\"Authorization\": f\"Bearer {self.api_key}\", \"Content-Type\": \"application/json\"}\n  1358→\n  1359→        for attempt in range(self.max_retries):\n  1360→            try:\n  1361→                if method.upper() == \"GET\":\n  1362→                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)\n  1363→                else:\n  1364→                    response = requests.post(url, headers=headers, json=data, params=params, timeout=self.timeout)\n  1365→\n  1366→                response.raise_for_status()\n  1367→\n  1368→                # 解析响应（增强容错：包括编码问题回退）\n  1369→                try:\n  1370→                    result = response.json()\n  1371→                except (json.JSONDecodeError, UnicodeDecodeError) as e:\n  1372→                    raw = response.content or b\"\"\n  1373→                    tried = set()\n  1374→                    result = None\n  1375→                    for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n  1376→                        if not enc or enc in tried:\n  1377→                            continue\n  1378→                        tried.add(enc)\n  1379→                        try:\n  1380→                            text = raw.decode(enc, errors=\"strict\")\n  1381→                            result = json.loads(text)\n  1382→                            logger.debug(f\"_make_request - 通过备用编码解析成功: {enc}\")\n  1383→                            break\n  1384→                        except Exception:\n  1385→                            continue\n  1386→                    if result is None:\n  1387→                        try:\n  1388→                            preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n  1389→                        except Exception:\n  1390→                            preview = str(raw[:200])\n  1391→                        logger.error(f\"_make_request - JSON解析失败(编码问题): {preview}\")\n  1392→                        raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n  1393→\n  1394→                return {\"success\": True, \"data\": result}\n  1395→\n  1396→            except requests.exceptions.Timeout:\n  1397→                logger.warning(f\"请求超时，第{attempt + 1}次重试\")\n  1398→                if attempt < self.max_retries - 1:\n  1399→                    time.sleep(self.retry_delay)\n  1400→                    continue\n  1401→                else:\n  1402→                    return {\"success\": False, \"error\": \"请求超时\", \"error_code\": \"TIMEOUT_ERROR\"}\n  1403→\n  1404→            except requests.exceptions.HTTPError as e:\n  1405→                if response.status_code == 429:\n  1406→                    logger.warning(f\"API配额限制，第{attempt + 1}次重试\")\n  1407→                    if attempt < self.max_retries - 1:\n  1408→                        time.sleep(self.retry_delay * 2)  # 配额限制时等待更长时间\n  1409→                        continue\n  1410→                    else:\n  1411→                        return {\"success\": False, \"error\": \"API配额已用完\", \"error_code\": \"QUOTA_EXCEEDED\"}\n  1412→                else:\n  1413→                    try:\n  1414→                        # 安全解析错误响应\n  1415→                        try:\n  1416→                            error_data = response.json()\n  1417→                        except (json.JSONDecodeError, UnicodeDecodeError):\n  1418→                            # 编码问题时使用安全解码\n  1419→                            try:\n  1420→                                safe_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n  1421→                                error_data = json.loads(safe_text)\n  1422→                            except Exception:\n  1423→                                error_data = {\"error\": {\"message\": \"响应解析失败\"}}\n  1424→                        error_message = error_data.get(\"error\", {}).get(\"message\", str(e))\n  1425→                    except:\n  1426→                        error_message = str(e)\n  1427→\n  1428→                    return {\n  1429→                        \"success\": False,\n  1430→                        \"error\": error_message,\n  1431→                        \"error_code\": \"API_ERROR\",\n  1432→                        \"status_code\": response.status_code,\n  1433→                    }\n  1434→\n  1435→            except requests.exceptions.RequestException as e:\n  1436→                logger.warning(f\"网络错误，第{attempt + 1}次重试: {e}\")\n  1437→                if attempt < self.max_retries - 1:\n  1438→                    time.sleep(self.retry_delay)\n  1439→                    continue\n  1440→                else:\n  1441→                    return {\"success\": False, \"error\": f\"网络连接错误: {e}\", \"error_code\": \"NETWORK_ERROR\"}\n  1442→\n  1443→            except Exception as e:\n  1444→                logger.error(f\"未知错误: {e}\")\n  1445→                return {\"success\": False, \"error\": str(e), \"error_code\": \"UNKNOWN_ERROR\"}\n  1446→\n  1447→        return {\"success\": False, \"error\": \"达到最大重试次数\", \"error_code\": \"MAX_RETRIES_EXCEEDED\"}\n  1448→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b514a4a8-09e9-44e4-8828-66a7bed316b6","timestamp":"2025-12-30T09:55:49.771Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/modules/seedance/client.py","content":"# Seedance视频生成客户端\n# 封装火山引擎Seedance1.0pro的API调用\n\nimport os\nimport time\nimport json\nimport base64\nimport requests\nimport logging\nimport asyncio\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom pathlib import Path\nfrom loguru import logger\n# volcenginesdkarkruntime import removed - not used in current implementation\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\n# 导入配置管理器和错误处理\nfrom config.unified_config import get_unified_config\nfrom modules.utils.error_handler import ErrorHandler, AppError, error_handler, RetryHandler\nfrom .config import SeedanceModels, TaskStatus, SeedanceConfig\n\n\"\"\"\n常量与辅助方法（视频参数 P0b）\n- 仅保留“分辨率档位 + 比例”的新路径；不再支持旧 width/height → --rs 映射\n\"\"\"\n\n# 白名单常量\nRES_GRADES = {\"480p\", \"720p\", \"1080p\"}\nRATIOS = {\"16:9\", \"9:16\", \"4:3\", \"1:1\", \"3:4\", \"21:9\", \"adaptive\"}\n\ndef _summarize_payload_for_storage(\n    data: Dict[str, Any],\n    *,\n    resolution_grade: Optional[str],\n    ratio: Optional[str],\n    duration: int,\n    fps: int,\n    seed: Optional[int],\n    camera_fixed: bool,\n    used_rs: str,\n    used_rt: str,\n    mode: str,\n) -> Dict[str, Any]:\n    \"\"\"\n    生成可落盘的 params_sent（避免保存 base64 / 大字段）。\n\n    注意：\n    - 仅存储与“参数一致性/复用/恢复”相关信息，不落 content.image_url.url 等内容。\n    \"\"\"\n    try:\n        content = data.get(\"content\") or []\n        image_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"image_url\"]\n        text_items = [item for item in content if isinstance(item, dict) and item.get(\"type\") == \"text\"]\n        text_len = 0\n        if text_items:\n            try:\n                text_len = len(str(text_items[0].get(\"text\") or \"\"))\n            except Exception:\n                text_len = 0\n\n        roles = []\n        for item in image_items:\n            role = item.get(\"role\")\n            if role:\n                roles.append(str(role))\n\n        resolved_rs = used_rs or (resolution_grade or \"\")\n        resolved_rt = used_rt or (ratio or \"\")\n        return {\n            \"model\": data.get(\"model\"),\n            \"mode\": mode,\n            \"service_tier\": data.get(\"service_tier\"),\n            \"execution_expires_after\": data.get(\"execution_expires_after\"),\n            \"generate_audio\": data.get(\"generate_audio\"),\n            \"resolution\": resolved_rs,\n            \"ratio\": resolved_rt,\n            \"duration\": int(duration),\n            \"framespersecond\": int(fps),\n            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n            \"camera_fixed\": bool(camera_fixed),\n            # 服务端 watermark 已强制关闭（仅本地水印）\n            \"watermark\": bool(data.get(\"watermark\", False)) if isinstance(data, dict) else False,\n            \"content_summary\": {\n                \"image_count\": len(image_items),\n                \"image_roles\": roles,\n                \"text_prompt_length\": text_len,\n            },\n        }\n    except Exception:\n        # 兜底：永远不让 params_sent 影响主流程\n        return {\n            \"model\": data.get(\"model\") if isinstance(data, dict) else None,\n            \"mode\": mode,\n            \"resolution\": used_rs or resolution_grade,\n            \"ratio\": used_rt or ratio,\n            \"duration\": int(duration),\n            \"framespersecond\": int(fps),\n            \"seed\": (None if seed is None or seed == -1 else int(seed)),\n        }\n\ndef _validate_and_build_flags(\n    resolution_grade: Optional[str],\n    ratio: Optional[str],\n    duration: int,\n    fps: int,\n    watermark: bool,\n    camera_fixed: bool,\n    seed: Optional[int],\n) -> Tuple[str, bool, str, str, str]:\n    \"\"\"生成安全版文本命令片段；返回 (flags_text, fallback_applied, fallback_reason, used_rs, used_rt)\"\"\"\n    used_rs = resolution_grade or \"\"\n    used_rt = ratio or \"\"\n    fallback_applied = False\n    fallback_reasons: List[str] = []\n\n    # 校验白名单\n    if not used_rs or used_rs not in RES_GRADES:\n        fallback_applied = True\n        fallback_reasons.append(f\"无效分辨率: {used_rs or '缺失'}\")\n        used_rs = \"1080p\"\n    if not used_rt or used_rt not in RATIOS:\n        fallback_applied = True\n        fallback_reasons.append(f\"无效比例: {used_rt or '缺失'}\")\n        used_rt = \"16:9\"\n\n    # 组装顺序: --rs --rt --dur --fps --wm --seed --cf\n    parts: List[str] = []\n    parts += [\"--rs\", used_rs, \"--rt\", used_rt, \"--dur\", str(int(duration)), \"--fps\", str(int(fps))]\n    parts += [\"--wm\", str(bool(watermark)).lower()]\n    if seed is not None and seed != -1:\n        try:\n            parts += [\"--seed\", str(int(seed))]\n        except Exception:\n            # 种子解析异常时忽略，不触发全局fallback\n            logger.warning(\"种子参数无效，已忽略 --seed\")\n    parts += [\"--cf\", str(bool(camera_fixed)).lower()]\n\n    flags_text = \" \".join(parts)\n    fallback_reason = \", \".join(fallback_reasons) if fallback_applied else \"\"\n    return flags_text, fallback_applied, fallback_reason, used_rs, used_rt\n\n\nclass SeedanceClient:\n    \"\"\"火山引擎Seedance视频生成客户端\n\n    提供文生视频、图生视频和首尾帧视频生成功能\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: str = \"https://ark.cn-beijing.volces.com/api/v3\",\n        timeout: int = 60,\n        max_retries: int = 3,\n    ):\n        \"\"\"初始化Seedance客户端\n\n        Args:\n            api_key: 火山引擎API密钥，如果为None则从配置管理器获取\n            base_url: API基础URL\n            timeout: 请求超时时间（秒）\n            max_retries: 最大重试次数\n        \"\"\"\n        # 获取API密钥\n        if api_key is None:\n            try:\n                api_key = get_unified_config().get_api_key(\"volcengine\")\n            except Exception as exc:\n                raise AppError(str(exc), ErrorHandler.ErrorType.AUTH_ERROR) from exc\n\n        self.api_key = api_key\n        self.base_url = base_url.rstrip(\"/\")\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self.retry_delay = 2\n        self.config = SeedanceConfig()\n        self._active_tasks = set()  # 跟踪活跃任务\n\n        # 配置会话\n        self.session = requests.Session()\n        \n        # 配置SSL和连接参数\n        import ssl\n        from requests.adapters import HTTPAdapter\n        from urllib3.util.retry import Retry\n        from urllib3.util.ssl_ import create_urllib3_context\n        \n        # 创建自定义SSL上下文\n        ssl_context = create_urllib3_context()\n        ssl_context.check_hostname = False\n        ssl_context.verify_mode = ssl.CERT_NONE\n        ssl_context.set_ciphers('DEFAULT@SECLEVEL=1')\n        \n        # 配置更强的重试策略\n        retry_strategy = Retry(\n            total=max_retries * 2,  # 增加重试次数\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"POST\"],\n            backoff_factor=2,  # 增加退避因子\n            raise_on_status=False\n        )\n        \n        # 创建自定义适配器\n        class SSLAdapter(HTTPAdapter):\n            def init_poolmanager(self, *args, **kwargs):\n                kwargs['ssl_context'] = ssl_context\n                kwargs['socket_options'] = [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]\n                return super().init_poolmanager(*args, **kwargs)\n        \n        import socket\n        adapter = SSLAdapter(\n            max_retries=retry_strategy,\n            pool_connections=10,\n            pool_maxsize=20,\n            pool_block=False\n        )\n        \n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        # 设置会话级别的超时和连接参数\n        self.session.timeout = (30, 120)  # (连接超时, 读取超时)\n        self.session.verify = False  # 直接禁用SSL验证，避免证书问题\n\n        # 禁用SSL警告\n        import urllib3\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n        self.session.headers.update({\n            'Connection': 'keep-alive',\n            'Keep-Alive': 'timeout=30, max=100'\n        })\n\n        # 初始化性能监控\n        self._performance_stats = {\n            \"total_requests\": 0,\n            \"successful_requests\": 0,\n            \"failed_requests\": 0,\n            \"total_response_time\": 0,\n            \"last_request_time\": None\n        }\n        self._last_error: Dict[str, Any] = {\"code\": None, \"message\": None}\n        \n        logger.info(\"Seedance客户端初始化完成\")\n        logger.info(f\"使用配置: 基础URL={self.base_url}, 超时={timeout}秒, 最大重试={max_retries}次\")\n\n    def _provider_enabled(self) -> bool:\n        try:\n            import os\n            v = (os.environ.get(\"GEMENG_PROVIDER_ENABLED\", \"1\") or \"1\").lower().strip()\n            return v not in {\"0\", \"false\", \"no\"}\n        except Exception:\n            return True\n\n    def _get_headers(self) -> Dict[str, str]:\n        \"\"\"获取请求头\"\"\"\n        api_key = str(self.api_key).strip()\n\n        # 检查 API key 是否为纯 ASCII（HTTP headers 必须是 latin-1 可编码的）\n        try:\n            api_key.encode('ascii')\n        except UnicodeEncodeError:\n            raise ValueError(f\"API密钥包含非ASCII字符（如中文），请检查配置是否正确: {api_key[:20]}...\")\n\n        return {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"User-Agent\": \"Seedance-Client/1.0.0\",\n        }\n\n    def _safe_json_post(self, url: str, headers: Dict[str, str], data: Dict[str, Any], timeout=60):\n        \"\"\"安全的 JSON POST 请求，手动编码避免 PyInstaller latin-1 问题\"\"\"\n        body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n        return self.session.post(url, headers=headers, data=body, timeout=timeout)\n\n    def _handle_response(self, response: requests.Response, operation: str = \"API调用\") -> Dict[str, Any]:\n        \"\"\"处理API响应\n\n        Args:\n            response: HTTP响应对象\n            operation: 操作描述，用于日志记录\n\n        Returns:\n            解析后的响应数据\n\n        Raises:\n            Exception: 当API返回错误时\n        \"\"\"\n        try:\n            # 记录响应基本信息\n            logger.info(f\"{operation} - 响应状态码: {response.status_code}\")\n            \n            # 处理HTTP错误状态码\n            if not response.ok:\n                error_details = {\n                    \"status_code\": response.status_code,\n                    \"url\": response.url,\n                    \"headers\": dict(response.headers),\n                    \"operation\": operation\n                }\n                \n                try:\n                    error_body = response.json()\n                    error_details[\"response_body\"] = error_body\n                except Exception:\n                    try:\n                        error_details[\"response_text\"] = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        error_details[\"response_text\"] = str(response.content[:500])\n                \n                # 根据状态码分类错误\n                if response.status_code == 400:\n                    logger.error(f\"{operation} - 请求参数错误: {error_details}\")\n                    try:\n                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        preview = str(response.content[:500])\n                    raise Exception(f\"请求参数错误: {preview}\")\n                elif response.status_code == 401:\n                    logger.error(f\"{operation} - 认证失败: API密钥无效\")\n                    raise Exception(\"认证失败: 请检查API密钥是否正确\")\n                elif response.status_code == 403:\n                    logger.error(f\"{operation} - 权限不足: {error_details}\")\n                    raise Exception(\"权限不足: 请检查API密钥权限\")\n                elif response.status_code == 404:\n                    logger.error(f\"{operation} - 资源不存在: {error_details}\")\n                    raise Exception(\"资源不存在: 请检查API端点或任务ID\")\n                elif response.status_code == 429:\n                    logger.error(f\"{operation} - 请求频率限制: {error_details}\")\n                    raise Exception(\"请求频率过高: 请稍后重试\")\n                elif response.status_code >= 500:\n                    logger.error(f\"{operation} - 服务器错误: {error_details}\")\n                    raise Exception(f\"服务器错误: {response.status_code}\")\n                else:\n                    logger.error(f\"{operation} - HTTP错误: {error_details}\")\n                    try:\n                        preview = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')[:500]\n                    except Exception:\n                        preview = str(response.content[:500])\n                    raise Exception(f\"HTTP错误: {response.status_code} - {preview}\")\n\n            # 解析JSON响应（增强容错：包括编码问题回退）\n            try:\n                result = response.json()\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                raw = response.content or b\"\"\n                tried = set()\n                result = None\n                for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                    if not enc or enc in tried:\n                        continue\n                    tried.add(enc)\n                    try:\n                        text = raw.decode(enc, errors=\"strict\")\n                        result = json.loads(text)\n                        logger.debug(f\"{operation} - 通过备用编码解析成功: {enc}\")\n                        break\n                    except Exception:\n                        continue\n                if result is None:\n                    # 最后尝试宽松日志预览，抛出统一错误\n                    try:\n                        preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                    except Exception:\n                        preview = str(raw[:200])\n                    logger.error(f\"{operation} - JSON解析失败(编码问题): {preview}\")\n                    raise Exception(f\"响���格式错误: 无法解析JSON - {str(e)}\")\n\n            # 检查业务错误\n            if \"error\" in result:\n                error_info = result[\"error\"]\n                error_msg = error_info.get(\"message\", \"未知错误\")\n                error_code = error_info.get(\"code\", \"UNKNOWN_ERROR\")\n                \n                logger.error(f\"{operation} - API业务错误: {error_msg} (代码: {error_code})\")\n                logger.error(f\"完整错误信息: {result}\")\n                \n                # 根据错误代码提供更友好的错误信息\n                friendly_msg = self._get_friendly_error_message(error_code, error_msg)\n                raise Exception(f\"API业务错误: {friendly_msg}\")\n\n            # 记录成功响应的关键信息\n            if \"id\" in result:\n                logger.info(f\"{operation} - 成功，任务ID: {result['id']}\")\n            elif \"status\" in result:\n                logger.info(f\"{operation} - 成功，状态: {result['status']}\")\n            else:\n                logger.info(f\"{operation} - 成功\")\n\n            return result\n\n        except requests.exceptions.Timeout as e:\n            logger.error(f\"{operation} - 请求超时: {str(e)}\")\n            raise Exception(f\"请求超时: 请检查网络连接或稍后重试\")\n        except requests.exceptions.ConnectionError as e:\n            logger.error(f\"{operation} - 连接错误: {str(e)}\")\n            raise Exception(f\"网络连接错误: 请检查网络连接\")\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"{operation} - 网络请求错误: {str(e)}\")\n            raise Exception(f\"网络请求失败: {str(e)}\")\n        except Exception as e:\n            if \"API业务错误\" in str(e) or \"请求参数错误\" in str(e) or \"认证失败\" in str(e):\n                # 重新抛出已处理的业务错误\n                raise\n            else:\n                logger.error(f\"{operation} - 未知错误: {str(e)}\")\n                raise Exception(f\"处理响应时发生未知错误: {str(e)}\")\n    \n    def _get_friendly_error_message(self, error_code: str, error_msg: str) -> str:\n        \"\"\"获取友好的错误信息\n        \n        Args:\n            error_code: 错误代码\n            error_msg: 原始错误信息\n            \n        Returns:\n            友好的错误信息\n        \"\"\"\n        error_mapping = {\n            \"INVALID_PARAMETER\": \"参数无效，请检查输入参数\",\n            \"INSUFFICIENT_QUOTA\": \"配额不足，请检查账户余额\",\n            \"MODEL_NOT_FOUND\": \"模型不存在，请检查模型名称\",\n            \"TASK_NOT_FOUND\": \"任务不存在，请检查任务ID\",\n            \"TASK_ALREADY_CANCELLED\": \"任务已被取消\",\n            \"TASK_ALREADY_COMPLETED\": \"任务已完成，无法取消\",\n            \"RATE_LIMIT_EXCEEDED\": \"请求频率过高，请稍后重试\",\n            \"INTERNAL_ERROR\": \"服务内部错误，请稍后重试\",\n            \"UNAUTHORIZED\": \"未授权访问，请检查API密钥\",\n            \"FORBIDDEN\": \"禁止访问，请检查权限设置\"\n        }\n        \n        return error_mapping.get(error_code, f\"{error_msg} (错误代码: {error_code})\")\n    \n    def _record_request_stats(\n        self,\n        operation: str,\n        success: bool,\n        response_time: float,\n        error_code: Optional[str] = None,\n        error_message: Optional[str] = None,\n    ):\n        \"\"\"记录请求统计信息（统一结构 + 最近错误）。\"\"\"\n        try:\n            self._performance_stats[\"total_requests\"] += 1\n            self._performance_stats[\"total_response_time\"] += max(0.0, float(response_time))\n            self._performance_stats[\"last_request_time\"] = time.time()\n            \n            if success:\n                self._performance_stats[\"successful_requests\"] += 1\n            else:\n                self._performance_stats[\"failed_requests\"] += 1\n                if error_code or error_message:\n                    self._last_error = {\"code\": error_code, \"message\": (str(error_message)[:200] if error_message else None)}\n            \n            # 记录性能日志（安全摘要）\n            total = max(1, self._performance_stats[\"total_requests\"])\n            avg = self._performance_stats[\"total_response_time\"] / total\n            success_rate = (self._performance_stats[\"successful_requests\"] / total) * 100\n            logger.debug(f\"{operation} - 响应时间: {response_time:.2f}s, 平均: {avg:.2f}s, 成功率: {success_rate:.1f}%\")\n        except Exception:\n            pass\n    \n    def get_performance_stats(self) -> Dict[str, Any]:\n        \"\"\"获取性能统计信息（统一字段命名）。\"\"\"\n        stats = dict(self._performance_stats)\n        total = stats.get(\"total_requests\", 0) or 0\n        if total > 0:\n            avg = stats.get(\"total_response_time\", 0.0) / total\n            suc_rate = (stats.get(\"successful_requests\", 0) / total) * 100.0\n        else:\n            avg = 0.0\n            suc_rate = 0.0\n        return {\n            \"total_requests\": total,\n            \"successful_requests\": stats.get(\"successful_requests\", 0),\n            \"failed_requests\": stats.get(\"failed_requests\", 0),\n            \"avg_response_time\": avg,\n            \"success_rate\": suc_rate,\n            \"last_error\": dict(self._last_error) if self._last_error else {\"code\": None, \"message\": None},\n        }\n\n    def dump_metrics(self) -> Dict[str, Any]:\n        \"\"\"导出统一指标，便于诊断脚本读取。\"\"\"\n        m = self.get_performance_stats()\n        m.update({\n            \"client\": \"Seedance\",\n            \"base_url\": self.base_url,\n        })\n        return m\n\n    def create_video_task(\n        self,\n        prompt: str,\n        image_path: Optional[str] = None,\n        first_frame_path: Optional[str] = None,\n        last_frame_path: Optional[str] = None,\n        duration: int = 8,\n        fps: int = 24,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        seed: Optional[int] = None,\n        use_pro_model: bool = True,\n        model_type: Optional[str] = None,\n        model_variant: Optional[str] = None,\n        camera_fixed: bool = True,\n        resolution_grade: Optional[str] = None,\n        ratio: Optional[str] = None,\n        watermark: bool = False,\n        reference_images: Optional[List[str]] = None,\n        generate_audio: Optional[bool] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        创建视频生成任务（新路径：分辨率档位 + 比例）\n\n        Args:\n            prompt: 视频描述提示词\n            image_path: 输入图片路径（图生视频）\n            first_frame_path: 首帧图片路径（首尾帧模式）\n            last_frame_path: 尾帧图片路径（首尾帧模式）\n            duration: 视频时长（秒），默认8秒\n            fps: 帧率，默认24fps\n            width/height: 旧路径兼容（关闭灰度时使用）\n            seed: 随机种子\n            use_pro_model: 是否使用Pro模型（兼容旧调用）\n            model_type: 模型类型 \"pro\"/\"pro_fast\"/\"lite\"（优先级高于 use_pro_model）\n            model_variant: UI 侧模型变体（如 seedance_1_5_pro）\n            camera_fixed: 是否固定摄像头视角\n            resolution_grade: 分辨率档位\n            ratio: 画面比例\n            watermark: 是否添加水印\n            reference_images: 额外参考图（base64/url），Seedream 4.0 视频扩展预留\n            generate_audio: 是否生成同步音频（仅 Seedance 1.5 Pro 生效）\n\n        Returns:\n            包含任务ID的响应结果\n        \"\"\"\n        url = f\"{self.base_url}/contents/generations/tasks\"\n        is_seedance_1_5_variant = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n\n        # 通过 Provider Schema 映射（默认启用；关闭时回退旧逻辑）\n        data = None\n        mode = \"\"\n        fallback_applied = False\n        fallback_reason = \"\"\n        used_rs = \"\"\n        used_rt = \"\"\n        if self._provider_enabled():\n            try:\n                # 预编码图片为 data URL（与旧实现一致），再交由 Provider 组装 content\n                enc_first = self._encode_image(first_frame_path) if first_frame_path else None\n                enc_last = self._encode_image(last_frame_path) if last_frame_path else None\n                enc_img = self._encode_image(image_path) if image_path else None\n\n                from modules.provider.factory import get_default_provider\n                from modules.provider.schema import VideoParams\n                provider = get_default_provider()\n                mapped, fb, reason, used_rs, used_rt = provider.map_video(VideoParams(\n                    prompt=prompt,\n                    image_path=enc_img,\n                    first_frame_path=enc_first,\n                    last_frame_path=enc_last,\n                    duration=int(duration),\n                    fps=int(fps),\n                    seed=(None if (seed is None or seed == -1) else seed),\n                    camera_fixed=bool(camera_fixed),\n                    watermark=False,\n                    resolution_grade=resolution_grade,\n                    ratio=ratio,\n                    use_pro_model=bool(use_pro_model),\n                    model_variant=model_variant,\n                    generate_audio=generate_audio,\n                    reference_images=(reference_images or []),\n                ))\n                data = {\"model\": mapped[\"model\"], \"content\": mapped[\"content\"]}\n                mode = mapped.get(\"mode\", \"视频\")\n                model = data[\"model\"]\n                fallback_applied, fallback_reason = fb, reason\n                if fb:\n                    logger.warning(f\"参数回退: {reason}\")\n                logger.info(f\"安全版参数: {mapped.get('flags_text', '')}\")\n            except Exception as _e:\n                logger.warning(f\"Provider 映射失败，回退旧路径: {_e}\")\n\n        if data is None:\n            # 旧内容组装路径\n            content: List[Dict[str, Any]] = []\n\n            # 解析 model_type（优先级高于 use_pro_model）\n            effective_model_type = model_type\n            if not effective_model_type:\n                effective_model_type = \"pro\" if use_pro_model else \"lite\"\n\n            # Seedance 1.5 Pro：独立模型（有声），不支持参考图模式\n            is_seedance_1_5 = str(model_variant or \"\").strip().lower() == \"seedance_1_5_pro\"\n            if is_seedance_1_5 and reference_images:\n                raise ValueError(\"Seedance 1.5 Pro 不支持参考图模式（reference_image）\")\n\n            # 1.5 Pro 暂不支持 1080p，提前降级避免走到 flags fallback\n            if is_seedance_1_5 and (not resolution_grade or resolution_grade == \"1080p\"):\n                resolution_grade = \"720p\"\n            if is_seedance_1_5 and not ratio:\n                ratio = \"adaptive\"\n\n            # Pro-fast 不支持首尾帧模式，如果用户选了 pro_fast 但又传了首尾帧，回退到 Pro\n            has_first_last_frame = bool(first_frame_path and last_frame_path)\n            if effective_model_type == \"pro_fast\" and has_first_last_frame:\n                logger.warning(\"Pro-fast 不支持首尾帧模式，自动切换到 Pro 模型\")\n                effective_model_type = \"pro\"\n\n            if is_seedance_1_5:\n                model = SeedanceModels.PRO_1_5.value\n                mode = (\n                    \"首尾帧视频(1.5 Pro)\"\n                    if has_first_last_frame\n                    else (\"图生视频(1.5 Pro)\" if image_path else \"文生视频(1.5 Pro)\")\n                )\n            else:\n                # 模型选择逻辑\n                if has_first_last_frame:\n                    # 首尾帧模式：Pro 或 Lite-i2v（Pro-fast 已在上面被回退）\n                    if effective_model_type in (\"pro\", \"pro_fast\"):\n                        model = SeedanceModels.PRO.value\n                        mode = \"首尾帧视频(Pro)\"\n                    else:\n                        model = SeedanceModels.LITE_I2V.value\n                        mode = \"首尾帧视频(Lite)\"\n                elif effective_model_type == \"pro_fast\":\n                    # Pro-fast 模式（文生视频或首帧图生视频）\n                    model = SeedanceModels.PRO_FAST.value\n                    mode = \"图生视频(Pro-fast)\" if image_path else \"文生视频(Pro-fast)\"\n                elif effective_model_type == \"pro\":\n                    model = SeedanceModels.PRO.value\n                    mode = \"图生视频(Pro)\" if image_path else \"文生视频(Pro)\"\n                else:\n                    # Lite 模式\n                    if image_path or reference_images:\n                        model = SeedanceModels.LITE_I2V.value\n                        if reference_images and not image_path:\n                            mode = f\"参考图视频(Lite, {len(reference_images)}张)\"\n                        else:\n                            mode = \"图生视频(Lite)\"\n                    else:\n                        model = SeedanceModels.LITE_T2V.value\n                        mode = \"文生视频(Lite)\"\n\n            if first_frame_path and last_frame_path:\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(first_frame_path)},\n                    \"role\": \"first_frame\"\n                })\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(last_frame_path)},\n                    \"role\": \"last_frame\"\n                })\n            elif image_path:\n                content.append({\n                    \"type\": \"image_url\",\n                    \"image_url\": {\"url\": self._encode_image(image_path)},\n                    \"role\": \"first_frame\"\n                })\n            if reference_images:\n                for ref_img in reference_images:\n                    ref_path = ref_img.get('path') if isinstance(ref_img, dict) else ref_img\n                    if ref_path:\n                        content.append({\n                            \"type\": \"image_url\",\n                            \"image_url\": {\"url\": self._encode_image(ref_path)},\n                            \"role\": \"reference_image\"\n                        })\n                logger.info(f\"添加 {len(reference_images)} 张参考图到请求\")\n\n            # Lite 参考图模式（r2v）不支持 1080p，强制降级到 720p\n            if reference_images and not image_path and effective_model_type == \"lite\":\n                if resolution_grade == \"1080p\" or not resolution_grade:\n                    resolution_grade = \"720p\"\n                    logger.info(\"Lite 参考图模式不支持 1080p，已自动降级到 720p\")\n\n            # 文本命令\n            # Force server-side watermark off for Plan B (local watermark only)\n            flags_text, fallback_applied, fallback_reason, used_rs, used_rt = _validate_and_build_flags(\n                resolution_grade=resolution_grade,\n                ratio=ratio,\n                duration=duration,\n                fps=fps,\n                watermark=False,\n                camera_fixed=camera_fixed,\n                seed=seed,\n            )\n            text_prompt = f\"{prompt} {flags_text}\".strip()\n            if fallback_applied:\n                logger.warning(f\"参数回退: {fallback_reason}\")\n            logger.info(f\"安全版参数: {flags_text}\")\n            content.append({\"type\": \"text\", \"text\": text_prompt})\n            data = {\"model\": model, \"content\": content}\n\n        # 固定后端参数：service_tier=default, execution_expires_after=6h（21600s）\n        # 不暴露 UI；用于服务端任务超时治理\n        try:\n            data.setdefault(\"service_tier\", \"default\")\n            data.setdefault(\"execution_expires_after\", 21600)\n        except Exception:\n            pass\n\n        # Seedance 1.5 Pro：生成音频开关（默认 true）\n        try:\n            if is_seedance_1_5_variant or data.get(\"model\") == SeedanceModels.PRO_1_5.value:\n                data[\"generate_audio\"] = bool(True if generate_audio is None else generate_audio)\n        except Exception:\n            pass\n\n        headers = self._get_headers()\n        logger.info(f\"创建{mode}任务: {prompt[:50]}...\")\n        logger.info(f\"使用模型: {model}\")\n        logger.info(f\"参数: {used_rs or resolution_grade}+{used_rt or ratio}, dur={duration}s, fps={fps}\")\n\n        params_sent_summary = _summarize_payload_for_storage(\n            data,\n            resolution_grade=resolution_grade,\n            ratio=ratio,\n            duration=duration,\n            fps=fps,\n            seed=seed,\n            camera_fixed=camera_fixed,\n            used_rs=used_rs,\n            used_rt=used_rt,\n            mode=mode,\n        )\n\n        start_time = time.time()\n        success = False\n        err_code: Optional[str] = None\n        err_msg: Optional[str] = None\n        try:\n            logger.info(f\"发送请求到: {url}\")\n            # 安全日志对象，避免 content 结构异常导致索引错误\n            text_items = [item for item in data.get(\"content\", []) if item.get(\"type\") == \"text\"]\n            text_len = 0\n            if text_items:\n                try:\n                    text_len = len(text_items[0].get(\"text\", \"\"))\n                except Exception:\n                    text_len = 0\n            safe_data = {\n                \"model\": data.get(\"model\"),\n                \"content_types\": [item.get(\"type\") for item in data.get(\"content\", [])],\n                \"text_prompt_length\": text_len,\n                \"image_count\": len([item for item in data.get(\"content\", []) if item.get(\"type\") == \"image_url\"]) \n            }\n            logger.info(f\"请求参数: {json.dumps(safe_data, indent=2, ensure_ascii=False)}\")\n\n            response = self._safe_json_post(url, headers, data, timeout=60)\n            response_time = time.time() - start_time\n            logger.info(f\"响应状态码: {response.status_code}, 响应时间: {response_time:.2f}s\")\n\n            result = self._handle_response(response, \"创建视频任务\")\n            success = True\n            task_id = result.get(\"id\")\n            if task_id:\n                self._active_tasks.add(task_id)\n                logger.info(f\"{mode}任务创建成功，任务ID: {task_id}\")\n                try:\n                    params_sent_summary[\"api_task_id\"] = task_id\n                except Exception:\n                    pass\n                result_obj = {\n                    \"success\": True,\n                    \"task_id\": task_id,\n                    \"status\": result.get(\"status\", \"processing\"),\n                    \"model\": model,\n                    \"mode\": mode,\n                    \"estimated_cost\": self._calculate_cost(model, duration),\n                    \"created_at\": time.time(),\n                    \"fallback_applied\": fallback_applied,\n                    \"fallback_reason\": fallback_reason,\n                    \"used_rs\": used_rs,\n                    \"used_rt\": used_rt,\n                    \"params_sent\": params_sent_summary,\n                }\n                # 安全摘要日志\n                logger.info(\n                    f\"摘要|operation=create_task status=success elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id}\"\n                )\n                return result_obj\n            else:\n                logger.error(f\"{mode}任务创建失败，未获取到任务ID\")\n                return {\"success\": False, \"error\": \"未获取到任务ID\", \"response\": result}\n\n        except requests.exceptions.SSLError as e:\n            logger.error(f\"{mode}任务创建失败 - SSL错误: {str(e)}\")\n            logger.info(\"尝试使用备用SSL配置重新连接...\")\n            try:\n                backup_session = requests.Session()\n                backup_session.verify = False\n                import urllib3\n                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n                # 手动编码避免 PyInstaller latin-1 问题\n                body = json.dumps(data, ensure_ascii=False).encode(\"utf-8\")\n                response = backup_session.post(url, headers=headers, data=body, timeout=(30, 120))\n                result = self._handle_response(response, \"创建视频任务(备用连接)\")\n                success = True\n                task_id = result.get(\"id\")\n                if task_id:\n                    self._active_tasks.add(task_id)\n                    logger.info(f\"{mode}任务创建成功(备用连接)，任务ID: {task_id}\")\n                    try:\n                        params_sent_summary[\"api_task_id\"] = task_id\n                    except Exception:\n                        pass\n                    result_obj = {\n                        \"success\": True,\n                        \"task_id\": task_id,\n                        \"status\": result.get(\"status\", \"processing\"),\n                        \"model\": model,\n                        \"mode\": mode,\n                        \"estimated_cost\": self._calculate_cost(model, duration),\n                        \"created_at\": time.time(),\n                        \"fallback_applied\": fallback_applied,\n                        \"fallback_reason\": fallback_reason,\n                        \"used_rs\": used_rs,\n                        \"used_rt\": used_rt,\n                        \"params_sent\": params_sent_summary,\n                    }\n                    logger.info(\n                        f\"摘要|operation=create_task status=success elapsed={time.time() - start_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s task_id={task_id} (backup)\"\n                    )\n                    return result_obj\n                else:\n                    raise Exception(\"备用连接也未获取到任务ID\")\n            except Exception as backup_e:\n                logger.error(f\"备用连接也失败: {str(backup_e)}\")\n                err_code, err_msg = \"SSL_ERROR\", f\"SSL连接失败: {str(e)}; 备用: {str(backup_e)}\"\n                raise Exception(f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}\")\n        except requests.exceptions.ConnectionError as e:\n            logger.error(f\"{mode}任务创建失败 - 连接错误: {str(e)}\")\n            err_code, err_msg = \"NETWORK_ERROR\", str(e)\n            raise Exception(f\"网络连接失败，请检查网络连接: {str(e)}\")\n        except requests.exceptions.Timeout as e:\n            logger.error(f\"{mode}任务创建失败 - 超时: {str(e)}\")\n            err_code, err_msg = \"TIMEOUT_ERROR\", str(e)\n            raise Exception(f\"请求超时，请稍后重试: {str(e)}\")\n        except Exception as e:\n            logger.error(f\"{mode}任务创建失败: {str(e)}\")\n            err_code, err_msg = \"UNKNOWN_ERROR\", str(e)\n            raise Exception(f\"视频生成任务创建失败: {str(e)}\")\n        finally:\n            response_time = time.time() - start_time\n            # 失败时记录摘要\n            if not success:\n                logger.info(\n                    f\"摘要|operation=create_task status=failed elapsed={response_time:.2f}s mode={mode} rs={used_rs} rt={used_rt} fps={fps} dur={duration}s error={err_code}\"\n                )\n            self._record_request_stats(\"创建视频任务\", success, response_time, err_code, err_msg)\n\n    \n    def _calculate_cost(self, model: str, duration: int) -> float:\n        \"\"\"计算预估成本\"\"\"\n        base_cost = self.config.MODEL_PRICING.get(model, 15)\n        # 简单的成本估算：基础价格 * 时长系数\n        return base_cost * (duration / 5.0)  # 以5秒为基准\n\n    def query_video_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"查询视频生成任务状态\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            任务状态信息\n\n        Raises:\n            AppError: 当API调用失败时\n        \"\"\"\n        # 使用正确的查询API端点\n        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n        headers = self._get_headers()\n\n        logger.info(f\"查询视频任务状态: {task_id}\")\n\n        try:\n            try:\n                response = self.session.get(url, headers=headers, timeout=30)\n            except requests.exceptions.SSLError as e:\n                logger.error(f\"查询视频任务状态失败 - SSL错误: {str(e)}\")\n                logger.info(\"尝试使用备用SSL配置重新查询任务状态...\")\n                try:\n                    backup_session = requests.Session()\n                    backup_session.verify = False\n                    import urllib3\n                    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n                    response = backup_session.get(url, headers=headers, timeout=30)\n                except Exception as backup_e:\n                    logger.error(f\"备用SSL配置查询失败: {str(backup_e)}\")\n                    raise Exception(\n                        f\"SSL连接失败，请检查网络环境。原始错误: {str(e)}; 备用: {str(backup_e)}\"\n                    ) from e\n\n            result = self._handle_response(response, \"查询视频任务\")\n\n            # 根据官方API返回格式解析状态\n            status = result.get(\"status\", \"unknown\")\n            video_url = result.get(\"content\", {}).get(\"video_url\")\n            \n            logger.info(f\"任务 {task_id} 状态: {status}\")\n            \n            if status == \"succeeded\" and video_url:\n                logger.info(f\"视频生成完成: {video_url}\")\n\n            # 获取缩略图URL\n            thumbnail_url = result.get(\"content\", {}).get(\"thumbnail_url\") or result.get(\"thumbnail_url\")\n            preview_url = result.get(\"content\", {}).get(\"preview_url\") or result.get(\"preview_url\")\n\n            # 解析关键“实际参数”（用于 params_actual 落盘）\n            seed_value = result.get(\"seed\")\n            ratio_value = result.get(\"ratio\")\n            fps_value = result.get(\"framespersecond\")\n            service_tier = result.get(\"service_tier\")\n            execution_expires_after = result.get(\"execution_expires_after\")\n            generate_audio = result.get(\"generate_audio\")\n            \n            result_obj = {\n                \"success\": True,\n                \"task_id\": task_id,\n                \"status\": status,\n                \"video_url\": video_url,\n                \"thumbnail_url\": thumbnail_url,\n                \"preview_url\": preview_url,\n                \"model\": result.get(\"model\"),\n                \"resolution\": result.get(\"resolution\"),\n                \"ratio\": ratio_value,\n                \"duration\": result.get(\"duration\"),\n                \"fps\": fps_value,\n                \"framespersecond\": fps_value,\n                \"seed\": seed_value,\n                \"service_tier\": service_tier,\n                \"execution_expires_after\": execution_expires_after,\n                \"generate_audio\": generate_audio,\n                \"usage\": result.get(\"usage\"),\n                \"created_at\": result.get(\"created_at\"),\n                \"updated_at\": result.get(\"updated_at\")\n            }\n            # 安全摘要日志\n            logger.info(\n                f\"摘要|operation=query_task status={status} task_id={task_id} video_ready={'yes' if bool(video_url) else 'no'}\"\n            )\n            return result_obj\n\n        except Exception as e:\n            logger.error(f\"查询视频任务状态失败: {str(e)}\")\n            raise Exception(f\"查询任务状态失败: {str(e)}\")\n\n    def get_task_status(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        查询任务状态（兼容旧接口）\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            Dict: 任务状态信息\n        \"\"\"\n        return self.query_video_task(task_id)\n\n    def wait_for_completion(self, task_id: str, max_wait_time: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"\n        等待任务完成（智能轮询）\n\n        Args:\n            task_id: 任务ID\n            max_wait_time: 最大等待时间（秒），默认使用配置值\n\n        Returns:\n            Dict: 最终任务结果\n        \"\"\"\n        max_wait_time = max_wait_time or self.config.POLLING[\"max_wait_time\"]\n        intervals = self.config.POLLING[\"intervals\"]\n        \n        logger.info(f\"开始智能轮询任务: {task_id}\")\n        \n        start_time = time.time()\n        attempt = 0\n\n        while time.time() - start_time < max_wait_time:\n            try:\n                # 查询任务状态\n                status_result = self.get_task_status(task_id)\n\n                if not status_result[\"success\"]:\n                    return status_result\n\n                status = status_result[\"status\"]\n                progress = status_result.get(\"progress\", 0)\n\n                logger.info(f\"任务 {task_id} 状态: {status}, 进度: {progress}%\")\n\n                # 检查是否为终态\n                if TaskStatus.is_terminal(status):\n                    if status == TaskStatus.SUCCEEDED.value:\n                        logger.success(f\"任务完成: {task_id}\")\n                    elif status == TaskStatus.FAILED.value:\n                        logger.error(f\"任务失败: {task_id}\")\n                    elif status == TaskStatus.CANCELLED.value:\n                        logger.warning(f\"任务被取消: {task_id}\")\n                    \n                    # 从活跃任务中移除\n                    self._active_tasks.discard(task_id)\n                    return status_result\n\n                # 动态调整轮询间隔\n                interval = intervals[min(attempt, len(intervals) - 1)]\n                logger.debug(f\"等待 {interval} 秒后继续轮询\")\n                time.sleep(interval)\n                attempt += 1\n                \n            except Exception as e:\n                logger.error(f\"轮询异常: {e}\")\n                time.sleep(5)  # 异常时等待5秒\n\n        # 超时处理\n        logger.error(f\"轮询超时: {task_id}\")\n        self._active_tasks.discard(task_id)\n        return {\n            \"success\": False, \n            \"error\": \"等待任务完成超时\", \n            \"error_code\": \"TIMEOUT_ERROR\", \n            \"task_id\": task_id,\n            \"elapsed_time\": time.time() - start_time\n        }\n\n    def cancel_task(self, task_id: str) -> Dict[str, Any]:\n        \"\"\"\n        取消视频生成任务（仅在queued状态有效）\n\n        Args:\n            task_id: 任务ID\n\n        Returns:\n            成功: {\"success\": True, \"status\": \"cancelled\"}\n            失败: {\"success\": False, \"error\": \"错误信息\"}\n        \"\"\"\n        url = f\"{self.base_url}/contents/generations/tasks/{task_id}\"\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.api_key}\"\n        }\n\n        try:\n            response = requests.delete(url, headers=headers, timeout=10)\n\n            if response.status_code == 200:\n                # DELETE请求成功，等待0.5秒后查询实际状态\n                time.sleep(0.5)\n\n                # 查询任务状态以确认是否真的变成cancelled\n                try:\n                    status_result = self.query_video_task(task_id)\n                    current_status = status_result.get(\"status\", \"unknown\")\n\n                    if current_status == \"cancelled\":\n                        # 真正成功取消\n                        self._active_tasks.discard(task_id)\n                        logger.info(f\"任务已成功取消: {task_id}，状态已变更为 cancelled\")\n                        return {\"success\": True, \"status\": \"cancelled\"}\n                    else:\n                        # DELETE成功但状态不是cancelled（任务可能已在执行中）\n                        logger.warning(f\"DELETE请求成功，但任务状态为 {current_status}（任务可能已在执行中，无法取消）\")\n                        return {\"success\": False, \"status\": current_status, \"error\": f\"任务状态为 {current_status}，无法取消\"}\n                except Exception as query_e:\n                    # 状态查询失败，但DELETE请求成功\n                    logger.warning(f\"DELETE请求成功，但状态查询失败: {query_e}\")\n                    self._active_tasks.discard(task_id)\n                    return {\"success\": True, \"status\": \"cancelled\", \"warning\": \"状态确认失败\"}\n\n            if response.status_code == 400:\n                error_msg = response.json().get(\"error\", {}).get(\"message\", \"任务无法取消（可能已在执行中）\")\n                logger.warning(f\"取消任务失败: {task_id} - {error_msg}\")\n                return {\"success\": False, \"error\": error_msg}\n\n            error_msg = f\"HTTP {response.status_code}: {response.text}\"\n            logger.error(f\"取消任务请求失败: {error_msg}\")\n            return {\"success\": False, \"error\": error_msg}\n\n        except Exception as e:  # pylint: disable=broad-except\n            logger.error(f\"取消任务异常: {task_id} - {e}\")\n            return {\"success\": False, \"error\": str(e)}\n\n    def list_tasks(self, limit: int = 20, offset: int = 0, status_filter: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        获取任务列表（改进版）\n\n        Args:\n            limit: 返回数量限制\n            offset: 偏移量\n            status_filter: 状态过滤器\n\n        Returns:\n            Dict: 任务列表\n        \"\"\"\n        url = f\"{self.base_url}{self.config.ENDPOINTS['list_tasks']}\"\n        headers = self._get_headers()\n        \n        params = {\n            \"limit\": limit,\n            \"offset\": offset\n        }\n        \n        if status_filter:\n            params[\"status\"] = status_filter\n        \n        logger.info(f\"获取任务列表: limit={limit}, offset={offset}, status_filter={status_filter}\")\n        \n        # 记录开始时间\n        start_time = time.time()\n        success = False\n\n        try:\n            response = self.session.get(url, headers=headers, params=params, timeout=30)\n            result = self._handle_response(response, \"获取任务列表\")\n            \n            tasks = result.get(\"data\", [])\n            total = result.get(\"total\", len(tasks))\n            \n            logger.success(f\"获取任务列表成功，共{len(tasks)}个任务\")\n            success = True\n            \n            return {\n                \"success\": True,\n                \"tasks\": tasks,\n                \"total\": total,\n                \"limit\": limit,\n                \"offset\": offset,\n                \"has_more\": offset + len(tasks) < total\n            }\n            \n        except Exception as e:\n            logger.error(f\"获取任务列表失败: {e}\")\n            return {\n                 \"success\": False,\n                 \"error\": str(e)\n             }\n        finally:\n            # 记录性能统计\n            response_time = time.time() - start_time\n            self._record_request_stats(\"获取任务列表\", success, response_time)\n    \n    def batch_query_tasks(self, task_ids: List[str]) -> Dict[str, Any]:\n        \"\"\"\n        批量查询任务状态\n        \n        Args:\n            task_ids: 任务ID列表\n        \n        Returns:\n            批量查询结果\n        \"\"\"\n        results = {}\n        success_count = 0\n        \n        logger.info(f\"批量查询{len(task_ids)}个任务\")\n        \n        for task_id in task_ids:\n            try:\n                result = self.query_video_task(task_id)\n                if result.get(\"success\", True):  # 兼容不同的返回格式\n                    success_count += 1\n                results[task_id] = result\n            except Exception as e:\n                results[task_id] = {\n                    \"success\": False,\n                    \"error\": str(e)\n                }\n        \n        return {\n            \"success\": True,\n            \"results\": results,\n            \"total\": len(task_ids),\n            \"success_count\": success_count,\n            \"failed_count\": len(task_ids) - success_count\n        }\n    \n    def cancel_all_active_tasks(self) -> Dict[str, Any]:\n        \"\"\"\n        取消所有活跃任务\n        \n        Returns:\n            取消结果统计\n        \"\"\"\n        active_tasks = list(self._active_tasks)\n        \n        if not active_tasks:\n            return {\n                \"success\": True,\n                \"message\": \"没有活跃任务需要取消\",\n                \"cancelled\": 0\n            }\n        \n        cancelled_count = 0\n        failed_count = 0\n        \n        logger.info(f\"取消{len(active_tasks)}个活跃任务\")\n        \n        for task_id in active_tasks:\n            result = self.cancel_task(task_id)\n            if result.get(\"success\"):\n                cancelled_count += 1\n            else:\n                failed_count += 1\n        \n        return {\n            \"success\": True,\n            \"cancelled\": cancelled_count,\n            \"failed\": failed_count,\n            \"total_active\": len(active_tasks)\n        }\n    \n    def get_task_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        获取任务统计信息\n        \n        Returns:\n            统计信息\n        \"\"\"\n        try:\n            # 获取最近的任务列表\n            tasks_result = self.list_tasks(limit=100)\n            \n            if not tasks_result.get(\"success\"):\n                return tasks_result\n            \n            tasks = tasks_result.get(\"tasks\", [])\n            \n            # 统计各状态任务数量\n            status_counts = {}\n            total_cost = 0\n            \n            for task in tasks:\n                status = task.get(\"status\", \"unknown\")\n                status_counts[status] = status_counts.get(status, 0) + 1\n                \n                # 估算成本\n                model = task.get(\"model\", \"\")\n                if model in self.config.MODEL_PRICING:\n                    total_cost += self.config.MODEL_PRICING[model]\n            \n            return {\n                \"success\": True,\n                \"total_tasks\": len(tasks),\n                \"active_tasks\": len(self._active_tasks),\n                \"status_counts\": status_counts,\n                \"estimated_total_cost\": total_cost,\n                \"timestamp\": time.time()\n            }\n            \n        except Exception as e:\n            logger.error(f\"获取统计信息失败: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\n    def _prepare_image(self, image_path: str) -> str:\n        \"\"\"准备图片数据，返回data URL格式\"\"\"\n        try:\n            # 使用新的图片格式验证器\n            from utils.image_format_validator import validate_and_prepare_image\n            \n            result = validate_and_prepare_image(image_path, auto_convert=True)\n            \n            if result['success']:\n                if result['is_converted']:\n                    logger.info(f\"图片已自动转换: {result['original_format']} -> {result['final_format']}\")\n                return result['data_url']\n            else:\n                raise Exception(result['error'])\n                \n        except Exception as e:\n            logger.error(f\"图片处理失败: {str(e)}\")\n            raise Exception(f\"图片处理失败: {str(e)}\")\n\n    def _encode_image(self, image_path: str) -> str:\n        \"\"\"将图像文件编码为data URL格式\n        集成图片格式验证和自动转换功能\n        \n        Args:\n            image_path: 图像文件路径\n            \n        Returns:\n            data URL格式的图像字符串\n            \n        Raises:\n            AppError: 当图像文件不存在或编码失败时\n        \"\"\"\n        try:\n            image_path = Path(image_path)\n            if not image_path.exists():\n                raise AppError(f\"图像文件不存在: {image_path}\", ErrorHandler.ErrorType.FILE_ERROR)\n            \n            # 使用图片格式验证器处理\n            from utils.image_format_validator import validate_and_prepare_image\n            \n            result = validate_and_prepare_image(str(image_path), auto_convert=True)\n            \n            if result['success']:\n                if result['is_converted']:\n                    logger.info(f\"图片格式已自动转换: {result['original_format']} -> {result['final_format']}\")\n                return result['data_url']\n            else:\n                logger.error(f\"图片处理失败: {result['error']}\")\n                raise AppError(f\"图片处理失败: {result['error']}\", ErrorHandler.ErrorType.FILE_ERROR)\n                \n        except AppError:\n            raise\n        except Exception as e:\n            # 避免在日志中显示可能包含base64数据的异常信息\n            error_msg = str(e)\n            if len(error_msg) > 200:\n                error_msg = error_msg[:200] + \"...[错误信息过长，已截断]\"\n            logger.error(f\"图像编码失败: {error_msg}\")\n            raise AppError(f\"图像编码失败: 文件处理错误\", ErrorHandler.ErrorType.FILE_ERROR)\n\n    def _get_mime_type(self, extension: str) -> str:\n        \"\"\"\n        根据文件扩展名获取MIME类型\n\n        Args:\n            extension: 文件扩展名\n\n        Returns:\n            str: MIME类型\n        \"\"\"\n        mime_types = {\".jpg\": \"image/jpeg\", \".jpeg\": \"image/jpeg\", \".png\": \"image/png\", \".webp\": \"image/webp\"}\n        return mime_types.get(extension, \"image/jpeg\")\n\n    def _make_request(\n        self,\n        endpoint: str,\n        data: Optional[Dict[str, Any]] = None,\n        params: Optional[Dict[str, Any]] = None,\n        method: str = \"POST\",\n    ) -> Dict[str, Any]:\n        \"\"\"\n        发送HTTP请求\n\n        Args:\n            endpoint: API端点\n            data: 请求数据\n            params: 查询参数\n            method: HTTP方法\n\n        Returns:\n            Dict: 响应结果\n        \"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n\n        headers = {\"Authorization\": f\"Bearer {self.api_key}\", \"Content-Type\": \"application/json\"}\n\n        for attempt in range(self.max_retries):\n            try:\n                if method.upper() == \"GET\":\n                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)\n                else:\n                    response = requests.post(url, headers=headers, json=data, params=params, timeout=self.timeout)\n\n                response.raise_for_status()\n\n                # 解析响应（增强容错：包括编码问题回退）\n                try:\n                    result = response.json()\n                except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                    raw = response.content or b\"\"\n                    tried = set()\n                    result = None\n                    for enc in [response.encoding, \"utf-8\", \"utf-8-sig\", \"gb18030\"]:\n                        if not enc or enc in tried:\n                            continue\n                        tried.add(enc)\n                        try:\n                            text = raw.decode(enc, errors=\"strict\")\n                            result = json.loads(text)\n                            logger.debug(f\"_make_request - 通过备用编码解析成功: {enc}\")\n                            break\n                        except Exception:\n                            continue\n                    if result is None:\n                        try:\n                            preview = raw.decode(\"utf-8\", errors=\"ignore\")[:200]\n                        except Exception:\n                            preview = str(raw[:200])\n                        logger.error(f\"_make_request - JSON解析失败(编码问题): {preview}\")\n                        raise Exception(f\"响应格式错误: 无法解析JSON - {str(e)}\")\n\n                return {\"success\": True, \"data\": result}\n\n            except requests.exceptions.Timeout:\n                logger.warning(f\"请求超时，第{attempt + 1}次重试\")\n                if attempt < self.max_retries - 1:\n                    time.sleep(self.retry_delay)\n                    continue\n                else:\n                    return {\"success\": False, \"error\": \"请求超时\", \"error_code\": \"TIMEOUT_ERROR\"}\n\n            except requests.exceptions.HTTPError as e:\n                if response.status_code == 429:\n                    logger.warning(f\"API配额限制，第{attempt + 1}次重试\")\n                    if attempt < self.max_retries - 1:\n                        time.sleep(self.retry_delay * 2)  # 配额限制时等待更长时间\n                        continue\n                    else:\n                        return {\"success\": False, \"error\": \"API配额已用完\", \"error_code\": \"QUOTA_EXCEEDED\"}\n                else:\n                    try:\n                        # 安全解析错误响应\n                        try:\n                            error_data = response.json()\n                        except (json.JSONDecodeError, UnicodeDecodeError):\n                            # 编码问题时使用安全解码\n                            try:\n                                safe_text = (response.content or b\"\").decode(response.encoding or 'utf-8', errors='ignore')\n                                error_data = json.loads(safe_text)\n                            except Exception:\n                                error_data = {\"error\": {\"message\": \"响应解析失败\"}}\n                        error_message = error_data.get(\"error\", {}).get(\"message\", str(e))\n                    except:\n                        error_message = str(e)\n\n                    return {\n                        \"success\": False,\n                        \"error\": error_message,\n                        \"error_code\": \"API_ERROR\",\n                        \"status_code\": response.status_code,\n                    }\n\n            except requests.exceptions.RequestException as e:\n                logger.warning(f\"网络错误，第{attempt + 1}次重试: {e}\")\n                if attempt < self.max_retries - 1:\n                    time.sleep(self.retry_delay)\n                    continue\n                else:\n                    return {\"success\": False, \"error\": f\"网络连接错误: {e}\", \"error_code\": \"NETWORK_ERROR\"}\n\n            except Exception as e:\n                logger.error(f\"未知错误: {e}\")\n                return {\"success\": False, \"error\": str(e), \"error_code\": \"UNKNOWN_ERROR\"}\n\n        return {\"success\": False, \"error\": \"达到最大重试次数\", \"error_code\": \"MAX_RETRIES_EXCEEDED\"}\n","numLines":1448,"startLine":1,"totalLines":1448}}}
{"parentUuid":"b514a4a8-09e9-44e4-8828-66a7bed316b6","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01WkWEdrNcf8besUqgYXqyom","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看视频下载相关的线程和组件代码："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":28249,"cache_creation_input_tokens":23125,"cache_read_input_tokens":23038,"cache_creation":{"ephemeral_5m_input_tokens":23125,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"9eb38ec2-eb62-46e4-b676-9c086118f3e1","timestamp":"2025-12-30T09:56:06.725Z"}
{"parentUuid":"9eb38ec2-eb62-46e4-b676-9c086118f3e1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01WkWEdrNcf8besUqgYXqyom","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dnbtg8aB1wExgCyj8fSX6h","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":28249,"cache_creation_input_tokens":23125,"cache_read_input_tokens":23038,"cache_creation":{"ephemeral_5m_input_tokens":23125,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"f03712e0-15fc-42d1-a289-8d3ea430dbf1","timestamp":"2025-12-30T09:56:07.324Z"}
{"parentUuid":"f03712e0-15fc-42d1-a289-8d3ea430dbf1","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01WkWEdrNcf8besUqgYXqyom","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FU82cSuw2i1EgfanqMHTr2","name":"Grep","input":{"pattern":"download|pending|recovery|30s","path":"/Users/yunchang/Documents/GitHub/gemeng2","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":28249,"cache_creation_input_tokens":23125,"cache_read_input_tokens":23038,"cache_creation":{"ephemeral_5m_input_tokens":23125,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"416b49d2-ce1b-4eec-a071-06e7e5776d3a","timestamp":"2025-12-30T09:56:07.949Z"}
{"parentUuid":"416b49d2-ce1b-4eec-a071-06e7e5776d3a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dnbtg8aB1wExgCyj8fSX6h","type":"tool_result","content":"     1→\"\"\"Video generation mode widget implementation.\"\"\"\n     2→\n     3→import os\n     4→from datetime import datetime\n     5→from pathlib import Path\n     6→from typing import Any, Dict, List, Optional\n     7→\n     8→from PySide6.QtCore import Qt, QTimer, QSize, Signal\n     9→from PySide6.QtGui import QIcon, QPixmap, QKeySequence, QColor\n    10→from PySide6.QtWidgets import (\n    11→    QGraphicsDropShadowEffect,\n    12→    QApplication,\n    13→    QFileDialog,\n    14→    QHBoxLayout,\n    15→    QLabel,\n    16→    QMessageBox,\n    17→    QProgressBar,\n    18→    QPushButton,\n    19→    QSizePolicy,\n    20→    QSplitter,\n    21→    QStackedLayout,\n    22→    QTextEdit,\n    23→    QVBoxLayout,\n    24→    QWidget,\n    25→    QFrame,\n    26→    QCheckBox,\n    27→)\n    28→from PySide6.QtGui import QShortcut\n    29→\n    30→from components.dialogs import VideoDetailDialog\n    31→from components.forms import SchemaFormRenderer\n    32→from components.adapters.history_adapter import HistoryViewAdapter\n    33→from components.widgets import ReferenceAssetsPanel\n    34→from components.widgets.video_image_upload_panel import VideoImageUploadPanel\n    35→from config_api import API_WATERMARK_CONFIG\n    36→from modules.provider import get_ui_schema\n    37→from modules.repository.manager import RepositoryManager\n    38→from services.generation_task_manager import GenerationTaskManager\n    39→from loguru import logger\n    40→from utils.reference_display import (\n    41→    _evaluate_dependency_rules,\n    42→    _mask_reference_ids,\n    43→)\n    44→from utils.task_runner import task_runner\n    45→from utils.style_system import unified_style_system\n    46→\n    47→__all__ = [\"VideoModeWidget\"]\n    48→\n    49→\n    50→class VideoModeWidget(QWidget):\n    51→    \"\"\"视频生成模式页面\"\"\"\n    52→\n    53→    video_history_initial_loaded = Signal(object)\n    54→    video_history_next_loaded = Signal(object)\n    55→    video_history_load_failed = Signal(str)\n    56→    pending_recovery_completed = Signal(object)\n    57→    pending_recovery_failed = Signal(str)\n    58→    \n    59→    def __init__(self, parent=None):\n    60→        super().__init__(parent)\n    61→        self.uploaded_images = [None, None]  # 支持两张图片\n    62→        self.uploaded_images_is_temp = [False, False]  # 标记是否为临时文件\n    63→        self._task_manager = GenerationTaskManager.instance()\n    64→        self._task_manager.task_started.connect(self._on_task_started)\n    65→        self._task_manager.task_progress.connect(self._on_task_progress)\n    66→        self._task_manager.task_completed.connect(self._on_task_completed)\n    67→        self._task_manager.task_failed.connect(self._on_task_failed)\n    68→        self._task_manager.queue_updated.connect(self._on_queue_updated)\n    69→        self._task_placeholder_cards: Dict[str, Any] = {}\n    70→        self._pending_recovery_timer: Optional[QTimer] = None\n    71→        self._pending_recovery_inflight = False\n    72→        self._pending_recovery_idle_rounds = 0\n    73→\n    74→        # 存储路径配置管理\n    75→        self._current_storage_path = None\n    76→        self._storage_manager = None\n    77→        self._config_check_timer = None\n    78→        self._repository_manager = None\n    79→        \n    80→        # 懒加载相关变量\n    81→        self.current_start_index = 0\n    82→        self.batch_size = 40\n    83→        self.loaded_items = []\n    84→        self.MAX_ITEMS_IN_MEMORY = 120\n    85→        self.is_loading = False\n    86→        \n    87→        # 历史记录去重加载状态（修复滚动重复加载问题）\n    88→        self._is_loading_history = False  # 历史记录专用加载标志\n    89→        self._loaded_record_ids = set()   # 已加载记录ID集合\n    90→        self._history_offset = 0          # 历史记录偏移量\n    91→        self._history_has_more = True     # 是否还有更多历史记录\n    92→        \n    93→        self._video_scroll_listener_bound = False\n    94→        self.video_schema_form: Optional[SchemaFormRenderer] = None\n    95→        self._video_schema_variant: Optional[str] = None\n    96→        self._video_schema: Optional[Any] = None\n    97→        self._video_form_cache: Dict[str, Any] = {}\n    98→        self.video_reference_panel: Optional[ReferenceAssetsPanel] = None\n    99→        self._video_reference_auto_field: Optional[str] = None\n   100→        self._video_reference_visibility_rules: List[Dict[str, Any]] = []\n   101→        self._video_reference_config: Dict[str, Any] = {}\n   102→        self.is_generating = False\n   103→\n   104→        self.video_history_initial_loaded.connect(self._on_video_history_initial_loaded)\n   105→        self.video_history_next_loaded.connect(self._on_video_history_next_loaded)\n   106→        self.video_history_load_failed.connect(self._on_video_history_load_failed)\n   107→        self.pending_recovery_completed.connect(self._on_pending_recovery_completed)\n   108→        self.pending_recovery_failed.connect(self._on_pending_recovery_failed)\n   109→\n   110→        self.setup_ui()\n   111→\n   112→        # 初始化存储管理器\n   113→        self._update_storage_manager()\n   114→        \n   115→        # 初始化Repository管理器\n   116→        self._update_repository_manager()\n   117→        # P2：进入页立即尝试恢复 pending 状态（若无进行中任务会在两轮后自动停掉定时器）\n   118→        self._ensure_pending_recovery_timer_running(immediate=True)\n   119→        \n   120→        self.setup_clipboard_paste()\n   121→        self.setup_drag_drop()\n   122→\n   123→        # 启动配置监听定时器\n   124→        self._setup_config_monitoring()\n   125→        \n   126→        # Subscribe to theme changes\n   127→        unified_style_system.styleChanged.connect(self._update_styles)\n   128→        self._update_styles()\n   129→    \n   130→    def _update_styles(self):\n   131→        \"\"\"Update dynamic styles when theme changes\"\"\"\n   132→        colors = unified_style_system.get_colors()\n   133→\n   134→        # 页面背景\n   135→        bg_app = colors.get('palette.neutral.bg_app') or colors.get('background') or colors.get('palette.neutral.bg_panel')\n   136→        self.setStyleSheet(f\"background-color: {bg_app};\")\n   137→\n   138→        if hasattr(self, 'prompt_input'):\n   139→            bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n   140→            text_color = colors.get('palette.text.primary') or colors.get('text')\n   141→            border_color = colors.get('palette.neutral.border_subtle') or colors.get('border')\n   142→            primary_color = colors.get('palette.brand.main') or colors.get('primary')\n   143→\n   144→            self.prompt_input.setStyleSheet(f\"\"\"\n   145→                QTextEdit {{\n   146→                    background-color: {bg_input};\n   147→                    color: {text_color};\n   148→                    border: 1px solid {border_color};\n   149→                    border-radius: 8px;\n   150→                    padding: 8px 8px 12px 8px;\n   151→                    margin-bottom: 2px;\n   152→                }}\n   153→                QTextEdit:focus {{\n   154→                    border: 1px solid {primary_color};\n   155→                }}\n   156→                QTextEdit QScrollBar:vertical {{\n   157→                    background: transparent;\n   158→                    width: 6px;\n   159→                }}\n   160→                QTextEdit QScrollBar::handle:vertical {{\n   161→                    background: {border_color};\n   162→                    border-radius: 3px;\n   163→                }}\n   164→                QTextEdit QScrollBar:horizontal {{\n   165→                    height: 0px;\n   166→                    background: transparent;\n   167→                }}\n   168→            \"\"\")\n   169→\n   170→    def setup_ui(self):\n   171→        \"\"\"设置UI\"\"\"\n   172→        # 页面背景由 _update_styles() 动态设置\n   173→        \n   174→        layout = QVBoxLayout(self)\n   175→        layout.setContentsMargins(10, 10, 10, 10)\n   176→        layout.setSpacing(10)\n   177→        \n   178→        # 创建分割器\n   179→        self.splitter = QSplitter(Qt.Vertical)\n   180→        \n   181→        # 上方：视频历史记录展示区域（占页面85%高度）\n   182→        upper_container = QWidget()\n   183→        try:\n   184→            upper_container.setObjectName(\"HistoryPanel\")\n   185→            # Eagle 风格：微妙阴影\n   186→            shadow = QGraphicsDropShadowEffect(upper_container)\n   187→            shadow.setBlurRadius(12)\n   188→            shadow.setColor(QColor(0, 0, 0, 30))\n   189→            shadow.setOffset(0, 2)\n   190→            upper_container.setGraphicsEffect(shadow)\n   191→        except Exception:\n   192→            pass\n   193→        upper_layout = QVBoxLayout(upper_container)\n   194→        upper_layout.setContentsMargins(5, 5, 5, 5)\n   195→        upper_layout.setSpacing(5)\n   196→        # Plan Y: 确立主角地位 - 上方区域必须是 Expanding\n   197→        upper_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   198→        \n   199→        # 状态标签\n   200→        self.status_label = QLabel(\"已加载 0 个视频\")\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c37eb1d4-7bc4-462b-96fc-5cc911f9808a","timestamp":"2025-12-30T09:56:08.015Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py","content":"\"\"\"Video generation mode widget implementation.\"\"\"\n\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom PySide6.QtCore import Qt, QTimer, QSize, Signal\nfrom PySide6.QtGui import QIcon, QPixmap, QKeySequence, QColor\nfrom PySide6.QtWidgets import (\n    QGraphicsDropShadowEffect,\n    QApplication,\n    QFileDialog,\n    QHBoxLayout,\n    QLabel,\n    QMessageBox,\n    QProgressBar,\n    QPushButton,\n    QSizePolicy,\n    QSplitter,\n    QStackedLayout,\n    QTextEdit,\n    QVBoxLayout,\n    QWidget,\n    QFrame,\n    QCheckBox,\n)\nfrom PySide6.QtGui import QShortcut\n\nfrom components.dialogs import VideoDetailDialog\nfrom components.forms import SchemaFormRenderer\nfrom components.adapters.history_adapter import HistoryViewAdapter\nfrom components.widgets import ReferenceAssetsPanel\nfrom components.widgets.video_image_upload_panel import VideoImageUploadPanel\nfrom config_api import API_WATERMARK_CONFIG\nfrom modules.provider import get_ui_schema\nfrom modules.repository.manager import RepositoryManager\nfrom services.generation_task_manager import GenerationTaskManager\nfrom loguru import logger\nfrom utils.reference_display import (\n    _evaluate_dependency_rules,\n    _mask_reference_ids,\n)\nfrom utils.task_runner import task_runner\nfrom utils.style_system import unified_style_system\n\n__all__ = [\"VideoModeWidget\"]\n\n\nclass VideoModeWidget(QWidget):\n    \"\"\"视频生成模式页面\"\"\"\n\n    video_history_initial_loaded = Signal(object)\n    video_history_next_loaded = Signal(object)\n    video_history_load_failed = Signal(str)\n    pending_recovery_completed = Signal(object)\n    pending_recovery_failed = Signal(str)\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.uploaded_images = [None, None]  # 支持两张图片\n        self.uploaded_images_is_temp = [False, False]  # 标记是否为临时文件\n        self._task_manager = GenerationTaskManager.instance()\n        self._task_manager.task_started.connect(self._on_task_started)\n        self._task_manager.task_progress.connect(self._on_task_progress)\n        self._task_manager.task_completed.connect(self._on_task_completed)\n        self._task_manager.task_failed.connect(self._on_task_failed)\n        self._task_manager.queue_updated.connect(self._on_queue_updated)\n        self._task_placeholder_cards: Dict[str, Any] = {}\n        self._pending_recovery_timer: Optional[QTimer] = None\n        self._pending_recovery_inflight = False\n        self._pending_recovery_idle_rounds = 0\n\n        # 存储路径配置管理\n        self._current_storage_path = None\n        self._storage_manager = None\n        self._config_check_timer = None\n        self._repository_manager = None\n        \n        # 懒加载相关变量\n        self.current_start_index = 0\n        self.batch_size = 40\n        self.loaded_items = []\n        self.MAX_ITEMS_IN_MEMORY = 120\n        self.is_loading = False\n        \n        # 历史记录去重加载状态（修复滚动重复加载问题）\n        self._is_loading_history = False  # 历史记录专用加载标志\n        self._loaded_record_ids = set()   # 已加载记录ID集合\n        self._history_offset = 0          # 历史记录偏移量\n        self._history_has_more = True     # 是否还有更多历史记录\n        \n        self._video_scroll_listener_bound = False\n        self.video_schema_form: Optional[SchemaFormRenderer] = None\n        self._video_schema_variant: Optional[str] = None\n        self._video_schema: Optional[Any] = None\n        self._video_form_cache: Dict[str, Any] = {}\n        self.video_reference_panel: Optional[ReferenceAssetsPanel] = None\n        self._video_reference_auto_field: Optional[str] = None\n        self._video_reference_visibility_rules: List[Dict[str, Any]] = []\n        self._video_reference_config: Dict[str, Any] = {}\n        self.is_generating = False\n\n        self.video_history_initial_loaded.connect(self._on_video_history_initial_loaded)\n        self.video_history_next_loaded.connect(self._on_video_history_next_loaded)\n        self.video_history_load_failed.connect(self._on_video_history_load_failed)\n        self.pending_recovery_completed.connect(self._on_pending_recovery_completed)\n        self.pending_recovery_failed.connect(self._on_pending_recovery_failed)\n\n        self.setup_ui()\n\n        # 初始化存储管理器\n        self._update_storage_manager()\n        \n        # 初始化Repository管理器\n        self._update_repository_manager()\n        # P2：进入页立即尝试恢复 pending 状态（若无进行中任务会在两轮后自动停掉定时器）\n        self._ensure_pending_recovery_timer_running(immediate=True)\n        \n        self.setup_clipboard_paste()\n        self.setup_drag_drop()\n\n        # 启动配置监听定时器\n        self._setup_config_monitoring()\n        \n        # Subscribe to theme changes\n        unified_style_system.styleChanged.connect(self._update_styles)\n        self._update_styles()\n    \n    def _update_styles(self):\n        \"\"\"Update dynamic styles when theme changes\"\"\"\n        colors = unified_style_system.get_colors()\n\n        # 页面背景\n        bg_app = colors.get('palette.neutral.bg_app') or colors.get('background') or colors.get('palette.neutral.bg_panel')\n        self.setStyleSheet(f\"background-color: {bg_app};\")\n\n        if hasattr(self, 'prompt_input'):\n            bg_input = colors.get('palette.neutral.bg_input') or colors.get('palette.neutral.bg_card') or colors.get('surface')\n            text_color = colors.get('palette.text.primary') or colors.get('text')\n            border_color = colors.get('palette.neutral.border_subtle') or colors.get('border')\n            primary_color = colors.get('palette.brand.main') or colors.get('primary')\n\n            self.prompt_input.setStyleSheet(f\"\"\"\n                QTextEdit {{\n                    background-color: {bg_input};\n                    color: {text_color};\n                    border: 1px solid {border_color};\n                    border-radius: 8px;\n                    padding: 8px 8px 12px 8px;\n                    margin-bottom: 2px;\n                }}\n                QTextEdit:focus {{\n                    border: 1px solid {primary_color};\n                }}\n                QTextEdit QScrollBar:vertical {{\n                    background: transparent;\n                    width: 6px;\n                }}\n                QTextEdit QScrollBar::handle:vertical {{\n                    background: {border_color};\n                    border-radius: 3px;\n                }}\n                QTextEdit QScrollBar:horizontal {{\n                    height: 0px;\n                    background: transparent;\n                }}\n            \"\"\")\n\n    def setup_ui(self):\n        \"\"\"设置UI\"\"\"\n        # 页面背景由 _update_styles() 动态设置\n        \n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(10, 10, 10, 10)\n        layout.setSpacing(10)\n        \n        # 创建分割器\n        self.splitter = QSplitter(Qt.Vertical)\n        \n        # 上方：视频历史记录展示区域（占页面85%高度）\n        upper_container = QWidget()\n        try:\n            upper_container.setObjectName(\"HistoryPanel\")\n            # Eagle 风格：微妙阴影\n            shadow = QGraphicsDropShadowEffect(upper_container)\n            shadow.setBlurRadius(12)\n            shadow.setColor(QColor(0, 0, 0, 30))\n            shadow.setOffset(0, 2)\n            upper_container.setGraphicsEffect(shadow)\n        except Exception:\n            pass\n        upper_layout = QVBoxLayout(upper_container)\n        upper_layout.setContentsMargins(5, 5, 5, 5)\n        upper_layout.setSpacing(5)\n        # Plan Y: 确立主角地位 - 上方区域必须是 Expanding\n        upper_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        \n        # 状态标签\n        self.status_label = QLabel(\"已加载 0 个视频\")","numLines":200,"startLine":1,"totalLines":2818}}}
{"parentUuid":"c37eb1d4-7bc4-462b-96fc-5cc911f9808a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FU82cSuw2i1EgfanqMHTr2","type":"tool_result","content":"Found 53 files\ncomponents/modes/video_mode_widget.py\ncomponents/modes/image_mode_widget.py\nREADME.md\nCLAUDE.md\ncomponents/views/video_history_view.py\ncomponents/views/image_history_view.py\ncomponents/main_window.py\ncomponents/dialogs/video_detail_dialog.py\ncomponents/dialogs/image_detail_dialog.py\n.gitignore\nservices/video_service.py\nmodules/seedance/manager.py\nmodules/seedance/config.py\nmodules/repository/sqlite_handler.py\nmodules/repository/manager.py\ndocs/seedance-1.5pro-plan.md\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py\n.claude/commands/pack-win.md\nutils/ui_utils.py\nutils/font_scaler.py\ntools/csv_to_sqlite_migration.py\ncomponents/delegates/video_card_delegate.py\ncomponents/delegates/image_card_delegate.py\ncomponents/adapters/generation_adapter.py\n.claude/commands/migrate.md\n.claude/THEME_SYSTEM_REFACTOR_PLAN.md\nmodules/seedream/manager.py\ntools/setup_ffmpeg.py\nscripts/windows/install_python_guide.bat\nscripts/run_seedance_watermark_direct.py\npackaging/windows/深度复盘_历史记录问题分析.md\nmodules/utils/progress_tracker.py\nmodules/__init__.py\ndocs/视频生成参数分析与建议.md\ndocs/执行者任务提示词_界面优化.md\ndocs/下一步执行计划_2025-09-22.md\ndocs/reference_manuals/API_Documentation.md\ndocs/planning/DETAILED_REFACTOR_PLAN.md\ndocs/debug/video_placeholder_disappear_fix.md\ndocs/codex 对话记录导出.md\ndocs/SEPARATED_ARCHITECTURE_DESIGN.md\ndocs/Python_Framework_安装指南_macOS.md\ndocs/IMPLEMENTATION_PLAN_AND_EXAMPLES.md\ndocs/Day5_ModularApplication组装_Codex执行提示词_20250924.md\ndocs/DATA_FLOW_AND_INTERACTIONS.md\ndocs/CSV存储系统使用示例.md\ndocs/CORE_INTERFACES_SPEC.md\nCHANGELOG.md\n.trae/documents/火山引擎Seedance视频生成API技术文档.md\n.trae/documents/Seedance后端代码改进方案.md\n.style_backup/qt_app.py\n.style_backup/components/generation/video_mode_widget.py\n.style_backup/components/cards/video_card.py"}]},"uuid":"f09f4634-7a0d-4e7f-b131-052e27fbc179","timestamp":"2025-12-30T09:56:08.033Z","toolUseResult":{"mode":"files_with_matches","filenames":["components/modes/video_mode_widget.py","components/modes/image_mode_widget.py","README.md","CLAUDE.md","components/views/video_history_view.py","components/views/image_history_view.py","components/main_window.py","components/dialogs/video_detail_dialog.py","components/dialogs/image_detail_dialog.py",".gitignore","services/video_service.py","modules/seedance/manager.py","modules/seedance/config.py","modules/repository/sqlite_handler.py","modules/repository/manager.py","docs/seedance-1.5pro-plan.md",".style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py",".claude/commands/pack-win.md","utils/ui_utils.py","utils/font_scaler.py","tools/csv_to_sqlite_migration.py","components/delegates/video_card_delegate.py","components/delegates/image_card_delegate.py","components/adapters/generation_adapter.py",".claude/commands/migrate.md",".claude/THEME_SYSTEM_REFACTOR_PLAN.md","modules/seedream/manager.py","tools/setup_ffmpeg.py","scripts/windows/install_python_guide.bat","scripts/run_seedance_watermark_direct.py","packaging/windows/深度复盘_历史记录问题分析.md","modules/utils/progress_tracker.py","modules/__init__.py","docs/视频生成参数分析与建议.md","docs/执行者任务提示词_界面优化.md","docs/下一步执行计划_2025-09-22.md","docs/reference_manuals/API_Documentation.md","docs/planning/DETAILED_REFACTOR_PLAN.md","docs/debug/video_placeholder_disappear_fix.md","docs/codex 对话记录导出.md","docs/SEPARATED_ARCHITECTURE_DESIGN.md","docs/Python_Framework_安装指南_macOS.md","docs/IMPLEMENTATION_PLAN_AND_EXAMPLES.md","docs/Day5_ModularApplication组装_Codex执行提示词_20250924.md","docs/DATA_FLOW_AND_INTERACTIONS.md","docs/CSV存储系统使用示例.md","docs/CORE_INTERFACES_SPEC.md","CHANGELOG.md",".trae/documents/火山引擎Seedance视频生成API技术文档.md",".trae/documents/Seedance后端代码改进方案.md",".style_backup/qt_app.py",".style_backup/components/generation/video_mode_widget.py",".style_backup/components/cards/video_card.py"],"numFiles":53}}
{"parentUuid":"f09f4634-7a0d-4e7f-b131-052e27fbc179","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018Lz6e1uUMmPkNVmVxzJbdn","type":"message","role":"assistant","content":[{"type":"text","text":"让我继续查看更多的视频模式 widget 代码，特别是 pending 恢复机制："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":32353,"cache_read_input_tokens":46163,"cache_creation":{"ephemeral_5m_input_tokens":32353,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"39cc68de-3efb-4772-99a7-247e9f44bc78","timestamp":"2025-12-30T09:56:19.033Z"}
{"parentUuid":"39cc68de-3efb-4772-99a7-247e9f44bc78","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018Lz6e1uUMmPkNVmVxzJbdn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012LnN9pFx2GMfGX1bXX7xzA","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py","limit":500,"offset":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":32353,"cache_read_input_tokens":46163,"cache_creation":{"ephemeral_5m_input_tokens":32353,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"dbd4f13c-bcda-4ea5-971b-7e2796594237","timestamp":"2025-12-30T09:56:19.578Z"}
{"parentUuid":"dbd4f13c-bcda-4ea5-971b-7e2796594237","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018Lz6e1uUMmPkNVmVxzJbdn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RHxVN1zmL8NBMsRfaMRxgS","name":"Grep","input":{"pattern":"pending_recovery|_ensure_pending_recovery|30.*s|recovery_idle","path":"/Users/yunchang/Documents/GitHub/gemeng2","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":32353,"cache_read_input_tokens":46163,"cache_creation":{"ephemeral_5m_input_tokens":32353,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"bab4f7cb-9c00-4ff2-8684-86840a50a4e0","timestamp":"2025-12-30T09:56:20.203Z"}
{"parentUuid":"bab4f7cb-9c00-4ff2-8684-86840a50a4e0","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012LnN9pFx2GMfGX1bXX7xzA","type":"tool_result","content":"   200→        self.status_label = QLabel(\"已加载 0 个视频\")\n   201→        colors = unified_style_system.get_colors()\n   202→        text_secondary = (\n   203→            colors.get('palette.text.secondary')\n   204→            or colors.get('text_secondary')\n   205→            or colors.get('palette.text.primary')\n   206→            or colors.get('text')\n   207→        )\n   208→        self.status_label.setStyleSheet(f\"color: {text_secondary};\")\n   209→        upper_layout.addWidget(self.status_label)\n   210→\n   211→        # 统一使用虚拟化历史视图（移除瀑布流分支）\n   212→        self.use_virtual_video_view = True\n   213→        self.video_history_view = HistoryViewAdapter(data_type=\"video\", parent=self, page_size=self.batch_size)\n   214→        self.video_history_view = self.video_history_view  # 兼容旧命名\n   215→\n   216→        self.video_history_view.set_status_callback(lambda text: self.status_label.setText(text))\n   217→        self.video_history_view.bind_repository(self.get_repository_manager())\n   218→        # 连接取消任务信号\n   219→        self.video_history_view.cancelRequested.connect(self._on_task_cancel_requested)\n   220→        # 连接复用参数信号\n   221→        try:\n   222→            self.video_history_view.reuseParametersRequested.connect(self._on_reuse_parameters)\n   223→            logger.info(\"[DEBUG] 视频模式 reuseParametersRequested 信号连接成功\")\n   224→            # Dynamic Style Subscription\n   225→            unified_style_system.styleChanged.connect(self._update_styles)\n   226→        except Exception as e:\n   227→            logger.error(f\"[DEBUG] 视频模式信号连接失败: {e}\")\n   228→\n   229→        def _open_detail(rec: Dict[str, Any]):\n   230→            try:\n   231→                # 从虚拟列表的 model 中获取已加载的所有记录\n   232→                model = getattr(self.video_history_view, 'model', None)\n   233→                if model and hasattr(model, '_items'):\n   234→                    # 使用虚拟列表中已加载的记录（支持增量加载的完整列表）\n   235→                    all_videos = [item for item in model._items if not item.get('is_placeholder')]\n   236→                    # 优先使用视图传递的索引（最准确）\n   237→                    current_index = rec.get('_view_index', 0)\n   238→                    # 过滤占位符后需要调整索引\n   239→                    if current_index > 0:\n   240→                        # 计算当前索引之前有多少个占位符\n   241→                        placeholder_count = sum(1 for i in range(current_index) if model._items[i].get('is_placeholder'))\n   242→                        current_index = current_index - placeholder_count\n   243→                else:\n   244→                    # 兜底：从数据库获取更多记录（10000条）\n   245→                    repo_manager = self.get_repository_manager()\n   246→                    all_videos = repo_manager.get_records_batch(0, 10000, 'video')\n   247→                    # 通过 file_id 查找索引\n   248→                    current_index = 0\n   249→                    current_file_id = rec.get('file_id', '')\n   250→                    for i, video in enumerate(all_videos):\n   251→                        if video.get('file_id', '') == current_file_id:\n   252→                            current_index = i\n   253→                            break\n   254→\n   255→                logger.debug(f\"[NAV] 当前索引: {current_index}, 总数: {len(all_videos)}, _view_index: {rec.get('_view_index', 'N/A')}\")\n   256→                \n   257→                # 复用对话框实例（防止硬件解码器耗尽）\n   258→                if not hasattr(self, '_cached_detail_dialog') or self._cached_detail_dialog is None:\n   259→                    # 首次创建对话框\n   260→                    logger.debug(\"[REUSE] 首次创建 VideoDetailDialog\")\n   261→                    self._cached_detail_dialog = VideoDetailDialog(rec, all_videos, current_index, self)\n   262→                    self._cached_detail_dialog.recordDeleted.connect(self.video_history_view.remove_record_by_id)\n   263→                else:\n   264→                    # 复用已有对话框\n   265→                    logger.debug(\"[REUSE] 复用已有 VideoDetailDialog\")\n   266→                    self._cached_detail_dialog.set_video_data(rec, all_videos, current_index)\n   267→                \n   268→                self._cached_detail_dialog.exec()\n   269→            except Exception as e:\n   270→                logger.error(f\"打开详情失败: {e}\")\n   271→\n   272→        self.video_history_view.set_item_click_callback(_open_detail)\n   273→        upper_layout.addWidget(self.video_history_view)\n   274→        self.splitter.addWidget(upper_container)\n   275→        \n   276→        # 下方：统一的输入控制区域（动态高度调整）\n   277→        self.input_widget = QWidget()\n   278→        try:\n   279→            self.input_widget.setObjectName(\"ParamPanel\")\n   280→            # Eagle 风格：微妙阴影\n   281→            shadow = QGraphicsDropShadowEffect(self.input_widget)\n   282→            shadow.setBlurRadius(12)\n   283→            shadow.setColor(QColor(0, 0, 0, 30))\n   284→            shadow.setOffset(0, 2)\n   285→            self.input_widget.setGraphicsEffect(shadow)\n   286→        except Exception:\n   287→            pass\n   288→        # Plan Y: 确立配角地位 - 下方垂直方向回归 Preferred\n   289→        self.input_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n   290→        try:\n   291→            self.input_widget.setMinimumHeight(140)\n   292→            # 移除最大高度限制以修复小屏显示问题\n   293→            # self.input_widget.setMaximumHeight(400)\n   294→        except Exception:\n   295→            pass\n   296→        input_layout = QVBoxLayout(self.input_widget)\n   297→        input_layout.setContentsMargins(16, 0, 16, 10)  # Plan P: 稳健底边距\n   298→        input_layout.setSpacing(0)\n   299→        \n   300→        # 参数面板（Schema 驱动）\n   301→        params_widget = QWidget(self.input_widget)\n   302→        params_widget.setStyleSheet(\"\"\"\n   303→            QWidget {\n   304→                background-color: transparent;\n   305→                border: none;\n   306→                border-radius: 12px;\n   307→            }\n   308→        \"\"\")\n   309→        params_container = QVBoxLayout(params_widget)\n   310→        params_container.setContentsMargins(8, 8, 8, 0)  # Plan N: 底部零留白\n   311→        params_container.setSpacing(2)\n   312→        self.video_schema_form = SchemaFormRenderer(self.input_widget)\n   313→        self.video_schema_form.setObjectName(\"videoSchemaForm\")\n   314→        self.video_schema_form.schemaReloadRequested.connect(self._on_video_schema_reload)\n   315→        self.video_schema_form.fieldValueChanged.connect(self._on_video_field_changed)\n   316→        params_container.addWidget(self.video_schema_form)\n   317→        input_layout.addWidget(params_widget)\n   318→        input_layout.addSpacing(6)\n   319→\n   320→        # 第二行：图片上传和提示词输入区域\n   321→        content_layout = QHBoxLayout()\n   322→        content_layout.setSpacing(10)\n   323→        content_layout.setContentsMargins(0, 0, 0, 0)\n   324→        \n   325→        # 左侧统一图片上传区域（宽度根据内容自适应）\n   326→        self.upload_area = QWidget()\n   327→        upload_area_layout = QVBoxLayout(self.upload_area)\n   328→        upload_area_layout.setContentsMargins(0, 0, 0, 0)\n   329→        upload_area_layout.setSpacing(0)\n   330→\n   331→        # 1.5 Pro：生成音频开关（仅在 1.5 Pro 下显示；放在上传区上方避免占用提示词高度）\n   332→        self.generate_audio_checkbox = QCheckBox(\"生成音频\")\n   333→        self.generate_audio_checkbox.setChecked(True)\n   334→        self.generate_audio_checkbox.setVisible(False)\n   335→        self.generate_audio_checkbox.setToolTip(\"仅 Seedance 1.5 Pro：生成与画面同步的声音（人声/音效/BGM）\")\n   336→        try:\n   337→            unified_style_system.apply_to_widget(self.generate_audio_checkbox)\n   338→        except Exception:\n   339→            pass\n   340→        upload_area_layout.addWidget(self.generate_audio_checkbox)\n   341→\n   342→        # 使用新的统一上传面板\n   343→        self.video_image_panel = VideoImageUploadPanel(self)\n   344→        self.video_image_panel.imagesChanged.connect(self._on_video_images_changed)\n   345→        self.video_image_panel.modeChanged.connect(self._on_video_image_mode_changed)\n   346→        upload_area_layout.addWidget(self.video_image_panel)\n   347→\n   348→        # 兼容旧代码：保留空列表引用\n   349→        self.upload_containers = []\n   350→        self.upload_displays = []\n   351→        self.delete_buttons = []\n   352→        \n   353→        # 中间提示词输入区域（约80%宽度）\n   354→        input_area = QWidget()\n   355→        input_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n   356→        input_area_layout = QVBoxLayout(input_area)\n   357→        input_area_layout.setContentsMargins(0, 0, 0, 0)\n   358→        input_area_layout.setSpacing(5)\n   359→        \n   360→        # 提示词输入框\n   361→        self.prompt_input = QTextEdit()\n   362→        self.prompt_input.setMinimumHeight(65)   # Plan R: 最小高度 65px\n   363→        self.prompt_input.setMaximumHeight(250)  # Plan Alpha+: 设定手动拖拽上限 (约10行)\n   364→        # Plan S: 移除最大高度限制 -> Plan Z: 恢复上限限制\n   365→        self.prompt_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   366→\n   367→        # 绑定文本变化事件\n   368→        self.prompt_input.textChanged.connect(self.adjust_prompt_height)\n   369→        self.prompt_input.setPlaceholderText(\"请输入视频生成提示词...\")\n   370→        \n   371→        # 使用统一样式系统设置样式，不再硬编码颜色\n   372→        unified_style_system.apply_to_widget(self.prompt_input)\n   373→        \n   374→        # Dynamic styling handled by _update_styles\n   375→        self._update_styles()\n   376→               \n   377→        input_area_layout.addWidget(self.prompt_input)\n   378→        # Plan P: 移除 Stretch\n   379→        \n   380→        # 右侧生成按钮区域（约10%宽度）\n   381→        button_area = QWidget()\n   382→        button_area.setFixedWidth(120)\n   383→        button_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n   384→        button_area_layout = QVBoxLayout(button_area)\n   385→        button_area_layout.setContentsMargins(0, 0, 0, 0)\n   386→        button_area_layout.setSpacing(5)\n   387→        \n   388→        # 按钮容器（水平布局）\n   389→        buttons_container = QWidget()\n   390→        buttons_container.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n   391→        buttons_layout = QHBoxLayout(buttons_container)\n   392→        buttons_layout.setContentsMargins(0, 0, 0, 0)\n   393→        buttons_layout.setSpacing(5)\n   394→        \n   395→        # 生成按钮\n   396→        self.generate_button = QPushButton(\"生成视频\")\n   397→        self.generate_button.setMinimumHeight(50)\n   398→        self.generate_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)\n   399→        self.generate_button.setObjectName(\"generateButton\")\n   400→        unified_style_system.apply_to_widget(self.generate_button, extra={'variant': 'primary'})\n   401→        self.generate_button.clicked.connect(self.generate_video)\n   402→        \n   403→        # 终止按钮（圆形）\n   404→        self.stop_button = QPushButton(\"⏹\")\n   405→        self.stop_button.setFixedSize(30, 30)\n   406→        self.stop_button.setVisible(False)  # 默认隐藏\n   407→        # 保留圆角样式，应用危险变体\n   408→        self.stop_button.setStyleSheet(\"border-radius: 15px;\")\n   409→        unified_style_system.apply_to_widget(self.stop_button, extra={'variant': 'danger'})\n   410→        self.stop_button.clicked.connect(self.stop_video_generation)\n   411→        \n   412→        buttons_layout.addWidget(self.generate_button)\n   413→        buttons_layout.addWidget(self.stop_button)\n   414→        \n   415→        button_area_layout.addWidget(buttons_container)\n   416→        \n   417→        # 添加到内容布局\n   418→        content_layout.addWidget(self.upload_area)\n   419→        content_layout.addWidget(input_area)\n   420→        content_layout.addWidget(button_area)\n   421→        \n   422→        # 设置布局比例（上传区域按内容自适应，输入区域填充剩余空间）\n   423→        content_layout.setStretch(0, 0)   # 上传区域：按内容自适应\n   424→        content_layout.setStretch(1, 1)   # 输入区域：填充剩余空间\n   425→        content_layout.setStretch(2, 0)   # 按钮区域：固定宽度\n   426→        \n   427→        # 用容器包裹第二行，使其可按需填充高度\n   428→        self.row_container = QWidget()\n   429→        self.row_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n   430→        self.row_container.setLayout(content_layout)\n   431→        self.row_container.setMinimumHeight(80)  # 保证按钮区域最小高度\n   432→\n   433→        # 添加内容容器到主布局\n   434→        input_layout.addWidget(self.row_container)\n   435→\n   436→        # 参考图面板（默认由 Schema 控制显示）\n   437→        self.video_reference_panel = ReferenceAssetsPanel(self.input_widget)\n   438→        self.video_reference_panel.setVisible(False)\n   439→        self.video_reference_panel.set_panel_enabled(False)\n   440→        self.video_reference_panel.filesChanged.connect(self._on_video_reference_files_changed)\n   441→        self.video_reference_panel.warningEmitted.connect(self._on_video_reference_warning)\n   442→        input_layout.addWidget(self.video_reference_panel)\n   443→\n   444→        # 设置主输入布局的垂直拉伸，让第二行容器填充可用高度\n   445→        try:\n   446→            input_layout.setStretch(0, 0)  # 参数区\n   447→            input_layout.setStretch(1, 1)  # 第二行容器\n   448→            input_layout.setStretch(2, 0)  # 参考图面板\n   449→        except Exception:\n   450→            pass\n   451→\n   452→        # 初始加载 Schema 定义\n   453→        self._load_video_schema()\n   454→\n   455→        self.splitter.addWidget(self.input_widget)\n   456→        \n   457→        # Plan Y: 移除 Stretch Factor Hack，回归第一性原理\n   458→        # self.splitter.setStretchFactor(0, 1)\n   459→        # self.splitter.setStretchFactor(1, 0)\n   460→\n   461→        # 设置QSplitter拖拽手柄光标（修复光标消失问题）\n   462→        try:\n   463→            handle = self.splitter.handle(1)\n   464→            if handle:\n   465→                handle.setCursor(Qt.SplitVCursor)\n   466→                logger.debug(\"[VideoModeWidget] QSplitter拖拽手柄光标已设置\")\n   467→        except Exception as e:\n   468→            logger.warning(f\"[VideoModeWidget] 设置QSplitter光标失败: {e}\")\n   469→\n   470→        # 设置分割器比例（增加底部输入区域高度，确保图片上传面板可见）\n   471→        self.splitter.setSizes([700, 300])\n   472→        \n   473→        layout.addWidget(self.splitter)\n   474→        \n   475→        # 进度条\n   476→        self.progress_bar = QProgressBar()\n   477→        self.progress_bar.setVisible(False)\n   478→        # 使用橙色进度条\n   479→        unified_style_system.apply_to_widget(self.progress_bar, extra={'variant': 'primary_warning'})\n   480→        layout.addWidget(self.progress_bar)\n   481→\n   482→        # 应用初始主题样式\n   483→        self._update_styles()\n   484→\n   485→    # ------------------------------------------------------------------\n   486→    # Schema handling\n   487→    # ------------------------------------------------------------------\n   488→\n   489→    def _load_video_schema(\n   490→        self,\n   491→        variant: Optional[str] = None,\n   492→        *,\n   493→        keep_values: bool = True,\n   494→        initial_values: Optional[Dict[str, Any]] = None,\n   495→    ) -> None:\n   496→        if not self.video_schema_form:\n   497→            return\n   498→\n   499→        preserved: Dict[str, Any] = {}\n   500→        if keep_values and self.video_schema_form.schema():\n   501→            try:\n   502→                current_values, _errors = self.video_schema_form.collect_values()\n   503→                preserved.update(current_values)\n   504→            except Exception as exc:  # pragma: no cover - best effort\n   505→                logger.debug(f\"采集视频旧参数失败: {exc}\")\n   506→        if self._video_form_cache:\n   507→            preserved.update(self._video_form_cache)\n   508→        if initial_values:\n   509→            preserved.update(initial_values)\n   510→\n   511→        try:\n   512→            schema = get_ui_schema(\"seedance\", \"video\", variant)\n   513→        except Exception as exc:\n   514→            logger.error(f\"加载视频 Schema 失败: {exc}\")\n   515→            return\n   516→\n   517→        self._video_schema = schema\n   518→        self._video_schema_variant = schema.variant\n   519→        self.video_schema_form.set_schema(schema, initial_values=preserved)\n   520→        self._video_form_cache = preserved\n   521→        self._handle_video_schema_extras(schema, preserved)\n   522→        self._refresh_video_reference_panel_state(preserved)\n   523→        # 更新图片上传面板的模型类型\n   524→        self._update_video_image_panel_model_type()\n   525→\n   526→    def _handle_video_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n   527→        # 1.5 Pro：生成音频开关（位置固定但仅在对应模型显示）\n   528→        try:\n   529→            extra = getattr(schema, \"extra\", {}) or {}\n   530→            show_audio = bool(extra.get(\"show_generate_audio_toggle\", False))\n   531→            if hasattr(self, \"generate_audio_checkbox\") and self.generate_audio_checkbox is not None:\n   532→                self.generate_audio_checkbox.setVisible(show_audio)\n   533→        except Exception:\n   534→            pass\n   535→\n   536→        config = getattr(schema, \"reference_assets\", {}) or {}\n   537→        self._video_reference_config = config\n   538→        self._video_reference_visibility_rules = config.get('visible_if') or []\n   539→        self._video_reference_auto_field = config.get('auto_compress_field')\n   540→\n   541→        panel = self.video_reference_panel\n   542→        if not panel:\n   543→            return\n   544→\n   545→        if not config.get('enabled'):\n   546→            panel.clear()\n   547→            panel.set_panel_enabled(False)\n   548→            self._video_reference_visibility_rules = []\n   549→            self._video_reference_auto_field = None\n   550→            return\n   551→\n   552→        panel.set_panel_enabled(True)\n   553→        panel.set_limits(\n   554→            max_count=config.get('max_count'),\n   555→            bundle_limit=config.get('bundle_limit'),\n   556→        )\n   557→        if config.get('accept'):\n   558→            panel.set_accept_mime_types(config.get('accept'))\n   559→        panel.set_hint_text(config.get('help_text'))\n   560→\n   561→    def _on_video_schema_reload(self, variant: str) -> None:\n   562→        logger.info(f\"视频 Schema 切换请求: {variant}\")\n   563→        self._load_video_schema(variant=variant, keep_values=False)\n   564→        # Plan P: 切换模型时强制重置布局状态\n   565→        self._reset_input_layout()\n   566→\n   567→    def _on_video_field_changed(self, field_name: str, value: Any) -> None:\n   568→        self._video_form_cache[field_name] = value\n   569→        self._refresh_video_reference_panel_state()\n   570→\n   571→    def _collect_video_form_values(self) -> Optional[Dict[str, Any]]:\n   572→        if not self.video_schema_form:\n   573→            return {}\n   574→        values, errors = self.video_schema_form.collect_values()\n   575→        if errors:\n   576→            QMessageBox.warning(self, \"参数校验失败\", \"\\n\".join(errors))\n   577→            return None\n   578→        self._video_form_cache = dict(values)\n   579→        return values\n   580→\n   581→    def _refresh_video_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n   582→        panel = self.video_reference_panel\n   583→        if not panel:\n   584→            return\n   585→\n   586→        config = self._video_reference_config or {}\n   587→        if not config.get('enabled'):\n   588→            panel.set_panel_enabled(False)\n   589→            return\n   590→\n   591→        panel.set_panel_enabled(True)\n   592→\n   593→        data = dict(self._video_form_cache)\n   594→        if values:\n   595→            data.update(values)\n   596→\n   597→        visible = _evaluate_dependency_rules(self._video_reference_visibility_rules, data)\n   598→        panel.setVisible(visible)\n   599→\n   600→        if self._video_reference_auto_field:\n   601→            panel.set_auto_compress_enabled(bool(data.get(self._video_reference_auto_field, True)))\n   602→\n   603→    def _on_video_reference_files_changed(self) -> None:\n   604→        if not self.video_reference_panel:\n   605→            return\n   606→        count = self.video_reference_panel.current_count()\n   607→        logger.info(f\"视频参考图更新，当前数量: {count}\")\n   608→\n   609→    def _on_video_reference_warning(self, message: str) -> None:\n   610→        if not message:\n   611→            return\n   612→        logger.warning(message)\n   613→        try:\n   614→            self.row_container.setMinimumHeight(80)  # Plan P: 恢复最小高度 (80)\n   615→        except Exception:\n   616→            pass\n   617→\n   618→    def _collect_reference_assets_for_video(self) -> Optional[List[Dict[str, Any]]]:\n   619→        panel = self.video_reference_panel\n   620→        if not panel or not panel.isVisible() or not panel.isEnabled():\n   621→            return []\n   622→\n   623→        validation = panel.validate(expected_outputs=1)\n   624→        if not validation.get('valid', True):\n   625→            errors = \"\\n\".join(validation.get('errors', [])) or \"参考图数量超过限制\"\n   626→            if validation.get('can_trim') and validation.get('trim_to') is not None:\n   627→                trim_to = max(0, int(validation['trim_to']))\n   628→                msg = (\n   629→                    f\"参考图数量超出限制，是否自动裁剪至 {trim_to} 张？\"\\\n   630→                    + (\"\\n\\n\" + errors if errors else \"\")\n   631→                )\n   632→                choice = QMessageBox.question(\n   633→                    self,\n   634→                    \"参考图超限\",\n   635→                    msg,\n   636→                    QMessageBox.Yes | QMessageBox.No,\n   637→                    QMessageBox.Yes,\n   638→                )\n   639→                if choice == QMessageBox.Yes:\n   640→                    panel.trim_to(trim_to)\n   641→                    recheck = panel.validate(expected_outputs=1)\n   642→                    if not recheck.get('valid', True):\n   643→                        self.show_warning_toast(\"参考图仍超限，已取消生成\")\n   644→                        return None\n   645→                    try:\n   646→                        self.status_label.setText(f\"已裁剪参考图至 {trim_to} 张\")\n   647→                    except Exception:\n   648→                        pass\n   649→                else:\n   650→                    try:\n   651→                        self.status_label.setText(\"已取消生成（参考图超限）\")\n   652→                    except Exception:\n   653→                        pass\n   654→                    return None\n   655→            else:\n   656→                self.show_warning_toast(errors)\n   657→                return None\n   658→\n   659→        return panel.collect_assets()\n   660→    \n   661→    def _setup_config_monitoring(self):\n   662→        \"\"\"设置配置监听定时器\"\"\"\n   663→        from PySide6.QtCore import QTimer\n   664→        self._config_check_timer = QTimer()\n   665→        self._config_check_timer.timeout.connect(self._check_config_changes)\n   666→        self._config_check_timer.start(2000)  # 每2秒检查一次配置变化\n   667→        \n   668→    def _check_config_changes(self):\n   669→        \"\"\"检查配置变化（兜底机制，主渠道是 SettingsPage.settings_applied -> MainWindow.on_storage_path_changed）。\"\"\"\n   670→        try:\n   671→            from config_api import get_storage_dir\n   672→            current_path = get_storage_dir()\n   673→            \n   674→            if self._current_storage_path != current_path:\n   675→                logger.info(f\"[定时器检测] 视频存储路径变更: {self._current_storage_path} -> {current_path}\")\n   676→                # 先更新本地记录，避免每2秒重复触发\n   677→                self._current_storage_path = current_path\n   678→\n   679→                # 如果主信号已经完成了重绑/加载，这里不再做任何同步重初始化\n   680→                try:\n   681→                    view = getattr(self, 'video_history_view', None)\n   682→                    model = getattr(view, 'model', None) if view else None\n   683→                    if model and model.rowCount() > 0:\n   684→                        return\n   685→                except Exception:\n   686→                    pass\n   687→\n   688→                # 兜底：仅在页面无数据时执行重绑 + 初次加载\n   689→                try:\n   690→                    self._update_storage_manager(current_path)\n   691→                except Exception:\n   692→                    pass\n   693→                try:\n   694→                    self._update_repository_manager(current_path)\n   695→                except Exception:\n   696→                    pass\n   697→                try:\n   698→                    view = getattr(self, 'video_history_view', None)\n   699→                    if view and hasattr(view, 'clear') and hasattr(view, 'bind_repository') and hasattr(view, 'load_initial'):\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"dc02ead5-7060-40bd-93b9-93c4d1045c8f","timestamp":"2025-12-30T09:56:20.262Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py","content":"        self.status_label = QLabel(\"已加载 0 个视频\")\n        colors = unified_style_system.get_colors()\n        text_secondary = (\n            colors.get('palette.text.secondary')\n            or colors.get('text_secondary')\n            or colors.get('palette.text.primary')\n            or colors.get('text')\n        )\n        self.status_label.setStyleSheet(f\"color: {text_secondary};\")\n        upper_layout.addWidget(self.status_label)\n\n        # 统一使用虚拟化历史视图（移除瀑布流分支）\n        self.use_virtual_video_view = True\n        self.video_history_view = HistoryViewAdapter(data_type=\"video\", parent=self, page_size=self.batch_size)\n        self.video_history_view = self.video_history_view  # 兼容旧命名\n\n        self.video_history_view.set_status_callback(lambda text: self.status_label.setText(text))\n        self.video_history_view.bind_repository(self.get_repository_manager())\n        # 连接取消任务信号\n        self.video_history_view.cancelRequested.connect(self._on_task_cancel_requested)\n        # 连接复用参数信号\n        try:\n            self.video_history_view.reuseParametersRequested.connect(self._on_reuse_parameters)\n            logger.info(\"[DEBUG] 视频模式 reuseParametersRequested 信号连接成功\")\n            # Dynamic Style Subscription\n            unified_style_system.styleChanged.connect(self._update_styles)\n        except Exception as e:\n            logger.error(f\"[DEBUG] 视频模式信号连接失败: {e}\")\n\n        def _open_detail(rec: Dict[str, Any]):\n            try:\n                # 从虚拟列表的 model 中获取已加载的所有记录\n                model = getattr(self.video_history_view, 'model', None)\n                if model and hasattr(model, '_items'):\n                    # 使用虚拟列表中已加载的记录（支持增量加载的完整列表）\n                    all_videos = [item for item in model._items if not item.get('is_placeholder')]\n                    # 优先使用视图传递的索引（最准确）\n                    current_index = rec.get('_view_index', 0)\n                    # 过滤占位符后需要调整索引\n                    if current_index > 0:\n                        # 计算当前索引之前有多少个占位符\n                        placeholder_count = sum(1 for i in range(current_index) if model._items[i].get('is_placeholder'))\n                        current_index = current_index - placeholder_count\n                else:\n                    # 兜底：从数据库获取更多记录（10000条）\n                    repo_manager = self.get_repository_manager()\n                    all_videos = repo_manager.get_records_batch(0, 10000, 'video')\n                    # 通过 file_id 查找索引\n                    current_index = 0\n                    current_file_id = rec.get('file_id', '')\n                    for i, video in enumerate(all_videos):\n                        if video.get('file_id', '') == current_file_id:\n                            current_index = i\n                            break\n\n                logger.debug(f\"[NAV] 当前索引: {current_index}, 总数: {len(all_videos)}, _view_index: {rec.get('_view_index', 'N/A')}\")\n                \n                # 复用对话框实例（防止硬件解码器耗尽）\n                if not hasattr(self, '_cached_detail_dialog') or self._cached_detail_dialog is None:\n                    # 首次创建对话框\n                    logger.debug(\"[REUSE] 首次创建 VideoDetailDialog\")\n                    self._cached_detail_dialog = VideoDetailDialog(rec, all_videos, current_index, self)\n                    self._cached_detail_dialog.recordDeleted.connect(self.video_history_view.remove_record_by_id)\n                else:\n                    # 复用已有对话框\n                    logger.debug(\"[REUSE] 复用已有 VideoDetailDialog\")\n                    self._cached_detail_dialog.set_video_data(rec, all_videos, current_index)\n                \n                self._cached_detail_dialog.exec()\n            except Exception as e:\n                logger.error(f\"打开详情失败: {e}\")\n\n        self.video_history_view.set_item_click_callback(_open_detail)\n        upper_layout.addWidget(self.video_history_view)\n        self.splitter.addWidget(upper_container)\n        \n        # 下方：统一的输入控制区域（动态高度调整）\n        self.input_widget = QWidget()\n        try:\n            self.input_widget.setObjectName(\"ParamPanel\")\n            # Eagle 风格：微妙阴影\n            shadow = QGraphicsDropShadowEffect(self.input_widget)\n            shadow.setBlurRadius(12)\n            shadow.setColor(QColor(0, 0, 0, 30))\n            shadow.setOffset(0, 2)\n            self.input_widget.setGraphicsEffect(shadow)\n        except Exception:\n            pass\n        # Plan Y: 确立配角地位 - 下方垂直方向回归 Preferred\n        self.input_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n        try:\n            self.input_widget.setMinimumHeight(140)\n            # 移除最大高度限制以修复小屏显示问题\n            # self.input_widget.setMaximumHeight(400)\n        except Exception:\n            pass\n        input_layout = QVBoxLayout(self.input_widget)\n        input_layout.setContentsMargins(16, 0, 16, 10)  # Plan P: 稳健底边距\n        input_layout.setSpacing(0)\n        \n        # 参数面板（Schema 驱动）\n        params_widget = QWidget(self.input_widget)\n        params_widget.setStyleSheet(\"\"\"\n            QWidget {\n                background-color: transparent;\n                border: none;\n                border-radius: 12px;\n            }\n        \"\"\")\n        params_container = QVBoxLayout(params_widget)\n        params_container.setContentsMargins(8, 8, 8, 0)  # Plan N: 底部零留白\n        params_container.setSpacing(2)\n        self.video_schema_form = SchemaFormRenderer(self.input_widget)\n        self.video_schema_form.setObjectName(\"videoSchemaForm\")\n        self.video_schema_form.schemaReloadRequested.connect(self._on_video_schema_reload)\n        self.video_schema_form.fieldValueChanged.connect(self._on_video_field_changed)\n        params_container.addWidget(self.video_schema_form)\n        input_layout.addWidget(params_widget)\n        input_layout.addSpacing(6)\n\n        # 第二行：图片上传和提示词输入区域\n        content_layout = QHBoxLayout()\n        content_layout.setSpacing(10)\n        content_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # 左侧统一图片上传区域（宽度根据内容自适应）\n        self.upload_area = QWidget()\n        upload_area_layout = QVBoxLayout(self.upload_area)\n        upload_area_layout.setContentsMargins(0, 0, 0, 0)\n        upload_area_layout.setSpacing(0)\n\n        # 1.5 Pro：生成音频开关（仅在 1.5 Pro 下显示；放在上传区上方避免占用提示词高度）\n        self.generate_audio_checkbox = QCheckBox(\"生成音频\")\n        self.generate_audio_checkbox.setChecked(True)\n        self.generate_audio_checkbox.setVisible(False)\n        self.generate_audio_checkbox.setToolTip(\"仅 Seedance 1.5 Pro：生成与画面同步的声音（人声/音效/BGM）\")\n        try:\n            unified_style_system.apply_to_widget(self.generate_audio_checkbox)\n        except Exception:\n            pass\n        upload_area_layout.addWidget(self.generate_audio_checkbox)\n\n        # 使用新的统一上传面板\n        self.video_image_panel = VideoImageUploadPanel(self)\n        self.video_image_panel.imagesChanged.connect(self._on_video_images_changed)\n        self.video_image_panel.modeChanged.connect(self._on_video_image_mode_changed)\n        upload_area_layout.addWidget(self.video_image_panel)\n\n        # 兼容旧代码：保留空列表引用\n        self.upload_containers = []\n        self.upload_displays = []\n        self.delete_buttons = []\n        \n        # 中间提示词输入区域（约80%宽度）\n        input_area = QWidget()\n        input_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n        input_area_layout = QVBoxLayout(input_area)\n        input_area_layout.setContentsMargins(0, 0, 0, 0)\n        input_area_layout.setSpacing(5)\n        \n        # 提示词输入框\n        self.prompt_input = QTextEdit()\n        self.prompt_input.setMinimumHeight(65)   # Plan R: 最小高度 65px\n        self.prompt_input.setMaximumHeight(250)  # Plan Alpha+: 设定手动拖拽上限 (约10行)\n        # Plan S: 移除最大高度限制 -> Plan Z: 恢复上限限制\n        self.prompt_input.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        # 绑定文本变化事件\n        self.prompt_input.textChanged.connect(self.adjust_prompt_height)\n        self.prompt_input.setPlaceholderText(\"请输入视频生成提示词...\")\n        \n        # 使用统一样式系统设置样式，不再硬编码颜色\n        unified_style_system.apply_to_widget(self.prompt_input)\n        \n        # Dynamic styling handled by _update_styles\n        self._update_styles()\n               \n        input_area_layout.addWidget(self.prompt_input)\n        # Plan P: 移除 Stretch\n        \n        # 右侧生成按钮区域（约10%宽度）\n        button_area = QWidget()\n        button_area.setFixedWidth(120)\n        button_area.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n        button_area_layout = QVBoxLayout(button_area)\n        button_area_layout.setContentsMargins(0, 0, 0, 0)\n        button_area_layout.setSpacing(5)\n        \n        # 按钮容器（水平布局）\n        buttons_container = QWidget()\n        buttons_container.setStyleSheet(\"QWidget { border: none; background-color: transparent; }\")\n        buttons_layout = QHBoxLayout(buttons_container)\n        buttons_layout.setContentsMargins(0, 0, 0, 0)\n        buttons_layout.setSpacing(5)\n        \n        # 生成按钮\n        self.generate_button = QPushButton(\"生成视频\")\n        self.generate_button.setMinimumHeight(50)\n        self.generate_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)\n        self.generate_button.setObjectName(\"generateButton\")\n        unified_style_system.apply_to_widget(self.generate_button, extra={'variant': 'primary'})\n        self.generate_button.clicked.connect(self.generate_video)\n        \n        # 终止按钮（圆形）\n        self.stop_button = QPushButton(\"⏹\")\n        self.stop_button.setFixedSize(30, 30)\n        self.stop_button.setVisible(False)  # 默认隐藏\n        # 保留圆角样式，应用危险变体\n        self.stop_button.setStyleSheet(\"border-radius: 15px;\")\n        unified_style_system.apply_to_widget(self.stop_button, extra={'variant': 'danger'})\n        self.stop_button.clicked.connect(self.stop_video_generation)\n        \n        buttons_layout.addWidget(self.generate_button)\n        buttons_layout.addWidget(self.stop_button)\n        \n        button_area_layout.addWidget(buttons_container)\n        \n        # 添加到内容布局\n        content_layout.addWidget(self.upload_area)\n        content_layout.addWidget(input_area)\n        content_layout.addWidget(button_area)\n        \n        # 设置布局比例（上传区域按内容自适应，输入区域填充剩余空间）\n        content_layout.setStretch(0, 0)   # 上传区域：按内容自适应\n        content_layout.setStretch(1, 1)   # 输入区域：填充剩余空间\n        content_layout.setStretch(2, 0)   # 按钮区域：固定宽度\n        \n        # 用容器包裹第二行，使其可按需填充高度\n        self.row_container = QWidget()\n        self.row_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        self.row_container.setLayout(content_layout)\n        self.row_container.setMinimumHeight(80)  # 保证按钮区域最小高度\n\n        # 添加内容容器到主布局\n        input_layout.addWidget(self.row_container)\n\n        # 参考图面板（默认由 Schema 控制显示）\n        self.video_reference_panel = ReferenceAssetsPanel(self.input_widget)\n        self.video_reference_panel.setVisible(False)\n        self.video_reference_panel.set_panel_enabled(False)\n        self.video_reference_panel.filesChanged.connect(self._on_video_reference_files_changed)\n        self.video_reference_panel.warningEmitted.connect(self._on_video_reference_warning)\n        input_layout.addWidget(self.video_reference_panel)\n\n        # 设置主输入布局的垂直拉伸，让第二行容器填充可用高度\n        try:\n            input_layout.setStretch(0, 0)  # 参数区\n            input_layout.setStretch(1, 1)  # 第二行容器\n            input_layout.setStretch(2, 0)  # 参考图面板\n        except Exception:\n            pass\n\n        # 初始加载 Schema 定义\n        self._load_video_schema()\n\n        self.splitter.addWidget(self.input_widget)\n        \n        # Plan Y: 移除 Stretch Factor Hack，回归第一性原理\n        # self.splitter.setStretchFactor(0, 1)\n        # self.splitter.setStretchFactor(1, 0)\n\n        # 设置QSplitter拖拽手柄光标（修复光标消失问题）\n        try:\n            handle = self.splitter.handle(1)\n            if handle:\n                handle.setCursor(Qt.SplitVCursor)\n                logger.debug(\"[VideoModeWidget] QSplitter拖拽手柄光标已设置\")\n        except Exception as e:\n            logger.warning(f\"[VideoModeWidget] 设置QSplitter光标失败: {e}\")\n\n        # 设置分割器比例（增加底部输入区域高度，确保图片上传面板可见）\n        self.splitter.setSizes([700, 300])\n        \n        layout.addWidget(self.splitter)\n        \n        # 进度条\n        self.progress_bar = QProgressBar()\n        self.progress_bar.setVisible(False)\n        # 使用橙色进度条\n        unified_style_system.apply_to_widget(self.progress_bar, extra={'variant': 'primary_warning'})\n        layout.addWidget(self.progress_bar)\n\n        # 应用初始主题样式\n        self._update_styles()\n\n    # ------------------------------------------------------------------\n    # Schema handling\n    # ------------------------------------------------------------------\n\n    def _load_video_schema(\n        self,\n        variant: Optional[str] = None,\n        *,\n        keep_values: bool = True,\n        initial_values: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        if not self.video_schema_form:\n            return\n\n        preserved: Dict[str, Any] = {}\n        if keep_values and self.video_schema_form.schema():\n            try:\n                current_values, _errors = self.video_schema_form.collect_values()\n                preserved.update(current_values)\n            except Exception as exc:  # pragma: no cover - best effort\n                logger.debug(f\"采集视频旧参数失败: {exc}\")\n        if self._video_form_cache:\n            preserved.update(self._video_form_cache)\n        if initial_values:\n            preserved.update(initial_values)\n\n        try:\n            schema = get_ui_schema(\"seedance\", \"video\", variant)\n        except Exception as exc:\n            logger.error(f\"加载视频 Schema 失败: {exc}\")\n            return\n\n        self._video_schema = schema\n        self._video_schema_variant = schema.variant\n        self.video_schema_form.set_schema(schema, initial_values=preserved)\n        self._video_form_cache = preserved\n        self._handle_video_schema_extras(schema, preserved)\n        self._refresh_video_reference_panel_state(preserved)\n        # 更新图片上传面板的模型类型\n        self._update_video_image_panel_model_type()\n\n    def _handle_video_schema_extras(self, schema: Any, values: Dict[str, Any]) -> None:\n        # 1.5 Pro：生成音频开关（位置固定但仅在对应模型显示）\n        try:\n            extra = getattr(schema, \"extra\", {}) or {}\n            show_audio = bool(extra.get(\"show_generate_audio_toggle\", False))\n            if hasattr(self, \"generate_audio_checkbox\") and self.generate_audio_checkbox is not None:\n                self.generate_audio_checkbox.setVisible(show_audio)\n        except Exception:\n            pass\n\n        config = getattr(schema, \"reference_assets\", {}) or {}\n        self._video_reference_config = config\n        self._video_reference_visibility_rules = config.get('visible_if') or []\n        self._video_reference_auto_field = config.get('auto_compress_field')\n\n        panel = self.video_reference_panel\n        if not panel:\n            return\n\n        if not config.get('enabled'):\n            panel.clear()\n            panel.set_panel_enabled(False)\n            self._video_reference_visibility_rules = []\n            self._video_reference_auto_field = None\n            return\n\n        panel.set_panel_enabled(True)\n        panel.set_limits(\n            max_count=config.get('max_count'),\n            bundle_limit=config.get('bundle_limit'),\n        )\n        if config.get('accept'):\n            panel.set_accept_mime_types(config.get('accept'))\n        panel.set_hint_text(config.get('help_text'))\n\n    def _on_video_schema_reload(self, variant: str) -> None:\n        logger.info(f\"视频 Schema 切换请求: {variant}\")\n        self._load_video_schema(variant=variant, keep_values=False)\n        # Plan P: 切换模型时强制重置布局状态\n        self._reset_input_layout()\n\n    def _on_video_field_changed(self, field_name: str, value: Any) -> None:\n        self._video_form_cache[field_name] = value\n        self._refresh_video_reference_panel_state()\n\n    def _collect_video_form_values(self) -> Optional[Dict[str, Any]]:\n        if not self.video_schema_form:\n            return {}\n        values, errors = self.video_schema_form.collect_values()\n        if errors:\n            QMessageBox.warning(self, \"参数校验失败\", \"\\n\".join(errors))\n            return None\n        self._video_form_cache = dict(values)\n        return values\n\n    def _refresh_video_reference_panel_state(self, values: Optional[Dict[str, Any]] = None) -> None:\n        panel = self.video_reference_panel\n        if not panel:\n            return\n\n        config = self._video_reference_config or {}\n        if not config.get('enabled'):\n            panel.set_panel_enabled(False)\n            return\n\n        panel.set_panel_enabled(True)\n\n        data = dict(self._video_form_cache)\n        if values:\n            data.update(values)\n\n        visible = _evaluate_dependency_rules(self._video_reference_visibility_rules, data)\n        panel.setVisible(visible)\n\n        if self._video_reference_auto_field:\n            panel.set_auto_compress_enabled(bool(data.get(self._video_reference_auto_field, True)))\n\n    def _on_video_reference_files_changed(self) -> None:\n        if not self.video_reference_panel:\n            return\n        count = self.video_reference_panel.current_count()\n        logger.info(f\"视频参考图更新，当前数量: {count}\")\n\n    def _on_video_reference_warning(self, message: str) -> None:\n        if not message:\n            return\n        logger.warning(message)\n        try:\n            self.row_container.setMinimumHeight(80)  # Plan P: 恢复最小高度 (80)\n        except Exception:\n            pass\n\n    def _collect_reference_assets_for_video(self) -> Optional[List[Dict[str, Any]]]:\n        panel = self.video_reference_panel\n        if not panel or not panel.isVisible() or not panel.isEnabled():\n            return []\n\n        validation = panel.validate(expected_outputs=1)\n        if not validation.get('valid', True):\n            errors = \"\\n\".join(validation.get('errors', [])) or \"参考图数量超过限制\"\n            if validation.get('can_trim') and validation.get('trim_to') is not None:\n                trim_to = max(0, int(validation['trim_to']))\n                msg = (\n                    f\"参考图数量超出限制，是否自动裁剪至 {trim_to} 张？\"\\\n                    + (\"\\n\\n\" + errors if errors else \"\")\n                )\n                choice = QMessageBox.question(\n                    self,\n                    \"参考图超限\",\n                    msg,\n                    QMessageBox.Yes | QMessageBox.No,\n                    QMessageBox.Yes,\n                )\n                if choice == QMessageBox.Yes:\n                    panel.trim_to(trim_to)\n                    recheck = panel.validate(expected_outputs=1)\n                    if not recheck.get('valid', True):\n                        self.show_warning_toast(\"参考图仍超限，已取消生成\")\n                        return None\n                    try:\n                        self.status_label.setText(f\"已裁剪参考图至 {trim_to} 张\")\n                    except Exception:\n                        pass\n                else:\n                    try:\n                        self.status_label.setText(\"已取消生成（参考图超限）\")\n                    except Exception:\n                        pass\n                    return None\n            else:\n                self.show_warning_toast(errors)\n                return None\n\n        return panel.collect_assets()\n    \n    def _setup_config_monitoring(self):\n        \"\"\"设置配置监听定时器\"\"\"\n        from PySide6.QtCore import QTimer\n        self._config_check_timer = QTimer()\n        self._config_check_timer.timeout.connect(self._check_config_changes)\n        self._config_check_timer.start(2000)  # 每2秒检查一次配置变化\n        \n    def _check_config_changes(self):\n        \"\"\"检查配置变化（兜底机制，主渠道是 SettingsPage.settings_applied -> MainWindow.on_storage_path_changed）。\"\"\"\n        try:\n            from config_api import get_storage_dir\n            current_path = get_storage_dir()\n            \n            if self._current_storage_path != current_path:\n                logger.info(f\"[定时器检测] 视频存储路径变更: {self._current_storage_path} -> {current_path}\")\n                # 先更新本地记录，避免每2秒重复触发\n                self._current_storage_path = current_path\n\n                # 如果主信号已经完成了重绑/加载，这里不再做任何同步重初始化\n                try:\n                    view = getattr(self, 'video_history_view', None)\n                    model = getattr(view, 'model', None) if view else None\n                    if model and model.rowCount() > 0:\n                        return\n                except Exception:\n                    pass\n\n                # 兜底：仅在页面无数据时执行重绑 + 初次加载\n                try:\n                    self._update_storage_manager(current_path)\n                except Exception:\n                    pass\n                try:\n                    self._update_repository_manager(current_path)\n                except Exception:\n                    pass\n                try:\n                    view = getattr(self, 'video_history_view', None)\n                    if view and hasattr(view, 'clear') and hasattr(view, 'bind_repository') and hasattr(view, 'load_initial'):","numLines":500,"startLine":200,"totalLines":2818}}}
{"parentUuid":"dc02ead5-7060-40bd-93b9-93c4d1045c8f","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RHxVN1zmL8NBMsRfaMRxgS","type":"tool_result","content":"marketing/01_godream_intro_styled.html:16:    <section style=\"margin-bottom: 30px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.08);\">\nmarketing/01_godream_intro_styled.html:187:        <p style=\"color: #888; font-size: 14px; margin-bottom: 30px; letter-spacing: 2px;\">让你的 AIGC 资产，真正成为你的财富</p>\nCLAUDE.md:28:- [x] 恢复机制 (pending + 30s 刷新)\nCLAUDE.md:101:- 恢复机制 (pending + 30s 刷新)\nsnapshot1.json:31:      uid=1_30 link \"视频生成\" url=\"https://www.volcengine.com/docs/82379/1366799\"\nsnapshot1.json:378:  uid=1_300 StaticText \"doubao-seedance-1-0-pro&pro-fast 默认值：\"\ndocs/ARCH_REVIEW_AND_REFACTOR_PLAN.md:121:- API/IO 入口均通过 TaskRunner 执行；游标分页在 10 万条规模下请求下一页 < 100ms（冷启动 < 300ms）。\ndocs/ARCH_REVIEW_AND_REFACTOR_PLAN.md:178:- 加载响应：预取完成并渲染下一页 < 150ms（缓存冷启动下 < 300ms）；\ndocs/ARCH_REVIEW_AND_REFACTOR_PLAN.md:208:  - 指标：首帧出现 < 300ms（缓存热）、播放过程无明显丢帧/卡顿；\ndocs/refactor/PHASE1_COMPLETE_REPORT.md:567:qt_app.py (减少300+ lines)\r\ndocs/refactor/qt_app_analysis.md:12:| `build_resolution_text` | 134-163 | 30 | 生成“分辨率档位 + 比例 / WxH”文本 | `_parse_parameters_field` |\ndocs/refactor/qt_app_analysis.md:32:| `ExportBundleController` | 247-550 | 304 | 封装“导出历史记录/参考资产”按钮逻辑，调度 `RepositoryManager`、任务取消、toast | `task_runner`, `CancelToken`, `_resolve_repository_manager`, Qt signals |\ndocs/refactor/qt_app_analysis.md:41:| `WaterfallWidget` | 4495-5024 | 530 | 历史记录瀑布流，负责懒加载、列数计算、缓存策略 | `VideoCard`, `ImageCard`, `RepositoryManager`, `logger` |\ndocs/release_notes/CHANGELOG.md:82:- 统一移除小边 < 1024 的条目，保留大尺寸 21:9 为 3024×1296；在 4.0 模式对尺寸选项做安全过滤，避免旧项残留（modules/provider/schema.py）。\ndocs/release_notes/CHANGELOG.md:129:- **响应式布局**：300ms防抖优化，流畅的窗口尺寸调整体验\ndocs/seedance-1.5pro-plan.md:22:- P2 完成：`feat(recovery): resume pending on enter + 30s refresh`\ndocs/seedance-1.5pro-plan.md:61:5. 增加“重启恢复/刷新 pending 状态”机制：进入视频页立即刷新 + 每 30s 刷新；`succeeded` 且未下载自动下载并补全记录。\ndocs/seedance-1.5pro-plan.md:149:## 重启恢复/刷新 pending 状态（进入页 + 30s）\ndocs/seedance-1.5pro-plan.md:155:- 触发：进入视频页立即刷新一次；随后每 30s 刷新一次。\ndocs/seedance-1.5pro-plan.md:185:- 进入视频页 + 30s 刷新\ndocs/seedance-1.5pro-plan.md:220:  - 完成：`61a812d` `feat(recovery): resume pending on enter + 30s refresh`\ndocs/开发团队_交接清单.md:84:resize_debounce = 300         # 防抖延迟(ms)\ndocs/开发团队_交接清单.md:198:3. **防抖机制** - 300ms延迟确保体验流畅\ndocs/codex 对话记录导出.md:71:Image: gemeng/components/models/image_history_model.py:30, 54（scaled 到方形尺寸）；gemeng/qt_app.py:612-666（ImageCard 显示 200x200）。\ndocs/codex 对话记录导出.md:2787:看日志中 VideoThumbnailGenerator 的耗时，是否超过 300–800ms；以及是否与其他任务（比如下载/保存）在同一线程池排队。\ndocs/codex 对话记录导出.md:2821:验收脚本：新生成后历史项出现 ≤ 300ms 完成加载（以缩略图文件/预热为准），日志记录“摘要|thumb_elapsed=xxxms”。\ndocs/codex 对话记录导出.md:2827:T4：自测：同一视频出片后，历史列表中条目从“加载中”到显示缩略图的时间线性下降至 <300–500ms；并发生成下仍稳定。\ndocs/codex 对话记录导出.md:2859:新生成条目的缩略图展示时延明显降低（<300–500ms）\ndocs/codex 对话记录导出.md:2956:2025-09-16 17:52:30.734 | DEBUG | config_api:get_storage_dir:143 - Storage: using custom root -> /Users/yunchang/Desktop/测试\ndocs/codex 对话记录导出.md:2957:2025-09-16 17:52:30.734 | DEBUG | config_api:get_storage_dir:143 - Storage: using custom root -> /Users/yunchang/Desktop/测试\ndocs/codex 对话记录导出.md:3076:将“成功→历史区可见”的时延从 ~1.5s 降到 <300–500ms。\ndocs/codex 对话记录导出.md:3094:T4 自测：生成一次视频，观察“成功→显示缩略图”的时延（目标 <300–500ms）；检查日志摘要是否有 thumb_elapsed。\ndocs/codex 对话记录导出.md:3135:触发一次生成：观察 succeeded 到“列表显示缩略图”的时延，预期 < 300–500ms（下载+缩略图+单项刷新）\ndocs/codex 对话记录导出.md:3212:T5 自测：生成一次视频，统计“succeeded→显示缩略图”时延（目标 <300–500ms）；不开点击即显；开/关 v4 能跑通且回退正常\ndocs/codex 对话记录导出.md:3220:不点击，生成完成后历史卡片自动出现缩略图，succeeded→显示时延 <300–500ms（日志含 thumb_elapsed）\ndocs/codex 对话记录导出.md:3301:- T2 LRU 预热 + 单项刷新，延迟缩短；自测 show_latency < 300–500ms。\ndocs/codex 对话记录导出.md:3312:- 生成完成后无需点击即可看到缩略图，且延迟 < 300–500ms；\ndocs/codex 对话记录导出.md:3986:提交成功后前端日志显示参考图数量/掩码 ID；缩略图刷新时延保持 <300–500ms。\ndocs/codex 对话记录导出.md:4100:qt_app.py:636-830 (ImageCard.setup_ui, _update_image_pixmap)：包裹现有 image_label 为叠层容器，新添 self._ref_badge 角标标签（右上圆角底、数量文本），在 init 时根据 parameters[\"reference_assets\"] 预缓存计数与概要，并调用即将新增的引用解析 helper 获取绝对路径缓存；setToolTip 输出“参考图 n 张：#01、#02…”摘要（缺失则清除角标与 tooltip）。\ndocs/codex 对话记录导出.md:4101:qt_app.py:260-430 (VideoCard.setup_ui, _update_video_pixmap)：与图片卡一致地添加 self._ref_badge 与 tooltip，确保悬停/右键行为不受影响。\ndocs/codex 对话记录导出.md:4102:components/delegates/image_card_delegate.py:30-120、components/delegates/video_card_delegate.py:24-120：在 paint() 中读取模型提供的引用摘要，右上角绘制半透明圆角背景及数量文字；若有摘要则绘制 tooltip 三角提示色条；保持 sizeHint 逻辑不变。\ndocs/design/macOS_体验版打包_执行方案_待审批.md:69:- 旧记录（10月29-30日）：格式 `images/20251029/xxx.jpg` ❌\ndocs/theme_audit_report_v3.md:120:| video_mode_widget.py | 2306,2317,2322 | `#FF6B35`,`#E55A2B`,`#CC4A21` | `semantic.warning` + hover/pressed | 生成按钮 |\ndocs/theme_audit_report_v3.md:131:| 141 | `QColor(220,50,50,230)` | `semantic.error` + alpha | 删除按钮 |\ndocs/api/请求结构-API签名调用指南-火山引擎.md:101:| Authorization | String | 是 | HMAC-SHA256 Credential={AccessKeyId}/{ShortDate}/{Region}/{Service}/request, SignedHeaders={SignedHeaders}, Signature={Signature} 。如何构建，请参考签名方法 | HMAC-SHA256 Credential=AKLTMjI2ODVlYzI3ZGY1NGU4ZjhjYWRjMTlmNTM5OTZkYzE/20201230/cn-north-1/iam/request, SignedHeaders=content-type;host;x-content-sha256;x-date, Signature=28eeabbbd726b87002e0fe58ad8c1c768e619b06e2646f35b6ad7ed029a6d8a7 |\ndocs/api/请求结构-API签名调用指南-火山引擎.md:121:| X-Credential | String | 是 | 由{AccessKeyId}/{ShortDate}/{Region}/{Service}/request组成。 | AKLTMjI2ODVlYzI3ZGY1NGU4ZjhjYWRjMTlmNTM5OTZkYzE/20201230/cn-north-1/iam/request |\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/chat_components.py:336:        # self.stream_checkbox.setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system\ndocs/PRODUCT_ROADMAP.md:29:   - `ParameterFormWidget` 通过 schema 动态展示控件，300ms 防抖；支持 Seedream 3.0/4.0 参数差异。\npackaging/windows/临时方案_1000条数据支持.md:196:- 每次加载30条 ≈ 50ms\r\ntools/performance_benchmark.py:443:| 10k记录内存占用 | {summary['10k_record_memory']:.1f}MB | <300MB | {'✅' if summary['10k_record_memory'] < 300 else '❌'} |\n.style_backup/components/chat_components.py:336:        # self.stream_checkbox.# setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system\nmcp-servers/gemini-server/index.js:24:  gemini: { command: \"gemini\", defaultArgs: [\"-o\", \"stream-json\", \"--yolo\"], timeout: 300000, environment: { GEMINI_IDE_INTEGRATION: \"false\" } },\ndocs/下一步行动计划_待审批_20250924.md:38:- **验收**：性能脚本重新运行后达成目标值（加载<3s、内存<300MB、FPS≈60、表单延迟<50ms）。\ntools/system_diagnosis.py:541:        penalty = high_severity * 30 + medium_severity * 15 + low_severity * 5\ndocs/执行者任务提示词_界面优化.md:105:   - 实现300ms防抖延迟\ndocs/执行者任务提示词_界面优化.md:140:- 界面响应时间不超过300ms\ndocs/性能测试报告_20250924.md:48:  - `docs/test_reports/performance_benchmark_20250926_130923.json`\npackaging/windows/瀑布流1000条可行性评估.md:59:- 总加载时间：~300-600ms\r\npackaging/windows/瀑布流1000条可行性评估.md:254:- 增量加载30条：<200ms\r\n.style_backup/components/cards/video_card.py:166:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/components/cards/image_card.py:171:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:794:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:1300:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:3812:        # zoom_info.setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system  # 与按钮高度一致\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:3990:        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4752:        self.resize_timer.start(300)  # 300ms防抖延迟\n.style_backup/components/forms/parameter_form_standard.py:292:        self.update_timer.start(300)  # 300ms防抖\n.style_backup/qt_app.py:799:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/qt_app.py:1305:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/qt_app.py:3817:        # zoom_info.# setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system  # 与按钮高度一致\n.style_backup/qt_app.py:3995:        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n.style_backup/qt_app.py:4757:        self.resize_timer.start(300)  # 300ms防抖延迟\nutils/image_format_validator.py:22:    # 火山引擎API支持的图片格式 <mcreference link=\"https://blog.csdn.net/weixin_44786530/article/details/146113781\" index=\"1\">1</mcreference>\nutils/logger.py:17:    retention: str = \"30 days\",\nutils/logger.py:193:        retention=\"30 days\"\n.claude/UI_AUDIT_REPORT_v1.md:29:*   **分析**: Python 类定义中，后定义的 `closeEvent` 覆盖了先定义的。文件末尾残留了旧版代码（L1230+），引用了已被重构移除的 `self.is_using_opencv`。\n.claude/THEME_SYSTEM_REFACTOR_PLAN.md:32:        ├── 第 306 行: self._apply_theme_styles()\ncomponents/dialogs/image_detail_dialog.py:366:        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\ncomponents/forms/parameter_form_standard.py:292:        self.update_timer.start(300)  # 300ms防抖\ncomponents/modes/image_mode_widget.py:1442:                # Given the instruction \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\ncomponents/modes/image_mode_widget.py:1471:                # I will insert `self.splitter.setSizes([700, 300])` at the specified location,\ncomponents/modes/image_mode_widget.py:1474:                # \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\ncomponents/modes/image_mode_widget.py:1480:                # I will insert *only* the line `self.splitter.setSizes([700, 300])` at the indicated position,\ncomponents/modes/image_mode_widget.py:1485:                # Re-evaluating: The instruction is \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`.\"\ncomponents/modes/image_mode_widget.py:1496:                # I will insert the line `self.splitter.setSizes([700, 300])` at the specified location,\ncomponents/modes/image_mode_widget.py:2316:                    QTimer.singleShot(3000, lambda tid=pid: self.image_history_view.remove_placeholder(tid))\ndocs/macOS打包完整指南_PyInstaller方案.md:42:13:30 - 关键决策：放弃py2app，切换PyInstaller\ndocs/macOS打包完整指南_PyInstaller方案.md:47:14:30 - 创建macOS spec文件\ndocs/macOS打包完整指南_PyInstaller方案.md:55:15:30 - 创建自定义PyQt5 hooks\ncomponents/modes/video_mode_widget.py:56:    pending_recovery_completed = Signal(object)\ncomponents/modes/video_mode_widget.py:57:    pending_recovery_failed = Signal(str)\ncomponents/modes/video_mode_widget.py:70:        self._pending_recovery_timer: Optional[QTimer] = None\ncomponents/modes/video_mode_widget.py:71:        self._pending_recovery_inflight = False\ncomponents/modes/video_mode_widget.py:72:        self._pending_recovery_idle_rounds = 0\ncomponents/modes/video_mode_widget.py:107:        self.pending_recovery_completed.connect(self._on_pending_recovery_completed)\ncomponents/modes/video_mode_widget.py:108:        self.pending_recovery_failed.connect(self._on_pending_recovery_failed)\ncomponents/modes/video_mode_widget.py:118:        self._ensure_pending_recovery_timer_running(immediate=True)\ncomponents/modes/video_mode_widget.py:836:    # P2: 重启恢复 / 刷新 pending 状态（进入页 + 30s）\ncomponents/modes/video_mode_widget.py:839:    def _ensure_pending_recovery_timer_running(self, *, immediate: bool = False) -> None:\ncomponents/modes/video_mode_widget.py:842:            if self._pending_recovery_timer is None:\ncomponents/modes/video_mode_widget.py:843:                self._pending_recovery_timer = QTimer(self)\ncomponents/modes/video_mode_widget.py:844:                self._pending_recovery_timer.setInterval(30_000)\ncomponents/modes/video_mode_widget.py:845:                self._pending_recovery_timer.timeout.connect(self._trigger_pending_recovery)\ncomponents/modes/video_mode_widget.py:847:            if not self._pending_recovery_timer.isActive():\ncomponents/modes/video_mode_widget.py:848:                self._pending_recovery_idle_rounds = 0\ncomponents/modes/video_mode_widget.py:849:                self._pending_recovery_timer.start()\ncomponents/modes/video_mode_widget.py:852:                QTimer.singleShot(0, self._trigger_pending_recovery)\ncomponents/modes/video_mode_widget.py:856:    def _trigger_pending_recovery(self) -> None:\ncomponents/modes/video_mode_widget.py:857:        if self._pending_recovery_inflight:\ncomponents/modes/video_mode_widget.py:860:        self._pending_recovery_inflight = True\ncomponents/modes/video_mode_widget.py:863:            return self._run_pending_recovery_once()\ncomponents/modes/video_mode_widget.py:867:                self.pending_recovery_completed.emit(payload)\ncomponents/modes/video_mode_widget.py:873:                self.pending_recovery_failed.emit(str(exc))\ncomponents/modes/video_mode_widget.py:884:    def _run_pending_recovery_once(self) -> Dict[str, Any]:\ncomponents/modes/video_mode_widget.py:1048:    def _on_pending_recovery_completed(self, payload: Any) -> None:\ncomponents/modes/video_mode_widget.py:1049:        self._pending_recovery_inflight = False\ncomponents/modes/video_mode_widget.py:1058:            self._pending_recovery_idle_rounds += 1\ncomponents/modes/video_mode_widget.py:1060:            self._pending_recovery_idle_rounds = 0\ncomponents/modes/video_mode_widget.py:1062:        if self._pending_recovery_timer and self._pending_recovery_idle_rounds >= 2:\ncomponents/modes/video_mode_widget.py:1063:            self._pending_recovery_timer.stop()\ncomponents/modes/video_mode_widget.py:1076:    def _on_pending_recovery_failed(self, message: str) -> None:\ncomponents/modes/video_mode_widget.py:1077:        self._pending_recovery_inflight = False\ncomponents/modes/video_mode_widget.py:1954:                    QTimer.singleShot(3000, lambda tid=task_id: self.video_history_view.remove_placeholder(tid))\ncomponents/modes/video_mode_widget.py:2237:                    self._ensure_pending_recovery_timer_running(immediate=False)\n.claude/PYSIDE6_CLEANUP_PLAN_v1.md:112:| `start_app.py` | 29-30 | `from PyQt5.QtWidgets` | `from PySide6.QtWidgets` |\ncomponents/delegates/image_card_delegate.py:337:        preview = (prompt[:30] + '...') if len(prompt) > 30 else prompt\ncomponents/delegates/image_card_delegate.py:342:        prompt_rect = rect.adjusted(10, rect.height() - self.px(30), -10, -self.px(6))\ncomponents/delegates/video_card_delegate.py:284:        preview = (prompt[:30] + '...') if len(prompt) > 30 else prompt\ncomponents/delegates/video_card_delegate.py:289:        prompt_rect = rect.adjusted(10, rect.height() - self.px(30), -10, -self.px(6))"}]},"uuid":"d8577d5b-a59f-4d90-baaa-6a04883ed310","timestamp":"2025-12-30T09:56:20.281Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"marketing/01_godream_intro_styled.html:16:    <section style=\"margin-bottom: 30px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.08);\">\nmarketing/01_godream_intro_styled.html:187:        <p style=\"color: #888; font-size: 14px; margin-bottom: 30px; letter-spacing: 2px;\">让你的 AIGC 资产，真正成为你的财富</p>\nCLAUDE.md:28:- [x] 恢复机制 (pending + 30s 刷新)\nCLAUDE.md:101:- 恢复机制 (pending + 30s 刷新)\nsnapshot1.json:31:      uid=1_30 link \"视频生成\" url=\"https://www.volcengine.com/docs/82379/1366799\"\nsnapshot1.json:378:  uid=1_300 StaticText \"doubao-seedance-1-0-pro&pro-fast 默认值：\"\ndocs/ARCH_REVIEW_AND_REFACTOR_PLAN.md:121:- API/IO 入口均通过 TaskRunner 执行；游标分页在 10 万条规模下请求下一页 < 100ms（冷启动 < 300ms）。\ndocs/ARCH_REVIEW_AND_REFACTOR_PLAN.md:178:- 加载响应：预取完成并渲染下一页 < 150ms（缓存冷启动下 < 300ms）；\ndocs/ARCH_REVIEW_AND_REFACTOR_PLAN.md:208:  - 指标：首帧出现 < 300ms（缓存热）、播放过程无明显丢帧/卡顿；\ndocs/refactor/PHASE1_COMPLETE_REPORT.md:567:qt_app.py (减少300+ lines)\r\ndocs/refactor/qt_app_analysis.md:12:| `build_resolution_text` | 134-163 | 30 | 生成“分辨率档位 + 比例 / WxH”文本 | `_parse_parameters_field` |\ndocs/refactor/qt_app_analysis.md:32:| `ExportBundleController` | 247-550 | 304 | 封装“导出历史记录/参考资产”按钮逻辑，调度 `RepositoryManager`、任务取消、toast | `task_runner`, `CancelToken`, `_resolve_repository_manager`, Qt signals |\ndocs/refactor/qt_app_analysis.md:41:| `WaterfallWidget` | 4495-5024 | 530 | 历史记录瀑布流，负责懒加载、列数计算、缓存策略 | `VideoCard`, `ImageCard`, `RepositoryManager`, `logger` |\ndocs/release_notes/CHANGELOG.md:82:- 统一移除小边 < 1024 的条目，保留大尺寸 21:9 为 3024×1296；在 4.0 模式对尺寸选项做安全过滤，避免旧项残留（modules/provider/schema.py）。\ndocs/release_notes/CHANGELOG.md:129:- **响应式布局**：300ms防抖优化，流畅的窗口尺寸调整体验\ndocs/seedance-1.5pro-plan.md:22:- P2 完成：`feat(recovery): resume pending on enter + 30s refresh`\ndocs/seedance-1.5pro-plan.md:61:5. 增加“重启恢复/刷新 pending 状态”机制：进入视频页立即刷新 + 每 30s 刷新；`succeeded` 且未下载自动下载并补全记录。\ndocs/seedance-1.5pro-plan.md:149:## 重启恢复/刷新 pending 状态（进入页 + 30s）\ndocs/seedance-1.5pro-plan.md:155:- 触发：进入视频页立即刷新一次；随后每 30s 刷新一次。\ndocs/seedance-1.5pro-plan.md:185:- 进入视频页 + 30s 刷新\ndocs/seedance-1.5pro-plan.md:220:  - 完成：`61a812d` `feat(recovery): resume pending on enter + 30s refresh`\ndocs/开发团队_交接清单.md:84:resize_debounce = 300         # 防抖延迟(ms)\ndocs/开发团队_交接清单.md:198:3. **防抖机制** - 300ms延迟确保体验流畅\ndocs/codex 对话记录导出.md:71:Image: gemeng/components/models/image_history_model.py:30, 54（scaled 到方形尺寸）；gemeng/qt_app.py:612-666（ImageCard 显示 200x200）。\ndocs/codex 对话记录导出.md:2787:看日志中 VideoThumbnailGenerator 的耗时，是否超过 300–800ms；以及是否与其他任务（比如下载/保存）在同一线程池排队。\ndocs/codex 对话记录导出.md:2821:验收脚本：新生成后历史项出现 ≤ 300ms 完成加载（以缩略图文件/预热为准），日志记录“摘要|thumb_elapsed=xxxms”。\ndocs/codex 对话记录导出.md:2827:T4：自测：同一视频出片后，历史列表中条目从“加载中”到显示缩略图的时间线性下降至 <300–500ms；并发生成下仍稳定。\ndocs/codex 对话记录导出.md:2859:新生成条目的缩略图展示时延明显降低（<300–500ms）\ndocs/codex 对话记录导出.md:2956:2025-09-16 17:52:30.734 | DEBUG | config_api:get_storage_dir:143 - Storage: using custom root -> /Users/yunchang/Desktop/测试\ndocs/codex 对话记录导出.md:2957:2025-09-16 17:52:30.734 | DEBUG | config_api:get_storage_dir:143 - Storage: using custom root -> /Users/yunchang/Desktop/测试\ndocs/codex 对话记录导出.md:3076:将“成功→历史区可见”的时延从 ~1.5s 降到 <300–500ms。\ndocs/codex 对话记录导出.md:3094:T4 自测：生成一次视频，观察“成功→显示缩略图”的时延（目标 <300–500ms）；检查日志摘要是否有 thumb_elapsed。\ndocs/codex 对话记录导出.md:3135:触发一次生成：观察 succeeded 到“列表显示缩略图”的时延，预期 < 300–500ms（下载+缩略图+单项刷新）\ndocs/codex 对话记录导出.md:3212:T5 自测：生成一次视频，统计“succeeded→显示缩略图”时延（目标 <300–500ms）；不开点击即显；开/关 v4 能跑通且回退正常\ndocs/codex 对话记录导出.md:3220:不点击，生成完成后历史卡片自动出现缩略图，succeeded→显示时延 <300–500ms（日志含 thumb_elapsed）\ndocs/codex 对话记录导出.md:3301:- T2 LRU 预热 + 单项刷新，延迟缩短；自测 show_latency < 300–500ms。\ndocs/codex 对话记录导出.md:3312:- 生成完成后无需点击即可看到缩略图，且延迟 < 300–500ms；\ndocs/codex 对话记录导出.md:3986:提交成功后前端日志显示参考图数量/掩码 ID；缩略图刷新时延保持 <300–500ms。\ndocs/codex 对话记录导出.md:4100:qt_app.py:636-830 (ImageCard.setup_ui, _update_image_pixmap)：包裹现有 image_label 为叠层容器，新添 self._ref_badge 角标标签（右上圆角底、数量文本），在 init 时根据 parameters[\"reference_assets\"] 预缓存计数与概要，并调用即将新增的引用解析 helper 获取绝对路径缓存；setToolTip 输出“参考图 n 张：#01、#02…”摘要（缺失则清除角标与 tooltip）。\ndocs/codex 对话记录导出.md:4101:qt_app.py:260-430 (VideoCard.setup_ui, _update_video_pixmap)：与图片卡一致地添加 self._ref_badge 与 tooltip，确保悬停/右键行为不受影响。\ndocs/codex 对话记录导出.md:4102:components/delegates/image_card_delegate.py:30-120、components/delegates/video_card_delegate.py:24-120：在 paint() 中读取模型提供的引用摘要，右上角绘制半透明圆角背景及数量文字；若有摘要则绘制 tooltip 三角提示色条；保持 sizeHint 逻辑不变。\ndocs/design/macOS_体验版打包_执行方案_待审批.md:69:- 旧记录（10月29-30日）：格式 `images/20251029/xxx.jpg` ❌\ndocs/theme_audit_report_v3.md:120:| video_mode_widget.py | 2306,2317,2322 | `#FF6B35`,`#E55A2B`,`#CC4A21` | `semantic.warning` + hover/pressed | 生成按钮 |\ndocs/theme_audit_report_v3.md:131:| 141 | `QColor(220,50,50,230)` | `semantic.error` + alpha | 删除按钮 |\ndocs/api/请求结构-API签名调用指南-火山引擎.md:101:| Authorization | String | 是 | HMAC-SHA256 Credential={AccessKeyId}/{ShortDate}/{Region}/{Service}/request, SignedHeaders={SignedHeaders}, Signature={Signature} 。如何构建，请参考签名方法 | HMAC-SHA256 Credential=AKLTMjI2ODVlYzI3ZGY1NGU4ZjhjYWRjMTlmNTM5OTZkYzE/20201230/cn-north-1/iam/request, SignedHeaders=content-type;host;x-content-sha256;x-date, Signature=28eeabbbd726b87002e0fe58ad8c1c768e619b06e2646f35b6ad7ed029a6d8a7 |\ndocs/api/请求结构-API签名调用指南-火山引擎.md:121:| X-Credential | String | 是 | 由{AccessKeyId}/{ShortDate}/{Region}/{Service}/request组成。 | AKLTMjI2ODVlYzI3ZGY1NGU4ZjhjYWRjMTlmNTM5OTZkYzE/20201230/cn-north-1/iam/request |\n.style_backup/备份（界面正确版）/鸽梦 9.24/components/chat_components.py:336:        # self.stream_checkbox.setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system\ndocs/PRODUCT_ROADMAP.md:29:   - `ParameterFormWidget` 通过 schema 动态展示控件，300ms 防抖；支持 Seedream 3.0/4.0 参数差异。\npackaging/windows/临时方案_1000条数据支持.md:196:- 每次加载30条 ≈ 50ms\r\ntools/performance_benchmark.py:443:| 10k记录内存占用 | {summary['10k_record_memory']:.1f}MB | <300MB | {'✅' if summary['10k_record_memory'] < 300 else '❌'} |\n.style_backup/components/chat_components.py:336:        # self.stream_checkbox.# setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system\nmcp-servers/gemini-server/index.js:24:  gemini: { command: \"gemini\", defaultArgs: [\"-o\", \"stream-json\", \"--yolo\"], timeout: 300000, environment: { GEMINI_IDE_INTEGRATION: \"false\" } },\ndocs/下一步行动计划_待审批_20250924.md:38:- **验收**：性能脚本重新运行后达成目标值（加载<3s、内存<300MB、FPS≈60、表单延迟<50ms）。\ntools/system_diagnosis.py:541:        penalty = high_severity * 30 + medium_severity * 15 + low_severity * 5\ndocs/执行者任务提示词_界面优化.md:105:   - 实现300ms防抖延迟\ndocs/执行者任务提示词_界面优化.md:140:- 界面响应时间不超过300ms\ndocs/性能测试报告_20250924.md:48:  - `docs/test_reports/performance_benchmark_20250926_130923.json`\npackaging/windows/瀑布流1000条可行性评估.md:59:- 总加载时间：~300-600ms\r\npackaging/windows/瀑布流1000条可行性评估.md:254:- 增量加载30条：<200ms\r\n.style_backup/components/cards/video_card.py:166:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/components/cards/image_card.py:171:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:794:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:1300:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:3812:        # zoom_info.setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system  # 与按钮高度一致\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:3990:        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n.style_backup/备份（界面正确版）/鸽梦 9.24/qt_app.py:4752:        self.resize_timer.start(300)  # 300ms防抖延迟\n.style_backup/components/forms/parameter_form_standard.py:292:        self.update_timer.start(300)  # 300ms防抖\n.style_backup/qt_app.py:799:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/qt_app.py:1305:        prompt_label = QLabel(f\"提示词: {prompt[:30]}...\" if len(prompt) > 30 else f\"提示词: {prompt}\")\n.style_backup/qt_app.py:3817:        # zoom_info.# setMinimumHeight(30)  # Migrated to unified style system  # Migrated to unified style system  # 与按钮高度一致\n.style_backup/qt_app.py:3995:        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\n.style_backup/qt_app.py:4757:        self.resize_timer.start(300)  # 300ms防抖延迟\nutils/image_format_validator.py:22:    # 火山引擎API支持的图片格式 <mcreference link=\"https://blog.csdn.net/weixin_44786530/article/details/146113781\" index=\"1\">1</mcreference>\nutils/logger.py:17:    retention: str = \"30 days\",\nutils/logger.py:193:        retention=\"30 days\"\n.claude/UI_AUDIT_REPORT_v1.md:29:*   **分析**: Python 类定义中，后定义的 `closeEvent` 覆盖了先定义的。文件末尾残留了旧版代码（L1230+），引用了已被重构移除的 `self.is_using_opencv`。\n.claude/THEME_SYSTEM_REFACTOR_PLAN.md:32:        ├── 第 306 行: self._apply_theme_styles()\ncomponents/dialogs/image_detail_dialog.py:366:        self.show_copy_toast(f\"已复制: {text[:30]}...\" if len(text) > 30 else f\"已复制: {text}\")\ncomponents/forms/parameter_form_standard.py:292:        self.update_timer.start(300)  # 300ms防抖\ncomponents/modes/image_mode_widget.py:1442:                # Given the instruction \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\ncomponents/modes/image_mode_widget.py:1471:                # I will insert `self.splitter.setSizes([700, 300])` at the specified location,\ncomponents/modes/image_mode_widget.py:1474:                # \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`\"\ncomponents/modes/image_mode_widget.py:1480:                # I will insert *only* the line `self.splitter.setSizes([700, 300])` at the indicated position,\ncomponents/modes/image_mode_widget.py:1485:                # Re-evaluating: The instruction is \"Change `splitter.setSizes([700, 300])` to `self.splitter.setSizes([700, 300])`.\"\ncomponents/modes/image_mode_widget.py:1496:                # I will insert the line `self.splitter.setSizes([700, 300])` at the specified location,\ncomponents/modes/image_mode_widget.py:2316:                    QTimer.singleShot(3000, lambda tid=pid: self.image_history_view.remove_placeholder(tid))\ndocs/macOS打包完整指南_PyInstaller方案.md:42:13:30 - 关键决策：放弃py2app，切换PyInstaller\ndocs/macOS打包完整指南_PyInstaller方案.md:47:14:30 - 创建macOS spec文件\ndocs/macOS打包完整指南_PyInstaller方案.md:55:15:30 - 创建自定义PyQt5 hooks\ncomponents/modes/video_mode_widget.py:56:    pending_recovery_completed = Signal(object)\ncomponents/modes/video_mode_widget.py:57:    pending_recovery_failed = Signal(str)\ncomponents/modes/video_mode_widget.py:70:        self._pending_recovery_timer: Optional[QTimer] = None\ncomponents/modes/video_mode_widget.py:71:        self._pending_recovery_inflight = False\ncomponents/modes/video_mode_widget.py:72:        self._pending_recovery_idle_rounds = 0\ncomponents/modes/video_mode_widget.py:107:        self.pending_recovery_completed.connect(self._on_pending_recovery_completed)\ncomponents/modes/video_mode_widget.py:108:        self.pending_recovery_failed.connect(self._on_pending_recovery_failed)\ncomponents/modes/video_mode_widget.py:118:        self._ensure_pending_recovery_timer_running(immediate=True)\ncomponents/modes/video_mode_widget.py:836:    # P2: 重启恢复 / 刷新 pending 状态（进入页 + 30s）\ncomponents/modes/video_mode_widget.py:839:    def _ensure_pending_recovery_timer_running(self, *, immediate: bool = False) -> None:\ncomponents/modes/video_mode_widget.py:842:            if self._pending_recovery_timer is None:\ncomponents/modes/video_mode_widget.py:843:                self._pending_recovery_timer = QTimer(self)\ncomponents/modes/video_mode_widget.py:844:                self._pending_recovery_timer.setInterval(30_000)\ncomponents/modes/video_mode_widget.py:845:                self._pending_recovery_timer.timeout.connect(self._trigger_pending_recovery)\ncomponents/modes/video_mode_widget.py:847:            if not self._pending_recovery_timer.isActive():\ncomponents/modes/video_mode_widget.py:848:                self._pending_recovery_idle_rounds = 0\ncomponents/modes/video_mode_widget.py:849:                self._pending_recovery_timer.start()\ncomponents/modes/video_mode_widget.py:852:                QTimer.singleShot(0, self._trigger_pending_recovery)\ncomponents/modes/video_mode_widget.py:856:    def _trigger_pending_recovery(self) -> None:\ncomponents/modes/video_mode_widget.py:857:        if self._pending_recovery_inflight:\ncomponents/modes/video_mode_widget.py:860:        self._pending_recovery_inflight = True\ncomponents/modes/video_mode_widget.py:863:            return self._run_pending_recovery_once()\ncomponents/modes/video_mode_widget.py:867:                self.pending_recovery_completed.emit(payload)\ncomponents/modes/video_mode_widget.py:873:                self.pending_recovery_failed.emit(str(exc))\ncomponents/modes/video_mode_widget.py:884:    def _run_pending_recovery_once(self) -> Dict[str, Any]:\ncomponents/modes/video_mode_widget.py:1048:    def _on_pending_recovery_completed(self, payload: Any) -> None:\ncomponents/modes/video_mode_widget.py:1049:        self._pending_recovery_inflight = False\ncomponents/modes/video_mode_widget.py:1058:            self._pending_recovery_idle_rounds += 1\ncomponents/modes/video_mode_widget.py:1060:            self._pending_recovery_idle_rounds = 0\ncomponents/modes/video_mode_widget.py:1062:        if self._pending_recovery_timer and self._pending_recovery_idle_rounds >= 2:\ncomponents/modes/video_mode_widget.py:1063:            self._pending_recovery_timer.stop()\ncomponents/modes/video_mode_widget.py:1076:    def _on_pending_recovery_failed(self, message: str) -> None:\ncomponents/modes/video_mode_widget.py:1077:        self._pending_recovery_inflight = False\ncomponents/modes/video_mode_widget.py:1954:                    QTimer.singleShot(3000, lambda tid=task_id: self.video_history_view.remove_placeholder(tid))\ncomponents/modes/video_mode_widget.py:2237:                    self._ensure_pending_recovery_timer_running(immediate=False)\n.claude/PYSIDE6_CLEANUP_PLAN_v1.md:112:| `start_app.py` | 29-30 | `from PyQt5.QtWidgets` | `from PySide6.QtWidgets` |\ncomponents/delegates/image_card_delegate.py:337:        preview = (prompt[:30] + '...') if len(prompt) > 30 else prompt\ncomponents/delegates/image_card_delegate.py:342:        prompt_rect = rect.adjusted(10, rect.height() - self.px(30), -10, -self.px(6))\ncomponents/delegates/video_card_delegate.py:284:        preview = (prompt[:30] + '...') if len(prompt) > 30 else prompt\ncomponents/delegates/video_card_delegate.py:289:        prompt_rect = rect.adjusted(10, rect.height() - self.px(30), -10, -self.px(6))","numLines":129}}
{"parentUuid":"d8577d5b-a59f-4d90-baaa-6a04883ed310","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01J5NQe2xTr8JdGKEHsMNLzh","type":"message","role":"assistant","content":[{"type":"text","text":"很好！现在让我查看 pending 恢复的具体实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15799,"cache_read_input_tokens":78516,"cache_creation":{"ephemeral_5m_input_tokens":15799,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"fcac822e-6b5c-4a9a-a721-11adf0136f60","timestamp":"2025-12-30T09:56:36.673Z"}
{"parentUuid":"fcac822e-6b5c-4a9a-a721-11adf0136f60","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01J5NQe2xTr8JdGKEHsMNLzh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SSh9iJVUPZsVT98kFHke7d","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py","limit":400,"offset":836}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15799,"cache_read_input_tokens":78516,"cache_creation":{"ephemeral_5m_input_tokens":15799,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"021a2f21-650f-4ea6-9d8a-530001968b38","timestamp":"2025-12-30T09:56:37.126Z"}
{"parentUuid":"021a2f21-650f-4ea6-9d8a-530001968b38","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01J5NQe2xTr8JdGKEHsMNLzh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LWsBB2yiWgJ1Wg3RMPQ4qg","name":"Grep","input":{"pattern":"_run_pending_recovery_once|_on_pending_recovery|download|async|failed|succeeded","path":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py","output_mode":"content","head_limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15799,"cache_read_input_tokens":78516,"cache_creation":{"ephemeral_5m_input_tokens":15799,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"b28fb77e-5aa2-4fcd-9547-bf467e741b9a","timestamp":"2025-12-30T09:56:37.862Z"}
{"parentUuid":"b28fb77e-5aa2-4fcd-9547-bf467e741b9a","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SSh9iJVUPZsVT98kFHke7d","type":"tool_result","content":"   836→    # P2: 重启恢复 / 刷新 pending 状态（进入页 + 30s）\n   837→    # ------------------------------------------------------------------\n   838→\n   839→    def _ensure_pending_recovery_timer_running(self, *, immediate: bool = False) -> None:\n   840→        \"\"\"确保 pending 恢复定时器已启动；若无进行中任务会在两轮后自动停止。\"\"\"\n   841→        try:\n   842→            if self._pending_recovery_timer is None:\n   843→                self._pending_recovery_timer = QTimer(self)\n   844→                self._pending_recovery_timer.setInterval(30_000)\n   845→                self._pending_recovery_timer.timeout.connect(self._trigger_pending_recovery)\n   846→\n   847→            if not self._pending_recovery_timer.isActive():\n   848→                self._pending_recovery_idle_rounds = 0\n   849→                self._pending_recovery_timer.start()\n   850→\n   851→            if immediate:\n   852→                QTimer.singleShot(0, self._trigger_pending_recovery)\n   853→        except Exception as exc:\n   854→            logger.debug(f\"启动 pending 恢复定时器失败: {exc}\")\n   855→\n   856→    def _trigger_pending_recovery(self) -> None:\n   857→        if self._pending_recovery_inflight:\n   858→            return\n   859→\n   860→        self._pending_recovery_inflight = True\n   861→\n   862→        def _task():\n   863→            return self._run_pending_recovery_once()\n   864→\n   865→        def _on_done(payload):\n   866→            try:\n   867→                self.pending_recovery_completed.emit(payload)\n   868→            except Exception:\n   869→                pass\n   870→\n   871→        def _on_error(exc: BaseException):\n   872→            try:\n   873→                self.pending_recovery_failed.emit(str(exc))\n   874→            except Exception:\n   875→                pass\n   876→\n   877→        task_runner.submit(\n   878→            _task,\n   879→            key=\"video-recovery:pending\",\n   880→            on_done=_on_done,\n   881→            on_error=_on_error,\n   882→        )\n   883→\n   884→    def _run_pending_recovery_once(self) -> Dict[str, Any]:\n   885→        \"\"\"后台线程：查询远端状态并在必要时自动下载 succeeded 视频。\"\"\"\n   886→        import os\n   887→\n   888→        from config.unified_config import get_unified_config\n   889→        from config_api import get_storage_dir\n   890→        from modules.repository.manager import RepositoryManager\n   891→        from modules.seedance.manager import SeedanceManager\n   892→        from services.video_service import VideoService\n   893→\n   894→        storage_dir = get_storage_dir()\n   895→        repo = RepositoryManager(storage_dir)\n   896→\n   897→        active_statuses = [\"pending\", \"queued\", \"running\"]\n   898→        records = repo.get_records_by_status(\"video\", active_statuses, limit=200) or []\n   899→\n   900→        # 单用户场景：按计划每轮最多处理 20 条，避免资源占用\n   901→        max_per_cycle = 20\n   902→        candidates = records[:max_per_cycle]\n   903→\n   904→        summary = {\n   905→            \"fetched\": len(records),\n   906→            \"processed\": 0,\n   907→            \"updated\": 0,\n   908→            \"downloaded\": 0,\n   909→            \"stale\": 0,\n   910→            \"remaining_active\": 0,\n   911→        }\n   912→\n   913→        if not candidates:\n   914→            return summary\n   915→\n   916→        api_key = get_unified_config().get_api_key(\"volcengine\")\n   917→        manager = SeedanceManager(api_key)\n   918→\n   919→        def _extract_record_id(rec: Dict[str, Any]) -> Optional[str]:\n   920→            return (\n   921→                rec.get(\"file_id\")\n   922→                or rec.get(\"generation_id\")\n   923→                or rec.get(\"task_id\")\n   924→                or rec.get(\"id\")\n   925→            )\n   926→\n   927→        def _extract_api_task_id(params: Dict[str, Any]) -> Optional[str]:\n   928→            sent = params.get(\"params_sent\") if isinstance(params, dict) else None\n   929→            actual = params.get(\"params_actual\") if isinstance(params, dict) else None\n   930→            if isinstance(sent, dict) and sent.get(\"api_task_id\"):\n   931→                return str(sent.get(\"api_task_id\"))\n   932→            if isinstance(actual, dict) and actual.get(\"api_task_id\"):\n   933→                return str(actual.get(\"api_task_id\"))\n   934→            if isinstance(params, dict) and params.get(\"api_task_id\"):\n   935→                return str(params.get(\"api_task_id\"))\n   936→            return None\n   937→\n   938→        for rec in candidates:\n   939→            record_id = _extract_record_id(rec)\n   940→            if not record_id:\n   941→                continue\n   942→\n   943→            params = rec.get(\"parameters\") or {}\n   944→            if not isinstance(params, dict):\n   945→                params = {}\n   946→\n   947→            api_task_id = _extract_api_task_id(params)\n   948→            if not api_task_id:\n   949→                summary[\"stale\"] += 1\n   950→                try:\n   951→                    repo.update_record(\n   952→                        str(record_id),\n   953→                        {\n   954→                            \"status\": \"failed\",\n   955→                            \"metadata\": {\"error\": \"missing api_task_id; cannot recover after restart\"},\n   956→                        },\n   957→                    )\n   958→                except Exception:\n   959→                    pass\n   960→                continue\n   961→\n   962→            summary[\"processed\"] += 1\n   963→\n   964→            try:\n   965→                status_result = manager.client.query_video_task(api_task_id)\n   966→            except Exception as exc:\n   967→                logger.debug(f\"pending recovery: query failed api_task_id={api_task_id}: {exc}\")\n   968→                continue\n   969→\n   970→            status = status_result.get(\"status\") or \"unknown\"\n   971→            params_actual = VideoService._build_params_actual(status_result)\n   972→            merged_params = VideoService._merge_params_bundle(existing=params, params_actual=params_actual)\n   973→\n   974→            local_path = rec.get(\"absolute_path\") or rec.get(\"file_path\") or \"\"\n   975→            has_local = bool(local_path and os.path.exists(local_path))\n   976→\n   977→            if status == \"succeeded\":\n   978→                if has_local:\n   979→                    try:\n   980→                        repo.update_record(str(record_id), {\"status\": status, \"parameters\": merged_params})\n   981→                        summary[\"updated\"] += 1\n   982→                    except Exception:\n   983→                        pass\n   984→                else:\n   985→                    try:\n   986→                        now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n   987→                        complete_payload = {\n   988→                            \"success\": True,\n   989→                            \"task_id\": str(record_id),\n   990→                            \"api_task_id\": api_task_id,\n   991→                            \"video_url\": status_result.get(\"video_url\"),\n   992→                            \"thumbnail_url\": status_result.get(\"thumbnail_url\", \"\"),\n   993→                            \"preview_url\": status_result.get(\"preview_url\", \"\"),\n   994→                            \"status\": status,\n   995→                            \"type\": \"video\",\n   996→                            \"input_image\": \"\",\n   997→                            \"parameters\": merged_params,\n   998→                            \"created_at\": rec.get(\"created_at\") or now,\n   999→                            \"completed_at\": now,\n  1000→                            \"reference_assets\": merged_params.get(\"reference_assets\") or [],\n  1001→                        }\n  1002→                        save_result = manager._save_video_locally(complete_payload)\n  1003→                        if isinstance(save_result, dict) and save_result.get(\"local_save_error\"):\n  1004→                            repo.update_record(\n  1005→                                str(record_id),\n  1006→                                {\n  1007→                                    \"status\": \"failed\",\n  1008→                                    \"metadata\": {\"error\": str(save_result.get(\"local_save_error\"))},\n  1009→                                    \"parameters\": merged_params,\n  1010→                                },\n  1011→                            )\n  1012→                        else:\n  1013→                            summary[\"downloaded\"] += 1\n  1014→                    except Exception as exc:\n  1015→                        logger.debug(f\"pending recovery: save failed record_id={record_id}: {exc}\")\n  1016→                        try:\n  1017→                            repo.update_record(\n  1018→                                str(record_id),\n  1019→                                {\n  1020→                                    \"status\": \"failed\",\n  1021→                                    \"metadata\": {\"error\": str(exc)},\n  1022→                                    \"parameters\": merged_params,\n  1023→                                },\n  1024→                            )\n  1025→                        except Exception:\n  1026→                            pass\n  1027→            elif status in {\"failed\", \"cancelled\", \"expired\"}:\n  1028→                try:\n  1029→                    repo.update_record(str(record_id), {\"status\": status, \"parameters\": merged_params})\n  1030→                    summary[\"updated\"] += 1\n  1031→                except Exception:\n  1032→                    pass\n  1033→            else:\n  1034→                # 仍在进行中：同步远端状态（pending/queued/running/processing 等）\n  1035→                try:\n  1036→                    repo.update_record(str(record_id), {\"status\": status, \"parameters\": merged_params})\n  1037→                    summary[\"updated\"] += 1\n  1038→                except Exception:\n  1039→                    pass\n  1040→                summary[\"remaining_active\"] += 1\n  1041→\n  1042→        # 若本轮未处理完全部记录，保守认为仍有进行中任务\n  1043→        if len(records) > len(candidates):\n  1044→            summary[\"remaining_active\"] += max(0, len(records) - len(candidates))\n  1045→\n  1046→        return summary\n  1047→\n  1048→    def _on_pending_recovery_completed(self, payload: Any) -> None:\n  1049→        self._pending_recovery_inflight = False\n  1050→\n  1051→        summary = payload if isinstance(payload, dict) else {}\n  1052→        remaining = int(summary.get(\"remaining_active\") or 0)\n  1053→        updated = int(summary.get(\"updated\") or 0)\n  1054→        downloaded = int(summary.get(\"downloaded\") or 0)\n  1055→        stale = int(summary.get(\"stale\") or 0)\n  1056→\n  1057→        if remaining <= 0:\n  1058→            self._pending_recovery_idle_rounds += 1\n  1059→        else:\n  1060→            self._pending_recovery_idle_rounds = 0\n  1061→\n  1062→        if self._pending_recovery_timer and self._pending_recovery_idle_rounds >= 2:\n  1063→            self._pending_recovery_timer.stop()\n  1064→\n  1065→        if updated or downloaded or stale:\n  1066→            try:\n  1067→                self._delayed_refresh_history()\n  1068→            except Exception:\n  1069→                pass\n  1070→\n  1071→        if downloaded:\n  1072→            self.status_label.setText(f\"✅ 已恢复并下载 {downloaded} 个未落盘视频\")\n  1073→        elif remaining > 0:\n  1074→            self.status_label.setText(f\"🔄 正在恢复任务状态…（{remaining} 个进行中）\")\n  1075→\n  1076→    def _on_pending_recovery_failed(self, message: str) -> None:\n  1077→        self._pending_recovery_inflight = False\n  1078→        logger.debug(f\"pending recovery failed: {message}\")\n  1079→    \n  1080→    def _init_history_incremental_loading(self):\n  1081→        \"\"\"初始化瀑布流增量加载功能\"\"\"\n  1082→        try:\n  1083→            if hasattr(self, 'video_history_view') and self._repository_manager:\n  1084→                # 绑定Repository管理器到瀑布流组件\n  1085→                self.video_history_view.set_repository_manager(self._repository_manager)\n  1086→                logger.info(\"VideoModeWidget: 瀑布流增量加载功能初始化完成\")\n  1087→            else:\n  1088→                logger.warning(\"VideoModeWidget: 瀑布流组件或Repository管理器未就绪，跳过增量加载初始化\")\n  1089→        except Exception as e:\n  1090→            logger.error(f\"VideoModeWidget: 初始化瀑布流增量加载功能失败: {e}\")\n  1091→    \n  1092→    def fix_file_path(self, file_path: str) -> str:\n  1093→        \"\"\"\n  1094→        新路径绝对主义的文件路径处理\n  1095→        只处理当前存储路径下的文件，忽略其他路径的文件\n  1096→        \n  1097→        Args:\n  1098→            file_path: 原始文件路径\n  1099→            \n  1100→        Returns:\n  1101→            有效的文件路径，如果文件不在当前路径或不存在则返回None\n  1102→        \"\"\"\n  1103→        if not file_path:\n  1104→            return None\n  1105→            \n  1106→        try:\n  1107→            from config_api import get_storage_dir\n  1108→            current_storage = get_storage_dir()\n  1109→            \n  1110→            # 只处理当前存储路径下的文件\n  1111→            if not file_path.startswith(current_storage):\n  1112→                logger.debug(f\"忽略非当前路径文件: {file_path}\")\n  1113→                return None\n  1114→            \n  1115→            # 验证文件是否存在\n  1116→            if not os.path.exists(file_path):\n  1117→                logger.debug(f\"文件不存在，忽略: {file_path}\")\n  1118→                return None\n  1119→                \n  1120→            return file_path\n  1121→            \n  1122→        except Exception as e:\n  1123→            logger.error(f\"文件路径处理失败: {e}\")\n  1124→            return None\n  1125→    \n  1126→    def showEvent(self, event):\n  1127→        \"\"\"页面显示事件 - 自动加载历史记录\"\"\"\n  1128→        super().showEvent(event)\n  1129→        # 延迟加载历史记录，确保页面完全初始化\n  1130→        QTimer.singleShot(100, self._auto_load_history)\n  1131→\n  1132→    def _auto_load_history(self):\n  1133→        \"\"\"自动加载历史记录\"\"\"\n  1134→        try:\n  1135→            # 检查是否已经有数据，避免重复加载\n  1136→            if self.use_virtual_video_view:\n  1137→                if hasattr(self, 'video_history_view') and getattr(self.video_history_view, 'model', None):\n  1138→                    # 只有视图完全为空时才加载\n  1139→                    if self.video_history_view.model.rowCount() == 0:\n  1140→                        logger.debug(\"视频页面显示时自动加载历史记录（虚拟化视图）\")\n  1141→                        self.video_history_view.bind_repository(self.get_repository_manager())\n  1142→                        self.video_history_view.load_initial()\n  1143→                    else:\n  1144→                        count = self.video_history_view.model.rowCount()\n  1145→                        # 刷新最新记录（包括pending）确保数据同步\n  1146→                        try:\n  1147→                            self.video_history_view.prepend_latest(page_size=20)\n  1148→                            logger.debug(f\"[Pending追踪] 视频页面已有{count}条数据，已刷新最新记录\")\n  1149→                        except Exception as refresh_err:\n  1150→                            logger.debug(f\"刷新最新记录失败: {refresh_err}\")\n  1151→            else:\n  1152→                if len(self.video_history_view.image_list) == 0:\n  1153→                    logger.debug(\"视频页面显示时自动加载历史记录（瀑布流）\")\n  1154→                    self.load_history_videos()\n  1155→        except Exception as e:\n  1156→            logger.error(f\"自动加载历史记录失败: {e}\")\n  1157→\n  1158→    def load_history_videos(self):\n  1159→        \"\"\"加载历史视频（懒加载模式）- 支持80+30增量加载\"\"\"\n  1160→        try:\n  1161→            # 优先使用80+30增量加载模式\n  1162→            if hasattr(self, 'video_history_view') and hasattr(self.video_history_view, 'load_initial_data'):\n  1163→                try:\n  1164→                    logger.info(\"VideoModeWidget: 使用80+30增量加载模式加载视频历史\")\n  1165→                    self.video_history_view.load_initial_data()\n  1166→                    return\n  1167→                except Exception as e:\n  1168→                    logger.warning(f\"VideoModeWidget: 80+30增量加载失败，回退到传统模式: {e}\")\n  1169→            \n  1170→            # 传统加载模式作为兜底\n  1171→            logger.info(\"VideoModeWidget: 使用传统模式加载视频历史\")\n  1172→            self._load_history_videos_traditional()\n  1173→        except Exception as e:\n  1174→            logger.error(f\"VideoModeWidget: 加载历史视频失败: {e}\")\n  1175→    \n  1176→    def _load_history_videos_traditional(self):\n  1177→        \"\"\"传统的历史视频加载方法（兜底方案）\"\"\"\n  1178→        try:\n  1179→            # 重置加载状态\n  1180→            self.current_start_index = 0\n  1181→            self.loaded_items = []\n  1182→            self.video_history_view.clear_images()\n  1183→            self._video_scroll_listener_bound = False\n  1184→\n  1185→            repo_manager = self.get_repository_manager()\n  1186→\n  1187→            if self.use_virtual_video_view:\n  1188→                try:\n  1189→                    # 交由虚拟化视图自行加载\n  1190→                    self.video_history_view.clear()\n  1191→                    self.video_history_view.bind_repository(self.get_repository_manager())\n  1192→                    self.video_history_view.load_initial()\n  1193→                    self.is_loading = False\n  1194→                    return\n  1195→                except Exception as e:\n  1196→                    logger.error(f\"虚拟化视频视图加载失败，回退瀑布流: {e}\")\n  1197→                    self.use_virtual_video_view = False\n  1198→\n  1199→            def _task():\n  1200→                result = repo_manager.get_records(\n  1201→                    page_size=self.batch_size,\n  1202→                    cursor=None,\n  1203→                    record_type='video'\n  1204→                )\n  1205→                if isinstance(result, dict):\n  1206→                    records = result.get('items', []) or []\n  1207→                    next_cursor = result.get('next_cursor')\n  1208→                else:\n  1209→                    records = result or []\n  1210→                    next_cursor = None\n  1211→                total_count = repo_manager.get_total_count('video')\n  1212→                return {\n  1213→                    \"records\": records,\n  1214→                    \"next_cursor\": next_cursor,\n  1215→                    \"total_count\": total_count,\n  1216→                }\n  1217→\n  1218→            def _on_done(payload):\n  1219→                self.video_history_initial_loaded.emit(payload)\n  1220→\n  1221→            def _on_error(exc: BaseException):\n  1222→                message = f\"加载历史视频失败: {exc}\"\n  1223→                logger.error(message)\n  1224→                self.video_history_load_failed.emit(message)\n  1225→\n  1226→            self.is_loading = True\n  1227→            task_runner.submit(\n  1228→                _task,\n  1229→                key=\"video-history:initial\",\n  1230→                on_done=_on_done,\n  1231→                on_error=_on_error,\n  1232→            )\n  1233→        except Exception as e:\n  1234→            self.is_loading = False\n  1235→            self.status_label.setText(f\"加载历史视频失败: {str(e)}\")\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"69f3c16d-f646-47f7-886a-9654280faf92","timestamp":"2025-12-30T09:56:37.933Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/components/modes/video_mode_widget.py","content":"    # P2: 重启恢复 / 刷新 pending 状态（进入页 + 30s）\n    # ------------------------------------------------------------------\n\n    def _ensure_pending_recovery_timer_running(self, *, immediate: bool = False) -> None:\n        \"\"\"确保 pending 恢复定时器已启动；若无进行中任务会在两轮后自动停止。\"\"\"\n        try:\n            if self._pending_recovery_timer is None:\n                self._pending_recovery_timer = QTimer(self)\n                self._pending_recovery_timer.setInterval(30_000)\n                self._pending_recovery_timer.timeout.connect(self._trigger_pending_recovery)\n\n            if not self._pending_recovery_timer.isActive():\n                self._pending_recovery_idle_rounds = 0\n                self._pending_recovery_timer.start()\n\n            if immediate:\n                QTimer.singleShot(0, self._trigger_pending_recovery)\n        except Exception as exc:\n            logger.debug(f\"启动 pending 恢复定时器失败: {exc}\")\n\n    def _trigger_pending_recovery(self) -> None:\n        if self._pending_recovery_inflight:\n            return\n\n        self._pending_recovery_inflight = True\n\n        def _task():\n            return self._run_pending_recovery_once()\n\n        def _on_done(payload):\n            try:\n                self.pending_recovery_completed.emit(payload)\n            except Exception:\n                pass\n\n        def _on_error(exc: BaseException):\n            try:\n                self.pending_recovery_failed.emit(str(exc))\n            except Exception:\n                pass\n\n        task_runner.submit(\n            _task,\n            key=\"video-recovery:pending\",\n            on_done=_on_done,\n            on_error=_on_error,\n        )\n\n    def _run_pending_recovery_once(self) -> Dict[str, Any]:\n        \"\"\"后台线程：查询远端状态并在必要时自动下载 succeeded 视频。\"\"\"\n        import os\n\n        from config.unified_config import get_unified_config\n        from config_api import get_storage_dir\n        from modules.repository.manager import RepositoryManager\n        from modules.seedance.manager import SeedanceManager\n        from services.video_service import VideoService\n\n        storage_dir = get_storage_dir()\n        repo = RepositoryManager(storage_dir)\n\n        active_statuses = [\"pending\", \"queued\", \"running\"]\n        records = repo.get_records_by_status(\"video\", active_statuses, limit=200) or []\n\n        # 单用户场景：按计划每轮最多处理 20 条，避免资源占用\n        max_per_cycle = 20\n        candidates = records[:max_per_cycle]\n\n        summary = {\n            \"fetched\": len(records),\n            \"processed\": 0,\n            \"updated\": 0,\n            \"downloaded\": 0,\n            \"stale\": 0,\n            \"remaining_active\": 0,\n        }\n\n        if not candidates:\n            return summary\n\n        api_key = get_unified_config().get_api_key(\"volcengine\")\n        manager = SeedanceManager(api_key)\n\n        def _extract_record_id(rec: Dict[str, Any]) -> Optional[str]:\n            return (\n                rec.get(\"file_id\")\n                or rec.get(\"generation_id\")\n                or rec.get(\"task_id\")\n                or rec.get(\"id\")\n            )\n\n        def _extract_api_task_id(params: Dict[str, Any]) -> Optional[str]:\n            sent = params.get(\"params_sent\") if isinstance(params, dict) else None\n            actual = params.get(\"params_actual\") if isinstance(params, dict) else None\n            if isinstance(sent, dict) and sent.get(\"api_task_id\"):\n                return str(sent.get(\"api_task_id\"))\n            if isinstance(actual, dict) and actual.get(\"api_task_id\"):\n                return str(actual.get(\"api_task_id\"))\n            if isinstance(params, dict) and params.get(\"api_task_id\"):\n                return str(params.get(\"api_task_id\"))\n            return None\n\n        for rec in candidates:\n            record_id = _extract_record_id(rec)\n            if not record_id:\n                continue\n\n            params = rec.get(\"parameters\") or {}\n            if not isinstance(params, dict):\n                params = {}\n\n            api_task_id = _extract_api_task_id(params)\n            if not api_task_id:\n                summary[\"stale\"] += 1\n                try:\n                    repo.update_record(\n                        str(record_id),\n                        {\n                            \"status\": \"failed\",\n                            \"metadata\": {\"error\": \"missing api_task_id; cannot recover after restart\"},\n                        },\n                    )\n                except Exception:\n                    pass\n                continue\n\n            summary[\"processed\"] += 1\n\n            try:\n                status_result = manager.client.query_video_task(api_task_id)\n            except Exception as exc:\n                logger.debug(f\"pending recovery: query failed api_task_id={api_task_id}: {exc}\")\n                continue\n\n            status = status_result.get(\"status\") or \"unknown\"\n            params_actual = VideoService._build_params_actual(status_result)\n            merged_params = VideoService._merge_params_bundle(existing=params, params_actual=params_actual)\n\n            local_path = rec.get(\"absolute_path\") or rec.get(\"file_path\") or \"\"\n            has_local = bool(local_path and os.path.exists(local_path))\n\n            if status == \"succeeded\":\n                if has_local:\n                    try:\n                        repo.update_record(str(record_id), {\"status\": status, \"parameters\": merged_params})\n                        summary[\"updated\"] += 1\n                    except Exception:\n                        pass\n                else:\n                    try:\n                        now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                        complete_payload = {\n                            \"success\": True,\n                            \"task_id\": str(record_id),\n                            \"api_task_id\": api_task_id,\n                            \"video_url\": status_result.get(\"video_url\"),\n                            \"thumbnail_url\": status_result.get(\"thumbnail_url\", \"\"),\n                            \"preview_url\": status_result.get(\"preview_url\", \"\"),\n                            \"status\": status,\n                            \"type\": \"video\",\n                            \"input_image\": \"\",\n                            \"parameters\": merged_params,\n                            \"created_at\": rec.get(\"created_at\") or now,\n                            \"completed_at\": now,\n                            \"reference_assets\": merged_params.get(\"reference_assets\") or [],\n                        }\n                        save_result = manager._save_video_locally(complete_payload)\n                        if isinstance(save_result, dict) and save_result.get(\"local_save_error\"):\n                            repo.update_record(\n                                str(record_id),\n                                {\n                                    \"status\": \"failed\",\n                                    \"metadata\": {\"error\": str(save_result.get(\"local_save_error\"))},\n                                    \"parameters\": merged_params,\n                                },\n                            )\n                        else:\n                            summary[\"downloaded\"] += 1\n                    except Exception as exc:\n                        logger.debug(f\"pending recovery: save failed record_id={record_id}: {exc}\")\n                        try:\n                            repo.update_record(\n                                str(record_id),\n                                {\n                                    \"status\": \"failed\",\n                                    \"metadata\": {\"error\": str(exc)},\n                                    \"parameters\": merged_params,\n                                },\n                            )\n                        except Exception:\n                            pass\n            elif status in {\"failed\", \"cancelled\", \"expired\"}:\n                try:\n                    repo.update_record(str(record_id), {\"status\": status, \"parameters\": merged_params})\n                    summary[\"updated\"] += 1\n                except Exception:\n                    pass\n            else:\n                # 仍在进行中：同步远端状态（pending/queued/running/processing 等）\n                try:\n                    repo.update_record(str(record_id), {\"status\": status, \"parameters\": merged_params})\n                    summary[\"updated\"] += 1\n                except Exception:\n                    pass\n                summary[\"remaining_active\"] += 1\n\n        # 若本轮未处理完全部记录，保守认为仍有进行中任务\n        if len(records) > len(candidates):\n            summary[\"remaining_active\"] += max(0, len(records) - len(candidates))\n\n        return summary\n\n    def _on_pending_recovery_completed(self, payload: Any) -> None:\n        self._pending_recovery_inflight = False\n\n        summary = payload if isinstance(payload, dict) else {}\n        remaining = int(summary.get(\"remaining_active\") or 0)\n        updated = int(summary.get(\"updated\") or 0)\n        downloaded = int(summary.get(\"downloaded\") or 0)\n        stale = int(summary.get(\"stale\") or 0)\n\n        if remaining <= 0:\n            self._pending_recovery_idle_rounds += 1\n        else:\n            self._pending_recovery_idle_rounds = 0\n\n        if self._pending_recovery_timer and self._pending_recovery_idle_rounds >= 2:\n            self._pending_recovery_timer.stop()\n\n        if updated or downloaded or stale:\n            try:\n                self._delayed_refresh_history()\n            except Exception:\n                pass\n\n        if downloaded:\n            self.status_label.setText(f\"✅ 已恢复并下载 {downloaded} 个未落盘视频\")\n        elif remaining > 0:\n            self.status_label.setText(f\"🔄 正在恢复任务状态…（{remaining} 个进行中）\")\n\n    def _on_pending_recovery_failed(self, message: str) -> None:\n        self._pending_recovery_inflight = False\n        logger.debug(f\"pending recovery failed: {message}\")\n    \n    def _init_history_incremental_loading(self):\n        \"\"\"初始化瀑布流增量加载功能\"\"\"\n        try:\n            if hasattr(self, 'video_history_view') and self._repository_manager:\n                # 绑定Repository管理器到瀑布流组件\n                self.video_history_view.set_repository_manager(self._repository_manager)\n                logger.info(\"VideoModeWidget: 瀑布流增量加载功能初始化完成\")\n            else:\n                logger.warning(\"VideoModeWidget: 瀑布流组件或Repository管理器未就绪，跳过增量加载初始化\")\n        except Exception as e:\n            logger.error(f\"VideoModeWidget: 初始化瀑布流增量加载功能失败: {e}\")\n    \n    def fix_file_path(self, file_path: str) -> str:\n        \"\"\"\n        新路径绝对主义的文件路径处理\n        只处理当前存储路径下的文件，忽略其他路径的文件\n        \n        Args:\n            file_path: 原始文件路径\n            \n        Returns:\n            有效的文件路径，如果文件不在当前路径或不存在则返回None\n        \"\"\"\n        if not file_path:\n            return None\n            \n        try:\n            from config_api import get_storage_dir\n            current_storage = get_storage_dir()\n            \n            # 只处理当前存储路径下的文件\n            if not file_path.startswith(current_storage):\n                logger.debug(f\"忽略非当前路径文件: {file_path}\")\n                return None\n            \n            # 验证文件是否存在\n            if not os.path.exists(file_path):\n                logger.debug(f\"文件不存在，忽略: {file_path}\")\n                return None\n                \n            return file_path\n            \n        except Exception as e:\n            logger.error(f\"文件路径处理失败: {e}\")\n            return None\n    \n    def showEvent(self, event):\n        \"\"\"页面显示事件 - 自动加载历史记录\"\"\"\n        super().showEvent(event)\n        # 延迟加载历史记录，确保页面完全初始化\n        QTimer.singleShot(100, self._auto_load_history)\n\n    def _auto_load_history(self):\n        \"\"\"自动加载历史记录\"\"\"\n        try:\n            # 检查是否已经有数据，避免重复加载\n            if self.use_virtual_video_view:\n                if hasattr(self, 'video_history_view') and getattr(self.video_history_view, 'model', None):\n                    # 只有视图完全为空时才加载\n                    if self.video_history_view.model.rowCount() == 0:\n                        logger.debug(\"视频页面显示时自动加载历史记录（虚拟化视图）\")\n                        self.video_history_view.bind_repository(self.get_repository_manager())\n                        self.video_history_view.load_initial()\n                    else:\n                        count = self.video_history_view.model.rowCount()\n                        # 刷新最新记录（包括pending）确保数据同步\n                        try:\n                            self.video_history_view.prepend_latest(page_size=20)\n                            logger.debug(f\"[Pending追踪] 视频页面已有{count}条数据，已刷新最新记录\")\n                        except Exception as refresh_err:\n                            logger.debug(f\"刷新最新记录失败: {refresh_err}\")\n            else:\n                if len(self.video_history_view.image_list) == 0:\n                    logger.debug(\"视频页面显示时自动加载历史记录（瀑布流）\")\n                    self.load_history_videos()\n        except Exception as e:\n            logger.error(f\"自动加载历史记录失败: {e}\")\n\n    def load_history_videos(self):\n        \"\"\"加载历史视频（懒加载模式）- 支持80+30增量加载\"\"\"\n        try:\n            # 优先使用80+30增量加载模式\n            if hasattr(self, 'video_history_view') and hasattr(self.video_history_view, 'load_initial_data'):\n                try:\n                    logger.info(\"VideoModeWidget: 使用80+30增量加载模式加载视频历史\")\n                    self.video_history_view.load_initial_data()\n                    return\n                except Exception as e:\n                    logger.warning(f\"VideoModeWidget: 80+30增量加载失败，回退到传统模式: {e}\")\n            \n            # 传统加载模式作为兜底\n            logger.info(\"VideoModeWidget: 使用传统模式加载视频历史\")\n            self._load_history_videos_traditional()\n        except Exception as e:\n            logger.error(f\"VideoModeWidget: 加载历史视频失败: {e}\")\n    \n    def _load_history_videos_traditional(self):\n        \"\"\"传统的历史视频加载方法（兜底方案）\"\"\"\n        try:\n            # 重置加载状态\n            self.current_start_index = 0\n            self.loaded_items = []\n            self.video_history_view.clear_images()\n            self._video_scroll_listener_bound = False\n\n            repo_manager = self.get_repository_manager()\n\n            if self.use_virtual_video_view:\n                try:\n                    # 交由虚拟化视图自行加载\n                    self.video_history_view.clear()\n                    self.video_history_view.bind_repository(self.get_repository_manager())\n                    self.video_history_view.load_initial()\n                    self.is_loading = False\n                    return\n                except Exception as e:\n                    logger.error(f\"虚拟化视频视图加载失败，回退瀑布流: {e}\")\n                    self.use_virtual_video_view = False\n\n            def _task():\n                result = repo_manager.get_records(\n                    page_size=self.batch_size,\n                    cursor=None,\n                    record_type='video'\n                )\n                if isinstance(result, dict):\n                    records = result.get('items', []) or []\n                    next_cursor = result.get('next_cursor')\n                else:\n                    records = result or []\n                    next_cursor = None\n                total_count = repo_manager.get_total_count('video')\n                return {\n                    \"records\": records,\n                    \"next_cursor\": next_cursor,\n                    \"total_count\": total_count,\n                }\n\n            def _on_done(payload):\n                self.video_history_initial_loaded.emit(payload)\n\n            def _on_error(exc: BaseException):\n                message = f\"加载历史视频失败: {exc}\"\n                logger.error(message)\n                self.video_history_load_failed.emit(message)\n\n            self.is_loading = True\n            task_runner.submit(\n                _task,\n                key=\"video-history:initial\",\n                on_done=_on_done,\n                on_error=_on_error,\n            )\n        except Exception as e:\n            self.is_loading = False\n            self.status_label.setText(f\"加载历史视频失败: {str(e)}\")","numLines":400,"startLine":836,"totalLines":2818}}}
{"parentUuid":"69f3c16d-f646-47f7-886a-9654280faf92","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LWsBB2yiWgJ1Wg3RMPQ4qg","type":"tool_result","content":"55:    video_history_load_failed = Signal(str)\n57:    pending_recovery_failed = Signal(str)\n67:        self._task_manager.task_failed.connect(self._on_task_failed)\n106:        self.video_history_load_failed.connect(self._on_video_history_load_failed)\n107:        self.pending_recovery_completed.connect(self._on_pending_recovery_completed)\n108:        self.pending_recovery_failed.connect(self._on_pending_recovery_failed)\n863:            return self._run_pending_recovery_once()\n873:                self.pending_recovery_failed.emit(str(exc))\n884:    def _run_pending_recovery_once(self) -> Dict[str, Any]:\n885:        \"\"\"后台线程：查询远端状态并在必要时自动下载 succeeded 视频。\"\"\"\n908:            \"downloaded\": 0,\n954:                            \"status\": \"failed\",\n967:                logger.debug(f\"pending recovery: query failed api_task_id={api_task_id}: {exc}\")\n977:            if status == \"succeeded\":\n1007:                                    \"status\": \"failed\",\n1013:                            summary[\"downloaded\"] += 1\n1015:                        logger.debug(f\"pending recovery: save failed record_id={record_id}: {exc}\")\n1020:                                    \"status\": \"failed\",\n1027:            elif status in {\"failed\", \"cancelled\", \"expired\"}:\n1048:    def _on_pending_recovery_completed(self, payload: Any) -> None:\n1054:        downloaded = int(summary.get(\"downloaded\") or 0)\n1065:        if updated or downloaded or stale:\n1071:        if downloaded:\n1072:            self.status_label.setText(f\"✅ 已恢复并下载 {downloaded} 个未落盘视频\")\n1076:    def _on_pending_recovery_failed(self, message: str) -> None:\n1078:        logger.debug(f\"pending recovery failed: {message}\")\n1224:                self.video_history_load_failed.emit(message)\n1304:                self.video_history_load_failed.emit(message)\n1457:    def _on_video_history_load_failed(self, message: str):\n1853:                self.video_history_view.update_placeholder_status(task_id, 'failed')\n1946:    def _on_task_failed(self, task_id: str, content_type: str, error: str):\n1953:                    self.video_history_view.update_placeholder_status(task_id, 'failed')\n1956:                placeholder.set_status('failed', error)\n1958:        self.on_generation_failed(message)\n2269:                            self.video_history_view.update_placeholder_status(task_id, 'failed')\n2272:                        placeholder.set_status('failed', '已取消')\n2489:            self.video_history_view.update_placeholder_status(task_id, 'failed')\n2492:            placeholder.set_status('failed', '已取消')\n2540:    def on_generation_failed(self, error_message):\n2548:                \"UI|video_generation_failed reference_count=%s ref_ids=%s\",\n\n[Showing results with pagination = limit: 100, offset: 0]"}]},"uuid":"909f76a9-ecc4-4c69-a84a-640589d817ef","timestamp":"2025-12-30T09:56:37.948Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"55:    video_history_load_failed = Signal(str)\n57:    pending_recovery_failed = Signal(str)\n67:        self._task_manager.task_failed.connect(self._on_task_failed)\n106:        self.video_history_load_failed.connect(self._on_video_history_load_failed)\n107:        self.pending_recovery_completed.connect(self._on_pending_recovery_completed)\n108:        self.pending_recovery_failed.connect(self._on_pending_recovery_failed)\n863:            return self._run_pending_recovery_once()\n873:                self.pending_recovery_failed.emit(str(exc))\n884:    def _run_pending_recovery_once(self) -> Dict[str, Any]:\n885:        \"\"\"后台线程：查询远端状态并在必要时自动下载 succeeded 视频。\"\"\"\n908:            \"downloaded\": 0,\n954:                            \"status\": \"failed\",\n967:                logger.debug(f\"pending recovery: query failed api_task_id={api_task_id}: {exc}\")\n977:            if status == \"succeeded\":\n1007:                                    \"status\": \"failed\",\n1013:                            summary[\"downloaded\"] += 1\n1015:                        logger.debug(f\"pending recovery: save failed record_id={record_id}: {exc}\")\n1020:                                    \"status\": \"failed\",\n1027:            elif status in {\"failed\", \"cancelled\", \"expired\"}:\n1048:    def _on_pending_recovery_completed(self, payload: Any) -> None:\n1054:        downloaded = int(summary.get(\"downloaded\") or 0)\n1065:        if updated or downloaded or stale:\n1071:        if downloaded:\n1072:            self.status_label.setText(f\"✅ 已恢复并下载 {downloaded} 个未落盘视频\")\n1076:    def _on_pending_recovery_failed(self, message: str) -> None:\n1078:        logger.debug(f\"pending recovery failed: {message}\")\n1224:                self.video_history_load_failed.emit(message)\n1304:                self.video_history_load_failed.emit(message)\n1457:    def _on_video_history_load_failed(self, message: str):\n1853:                self.video_history_view.update_placeholder_status(task_id, 'failed')\n1946:    def _on_task_failed(self, task_id: str, content_type: str, error: str):\n1953:                    self.video_history_view.update_placeholder_status(task_id, 'failed')\n1956:                placeholder.set_status('failed', error)\n1958:        self.on_generation_failed(message)\n2269:                            self.video_history_view.update_placeholder_status(task_id, 'failed')\n2272:                        placeholder.set_status('failed', '已取消')\n2489:            self.video_history_view.update_placeholder_status(task_id, 'failed')\n2492:            placeholder.set_status('failed', '已取消')\n2540:    def on_generation_failed(self, error_message):\n2548:                \"UI|video_generation_failed reference_count=%s ref_ids=%s\",","numLines":40,"appliedLimit":100}}
{"parentUuid":"909f76a9-ecc4-4c69-a84a-640589d817ef","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AEkvvaPPXvonqKKKXC4G5K","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我检查水印配置的实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7369,"cache_read_input_tokens":94315,"cache_creation":{"ephemeral_5m_input_tokens":7369,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"6cfe2719-6210-436f-93b9-e28d71556190","timestamp":"2025-12-30T09:56:53.270Z"}
{"parentUuid":"6cfe2719-6210-436f-93b9-e28d71556190","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AEkvvaPPXvonqKKKXC4G5K","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BuNTgdmrCdALvj3QXAX3er","name":"Read","input":{"file_path":"/Users/yunchang/Documents/GitHub/gemeng2/edition/watermark_service.py","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7369,"cache_read_input_tokens":94315,"cache_creation":{"ephemeral_5m_input_tokens":7369,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"d3b319fa-be2d-4e94-a0a2-0aded568627b","timestamp":"2025-12-30T09:56:53.858Z"}
{"parentUuid":"d3b319fa-be2d-4e94-a0a2-0aded568627b","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AEkvvaPPXvonqKKKXC4G5K","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012svGJ7AqVsYfw2k7QnJLbK","name":"Grep","input":{"pattern":"should_add_watermark|get_watermark_text|get_watermark_opacity","path":"/Users/yunchang/Documents/GitHub/gemeng2","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7369,"cache_read_input_tokens":94315,"cache_creation":{"ephemeral_5m_input_tokens":7369,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"3a25ee6b-b1be-4c2a-a100-62a25c95279d","timestamp":"2025-12-30T09:56:54.489Z"}
{"parentUuid":"3a25ee6b-b1be-4c2a-a100-62a25c95279d","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BuNTgdmrCdALvj3QXAX3er","type":"tool_result","content":"     1→\"\"\"Watermark utilities for GoDream trial edition.\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import logging\n     6→import os\n     7→import shlex\n     8→import shutil\n     9→import subprocess\n    10→import tempfile\n    11→from pathlib import Path\n    12→from typing import Optional\n    13→\n    14→from PIL import Image, ImageDraw, ImageFont\n    15→\n    16→from .resources import resolve_font_path, resolve_ffmpeg_binary, ensure_ascii_font_path\n    17→\n    18→try:  # pragma: no cover - 配置文件可能在部分环境缺失\n    19→    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\n    20→except Exception:  # pragma: no cover\n    21→    LOCAL_WATERMARK_CONFIG = {\n    22→        \"enabled\": False,\n    23→        \"text\": \"\",\n    24→        \"opacity\": 0.0,\n    25→        \"position\": \"bottom_right\",\n    26→        \"font_size\": 0,\n    27→    }\n    28→\n    29→LOGGER = logging.getLogger(\"WatermarkService\")\n    30→\n    31→\n    32→class WatermarkService:\n    33→    \"\"\"Applies fixed text watermarks to images and videos.\"\"\"\n    34→\n    35→    def __init__(self, text: str, opacity: float = 0.3):\n    36→        self.text = text\n    37→        self.opacity = max(0.0, min(opacity, 1.0))\n    38→        raw_font_path = resolve_font_path()\n    39→        self._font_path: Optional[Path] = None\n    40→        if raw_font_path:\n    41→            self._font_path = ensure_ascii_font_path(Path(raw_font_path))\n    42→        if self._font_path:\n    43→            LOGGER.debug(\"Watermark font resolved: %s\", self._font_path)\n    44→        else:\n    45→            LOGGER.warning(\"Watermark font not found, falling back to default glyphs\")\n    46→\n    47→    # Image watermark -----------------------------------------------------\n    48→    def apply_to_image(self, image_path: Path) -> bool:\n    49→        try:\n    50→            image_path = Path(image_path)\n    51→            if not image_path.exists():\n    52→                LOGGER.warning(\"Image path does not exist: %s\", image_path)\n    53→                return False\n    54→\n    55→            with Image.open(image_path).convert(\"RGBA\") as base_image:\n    56→                watermark_layer = self._build_image_watermark_layer(base_image)\n    57→                composed = Image.alpha_composite(base_image, watermark_layer)\n    58→                composed = composed.convert(\"RGB\")\n    59→                composed.save(image_path, quality=95)\n    60→\n    61→            return True\n    62→        except Exception as exc:  # pylint: disable=broad-except\n    63→            LOGGER.exception(\"Failed to apply image watermark: %s\", exc)\n    64→            return False\n    65→\n    66→    def _build_image_watermark_layer(self, base_image: Image.Image) -> Image.Image:\n    67→        width, height = base_image.size\n    68→        layer = Image.new(\"RGBA\", base_image.size, (0, 0, 0, 0))\n    69→        draw = ImageDraw.Draw(layer)\n    70→\n    71→        font_size = max(int(min(width, height) * 0.12), 48)\n    72→        font = self._load_font(font_size)\n    73→\n    74→        bbox = draw.textbbox((0, 0), self.text, font=font)\n    75→        text_width = bbox[2] - bbox[0]\n    76→        text_height = bbox[3] - bbox[1]\n    77→\n    78→        target_y = int(height * 0.25 - text_height / 2)\n    79→        target_y = max(target_y, 0)\n    80→        target_x = int(width / 2 - text_width / 2)\n    81→        target_x = max(target_x, 0)\n    82→\n    83→        draw.text(\n    84→            (target_x, target_y),\n    85→            self.text,\n    86→            fill=(255, 255, 255, int(255 * self.opacity)),\n    87→            font=font,\n    88→        )\n    89→\n    90→        return layer\n    91→\n    92→    # Video watermark -----------------------------------------------------\n    93→    def apply_to_video(self, video_path: Path) -> bool:\n    94→        video_path = Path(video_path)\n    95→        if not video_path.exists():\n    96→            LOGGER.warning(\"Video path does not exist: %s\", video_path)\n    97→            return False\n    98→\n    99→        ffmpeg_binary = resolve_ffmpeg_binary() or shutil.which(os.environ.get(\"FFMPEG_BINARY\", \"ffmpeg\"))\n   100→        # On Windows, ignore non-.exe files (e.g., macOS/Linux binaries accidentally packaged)\n   101→        try:\n   102→            if os.name == \"nt\" and ffmpeg_binary and str(ffmpeg_binary).lower().endswith(\"\\\\ffmpeg\"):\n   103→                ffmpeg_binary = shutil.which(\"ffmpeg\")\n   104→        except Exception:\n   105→            pass\n   106→        if not ffmpeg_binary:\n   107→            LOGGER.warning(\"ffmpeg binary not found, skipping video watermark\")\n   108→            return False\n   109→        else:\n   110→            LOGGER.debug(\"Using ffmpeg binary for watermark: %s\", ffmpeg_binary)\n   111→\n   112→        # 处理非 ASCII 源视频路径：拷贝到临时 ASCII 路径后再处理\n   113→        def _is_ascii(s: str) -> bool:\n   114→            try:\n   115→                s.encode(\"ascii\")\n   116→                return True\n   117→            except UnicodeEncodeError:\n   118→                return False\n   119→\n   120→        temp_output: Optional[Path] = None\n   121→        temp_input: Optional[Path] = None\n   122→        try:\n   123→            with tempfile.NamedTemporaryFile(suffix=video_path.suffix, delete=False) as tmp_file:\n   124→                temp_output = Path(tmp_file.name)\n   125→\n   126→            src_input = video_path\n   127→            if not _is_ascii(str(video_path)):\n   128→                try:\n   129→                    with tempfile.NamedTemporaryFile(suffix=video_path.suffix, delete=False) as tmp_in:\n   130→                        temp_input = Path(tmp_in.name)\n   131→                    shutil.copy2(video_path, temp_input)\n   132→                    src_input = temp_input\n   133→                    LOGGER.debug(\"Using ASCII temp input for watermark: %s\", src_input)\n   134→                except Exception as e:\n   135→                    LOGGER.warning(\"Failed to prepare ASCII temp input: %s\", e)\n   136→\n   137→            # 不指定字体文件，让 ffmpeg 使用系统默认字体\n   138→            # 原因：Windows 路径中的冒号在 ffmpeg 滤镜参数中转义复杂，容易失败\n   139→            LOGGER.debug(\"Using system default font for video watermark\")\n   140→            LOGGER.debug(\"ASCII input path: %s; using temp: %s\", _is_ascii(str(video_path)), bool(temp_input))\n   141→            option_pairs = {\n   142→                \"text\": self.text,\n   143→                \"x\": \"(w-text_w)/2\",\n   144→                \"y\": \"h/4\",\n   145→                \"fontsize\": \"min(w,h)/10\",\n   146→                \"fontcolor\": f\"white@{self.opacity}\",\n   147→            }\n   148→            drawtext_options = [f\"{key}={self._escape_text(value)}\" for key, value in option_pairs.items()]\n   149→            drawtext_filter = \"drawtext=\" + \":\".join(drawtext_options)\n   150→\n   151→            # 优先尝试 libx264 + yuv420p，失败则回退默认编码\n   152→            def _run_ffmpeg(args: list[str]) -> subprocess.CompletedProcess:\n   153→                LOGGER.info(\"Applying video watermark with ffmpeg: %s\", \" \".join(shlex.quote(c) for c in args))\n   154→                # Windows 上隐藏控制台窗口\n   155→                creationflags = subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0\n   156→                return subprocess.run(args, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=creationflags)\n   157→\n   158→            cmd_common = [\n   159→                str(ffmpeg_binary),\n   160→                \"-y\",\n   161→                \"-i\",\n   162→                str(src_input),\n   163→                \"-vf\",\n   164→                drawtext_filter,\n   165→                \"-codec:a\",\n   166→                \"copy\",\n   167→            ]\n   168→\n   169→            cmd_try1 = cmd_common + [\"-c:v\", \"libx264\", \"-pix_fmt\", \"yuv420p\", str(temp_output)]\n   170→            result = _run_ffmpeg(cmd_try1)\n   171→            if result.returncode != 0:\n   172→                stderr1 = result.stderr.decode(\"utf-8\", errors=\"ignore\")\n   173→                LOGGER.warning(\"ffmpeg watermark try1 failed (code %s): %s\", result.returncode, stderr1[:400])\n   174→                # 回退到默认编码（不指定 -c:v）\n   175→                cmd_try2 = cmd_common + [str(temp_output)]\n   176→                result = _run_ffmpeg(cmd_try2)\n   177→                if result.returncode != 0:\n   178→                    stderr2 = result.stderr.decode(\"utf-8\", errors=\"ignore\")\n   179→                    # 报告疑似缺少 drawtext 或字体问题\n   180→                    if \"No such filter: 'drawtext'\" in stderr2 or \"No such filter: 'drawtext'\" in stderr1:\n   181→                        LOGGER.error(\"ffmpeg build does not include drawtext filter; cannot apply watermark\")\n   182→                    else:\n   183→                        LOGGER.warning(\"ffmpeg watermark try2 failed (code %s): %s\", result.returncode, stderr2[:400])\n   184→                    temp_output.unlink(missing_ok=True)\n   185→                    return False\n   186→\n   187→            # 覆盖源文件\n   188→            temp_output.replace(video_path)\n   189→            return True\n   190→        except Exception as exc:  # pylint: disable=broad-except\n   191→            LOGGER.exception(\"Failed to apply video watermark: %s\", exc)\n   192→            return False\n   193→        finally:\n   194→            if temp_output and temp_output.exists():\n   195→                try:\n   196→                    temp_output.unlink(missing_ok=True)\n   197→                except Exception:\n   198→                    pass\n   199→            if temp_input and temp_input.exists():\n   200→                try:\n   201→                    temp_input.unlink(missing_ok=True)\n   202→                except Exception:\n   203→                    pass\n   204→\n   205→    # Helpers -------------------------------------------------------------\n   206→    def _load_font(self, font_size: int) -> ImageFont.FreeTypeFont:\n   207→        font_candidates = []\n   208→        if self._font_path:\n   209→            font_candidates.append(self._font_path)\n   210→        font_candidates.extend(filter(None, self._font_fallbacks()))\n   211→\n   212→        for font_path in font_candidates:\n   213→            try:\n   214→                return ImageFont.truetype(str(font_path), font_size)\n   215→            except OSError:\n   216→                continue\n   217→        return ImageFont.load_default()\n   218→\n   219→    @staticmethod\n   220→    def _escape_text(value: str) -> str:\n   221→        return (\n   222→            value.replace(\"\\\\\", \"\\\\\\\\\")\n   223→            .replace(\":\", \"\\\\:\")\n   224→            .replace(\",\", \"\\\\,\")\n   225→            .replace(\"'\", \"\\\\'\")\n   226→            .replace(\"@\", \"\\\\@\")\n   227→        )\n   228→\n   229→    @staticmethod\n   230→    def _resolve_font() -> Optional[str]:\n   231→        path = resolve_font_path()\n   232→        if not path:\n   233→            return None\n   234→        ascii_path = ensure_ascii_font_path(Path(path))\n   235→        return str(ascii_path)\n   236→\n   237→    @staticmethod\n   238→    def _font_fallbacks() -> list[Path]:\n   239→        fallback_paths = [\n   240→            Path(\"/System/Library/Fonts/PingFang.ttc\"),\n   241→            Path(\"/System/Library/Fonts/Supplemental/SourceHanSansCN-Regular.otf\"),\n   242→            Path(\"/Library/Fonts/PingFang.ttc\"),\n   243→            Path(\"/Library/Fonts/Arial Unicode.ttf\"),\n   244→            Path(\"C:/Windows/Fonts/msyh.ttc\"),\n   245→            Path(\"C:/Windows/Fonts/msyhbd.ttc\"),\n   246→            Path(\"C:/Windows/Fonts/simsun.ttc\"),\n   247→            Path(\"/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc\"),\n   248→            Path(\"/usr/share/fonts/opentype/noto/NotoSansSC-Regular.otf\"),\n   249→        ]\n   250→        return [p for p in fallback_paths if p.exists()]\n   251→\n   252→\n   253→def _watermark_settings() -> tuple[bool, str, float]:\n   254→    enabled = bool(LOCAL_WATERMARK_CONFIG.get(\"enabled\", False))\n   255→    text = str(LOCAL_WATERMARK_CONFIG.get(\"text\", \"\"))\n   256→    opacity = float(LOCAL_WATERMARK_CONFIG.get(\"opacity\", 0.0))\n   257→    opacity = max(0.0, min(opacity, 1.0))\n   258→    if enabled and not text:\n   259→        text = \"PIGEON\"\n   260→    return enabled, text, opacity\n   261→\n   262→\n   263→ENABLE_WATERMARK, WATERMARK_TEXT, WATERMARK_OPACITY = _watermark_settings()\n   264→\n   265→\n   266→def should_add_watermark() -> bool:\n   267→    \"\"\"\n   268→    判断是否应该添加水印\n   269→    \n   270→    Returns:\n   271→        bool: True表示需要添加水印，False表示不需要\n   272→    \"\"\"\n   273→    return ENABLE_WATERMARK\n   274→\n   275→\n   276→def get_watermark_text() -> str:\n   277→    \"\"\"\n   278→    获取水印文本\n   279→    \n   280→    Returns:\n   281→        str: 水印文本内容\n   282→    \"\"\"\n   283→    return WATERMARK_TEXT\n   284→\n   285→\n   286→def get_watermark_opacity() -> float:\n   287→    \"\"\"\n   288→    获取水印透明度\n   289→    \n   290→    Returns:\n   291→        float: 水印透明度 (0.0-1.0)\n   292→    \"\"\"\n   293→    return WATERMARK_OPACITY\n   294→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"571b54cd-5704-4b23-9648-350b9c5e72c9","timestamp":"2025-12-30T09:56:54.549Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/yunchang/Documents/GitHub/gemeng2/edition/watermark_service.py","content":"\"\"\"Watermark utilities for GoDream trial edition.\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport shlex\nimport shutil\nimport subprocess\nimport tempfile\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom PIL import Image, ImageDraw, ImageFont\n\nfrom .resources import resolve_font_path, resolve_ffmpeg_binary, ensure_ascii_font_path\n\ntry:  # pragma: no cover - 配置文件可能在部分环境缺失\n    from config_api import LOCAL_WATERMARK_CONFIG  # type: ignore\nexcept Exception:  # pragma: no cover\n    LOCAL_WATERMARK_CONFIG = {\n        \"enabled\": False,\n        \"text\": \"\",\n        \"opacity\": 0.0,\n        \"position\": \"bottom_right\",\n        \"font_size\": 0,\n    }\n\nLOGGER = logging.getLogger(\"WatermarkService\")\n\n\nclass WatermarkService:\n    \"\"\"Applies fixed text watermarks to images and videos.\"\"\"\n\n    def __init__(self, text: str, opacity: float = 0.3):\n        self.text = text\n        self.opacity = max(0.0, min(opacity, 1.0))\n        raw_font_path = resolve_font_path()\n        self._font_path: Optional[Path] = None\n        if raw_font_path:\n            self._font_path = ensure_ascii_font_path(Path(raw_font_path))\n        if self._font_path:\n            LOGGER.debug(\"Watermark font resolved: %s\", self._font_path)\n        else:\n            LOGGER.warning(\"Watermark font not found, falling back to default glyphs\")\n\n    # Image watermark -----------------------------------------------------\n    def apply_to_image(self, image_path: Path) -> bool:\n        try:\n            image_path = Path(image_path)\n            if not image_path.exists():\n                LOGGER.warning(\"Image path does not exist: %s\", image_path)\n                return False\n\n            with Image.open(image_path).convert(\"RGBA\") as base_image:\n                watermark_layer = self._build_image_watermark_layer(base_image)\n                composed = Image.alpha_composite(base_image, watermark_layer)\n                composed = composed.convert(\"RGB\")\n                composed.save(image_path, quality=95)\n\n            return True\n        except Exception as exc:  # pylint: disable=broad-except\n            LOGGER.exception(\"Failed to apply image watermark: %s\", exc)\n            return False\n\n    def _build_image_watermark_layer(self, base_image: Image.Image) -> Image.Image:\n        width, height = base_image.size\n        layer = Image.new(\"RGBA\", base_image.size, (0, 0, 0, 0))\n        draw = ImageDraw.Draw(layer)\n\n        font_size = max(int(min(width, height) * 0.12), 48)\n        font = self._load_font(font_size)\n\n        bbox = draw.textbbox((0, 0), self.text, font=font)\n        text_width = bbox[2] - bbox[0]\n        text_height = bbox[3] - bbox[1]\n\n        target_y = int(height * 0.25 - text_height / 2)\n        target_y = max(target_y, 0)\n        target_x = int(width / 2 - text_width / 2)\n        target_x = max(target_x, 0)\n\n        draw.text(\n            (target_x, target_y),\n            self.text,\n            fill=(255, 255, 255, int(255 * self.opacity)),\n            font=font,\n        )\n\n        return layer\n\n    # Video watermark -----------------------------------------------------\n    def apply_to_video(self, video_path: Path) -> bool:\n        video_path = Path(video_path)\n        if not video_path.exists():\n            LOGGER.warning(\"Video path does not exist: %s\", video_path)\n            return False\n\n        ffmpeg_binary = resolve_ffmpeg_binary() or shutil.which(os.environ.get(\"FFMPEG_BINARY\", \"ffmpeg\"))\n        # On Windows, ignore non-.exe files (e.g., macOS/Linux binaries accidentally packaged)\n        try:\n            if os.name == \"nt\" and ffmpeg_binary and str(ffmpeg_binary).lower().endswith(\"\\\\ffmpeg\"):\n                ffmpeg_binary = shutil.which(\"ffmpeg\")\n        except Exception:\n            pass\n        if not ffmpeg_binary:\n            LOGGER.warning(\"ffmpeg binary not found, skipping video watermark\")\n            return False\n        else:\n            LOGGER.debug(\"Using ffmpeg binary for watermark: %s\", ffmpeg_binary)\n\n        # 处理非 ASCII 源视频路径：拷贝到临时 ASCII 路径后再处理\n        def _is_ascii(s: str) -> bool:\n            try:\n                s.encode(\"ascii\")\n                return True\n            except UnicodeEncodeError:\n                return False\n\n        temp_output: Optional[Path] = None\n        temp_input: Optional[Path] = None\n        try:\n            with tempfile.NamedTemporaryFile(suffix=video_path.suffix, delete=False) as tmp_file:\n                temp_output = Path(tmp_file.name)\n\n            src_input = video_path\n            if not _is_ascii(str(video_path)):\n                try:\n                    with tempfile.NamedTemporaryFile(suffix=video_path.suffix, delete=False) as tmp_in:\n                        temp_input = Path(tmp_in.name)\n                    shutil.copy2(video_path, temp_input)\n                    src_input = temp_input\n                    LOGGER.debug(\"Using ASCII temp input for watermark: %s\", src_input)\n                except Exception as e:\n                    LOGGER.warning(\"Failed to prepare ASCII temp input: %s\", e)\n\n            # 不指定字体文件，让 ffmpeg 使用系统默认字体\n            # 原因：Windows 路径中的冒号在 ffmpeg 滤镜参数中转义复杂，容易失败\n            LOGGER.debug(\"Using system default font for video watermark\")\n            LOGGER.debug(\"ASCII input path: %s; using temp: %s\", _is_ascii(str(video_path)), bool(temp_input))\n            option_pairs = {\n                \"text\": self.text,\n                \"x\": \"(w-text_w)/2\",\n                \"y\": \"h/4\",\n                \"fontsize\": \"min(w,h)/10\",\n                \"fontcolor\": f\"white@{self.opacity}\",\n            }\n            drawtext_options = [f\"{key}={self._escape_text(value)}\" for key, value in option_pairs.items()]\n            drawtext_filter = \"drawtext=\" + \":\".join(drawtext_options)\n\n            # 优先尝试 libx264 + yuv420p，失败则回退默认编码\n            def _run_ffmpeg(args: list[str]) -> subprocess.CompletedProcess:\n                LOGGER.info(\"Applying video watermark with ffmpeg: %s\", \" \".join(shlex.quote(c) for c in args))\n                # Windows 上隐藏控制台窗口\n                creationflags = subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0\n                return subprocess.run(args, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=creationflags)\n\n            cmd_common = [\n                str(ffmpeg_binary),\n                \"-y\",\n                \"-i\",\n                str(src_input),\n                \"-vf\",\n                drawtext_filter,\n                \"-codec:a\",\n                \"copy\",\n            ]\n\n            cmd_try1 = cmd_common + [\"-c:v\", \"libx264\", \"-pix_fmt\", \"yuv420p\", str(temp_output)]\n            result = _run_ffmpeg(cmd_try1)\n            if result.returncode != 0:\n                stderr1 = result.stderr.decode(\"utf-8\", errors=\"ignore\")\n                LOGGER.warning(\"ffmpeg watermark try1 failed (code %s): %s\", result.returncode, stderr1[:400])\n                # 回退到默认编码（不指定 -c:v）\n                cmd_try2 = cmd_common + [str(temp_output)]\n                result = _run_ffmpeg(cmd_try2)\n                if result.returncode != 0:\n                    stderr2 = result.stderr.decode(\"utf-8\", errors=\"ignore\")\n                    # 报告疑似缺少 drawtext 或字体问题\n                    if \"No such filter: 'drawtext'\" in stderr2 or \"No such filter: 'drawtext'\" in stderr1:\n                        LOGGER.error(\"ffmpeg build does not include drawtext filter; cannot apply watermark\")\n                    else:\n                        LOGGER.warning(\"ffmpeg watermark try2 failed (code %s): %s\", result.returncode, stderr2[:400])\n                    temp_output.unlink(missing_ok=True)\n                    return False\n\n            # 覆盖源文件\n            temp_output.replace(video_path)\n            return True\n        except Exception as exc:  # pylint: disable=broad-except\n            LOGGER.exception(\"Failed to apply video watermark: %s\", exc)\n            return False\n        finally:\n            if temp_output and temp_output.exists():\n                try:\n                    temp_output.unlink(missing_ok=True)\n                except Exception:\n                    pass\n            if temp_input and temp_input.exists():\n                try:\n                    temp_input.unlink(missing_ok=True)\n                except Exception:\n                    pass\n\n    # Helpers -------------------------------------------------------------\n    def _load_font(self, font_size: int) -> ImageFont.FreeTypeFont:\n        font_candidates = []\n        if self._font_path:\n            font_candidates.append(self._font_path)\n        font_candidates.extend(filter(None, self._font_fallbacks()))\n\n        for font_path in font_candidates:\n            try:\n                return ImageFont.truetype(str(font_path), font_size)\n            except OSError:\n                continue\n        return ImageFont.load_default()\n\n    @staticmethod\n    def _escape_text(value: str) -> str:\n        return (\n            value.replace(\"\\\\\", \"\\\\\\\\\")\n            .replace(\":\", \"\\\\:\")\n            .replace(\",\", \"\\\\,\")\n            .replace(\"'\", \"\\\\'\")\n            .replace(\"@\", \"\\\\@\")\n        )\n\n    @staticmethod\n    def _resolve_font() -> Optional[str]:\n        path = resolve_font_path()\n        if not path:\n            return None\n        ascii_path = ensure_ascii_font_path(Path(path))\n        return str(ascii_path)\n\n    @staticmethod\n    def _font_fallbacks() -> list[Path]:\n        fallback_paths = [\n            Path(\"/System/Library/Fonts/PingFang.ttc\"),\n            Path(\"/System/Library/Fonts/Supplemental/SourceHanSansCN-Regular.otf\"),\n            Path(\"/Library/Fonts/PingFang.ttc\"),\n            Path(\"/Library/Fonts/Arial Unicode.ttf\"),\n            Path(\"C:/Windows/Fonts/msyh.ttc\"),\n            Path(\"C:/Windows/Fonts/msyhbd.ttc\"),\n            Path(\"C:/Windows/Fonts/simsun.ttc\"),\n            Path(\"/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc\"),\n            Path(\"/usr/share/fonts/opentype/noto/NotoSansSC-Regular.otf\"),\n        ]\n        return [p for p in fallback_paths if p.exists()]\n\n\ndef _watermark_settings() -> tuple[bool, str, float]:\n    enabled = bool(LOCAL_WATERMARK_CONFIG.get(\"enabled\", False))\n    text = str(LOCAL_WATERMARK_CONFIG.get(\"text\", \"\"))\n    opacity = float(LOCAL_WATERMARK_CONFIG.get(\"opacity\", 0.0))\n    opacity = max(0.0, min(opacity, 1.0))\n    if enabled and not text:\n        text = \"PIGEON\"\n    return enabled, text, opacity\n\n\nENABLE_WATERMARK, WATERMARK_TEXT, WATERMARK_OPACITY = _watermark_settings()\n\n\ndef should_add_watermark() -> bool:\n    \"\"\"\n    判断是否应该添加水印\n    \n    Returns:\n        bool: True表示需要添加水印，False表示不需要\n    \"\"\"\n    return ENABLE_WATERMARK\n\n\ndef get_watermark_text() -> str:\n    \"\"\"\n    获取水印文本\n    \n    Returns:\n        str: 水印文本内容\n    \"\"\"\n    return WATERMARK_TEXT\n\n\ndef get_watermark_opacity() -> float:\n    \"\"\"\n    获取水印透明度\n    \n    Returns:\n        float: 水印透明度 (0.0-1.0)\n    \"\"\"\n    return WATERMARK_OPACITY\n","numLines":294,"startLine":1,"totalLines":294}}}
{"parentUuid":"571b54cd-5704-4b23-9648-350b9c5e72c9","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012svGJ7AqVsYfw2k7QnJLbK","type":"tool_result","content":"Found 4 files\ndocs/design/问题排查与修复方案_20251113.md\nmodules/seedance/manager.py\nedition/watermark_service.py\nmodules/seedream/manager.py"}]},"uuid":"afc98be3-1625-4e0a-8761-16a2e2244ed5","timestamp":"2025-12-30T09:56:54.565Z","toolUseResult":{"mode":"files_with_matches","filenames":["docs/design/问题排查与修复方案_20251113.md","modules/seedance/manager.py","edition/watermark_service.py","modules/seedream/manager.py"],"numFiles":4}}
{"parentUuid":"afc98be3-1625-4e0a-8761-16a2e2244ed5","isSidechain":true,"userType":"external","cwd":"/Users/yunchang/Documents/GitHub/gemeng2","sessionId":"a197f85a-bb99-4cc4-a3b5-444c273d9e8d","version":"2.0.76","gitBranch":"main","agentId":"a96c3af","slug":"agile-watching-llama","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Mt12pSpReZPJiRckzNqkUM","type":"message","role":"assistant","content":[{"type":"text","text":"完美！现在我有了足够的信息。让我生成完整的调研报告：\n\n## 完整调研报告：视频水印 + 下载稳定性问题\n\n### 问题1：视频水印（\"AI 生成\" vs \"pigeon\"）\n\n#### 1.1 水印添加逻辑位置\n\n**本地水印加载流程：**\n- **入口**：`modules/seedance/manager.py` 第 779-797 行（`_save_video_locally` 方法）\n- **配置来源**：`edition/watermark_service.py` 第 253-264 行\n- **调用链**：\n  ```\n  _save_video_locally()\n    └─ should_add_watermark()  [edition/watermark_service.py:266]\n       └─ 读取 LOCAL_WATERMARK_CONFIG (config_api.py 或 edition/watermark_config.py)\n    └─ WatermarkService(watermark_text, opacity).apply_to_video(local_path)\n       └─ ffmpeg drawtext 滤镜处理\n  ```\n\n#### 1.2 当前水印配置状态（关键发现！）\n\n**在 `edition/watermark_service.py` 第 21-27 行：**\n```python\nLOCAL_WATERMARK_CONFIG = {\n    \"enabled\": False,  # ⚠️ 禁用状态\n    \"text\": \"\",\n    \"opacity\": 0.0,\n    \"position\": \"bottom_right\",\n    \"font_size\": 0,\n}\n```\n\n**重要**：本地水印在正式版中默认**禁用**（`enabled: False`）。\n\n**水印文本逻辑** - `edition/watermark_service.py` 第 258-259 行：\n```python\nif enabled and not text:\n    text = \"PIGEON\"  # 若启用但无文本，自动用 PIGEON\n```\n\n所以用户看到 \"AI 生成\" 很可能是：**服务端水印问题**，而非本地水印问题。\n\n---\n\n#### 1.3 服务端水印禁用确认\n\n在 `modules/seedance/client.py` 第 682-691 行，创建视频任务时：\n```python\n# Force server-side watermark off for Plan B (local watermark only)\nflags_text, fallback_applied, fallback_reason, used_rs, used_rt = _validate_and_build_flags(\n    ...\n    watermark=False,  # ✅ 硬编码关闭服务端水印\n    ...\n)\n```\n\n**核心代码** - 第 688 行：\n```python\nwatermark=False,  # 服务端水印强制关闭（仅本地水印）\n```\n\n即使用户传入 `watermark=True`，实际发送给服务端的也是 `False`。\n\n**但** - `modules/seedance/manager.py` 第 218 行有个参数传递：\n```python\nwatermark=watermark_enabled,  # 来自配置\n```\n\n而 `watermark_enabled` 的定义在第 207-209 行：\n```python\nwatermark_enabled = bool(\n    LOCAL_WATERMARK_CONFIG.get(\"enabled\", API_WATERMARK_CONFIG.get(\"video_watermark\", False))\n)\n```\n\n**问题根源**：\n1. 本地水印配置 `enabled: False` → `watermark_enabled = False`\n2. 即使启用本地水印，也**只在下载完成后本地处理**，不会改变服务端行为\n3. 若用户看到 \"AI 生成\" 水印在视频上，说明**服务端返回了带水印的视频**\n\n---\n\n#### 1.4 用户看到\"AI 生成\"的可能原因\n\n1. **最可能**：服务端（火山引擎 Seedance API）默认添加了 \"AI 生成\" 水印\n   - 应检查 API 文档或服务端配置是否有\"是否添加水印\"的参数\n   - 当前代码 `watermark=False` 可能无效或被服务端忽略\n\n2. **其次**：本地水印配置被意外启用但 `text=\"\"` 时，系统会使用 \"PIGEON\" 而非 \"AI 生成\"\n   - 除非有其他地方改写了文本\n\n3. **检查方向**：\n   - 查看下载的原始视频文件（未经本地处理）是否已带水印\n   - 若已带，则是服务端问题；若无，则是本地处理流程问题\n\n---\n\n### 问题2：视频下载不稳定（加载中状态卡死）\n\n#### 2.1 下载完整链路\n\n**链路图：**\n```\npending → query_video_task(api_task_id)\n    ↓ (status == \"succeeded\")\n    ↓\nsucceeded 状态\n    ↓\n_save_video_locally()\n    ├─ safe_requests_get(video_url)  [获取视频数据]\n    ├─ 写入临时文件 [获取视频元数据]\n    ├─ 通过 UnifiedStorageManager.save_content_file() 保存\n    └─ WatermarkService.apply_to_video()  [本地水印]\n        ↓\nsucceeded + local_path 状态\n```\n\n**关键下载代码** - `modules/seedance/manager.py` 第 625-642 行：\n```python\nresponse = safe_requests_get(video_url, stream=True, timeout=300)\n# 检查 content-type\ncontent_type = response.headers.get('content-type', '')\nif 'video' not in content_type:\n    logger.warning(f\"Unexpected content type: {content_type}\")\n# 获取文件大小（用于进度）\ntotal_size = int(response.headers.get('content-length', 0))\nvideo_data = response.content\n```\n\n**超时配置**：`timeout=300` （5分钟）\n\n---\n\n#### 2.2 Pending 恢复机制（30秒刷新）\n\n**实现位置**：`components/modes/video_mode_widget.py` 第 836-1079 行\n\n**关键参数**：\n- 第 844 行：`self._pending_recovery_timer.setInterval(30_000)` - **30秒刷新一次**\n- 第 851-852 行：进入页面立即触发一次恢复（`immediate=True`）\n\n**恢复流程** - `_run_pending_recovery_once()` 第 884-1046 行：\n1. 查询所有 `pending/queued/running` 状态的记录（最多 200 条）\n2. 每轮最多处理 20 条（第 901 行）\n3. 对每条记录：\n   - 提取 `api_task_id`（从 `params_sent` 或 `params_actual`）\n   - **调用** `manager.client.query_video_task(api_task_id)`（第 965 行）\n   - 若状态 = `succeeded` 且无本地文件：\n     - **自动调用** `manager._save_video_locally()` 下载（第 1002 行）\n   - 更新本地状态与参数\n\n**自动停止条件** - 第 1057-1063 行：\n```python\nif remaining <= 0:\n    self._pending_recovery_idle_rounds += 1\nelse:\n    self._pending_recovery_idle_rounds = 0\n\nif self._pending_recovery_timer and self._pending_recovery_idle_rounds >= 2:\n    self._pending_recovery_timer.stop()  # 两轮无任务后停止\n```\n\n---\n\n#### 2.3 下载失败的可能原因及重试逻辑\n\n**下载调用链**：\n```\n_save_video_locally()\n    └─ safe_requests_get(video_url, stream=True, timeout=300)\n        └─ (来自 utils/safe_requests.py，可能有重试逻辑)\n```\n\n**问题检查点**：\n\n1. **API 任务状态查询失败**（第 967 行）：\n   ```python\n   try:\n       status_result = manager.client.query_video_task(api_task_id)\n   except Exception as exc:\n       logger.debug(f\"pending recovery: query failed api_task_id={api_task_id}: {exc}\")\n       continue  # ⚠️ 仅记录，跳过该条记录，不重试\n   ```\n   - **问题**：如果查询 API 失败，该条记录被跳过，不会重新触发下载\n   - **恢复**：30秒后下一轮重试（如果定时器仍运行）\n\n2. **缺少 api_task_id**（第 948-960 行）：\n   ```python\n   if not api_task_id:\n       summary[\"stale\"] += 1\n       repo.update_record(str(record_id), {\"status\": \"failed\", ...})  # 标记为失败\n       continue\n   ```\n   - **问题**：若 `params_sent` 和 `params_actual` 都缺 `api_task_id`，会被标记为 `failed` 而非重试\n   - **原因**：可能创建任务时没有正确保存 `api_task_id`\n\n3. **下载时网络中断**（第 625-642 行）：\n   - `safe_requests_get()` 有 `timeout=300` 但没有内置重试\n   - **问题**：下载失败直接抛异常，恢复流程捕获并记录为 `failed` 状态（第 1004-1026 行）\n\n4. **视频 URL 过期**：\n   - 若服务端返回的视频 URL 有时效性限制，长时间 pending 后 URL 失效\n   - **当前代码无处理**：会下载失败，标记为 `failed`\n\n---\n\n#### 2.4 \"加载中\"状态卡死的具体场景\n\n根据代码分析，用户遇到\"加载中\"卡死的原因可能是：\n\n**场景 1：params_sent 未正确保存**\n- 任务创建成功但 `api_task_id` 未写入数据库\n- 30秒恢复机制无法查询该任务（因为没有 `api_task_id`）\n- 任务被标记为 `failed` 但 UI 可能仍显示为 pending\n\n**场景 2：query_video_task 间歇性失败**\n- API 连接不稳定，查询状态失败\n- 该记录被跳过，等待 30 秒后重试\n- 如果多轮失败，用户长时间看到\"加载中\"\n\n**场景 3：下载失败后状态未更新**\n- `_save_video_locally()` 异常，参数更新失败（第 1014-1026 行）\n- 记录状态可能仍为 `pending` 或 `succeeded`（未落盘标记）\n\n---\n\n### 问题3：重点文件及修复建议\n\n| 问题 | 关键代码位置 | 当前状态 | 建议检查 |\n|------|-----------|--------|--------|\n| **水印显示 \"AI 生成\"** | `edition/watermark_service.py:253-264` | 本地水印禁用（enabled=False） | 检查服务端水印配置或火山引擎 API 文档 |\n| **下载链接获取** | `modules/seedance/manager.py:625-642` | 有 300s 超时但无重试 | 增加重试逻辑或异步重试机制 |\n| **Pending 恢复机制** | `components/modes/video_mode_widget.py:884-1046` | 30s 刷新，20条/轮，2轮无任务自动停止 | 日志追踪 api_task_id 的保存和恢复 |\n| **api_task_id 保存** | `services/video_service.py:291-333` | 创建后立即写入数据库 | 验证更新是否成功 |\n| **下载失败处理** | `modules/seedance/manager.py:1003-1026` | 失败标记为 failed 但不重试 | 考虑增加失败重试队列 |\n\n---\n\n### 总结与建议\n\n**问题1 根因**：\n- 服务端（火山引擎）可能默认或强制添加 \"AI 生成\" 水印\n- 本地水印配置默认禁用\n- 建议：检查火山引擎 API 是否有参数禁用服务端水印，或确认这是正常行为\n\n**问题2 根因**：\n- 下载链路中 `api_task_id` 的持久化可能有缺陷（创建成功后的写入可能失败）\n- 30秒恢复机制存在但边界条件有漏洞（api_task_id 缺失时直接标记为 failed）\n- 下载失败后无自动重试机制\n\n**建议行动**：\n1. **日志分析**：检查该卡死视频任务的日志，找 `api_task_id` 是否存在\n2. **参数追踪**：在 `services/video_service.py:312-331` 处添加日志，确认 `api_task_id` 写入成功\n3. **重试机制**：为 `_save_video_locally()` 的下载失败添加重试逻辑\n4. **水印确认**：生成一个视频，检查未经本地处理的原始视频是否已带 \"AI 生成\" 水印"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5007,"cache_read_input_tokens":101684,"cache_creation":{"ephemeral_5m_input_tokens":5007,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"type":"assistant","uuid":"1409b71a-e5e5-4907-b60f-400727e550f1","timestamp":"2025-12-30T09:57:40.730Z"}
