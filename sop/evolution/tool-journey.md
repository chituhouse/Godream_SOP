# AI 编程工具演进历程

> 基于 Godream 项目真实对话记录分析
> 时间跨度：2025-09 至 2026-01

## 目录

1. [工具演进时间线](#1-工具演进时间线)
2. [各工具优缺点分析](#2-各工具优缺点分析)
3. [切换决策深度分析](#3-切换决策深度分析)
4. [工具选择框架](#4-工具选择框架)
5. [模型能力感知](#5-模型能力感知)
6. [核心经验总结](#6-核心经验总结)

---

## 1. 工具演进时间线

### 1.1 整体演进图谱

```
2025-09-14                                2025-12-17                 2026-01
    |                                          |                        |
    v                                          v                        v
[Codex 单工具]-->[Codex+Serena]-->[Serena 主导]-->[Claude Code]-->[Claude+Agent]
    |               |                  |              |                |
    v               v                  v              v                v
 项目启动        代码分析增强      复杂性管理      Git操作+调试    系统性审计
```

### 1.2 月度工具使用统计

| 月份 | Codex 会话 | Serena 日志 | Claude 会话 | 主导工具 |
|------|------------|-------------|-------------|----------|
| 2025-09 | 55 | 66 | 0 | Serena |
| 2025-10 | 8 | 121 | 0 | Serena |
| 2025-11 | 0 | 181 | 23 | Serena+Claude |
| 2025-12-a | 0 | 49 | 99 | Claude |
| 2025-12-b | 0 | 0 | 219 | Claude |

### 1.3 关键切换节点

| 日期 | 切换事件 | 触发因素 | 结果 |
|------|----------|----------|------|
| 2025-09-22 | Codex -> Codex+Serena | 需要更强的代码分析能力 | 符号搜索和代码理解能力增强 |
| 2025-10-07 | Codex 重 -> Serena 主 | Serena 作为记忆和分析 MCP 工具 | 复杂性管理更有效 |
| 2025-11-25 | Serena/Codex -> Claude Code | 复杂打包任务需要更好的 Git 操作 | 打包问题解决，工作流更流畅 |
| 2025-12-17 | Claude -> Claude+Agent | 复杂任务需要多工具协作 | 代码审计效率提升 |

---

## 2. 各工具优缺点分析

### 2.1 Codex CLI

**使用时期**：2025-09-14 ~ 2025-10-14（主力期），后续作为辅助

**优点**：
- 强大的代码生成能力
- 支持 gpt-5-codex 模型，推理能力强
- 沙箱执行模式，安全性好
- 支持 shell 命令执行

**缺点**：
- **上下文管理困难**：长对话容易溢出（实际案例：9月18日单对话93条消息导致崩溃）
- **无 Git 集成**：所有 Git 操作需用户手动执行
- **记忆能力弱**：跨会话无法保持状态
- **调试能力有限**：遇到复杂错误难以排查

**真实对话片段**：
```
# 2025-09-18 上下文溢出事件
用户：给我写详细一点,完成的怎么样,没完成的,哪些做的比较差,列清楚,
     还有我的要求,你恢复的规划,都列出来,让主窗口充分认识到你的问题和局限,
     以便全盘考虑问题,规划下一步行动。
```

**适用场景**：
- 明确的单次编程任务
- 代码生成和重构
- 需要沙箱隔离的操作

### 2.2 Serena MCP

**使用时期**：2025-09-22 ~ 2025-12-09（活跃期）

**优点**：
- **符号级代码分析**：`find_symbol`、`get_symbols_overview`、`find_referencing_symbols`
- **跨会话记忆**：`write_memory`、`read_memory` 保持项目状态
- **Token 高效**：避免读取整个文件，按符号精确读取
- **项目结构理解**：快速了解代码架构

**缺点**：
- **只是工具**：不能自主决策，需要与其他工具配合
- **不擅长复杂打包/部署**：无法处理 Git 操作和系统级任务
- **配置复杂**：需要 MCP 服务器配置

**设计约定**（来自 `codex_serena_playbook.md`）：
```markdown
角色：我审批；你（Codex）推理/规划与执行；Serena 仅是工具箱（定位/检索/记忆/补丁），不自主决策。

路线选择：
- Fix TODO：入口明确、单文件、<=50 行、无需跨文件检索/重构
- Serena：入口不清/影响多文件/需调用链或重构；或单步 >50 行/总改动需分步
```

**真实对话片段**：
```
# 2025-09-25 上下文管理最高指令
与Serena MCP同步上下文记忆
- 任何时候都要确保跟serena mcp保持同步上下文记忆
- 及时使用write_memory更新项目状态和进展
- 避免上下文断裂导致信息丢失
- 严格控制上下文长度，防止塞爆大模型token
```

**适用场景**：
- 代码分析和理解
- 跨会话状态保持
- 大型代码库导航
- 符号级精确搜索

### 2.3 Claude Code

**使用时期**：2025-11-25 起成为主力

**优点**：
- **原生 Git 集成**：commit、diff、status 等操作无缝集成
- **更好的上下文管理**：自动压缩和摘要
- **交互式调试**：可以实时查看和分析错误
- **多工具协作**：可以调用 MCP 工具（包括 Serena）
- **Skill 系统**：可扩展的自定义技能
- **模型切换**：支持 Opus、Sonnet 等多模型

**缺点**：
- **学习曲线**：新工具需要适应期（实际案例：12-a期间 vague/precise 比例短暂回升）
- **需要配置**：CLAUDE.md 等配置文件需要设计

**真实对话片段**：
```
# 2025-12 用户学习 Claude Code
用户：我需要把我的所有 plan mode 模式下的模型使用，默认为 opus4.5模型。
     其他模型默认 sonnet4.5，什么时候用 1M 上下文这个时机我倒是不太清楚，
     你给些建议。

用户：slash 是不是要主动触发才可以，skills 是 claude code 系统设定的机制，
     设定好以后，会自动触发对吗？
```

**适用场景**：
- 复杂的多步骤任务
- 需要 Git 操作的场景
- 打包和部署
- 调试和问题排查
- 代码审计和重构

---

## 3. 切换决策深度分析

### 3.1 从 Codex 到 Codex+Serena（2025-09-22）

**触发因素**：
- Codex 在代码分析方面能力有限
- 需要理解复杂的调用链
- 大型文件难以全部读入上下文

**解决的问题**：
- 符号级精确搜索代替全文件读取
- 跨会话记忆保持项目状态
- Token 效率提升

**决策模式**：
```
IF 入口明确 AND 单文件 AND <=50行:
    USE Codex 直接修复
ELSE:
    USE Serena 定位 -> Codex 执行
```

### 3.2 从 Codex 重到 Serena 主（2025-10-07）

**触发因素**：
- 项目复杂度增加（技术选型阶段）
- 需要管理多个阶段的规划和进度
- 上下文溢出问题仍然存在

**解决的问题**：
- 通过 Serena 记忆管理复杂性
- 文档驱动的开发模式
- 主规划窗口+执行窗口分离

**工作流变化**：
```
新会话启动 -> 读取 Serena 记忆 -> 恢复上下文 -> 执行任务 -> 写入记忆 -> 结束
```

### 3.3 从 Serena/Codex 到 Claude Code（2025-11-25）

**触发因素**：
- 打包任务需要大量 Git 操作（py2app -> PyInstaller 切换）
- Codex 没有 Git 工具
- 调试复杂的编码问题（credentials.json latin-1 污染）

**关键对话证据**：
```
# 2025-11-26 credentials.json 污染事件
问题：latin-1 编码错误导致应用无法启动
解决：第一性原理分析找到根因
影响：方法论验证，Claude Code 调试能力得到认可
```

**Claude Code 的决定性优势**：
1. **Git 原生支持**：不需要切换窗口执行 Git 命令
2. **更好的错误追踪**：可以直接查看堆栈和日志
3. **交互式调试**：实时修改和验证

### 3.4 从 Claude 到 Claude+Agent（2025-12-17）

**触发因素**：
- 硬编码样式问题需要系统性审计
- 单一会话难以处理全局性任务
- 需要 LSP 能力进行代码分析

**解决的问题**：
- 通过 Agent 模式委托复杂任务
- 保护主窗口上下文不被占满
- 系统性代码审计效率提升

---

## 4. 工具选择框架

### 4.1 任务复杂度矩阵

```
                    代码分析需求
                    低          高
                ┌──────────┬──────────┐
           低   │ Codex    │ Serena   │
  执行复杂度   │ 直接执行  │ 符号分析  │
                ├──────────┼──────────┤
           高   │ Claude   │ Claude   │
                │ Code     │ +Agent   │
                └──────────┴──────────┘
```

### 4.2 任务类型决策树

```
开始
 │
 ├─ 需要 Git 操作？
 │   └─ 是 → Claude Code
 │
 ├─ 需要跨会话记忆？
 │   └─ 是 → Serena MCP
 │
 ├─ 单文件 <=50 行？
 │   └─ 是 → Codex 直接修复
 │
 ├─ 需要代码理解？
 │   └─ 是 → Serena 定位 → Codex 执行
 │
 └─ 复杂多步骤任务？
     └─ 是 → Claude Code + Agent
```

### 4.3 工具协作模式

**模式一：Claude 主控 + Codex 执行**
```
Claude Code (规划、审核、Git)
     │
     └─→ Codex MCP (隔离执行复杂编程任务)
```

**模式二：Claude 主控 + Serena 分析**
```
Claude Code (规划、执行)
     │
     └─→ Serena MCP (代码分析、记忆管理)
```

**模式三：全栈 Claude**
```
Claude Code (全部任务)
     │
     ├─→ 内置 Git 工具
     ├─→ 内置文件操作
     └─→ Skill 扩展 (打包、调试等)
```

---

## 5. 模型能力感知

### 5.1 模型选择策略

| 场景 | 推荐模型 | 原因 |
|------|----------|------|
| 复杂规划/设计 | Opus 4.5 | 深度推理能力强 |
| 日常编程任务 | Sonnet 4.5 | 平衡速度和能力 |
| 大上下文分析 | 1M Context | 处理巨石文件 |
| 快速迭代 | Sonnet (快) | 响应速度优先 |

### 5.2 模型更新对决策的影响

**2025-09 ~ 2025-10**：
- 模型能力相对有限
- 用户不敢进行大规模重构
- 采用保守的"小步修复"策略

**2025-11 ~ 2025-12**：
- Claude Code 发布，模型能力提升
- 用户开始尝试更大范围的重构
- Token 系统、主题系统等系统性改进成为可能

**真实案例**：
```
# 2025-10 对巨石文件的态度
问题：qt_app.py 过大难以维护
决策：识别问题，规划拆分但优先功能修复（不敢动）

# 2025-12 对巨石文件的态度
问题：需要进行 PySide6 迁移
决策：借迁移之机进行模块化重构（敢动了）

触发因素：外部约束（迁移需求）+ 模型能力提升 = 重构时机成熟
```

### 5.3 用户对模型能力的感知曲线

```
信心程度
  ^
  │                              ┌───────
  │                         ┌────┘
  │                    ┌────┘
  │               ┌────┘
  │          ┌────┘
  │     ┌────┘
  │┌────┘
  └─────────────────────────────────────> 时间
   09    10    11    12    01
   探索  磨合  信任  深入  成熟
```

---

## 6. 核心经验总结

### 6.1 工具选择的黄金法则

1. **任务复杂度匹配**：工具能力要与任务复杂度匹配，过于强大或过于简单都会带来效率损失

2. **上下文优先**：保护主窗口上下文是第一优先级，复杂执行任务应隔离到子窗口/Agent

3. **Git 是分水岭**：需要 Git 操作的任务，Claude Code 是最优选择

4. **记忆要主动管理**：跨会话状态需要显式写入记忆（Serena/Git commit 信息）

5. **切换有成本**：工具切换会带来短暂的效率下降，但长期收益显著

### 6.2 Serena 使用场景归纳

| 场景 | Serena 工具 | 效果 |
|------|-------------|------|
| 理解代码结构 | `get_symbols_overview` | 快速了解文件/类/函数结构 |
| 查找符号定义 | `find_symbol` | 精确定位，避免读全文件 |
| 查找引用关系 | `find_referencing_symbols` | 理解调用链 |
| 搜索代码模式 | `search_for_pattern` | 正则匹配代码 |
| 保存项目状态 | `write_memory` | 跨会话保持上下文 |
| 恢复项目状态 | `read_memory` | 新会话快速上手 |

### 6.3 工具切换的信号

**该切换到 Serena 的信号**：
- "我不知道这个函数在哪里定义"
- "需要理解这个方法的调用链"
- "这个文件太大了"
- "下次对话需要记住这个结论"

**该切换到 Claude Code 的信号**：
- "需要提交代码"
- "需要查看 Git 历史"
- "这个 bug 需要调试"
- "需要打包/部署"

**该使用 Agent 的信号**：
- "需要系统性审计整个代码库"
- "这个任务太复杂会占满上下文"
- "需要多工具协作"

### 6.4 避免的反模式

1. **单窗口无差别工作**：所有任务放在一个窗口，导致上下文溢出
2. **给 AI 模糊指令**：让 AI 自己理解需求，结果乱改代码
3. **不审核结果**：Codex/Agent 执行后不检查，可能有错误
4. **修改代码前不备份**：高风险操作前不 commit，改坏无法恢复
5. **工具使用惯性**：死守一个工具，不根据任务切换

---

## 附录：数据来源

- 对话记录：`conversations/codex/`、`conversations/claude/`、`conversations/serena/`
- 分析数据：`analysis/overnight/cross_month.json`
- 工具配置：`conversations/serena/memories/`、`.claude/`
- 时间范围：2025-09-14 至 2026-01-11
- 总对话数：591 次
- 总用户消息：2267 条

---

*文档生成时间：2026-01-11*
*数据分析基于真实项目对话记录*
